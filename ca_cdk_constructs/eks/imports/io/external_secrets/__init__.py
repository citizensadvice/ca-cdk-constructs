from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

from ._jsii import *

import cdk8s as _cdk8s_d3d9af27
import constructs as _constructs_77d1e7e8


class ClusterExternalSecret(
    _cdk8s_d3d9af27.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="ioexternal-secrets.ClusterExternalSecret",
):
    '''ClusterExternalSecret is the Schema for the clusterexternalsecrets API.

    :schema: ClusterExternalSecret
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ClusterExternalSecretSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a "ClusterExternalSecret" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param metadata: 
        :param spec: ClusterExternalSecretSpec defines the desired state of ClusterExternalSecret.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__94e60b949b245b48a41fb74f8b3d1eb0f99bd46fa142d6bbb376323f6a4b972a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ClusterExternalSecretProps(metadata=metadata, spec=spec)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest")
    @builtins.classmethod
    def manifest(
        cls,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ClusterExternalSecretSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> typing.Any:
        '''Renders a Kubernetes manifest for "ClusterExternalSecret".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param metadata: 
        :param spec: ClusterExternalSecretSpec defines the desired state of ClusterExternalSecret.
        '''
        props = ClusterExternalSecretProps(metadata=metadata, spec=spec)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''Renders the object to Kubernetes JSON.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> _cdk8s_d3d9af27.GroupVersionKind:
        '''Returns the apiVersion and kind for "ClusterExternalSecret".'''
        return typing.cast(_cdk8s_d3d9af27.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretProps",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class ClusterExternalSecretProps:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ClusterExternalSecretSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''ClusterExternalSecret is the Schema for the clusterexternalsecrets API.

        :param metadata: 
        :param spec: ClusterExternalSecretSpec defines the desired state of ClusterExternalSecret.

        :schema: ClusterExternalSecret
        '''
        if isinstance(metadata, dict):
            metadata = _cdk8s_d3d9af27.ApiObjectMetadata(**metadata)
        if isinstance(spec, dict):
            spec = ClusterExternalSecretSpec(**spec)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f74e2ba2ccb6cd4ff807d66b5a3c6750a98bf9aadca80dd11e5f2ce993d61ce5)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(self) -> typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata]:
        '''
        :schema: ClusterExternalSecret#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata], result)

    @builtins.property
    def spec(self) -> typing.Optional["ClusterExternalSecretSpec"]:
        '''ClusterExternalSecretSpec defines the desired state of ClusterExternalSecret.

        :schema: ClusterExternalSecret#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["ClusterExternalSecretSpec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpec",
    jsii_struct_bases=[],
    name_mapping={
        "external_secret_spec": "externalSecretSpec",
        "external_secret_metadata": "externalSecretMetadata",
        "external_secret_name": "externalSecretName",
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
        "namespace_selectors": "namespaceSelectors",
        "refresh_time": "refreshTime",
    },
)
class ClusterExternalSecretSpec:
    def __init__(
        self,
        *,
        external_secret_spec: typing.Union["ClusterExternalSecretSpecExternalSecretSpec", typing.Dict[builtins.str, typing.Any]],
        external_secret_metadata: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretMetadata", typing.Dict[builtins.str, typing.Any]]] = None,
        external_secret_name: typing.Optional[builtins.str] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["ClusterExternalSecretSpecNamespaceSelector", typing.Dict[builtins.str, typing.Any]]] = None,
        namespace_selectors: typing.Optional[typing.Sequence[typing.Union["ClusterExternalSecretSpecNamespaceSelectors", typing.Dict[builtins.str, typing.Any]]]] = None,
        refresh_time: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ClusterExternalSecretSpec defines the desired state of ClusterExternalSecret.

        :param external_secret_spec: The spec for the ExternalSecrets to be created.
        :param external_secret_metadata: The metadata of the external secrets to be created.
        :param external_secret_name: The name of the external secrets to be created. Defaults to the name of the ClusterExternalSecret Default: the name of the ClusterExternalSecret
        :param namespaces: Choose namespaces by name. This field is ORed with anything that NamespaceSelectors ends up choosing.
        :param namespace_selector: The labels to select by to find the Namespaces to create the ExternalSecrets in. Deprecated: Use NamespaceSelectors instead.
        :param namespace_selectors: A list of labels to select by to find the Namespaces to create the ExternalSecrets in. The selectors are ORed.
        :param refresh_time: The time in which the controller should reconcile its objects and recheck namespaces for labels.

        :schema: ClusterExternalSecretSpec
        '''
        if isinstance(external_secret_spec, dict):
            external_secret_spec = ClusterExternalSecretSpecExternalSecretSpec(**external_secret_spec)
        if isinstance(external_secret_metadata, dict):
            external_secret_metadata = ClusterExternalSecretSpecExternalSecretMetadata(**external_secret_metadata)
        if isinstance(namespace_selector, dict):
            namespace_selector = ClusterExternalSecretSpecNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8ef14ba98eb89c9ca89bac0d3d6a848b1d08606ee897d4645723837a3a0c8363)
            check_type(argname="argument external_secret_spec", value=external_secret_spec, expected_type=type_hints["external_secret_spec"])
            check_type(argname="argument external_secret_metadata", value=external_secret_metadata, expected_type=type_hints["external_secret_metadata"])
            check_type(argname="argument external_secret_name", value=external_secret_name, expected_type=type_hints["external_secret_name"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
            check_type(argname="argument namespace_selectors", value=namespace_selectors, expected_type=type_hints["namespace_selectors"])
            check_type(argname="argument refresh_time", value=refresh_time, expected_type=type_hints["refresh_time"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "external_secret_spec": external_secret_spec,
        }
        if external_secret_metadata is not None:
            self._values["external_secret_metadata"] = external_secret_metadata
        if external_secret_name is not None:
            self._values["external_secret_name"] = external_secret_name
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector
        if namespace_selectors is not None:
            self._values["namespace_selectors"] = namespace_selectors
        if refresh_time is not None:
            self._values["refresh_time"] = refresh_time

    @builtins.property
    def external_secret_spec(self) -> "ClusterExternalSecretSpecExternalSecretSpec":
        '''The spec for the ExternalSecrets to be created.

        :schema: ClusterExternalSecretSpec#externalSecretSpec
        '''
        result = self._values.get("external_secret_spec")
        assert result is not None, "Required property 'external_secret_spec' is missing"
        return typing.cast("ClusterExternalSecretSpecExternalSecretSpec", result)

    @builtins.property
    def external_secret_metadata(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretMetadata"]:
        '''The metadata of the external secrets to be created.

        :schema: ClusterExternalSecretSpec#externalSecretMetadata
        '''
        result = self._values.get("external_secret_metadata")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretMetadata"], result)

    @builtins.property
    def external_secret_name(self) -> typing.Optional[builtins.str]:
        '''The name of the external secrets to be created.

        Defaults to the name of the ClusterExternalSecret

        :default: the name of the ClusterExternalSecret

        :schema: ClusterExternalSecretSpec#externalSecretName
        '''
        result = self._values.get("external_secret_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Choose namespaces by name.

        This field is ORed with anything that NamespaceSelectors ends up choosing.

        :schema: ClusterExternalSecretSpec#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecNamespaceSelector"]:
        '''The labels to select by to find the Namespaces to create the ExternalSecrets in.

        Deprecated: Use NamespaceSelectors instead.

        :schema: ClusterExternalSecretSpec#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecNamespaceSelector"], result)

    @builtins.property
    def namespace_selectors(
        self,
    ) -> typing.Optional[typing.List["ClusterExternalSecretSpecNamespaceSelectors"]]:
        '''A list of labels to select by to find the Namespaces to create the ExternalSecrets in.

        The selectors are ORed.

        :schema: ClusterExternalSecretSpec#namespaceSelectors
        '''
        result = self._values.get("namespace_selectors")
        return typing.cast(typing.Optional[typing.List["ClusterExternalSecretSpecNamespaceSelectors"]], result)

    @builtins.property
    def refresh_time(self) -> typing.Optional[builtins.str]:
        '''The time in which the controller should reconcile its objects and recheck namespaces for labels.

        :schema: ClusterExternalSecretSpec#refreshTime
        '''
        result = self._values.get("refresh_time")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretMetadata",
    jsii_struct_bases=[],
    name_mapping={"annotations": "annotations", "labels": "labels"},
)
class ClusterExternalSecretSpecExternalSecretMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''The metadata of the external secrets to be created.

        :param annotations: 
        :param labels: 

        :schema: ClusterExternalSecretSpecExternalSecretMetadata
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b5df8c612d909cfd3ff0b36342a11dca19f3ff5c30f04aefcbfcc75c64315a69)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if labels is not None:
            self._values["labels"] = labels

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpec",
    jsii_struct_bases=[],
    name_mapping={
        "data": "data",
        "data_from": "dataFrom",
        "refresh_interval": "refreshInterval",
        "secret_store_ref": "secretStoreRef",
        "target": "target",
    },
)
class ClusterExternalSecretSpecExternalSecretSpec:
    def __init__(
        self,
        *,
        data: typing.Optional[typing.Sequence[typing.Union["ClusterExternalSecretSpecExternalSecretSpecData", typing.Dict[builtins.str, typing.Any]]]] = None,
        data_from: typing.Optional[typing.Sequence[typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataFrom", typing.Dict[builtins.str, typing.Any]]]] = None,
        refresh_interval: typing.Optional[builtins.str] = None,
        secret_store_ref: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef", typing.Dict[builtins.str, typing.Any]]] = None,
        target: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecTarget", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''The spec for the ExternalSecrets to be created.

        :param data: Data defines the connection between the Kubernetes Secret keys and the Provider data.
        :param data_from: DataFrom is used to fetch all properties from a specific Provider data If multiple entries are specified, the Secret keys are merged in the specified order.
        :param refresh_interval: RefreshInterval is the amount of time before the values are read again from the SecretStore provider, specified as Golang Duration strings. Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h" Example values: "1h", "2h30m", "5d", "10s" May be set to zero to fetch and create it once. Defaults to 1h. Default: 1h.
        :param secret_store_ref: SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
        :param target: ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.

        :schema: ClusterExternalSecretSpecExternalSecretSpec
        '''
        if isinstance(secret_store_ref, dict):
            secret_store_ref = ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef(**secret_store_ref)
        if isinstance(target, dict):
            target = ClusterExternalSecretSpecExternalSecretSpecTarget(**target)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e3cb3046c16e6500023803a31ec0aefdedf2075416c3070aa91ce798a65a14b2)
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
            check_type(argname="argument data_from", value=data_from, expected_type=type_hints["data_from"])
            check_type(argname="argument refresh_interval", value=refresh_interval, expected_type=type_hints["refresh_interval"])
            check_type(argname="argument secret_store_ref", value=secret_store_ref, expected_type=type_hints["secret_store_ref"])
            check_type(argname="argument target", value=target, expected_type=type_hints["target"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if data is not None:
            self._values["data"] = data
        if data_from is not None:
            self._values["data_from"] = data_from
        if refresh_interval is not None:
            self._values["refresh_interval"] = refresh_interval
        if secret_store_ref is not None:
            self._values["secret_store_ref"] = secret_store_ref
        if target is not None:
            self._values["target"] = target

    @builtins.property
    def data(
        self,
    ) -> typing.Optional[typing.List["ClusterExternalSecretSpecExternalSecretSpecData"]]:
        '''Data defines the connection between the Kubernetes Secret keys and the Provider data.

        :schema: ClusterExternalSecretSpecExternalSecretSpec#data
        '''
        result = self._values.get("data")
        return typing.cast(typing.Optional[typing.List["ClusterExternalSecretSpecExternalSecretSpecData"]], result)

    @builtins.property
    def data_from(
        self,
    ) -> typing.Optional[typing.List["ClusterExternalSecretSpecExternalSecretSpecDataFrom"]]:
        '''DataFrom is used to fetch all properties from a specific Provider data If multiple entries are specified, the Secret keys are merged in the specified order.

        :schema: ClusterExternalSecretSpecExternalSecretSpec#dataFrom
        '''
        result = self._values.get("data_from")
        return typing.cast(typing.Optional[typing.List["ClusterExternalSecretSpecExternalSecretSpecDataFrom"]], result)

    @builtins.property
    def refresh_interval(self) -> typing.Optional[builtins.str]:
        '''RefreshInterval is the amount of time before the values are read again from the SecretStore provider, specified as Golang Duration strings.

        Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h"
        Example values: "1h", "2h30m", "5d", "10s"
        May be set to zero to fetch and create it once. Defaults to 1h.

        :default: 1h.

        :schema: ClusterExternalSecretSpecExternalSecretSpec#refreshInterval
        '''
        result = self._values.get("refresh_interval")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_store_ref(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef"]:
        '''SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :schema: ClusterExternalSecretSpecExternalSecretSpec#secretStoreRef
        '''
        result = self._values.get("secret_store_ref")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef"], result)

    @builtins.property
    def target(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTarget"]:
        '''ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.

        :schema: ClusterExternalSecretSpecExternalSecretSpec#target
        '''
        result = self._values.get("target")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTarget"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecData",
    jsii_struct_bases=[],
    name_mapping={
        "remote_ref": "remoteRef",
        "secret_key": "secretKey",
        "source_ref": "sourceRef",
    },
)
class ClusterExternalSecretSpecExternalSecretSpecData:
    def __init__(
        self,
        *,
        remote_ref: typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef", typing.Dict[builtins.str, typing.Any]],
        secret_key: builtins.str,
        source_ref: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataSourceRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''ExternalSecretData defines the connection between the Kubernetes Secret key (spec.data.) and the Provider data.

        :param remote_ref: RemoteRef points to the remote secret and defines which secret (version/property/..) to fetch.
        :param secret_key: The key in the Kubernetes Secret to store the value.
        :param source_ref: SourceRef allows you to override the source from which the value will be pulled.

        :schema: ClusterExternalSecretSpecExternalSecretSpecData
        '''
        if isinstance(remote_ref, dict):
            remote_ref = ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef(**remote_ref)
        if isinstance(source_ref, dict):
            source_ref = ClusterExternalSecretSpecExternalSecretSpecDataSourceRef(**source_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__698893d044926c5b5ba8069507216c8ba018dab3a976050e982d04ab806c4f9c)
            check_type(argname="argument remote_ref", value=remote_ref, expected_type=type_hints["remote_ref"])
            check_type(argname="argument secret_key", value=secret_key, expected_type=type_hints["secret_key"])
            check_type(argname="argument source_ref", value=source_ref, expected_type=type_hints["source_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "remote_ref": remote_ref,
            "secret_key": secret_key,
        }
        if source_ref is not None:
            self._values["source_ref"] = source_ref

    @builtins.property
    def remote_ref(self) -> "ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef":
        '''RemoteRef points to the remote secret and defines which secret (version/property/..) to fetch.

        :schema: ClusterExternalSecretSpecExternalSecretSpecData#remoteRef
        '''
        result = self._values.get("remote_ref")
        assert result is not None, "Required property 'remote_ref' is missing"
        return typing.cast("ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef", result)

    @builtins.property
    def secret_key(self) -> builtins.str:
        '''The key in the Kubernetes Secret to store the value.

        :schema: ClusterExternalSecretSpecExternalSecretSpecData#secretKey
        '''
        result = self._values.get("secret_key")
        assert result is not None, "Required property 'secret_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def source_ref(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataSourceRef"]:
        '''SourceRef allows you to override the source from which the value will be pulled.

        :schema: ClusterExternalSecretSpecExternalSecretSpecData#sourceRef
        '''
        result = self._values.get("source_ref")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataSourceRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecData(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFrom",
    jsii_struct_bases=[],
    name_mapping={
        "extract": "extract",
        "find": "find",
        "rewrite": "rewrite",
        "source_ref": "sourceRef",
    },
)
class ClusterExternalSecretSpecExternalSecretSpecDataFrom:
    def __init__(
        self,
        *,
        extract: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataFromExtract", typing.Dict[builtins.str, typing.Any]]] = None,
        find: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataFromFind", typing.Dict[builtins.str, typing.Any]]] = None,
        rewrite: typing.Optional[typing.Sequence[typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite", typing.Dict[builtins.str, typing.Any]]]] = None,
        source_ref: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param extract: Used to extract multiple key/value pairs from one secret Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.
        :param find: Used to find secrets based on tags or regular expressions Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.
        :param rewrite: Used to rewrite secret Keys after getting them from the secret Provider Multiple Rewrite operations can be provided. They are applied in a layered order (first to last)
        :param source_ref: SourceRef points to a store or generator which contains secret values ready to use. Use this in combination with Extract or Find pull values out of a specific SecretStore. When sourceRef points to a generator Extract or Find is not supported. The generator returns a static map of values

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFrom
        '''
        if isinstance(extract, dict):
            extract = ClusterExternalSecretSpecExternalSecretSpecDataFromExtract(**extract)
        if isinstance(find, dict):
            find = ClusterExternalSecretSpecExternalSecretSpecDataFromFind(**find)
        if isinstance(source_ref, dict):
            source_ref = ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef(**source_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab42e9c8e44193a216bc48255b69844a18cb95933d526955a5d60b90a2fe67fa)
            check_type(argname="argument extract", value=extract, expected_type=type_hints["extract"])
            check_type(argname="argument find", value=find, expected_type=type_hints["find"])
            check_type(argname="argument rewrite", value=rewrite, expected_type=type_hints["rewrite"])
            check_type(argname="argument source_ref", value=source_ref, expected_type=type_hints["source_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if extract is not None:
            self._values["extract"] = extract
        if find is not None:
            self._values["find"] = find
        if rewrite is not None:
            self._values["rewrite"] = rewrite
        if source_ref is not None:
            self._values["source_ref"] = source_ref

    @builtins.property
    def extract(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromExtract"]:
        '''Used to extract multiple key/value pairs from one secret Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFrom#extract
        '''
        result = self._values.get("extract")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromExtract"], result)

    @builtins.property
    def find(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromFind"]:
        '''Used to find secrets based on tags or regular expressions Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFrom#find
        '''
        result = self._values.get("find")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromFind"], result)

    @builtins.property
    def rewrite(
        self,
    ) -> typing.Optional[typing.List["ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite"]]:
        '''Used to rewrite secret Keys after getting them from the secret Provider Multiple Rewrite operations can be provided.

        They are applied in a layered order (first to last)

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFrom#rewrite
        '''
        result = self._values.get("rewrite")
        return typing.cast(typing.Optional[typing.List["ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite"]], result)

    @builtins.property
    def source_ref(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef"]:
        '''SourceRef points to a store or generator which contains secret values ready to use.

        Use this in combination with Extract or Find pull values out of
        a specific SecretStore.
        When sourceRef points to a generator Extract or Find is not supported.
        The generator returns a static map of values

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFrom#sourceRef
        '''
        result = self._values.get("source_ref")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromExtract",
    jsii_struct_bases=[],
    name_mapping={
        "key": "key",
        "conversion_strategy": "conversionStrategy",
        "decoding_strategy": "decodingStrategy",
        "metadata_policy": "metadataPolicy",
        "property": "property",
        "version": "version",
    },
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromExtract:
    def __init__(
        self,
        *,
        key: builtins.str,
        conversion_strategy: typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromExtractConversionStrategy"] = None,
        decoding_strategy: typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromExtractDecodingStrategy"] = None,
        metadata_policy: typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromExtractMetadataPolicy"] = None,
        property: typing.Optional[builtins.str] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Used to extract multiple key/value pairs from one secret Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.

        :param key: Key is the key used in the Provider, mandatory.
        :param conversion_strategy: Used to define a conversion Strategy.
        :param decoding_strategy: Used to define a decoding Strategy.
        :param metadata_policy: Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None Default: None
        :param property: Used to select a specific property of the Provider value (if a map), if supported.
        :param version: Used to select a specific version of the Provider value, if supported.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromExtract
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4e03ff5f59a1789f7214696b1cee4651df4495261ab18a2629aa1a0b877896e6)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument conversion_strategy", value=conversion_strategy, expected_type=type_hints["conversion_strategy"])
            check_type(argname="argument decoding_strategy", value=decoding_strategy, expected_type=type_hints["decoding_strategy"])
            check_type(argname="argument metadata_policy", value=metadata_policy, expected_type=type_hints["metadata_policy"])
            check_type(argname="argument property", value=property, expected_type=type_hints["property"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
        }
        if conversion_strategy is not None:
            self._values["conversion_strategy"] = conversion_strategy
        if decoding_strategy is not None:
            self._values["decoding_strategy"] = decoding_strategy
        if metadata_policy is not None:
            self._values["metadata_policy"] = metadata_policy
        if property is not None:
            self._values["property"] = property
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def key(self) -> builtins.str:
        '''Key is the key used in the Provider, mandatory.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def conversion_strategy(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromExtractConversionStrategy"]:
        '''Used to define a conversion Strategy.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#conversionStrategy
        '''
        result = self._values.get("conversion_strategy")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromExtractConversionStrategy"], result)

    @builtins.property
    def decoding_strategy(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromExtractDecodingStrategy"]:
        '''Used to define a decoding Strategy.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#decodingStrategy
        '''
        result = self._values.get("decoding_strategy")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromExtractDecodingStrategy"], result)

    @builtins.property
    def metadata_policy(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromExtractMetadataPolicy"]:
        '''Policy for fetching tags/labels from provider secrets, possible options are Fetch, None.

        Defaults to None

        :default: None

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#metadataPolicy
        '''
        result = self._values.get("metadata_policy")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromExtractMetadataPolicy"], result)

    @builtins.property
    def property(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific property of the Provider value (if a map), if supported.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#property
        '''
        result = self._values.get("property")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific version of the Provider value, if supported.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataFromExtract(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromExtractConversionStrategy"
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromExtractConversionStrategy(
    enum.Enum,
):
    '''Used to define a conversion Strategy.

    :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromExtractConversionStrategy
    '''

    DEFAULT = "DEFAULT"
    '''Default.'''
    UNICODE = "UNICODE"
    '''Unicode.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromExtractDecodingStrategy"
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromExtractDecodingStrategy(
    enum.Enum,
):
    '''Used to define a decoding Strategy.

    :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromExtractDecodingStrategy
    '''

    AUTO = "AUTO"
    '''Auto.'''
    BASE64 = "BASE64"
    '''Base64.'''
    BASE64_URL = "BASE64_URL"
    '''Base64URL.'''
    NONE = "NONE"
    '''None.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromExtractMetadataPolicy"
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromExtractMetadataPolicy(
    enum.Enum,
):
    '''Policy for fetching tags/labels from provider secrets, possible options are Fetch, None.

    Defaults to None

    :default: None

    :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromExtractMetadataPolicy
    '''

    NONE = "NONE"
    '''None.'''
    FETCH = "FETCH"
    '''Fetch.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromFind",
    jsii_struct_bases=[],
    name_mapping={
        "conversion_strategy": "conversionStrategy",
        "decoding_strategy": "decodingStrategy",
        "name": "name",
        "path": "path",
        "tags": "tags",
    },
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromFind:
    def __init__(
        self,
        *,
        conversion_strategy: typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromFindConversionStrategy"] = None,
        decoding_strategy: typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromFindDecodingStrategy"] = None,
        name: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataFromFindName", typing.Dict[builtins.str, typing.Any]]] = None,
        path: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Used to find secrets based on tags or regular expressions Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.

        :param conversion_strategy: Used to define a conversion Strategy.
        :param decoding_strategy: Used to define a decoding Strategy.
        :param name: Finds secrets based on the name.
        :param path: A root path to start the find operations.
        :param tags: Find secrets based on tags.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromFind
        '''
        if isinstance(name, dict):
            name = ClusterExternalSecretSpecExternalSecretSpecDataFromFindName(**name)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__92077ca7c2f4d118e3eed11ddd89115353a2bba1dbb58f94f8e98f0407ce8371)
            check_type(argname="argument conversion_strategy", value=conversion_strategy, expected_type=type_hints["conversion_strategy"])
            check_type(argname="argument decoding_strategy", value=decoding_strategy, expected_type=type_hints["decoding_strategy"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if conversion_strategy is not None:
            self._values["conversion_strategy"] = conversion_strategy
        if decoding_strategy is not None:
            self._values["decoding_strategy"] = decoding_strategy
        if name is not None:
            self._values["name"] = name
        if path is not None:
            self._values["path"] = path
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def conversion_strategy(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromFindConversionStrategy"]:
        '''Used to define a conversion Strategy.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromFind#conversionStrategy
        '''
        result = self._values.get("conversion_strategy")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromFindConversionStrategy"], result)

    @builtins.property
    def decoding_strategy(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromFindDecodingStrategy"]:
        '''Used to define a decoding Strategy.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromFind#decodingStrategy
        '''
        result = self._values.get("decoding_strategy")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromFindDecodingStrategy"], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromFindName"]:
        '''Finds secrets based on the name.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromFind#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromFindName"], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''A root path to start the find operations.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromFind#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Find secrets based on tags.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromFind#tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataFromFind(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromFindConversionStrategy"
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromFindConversionStrategy(
    enum.Enum,
):
    '''Used to define a conversion Strategy.

    :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromFindConversionStrategy
    '''

    DEFAULT = "DEFAULT"
    '''Default.'''
    UNICODE = "UNICODE"
    '''Unicode.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromFindDecodingStrategy"
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromFindDecodingStrategy(
    enum.Enum,
):
    '''Used to define a decoding Strategy.

    :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromFindDecodingStrategy
    '''

    AUTO = "AUTO"
    '''Auto.'''
    BASE64 = "BASE64"
    '''Base64.'''
    BASE64_URL = "BASE64_URL"
    '''Base64URL.'''
    NONE = "NONE"
    '''None.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromFindName",
    jsii_struct_bases=[],
    name_mapping={"regexp": "regexp"},
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromFindName:
    def __init__(self, *, regexp: typing.Optional[builtins.str] = None) -> None:
        '''Finds secrets based on the name.

        :param regexp: Finds secrets base.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromFindName
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5968a6b40dcf2aead8c61044c5dee50fa9d4651e3d45dc7f12383fe7760e25ac)
            check_type(argname="argument regexp", value=regexp, expected_type=type_hints["regexp"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if regexp is not None:
            self._values["regexp"] = regexp

    @builtins.property
    def regexp(self) -> typing.Optional[builtins.str]:
        '''Finds secrets base.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromFindName#regexp
        '''
        result = self._values.get("regexp")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataFromFindName(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite",
    jsii_struct_bases=[],
    name_mapping={"regexp": "regexp", "transform": "transform"},
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite:
    def __init__(
        self,
        *,
        regexp: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp", typing.Dict[builtins.str, typing.Any]]] = None,
        transform: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param regexp: Used to rewrite with regular expressions. The resulting key will be the output of a regexp.ReplaceAll operation.
        :param transform: Used to apply string transformation on the secrets. The resulting key will be the output of the template applied by the operation.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite
        '''
        if isinstance(regexp, dict):
            regexp = ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp(**regexp)
        if isinstance(transform, dict):
            transform = ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform(**transform)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f601bc7c910f4395527a2edbe9ff719509d7d8808af893ad08740c049a2c5b76)
            check_type(argname="argument regexp", value=regexp, expected_type=type_hints["regexp"])
            check_type(argname="argument transform", value=transform, expected_type=type_hints["transform"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if regexp is not None:
            self._values["regexp"] = regexp
        if transform is not None:
            self._values["transform"] = transform

    @builtins.property
    def regexp(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp"]:
        '''Used to rewrite with regular expressions.

        The resulting key will be the output of a regexp.ReplaceAll operation.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite#regexp
        '''
        result = self._values.get("regexp")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp"], result)

    @builtins.property
    def transform(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform"]:
        '''Used to apply string transformation on the secrets.

        The resulting key will be the output of the template applied by the operation.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite#transform
        '''
        result = self._values.get("transform")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp",
    jsii_struct_bases=[],
    name_mapping={"source": "source", "target": "target"},
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp:
    def __init__(self, *, source: builtins.str, target: builtins.str) -> None:
        '''Used to rewrite with regular expressions.

        The resulting key will be the output of a regexp.ReplaceAll operation.

        :param source: Used to define the regular expression of a re.Compiler.
        :param target: Used to define the target pattern of a ReplaceAll operation.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5b713d8124b2c817097f753f8dc9f6051b182ef78b70ea61bbbb37b1e8c58d59)
            check_type(argname="argument source", value=source, expected_type=type_hints["source"])
            check_type(argname="argument target", value=target, expected_type=type_hints["target"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "source": source,
            "target": target,
        }

    @builtins.property
    def source(self) -> builtins.str:
        '''Used to define the regular expression of a re.Compiler.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp#source
        '''
        result = self._values.get("source")
        assert result is not None, "Required property 'source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target(self) -> builtins.str:
        '''Used to define the target pattern of a ReplaceAll operation.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp#target
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform",
    jsii_struct_bases=[],
    name_mapping={"template": "template"},
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform:
    def __init__(self, *, template: builtins.str) -> None:
        '''Used to apply string transformation on the secrets.

        The resulting key will be the output of the template applied by the operation.

        :param template: Used to define the template to apply on the secret name. ``.value `` will specify the secret name in the template.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__593d67339e08298e9ffe3df7a50137c1841d53b5c13926c5f369a4f3172e807f)
            check_type(argname="argument template", value=template, expected_type=type_hints["template"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "template": template,
        }

    @builtins.property
    def template(self) -> builtins.str:
        '''Used to define the template to apply on the secret name.

        ``.value `` will specify the secret name in the template.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform#template
        '''
        result = self._values.get("template")
        assert result is not None, "Required property 'template' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef",
    jsii_struct_bases=[],
    name_mapping={"generator_ref": "generatorRef", "store_ref": "storeRef"},
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef:
    def __init__(
        self,
        *,
        generator_ref: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef", typing.Dict[builtins.str, typing.Any]]] = None,
        store_ref: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''SourceRef points to a store or generator which contains secret values ready to use.

        Use this in combination with Extract or Find pull values out of
        a specific SecretStore.
        When sourceRef points to a generator Extract or Find is not supported.
        The generator returns a static map of values

        :param generator_ref: GeneratorRef points to a generator custom resource.
        :param store_ref: SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef
        '''
        if isinstance(generator_ref, dict):
            generator_ref = ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef(**generator_ref)
        if isinstance(store_ref, dict):
            store_ref = ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef(**store_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f63e50d7ff4b9cb977470145546ff8b96ba9cecf3ea10b6d66a80ffeec2c911)
            check_type(argname="argument generator_ref", value=generator_ref, expected_type=type_hints["generator_ref"])
            check_type(argname="argument store_ref", value=store_ref, expected_type=type_hints["store_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if generator_ref is not None:
            self._values["generator_ref"] = generator_ref
        if store_ref is not None:
            self._values["store_ref"] = store_ref

    @builtins.property
    def generator_ref(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef"]:
        '''GeneratorRef points to a generator custom resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef#generatorRef
        '''
        result = self._values.get("generator_ref")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef"], result)

    @builtins.property
    def store_ref(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef"]:
        '''SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef#storeRef
        '''
        result = self._values.get("store_ref")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "name": "name", "api_version": "apiVersion"},
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef:
    def __init__(
        self,
        *,
        kind: "ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRefKind",
        name: builtins.str,
        api_version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''GeneratorRef points to a generator custom resource.

        :param kind: Specify the Kind of the generator resource.
        :param name: Specify the name of the generator resource.
        :param api_version: Specify the apiVersion of the generator resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4bc9961f5d7205cf72d9098890a30f80bd7454ee336863badedda3141aefda17)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "kind": kind,
            "name": name,
        }
        if api_version is not None:
            self._values["api_version"] = api_version

    @builtins.property
    def kind(
        self,
    ) -> "ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRefKind":
        '''Specify the Kind of the generator resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef#kind
        '''
        result = self._values.get("kind")
        assert result is not None, "Required property 'kind' is missing"
        return typing.cast("ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRefKind", result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Specify the name of the generator resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Specify the apiVersion of the generator resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef#apiVersion
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRefKind"
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRefKind(
    enum.Enum,
):
    '''Specify the Kind of the generator resource.

    :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRefKind
    '''

    ACR_ACCESS_TOKEN = "ACR_ACCESS_TOKEN"
    '''ACRAccessToken.'''
    CLUSTER_GENERATOR = "CLUSTER_GENERATOR"
    '''ClusterGenerator.'''
    ECR_AUTHORIZATION_TOKEN = "ECR_AUTHORIZATION_TOKEN"
    '''ECRAuthorizationToken.'''
    FAKE = "FAKE"
    '''Fake.'''
    GCR_ACCESS_TOKEN = "GCR_ACCESS_TOKEN"
    '''GCRAccessToken.'''
    GITHUB_ACCESS_TOKEN = "GITHUB_ACCESS_TOKEN"
    '''GithubAccessToken.'''
    PASSWORD = "PASSWORD"
    '''Password.'''
    STS_SESSION_TOKEN = "STS_SESSION_TOKEN"
    '''STSSessionToken.'''
    UUID = "UUID"
    '''UUID.'''
    VAULT_DYNAMIC_SECRET = "VAULT_DYNAMIC_SECRET"
    '''VaultDynamicSecret.'''
    WEBHOOK = "WEBHOOK"
    '''Webhook.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "name": "name"},
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef:
    def __init__(
        self,
        *,
        kind: typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRefKind"] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :param kind: Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``. Default: SecretStore`
        :param name: Name of the SecretStore resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__082917a72761ed0c1f366e52e34edade80e2390cdd82c1afa6c6598822467105)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if kind is not None:
            self._values["kind"] = kind
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def kind(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRefKind"]:
        '''Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``.

        :default: SecretStore`

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRefKind"], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the SecretStore resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRefKind"
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRefKind(
    enum.Enum,
):
    '''Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``.

    :default: SecretStore`

    :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRefKind
    '''

    SECRET_STORE = "SECRET_STORE"
    '''SecretStore.'''
    CLUSTER_SECRET_STORE = "CLUSTER_SECRET_STORE"
    '''ClusterSecretStore.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef",
    jsii_struct_bases=[],
    name_mapping={
        "key": "key",
        "conversion_strategy": "conversionStrategy",
        "decoding_strategy": "decodingStrategy",
        "metadata_policy": "metadataPolicy",
        "property": "property",
        "version": "version",
    },
)
class ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef:
    def __init__(
        self,
        *,
        key: builtins.str,
        conversion_strategy: typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefConversionStrategy"] = None,
        decoding_strategy: typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefDecodingStrategy"] = None,
        metadata_policy: typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefMetadataPolicy"] = None,
        property: typing.Optional[builtins.str] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''RemoteRef points to the remote secret and defines which secret (version/property/..) to fetch.

        :param key: Key is the key used in the Provider, mandatory.
        :param conversion_strategy: Used to define a conversion Strategy.
        :param decoding_strategy: Used to define a decoding Strategy.
        :param metadata_policy: Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None Default: None
        :param property: Used to select a specific property of the Provider value (if a map), if supported.
        :param version: Used to select a specific version of the Provider value, if supported.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e6f3244609ebbc535f95a19792829d629cfcad19ee4566882417287402c07f3f)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument conversion_strategy", value=conversion_strategy, expected_type=type_hints["conversion_strategy"])
            check_type(argname="argument decoding_strategy", value=decoding_strategy, expected_type=type_hints["decoding_strategy"])
            check_type(argname="argument metadata_policy", value=metadata_policy, expected_type=type_hints["metadata_policy"])
            check_type(argname="argument property", value=property, expected_type=type_hints["property"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
        }
        if conversion_strategy is not None:
            self._values["conversion_strategy"] = conversion_strategy
        if decoding_strategy is not None:
            self._values["decoding_strategy"] = decoding_strategy
        if metadata_policy is not None:
            self._values["metadata_policy"] = metadata_policy
        if property is not None:
            self._values["property"] = property
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def key(self) -> builtins.str:
        '''Key is the key used in the Provider, mandatory.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def conversion_strategy(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefConversionStrategy"]:
        '''Used to define a conversion Strategy.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#conversionStrategy
        '''
        result = self._values.get("conversion_strategy")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefConversionStrategy"], result)

    @builtins.property
    def decoding_strategy(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefDecodingStrategy"]:
        '''Used to define a decoding Strategy.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#decodingStrategy
        '''
        result = self._values.get("decoding_strategy")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefDecodingStrategy"], result)

    @builtins.property
    def metadata_policy(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefMetadataPolicy"]:
        '''Policy for fetching tags/labels from provider secrets, possible options are Fetch, None.

        Defaults to None

        :default: None

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#metadataPolicy
        '''
        result = self._values.get("metadata_policy")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefMetadataPolicy"], result)

    @builtins.property
    def property(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific property of the Provider value (if a map), if supported.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#property
        '''
        result = self._values.get("property")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific version of the Provider value, if supported.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefConversionStrategy"
)
class ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefConversionStrategy(
    enum.Enum,
):
    '''Used to define a conversion Strategy.

    :schema: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefConversionStrategy
    '''

    DEFAULT = "DEFAULT"
    '''Default.'''
    UNICODE = "UNICODE"
    '''Unicode.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefDecodingStrategy"
)
class ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefDecodingStrategy(
    enum.Enum,
):
    '''Used to define a decoding Strategy.

    :schema: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefDecodingStrategy
    '''

    AUTO = "AUTO"
    '''Auto.'''
    BASE64 = "BASE64"
    '''Base64.'''
    BASE64_URL = "BASE64_URL"
    '''Base64URL.'''
    NONE = "NONE"
    '''None.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefMetadataPolicy"
)
class ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefMetadataPolicy(enum.Enum):
    '''Policy for fetching tags/labels from provider secrets, possible options are Fetch, None.

    Defaults to None

    :default: None

    :schema: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefMetadataPolicy
    '''

    NONE = "NONE"
    '''None.'''
    FETCH = "FETCH"
    '''Fetch.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataSourceRef",
    jsii_struct_bases=[],
    name_mapping={"generator_ref": "generatorRef", "store_ref": "storeRef"},
)
class ClusterExternalSecretSpecExternalSecretSpecDataSourceRef:
    def __init__(
        self,
        *,
        generator_ref: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef", typing.Dict[builtins.str, typing.Any]]] = None,
        store_ref: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''SourceRef allows you to override the source from which the value will be pulled.

        :param generator_ref: GeneratorRef points to a generator custom resource. Deprecated: The generatorRef is not implemented in .data[]. this will be removed with v1.
        :param store_ref: SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataSourceRef
        '''
        if isinstance(generator_ref, dict):
            generator_ref = ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef(**generator_ref)
        if isinstance(store_ref, dict):
            store_ref = ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef(**store_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5561d58e41708dd168e9146076dbca74f307d640d7394ba6e3efbac3d41839a)
            check_type(argname="argument generator_ref", value=generator_ref, expected_type=type_hints["generator_ref"])
            check_type(argname="argument store_ref", value=store_ref, expected_type=type_hints["store_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if generator_ref is not None:
            self._values["generator_ref"] = generator_ref
        if store_ref is not None:
            self._values["store_ref"] = store_ref

    @builtins.property
    def generator_ref(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef"]:
        '''GeneratorRef points to a generator custom resource.

        Deprecated: The generatorRef is not implemented in .data[].
        this will be removed with v1.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataSourceRef#generatorRef
        '''
        result = self._values.get("generator_ref")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef"], result)

    @builtins.property
    def store_ref(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef"]:
        '''SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataSourceRef#storeRef
        '''
        result = self._values.get("store_ref")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataSourceRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "name": "name", "api_version": "apiVersion"},
)
class ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef:
    def __init__(
        self,
        *,
        kind: "ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRefKind",
        name: builtins.str,
        api_version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''GeneratorRef points to a generator custom resource.

        Deprecated: The generatorRef is not implemented in .data[].
        this will be removed with v1.

        :param kind: Specify the Kind of the generator resource.
        :param name: Specify the name of the generator resource.
        :param api_version: Specify the apiVersion of the generator resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ea867ab7ffd78985b5466cb669c1f19364ef24ebebfa02dc826fe1699e74668)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "kind": kind,
            "name": name,
        }
        if api_version is not None:
            self._values["api_version"] = api_version

    @builtins.property
    def kind(
        self,
    ) -> "ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRefKind":
        '''Specify the Kind of the generator resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef#kind
        '''
        result = self._values.get("kind")
        assert result is not None, "Required property 'kind' is missing"
        return typing.cast("ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRefKind", result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Specify the name of the generator resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Specify the apiVersion of the generator resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef#apiVersion
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRefKind"
)
class ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRefKind(
    enum.Enum,
):
    '''Specify the Kind of the generator resource.

    :schema: ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRefKind
    '''

    ACR_ACCESS_TOKEN = "ACR_ACCESS_TOKEN"
    '''ACRAccessToken.'''
    CLUSTER_GENERATOR = "CLUSTER_GENERATOR"
    '''ClusterGenerator.'''
    ECR_AUTHORIZATION_TOKEN = "ECR_AUTHORIZATION_TOKEN"
    '''ECRAuthorizationToken.'''
    FAKE = "FAKE"
    '''Fake.'''
    GCR_ACCESS_TOKEN = "GCR_ACCESS_TOKEN"
    '''GCRAccessToken.'''
    GITHUB_ACCESS_TOKEN = "GITHUB_ACCESS_TOKEN"
    '''GithubAccessToken.'''
    PASSWORD = "PASSWORD"
    '''Password.'''
    STS_SESSION_TOKEN = "STS_SESSION_TOKEN"
    '''STSSessionToken.'''
    UUID = "UUID"
    '''UUID.'''
    VAULT_DYNAMIC_SECRET = "VAULT_DYNAMIC_SECRET"
    '''VaultDynamicSecret.'''
    WEBHOOK = "WEBHOOK"
    '''Webhook.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "name": "name"},
)
class ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef:
    def __init__(
        self,
        *,
        kind: typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRefKind"] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :param kind: Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``. Default: SecretStore`
        :param name: Name of the SecretStore resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e3dac67fdb5213d238cd0251a7010fac0f8e7b8a057409fb1a8bee6f32d9f70a)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if kind is not None:
            self._values["kind"] = kind
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def kind(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRefKind"]:
        '''Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``.

        :default: SecretStore`

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRefKind"], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the SecretStore resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRefKind"
)
class ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRefKind(enum.Enum):
    '''Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``.

    :default: SecretStore`

    :schema: ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRefKind
    '''

    SECRET_STORE = "SECRET_STORE"
    '''SecretStore.'''
    CLUSTER_SECRET_STORE = "CLUSTER_SECRET_STORE"
    '''ClusterSecretStore.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "name": "name"},
)
class ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef:
    def __init__(
        self,
        *,
        kind: typing.Optional["ClusterExternalSecretSpecExternalSecretSpecSecretStoreRefKind"] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :param kind: Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``. Default: SecretStore`
        :param name: Name of the SecretStore resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bbbc20c608aad33b8e32e75a11fc646a7ee61bc1d1f2e94de5bf32865235fd04)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if kind is not None:
            self._values["kind"] = kind
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def kind(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecSecretStoreRefKind"]:
        '''Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``.

        :default: SecretStore`

        :schema: ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecSecretStoreRefKind"], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the SecretStore resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecSecretStoreRefKind"
)
class ClusterExternalSecretSpecExternalSecretSpecSecretStoreRefKind(enum.Enum):
    '''Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``.

    :default: SecretStore`

    :schema: ClusterExternalSecretSpecExternalSecretSpecSecretStoreRefKind
    '''

    SECRET_STORE = "SECRET_STORE"
    '''SecretStore.'''
    CLUSTER_SECRET_STORE = "CLUSTER_SECRET_STORE"
    '''ClusterSecretStore.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTarget",
    jsii_struct_bases=[],
    name_mapping={
        "creation_policy": "creationPolicy",
        "deletion_policy": "deletionPolicy",
        "immutable": "immutable",
        "name": "name",
        "template": "template",
    },
)
class ClusterExternalSecretSpecExternalSecretSpecTarget:
    def __init__(
        self,
        *,
        creation_policy: typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy"] = None,
        deletion_policy: typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy"] = None,
        immutable: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
        template: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecTargetTemplate", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.

        :param creation_policy: CreationPolicy defines rules on how to create the resulting Secret. Defaults to "Owner" Default: Owner"
        :param deletion_policy: DeletionPolicy defines rules on how to delete the resulting Secret. Defaults to "Retain" Default: Retain"
        :param immutable: Immutable defines if the final secret will be immutable.
        :param name: The name of the Secret resource to be managed. Defaults to the .metadata.name of the ExternalSecret resource Default: the .metadata.name of the ExternalSecret resource
        :param template: Template defines a blueprint for the created Secret resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecTarget
        '''
        if isinstance(template, dict):
            template = ClusterExternalSecretSpecExternalSecretSpecTargetTemplate(**template)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d7d283c53e5807e3a14479debfe5a62ad7d33bbe1884db78b4005c97d7f9e572)
            check_type(argname="argument creation_policy", value=creation_policy, expected_type=type_hints["creation_policy"])
            check_type(argname="argument deletion_policy", value=deletion_policy, expected_type=type_hints["deletion_policy"])
            check_type(argname="argument immutable", value=immutable, expected_type=type_hints["immutable"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument template", value=template, expected_type=type_hints["template"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if creation_policy is not None:
            self._values["creation_policy"] = creation_policy
        if deletion_policy is not None:
            self._values["deletion_policy"] = deletion_policy
        if immutable is not None:
            self._values["immutable"] = immutable
        if name is not None:
            self._values["name"] = name
        if template is not None:
            self._values["template"] = template

    @builtins.property
    def creation_policy(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy"]:
        '''CreationPolicy defines rules on how to create the resulting Secret.

        Defaults to "Owner"

        :default: Owner"

        :schema: ClusterExternalSecretSpecExternalSecretSpecTarget#creationPolicy
        '''
        result = self._values.get("creation_policy")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy"], result)

    @builtins.property
    def deletion_policy(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy"]:
        '''DeletionPolicy defines rules on how to delete the resulting Secret.

        Defaults to "Retain"

        :default: Retain"

        :schema: ClusterExternalSecretSpecExternalSecretSpecTarget#deletionPolicy
        '''
        result = self._values.get("deletion_policy")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy"], result)

    @builtins.property
    def immutable(self) -> typing.Optional[builtins.bool]:
        '''Immutable defines if the final secret will be immutable.

        :schema: ClusterExternalSecretSpecExternalSecretSpecTarget#immutable
        '''
        result = self._values.get("immutable")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource to be managed.

        Defaults to the .metadata.name of the ExternalSecret resource

        :default: the .metadata.name of the ExternalSecret resource

        :schema: ClusterExternalSecretSpecExternalSecretSpecTarget#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def template(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplate"]:
        '''Template defines a blueprint for the created Secret resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecTarget#template
        '''
        result = self._values.get("template")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplate"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecTarget(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy"
)
class ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy(enum.Enum):
    '''CreationPolicy defines rules on how to create the resulting Secret.

    Defaults to "Owner"

    :default: Owner"

    :schema: ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy
    '''

    OWNER = "OWNER"
    '''Owner.'''
    ORPHAN = "ORPHAN"
    '''Orphan.'''
    MERGE = "MERGE"
    '''Merge.'''
    NONE = "NONE"
    '''None.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy"
)
class ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy(enum.Enum):
    '''DeletionPolicy defines rules on how to delete the resulting Secret.

    Defaults to "Retain"

    :default: Retain"

    :schema: ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy
    '''

    DELETE = "DELETE"
    '''Delete.'''
    MERGE = "MERGE"
    '''Merge.'''
    RETAIN = "RETAIN"
    '''Retain.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetTemplate",
    jsii_struct_bases=[],
    name_mapping={
        "data": "data",
        "engine_version": "engineVersion",
        "merge_policy": "mergePolicy",
        "metadata": "metadata",
        "template_from": "templateFrom",
        "type": "type",
    },
)
class ClusterExternalSecretSpecExternalSecretSpecTargetTemplate:
    def __init__(
        self,
        *,
        data: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        engine_version: typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateEngineVersion"] = None,
        merge_policy: typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMergePolicy"] = None,
        metadata: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata", typing.Dict[builtins.str, typing.Any]]] = None,
        template_from: typing.Optional[typing.Sequence[typing.Union["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom", typing.Dict[builtins.str, typing.Any]]]] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Template defines a blueprint for the created Secret resource.

        :param data: 
        :param engine_version: EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].
        :param merge_policy: 
        :param metadata: ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
        :param template_from: 
        :param type: 

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplate
        '''
        if isinstance(metadata, dict):
            metadata = ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata(**metadata)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e17311f817cc6c3870009753fdfc8659a03aed047d52e1c28f68c66c22f4326d)
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
            check_type(argname="argument engine_version", value=engine_version, expected_type=type_hints["engine_version"])
            check_type(argname="argument merge_policy", value=merge_policy, expected_type=type_hints["merge_policy"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument template_from", value=template_from, expected_type=type_hints["template_from"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if data is not None:
            self._values["data"] = data
        if engine_version is not None:
            self._values["engine_version"] = engine_version
        if merge_policy is not None:
            self._values["merge_policy"] = merge_policy
        if metadata is not None:
            self._values["metadata"] = metadata
        if template_from is not None:
            self._values["template_from"] = template_from
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def data(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#data
        '''
        result = self._values.get("data")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def engine_version(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateEngineVersion"]:
        '''EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#engineVersion
        '''
        result = self._values.get("engine_version")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateEngineVersion"], result)

    @builtins.property
    def merge_policy(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMergePolicy"]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#mergePolicy
        '''
        result = self._values.get("merge_policy")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMergePolicy"], result)

    @builtins.property
    def metadata(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata"]:
        '''ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata"], result)

    @builtins.property
    def template_from(
        self,
    ) -> typing.Optional[typing.List["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom"]]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#templateFrom
        '''
        result = self._values.get("template_from")
        return typing.cast(typing.Optional[typing.List["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom"]], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecTargetTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetTemplateEngineVersion"
)
class ClusterExternalSecretSpecExternalSecretSpecTargetTemplateEngineVersion(enum.Enum):
    '''EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].

    :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateEngineVersion
    '''

    V1 = "V1"
    '''v1.'''
    V2 = "V2"
    '''v2.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMergePolicy"
)
class ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMergePolicy(enum.Enum):
    '''
    :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMergePolicy
    '''

    REPLACE = "REPLACE"
    '''Replace.'''
    MERGE = "MERGE"
    '''Merge.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata",
    jsii_struct_bases=[],
    name_mapping={"annotations": "annotations", "labels": "labels"},
)
class ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.

        :param annotations: 
        :param labels: 

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e700cd106840de6b6b862611a9af63e0d1be6bba0dd554c7aed6acca92d19244)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if labels is not None:
            self._values["labels"] = labels

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom",
    jsii_struct_bases=[],
    name_mapping={
        "config_map": "configMap",
        "literal": "literal",
        "secret": "secret",
        "target": "target",
    },
)
class ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom:
    def __init__(
        self,
        *,
        config_map: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap", typing.Dict[builtins.str, typing.Any]]] = None,
        literal: typing.Optional[builtins.str] = None,
        secret: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret", typing.Dict[builtins.str, typing.Any]]] = None,
        target: typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromTarget"] = None,
    ) -> None:
        '''
        :param config_map: 
        :param literal: 
        :param secret: 
        :param target: 

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom
        '''
        if isinstance(config_map, dict):
            config_map = ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap(**config_map)
        if isinstance(secret, dict):
            secret = ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret(**secret)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6afaa4c609906e7626220c4fddf4bc3a8fcc807598ec8beb344f6b9de0f6269b)
            check_type(argname="argument config_map", value=config_map, expected_type=type_hints["config_map"])
            check_type(argname="argument literal", value=literal, expected_type=type_hints["literal"])
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
            check_type(argname="argument target", value=target, expected_type=type_hints["target"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if config_map is not None:
            self._values["config_map"] = config_map
        if literal is not None:
            self._values["literal"] = literal
        if secret is not None:
            self._values["secret"] = secret
        if target is not None:
            self._values["target"] = target

    @builtins.property
    def config_map(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap"]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom#configMap
        '''
        result = self._values.get("config_map")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap"], result)

    @builtins.property
    def literal(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom#literal
        '''
        result = self._values.get("literal")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret"]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom#secret
        '''
        result = self._values.get("secret")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret"], result)

    @builtins.property
    def target(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromTarget"]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom#target
        '''
        result = self._values.get("target")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromTarget"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap",
    jsii_struct_bases=[],
    name_mapping={"items": "items", "name": "name"},
)
class ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap:
    def __init__(
        self,
        *,
        items: typing.Sequence[typing.Union["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems", typing.Dict[builtins.str, typing.Any]]],
        name: builtins.str,
    ) -> None:
        '''
        :param items: A list of keys in the ConfigMap/Secret to use as templates for Secret data.
        :param name: The name of the ConfigMap/Secret resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e735e4983134a60d5944c221483b47abb6e945d1e4363c5bd39324ef1f6d902e)
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "items": items,
            "name": name,
        }

    @builtins.property
    def items(
        self,
    ) -> typing.List["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems"]:
        '''A list of keys in the ConfigMap/Secret to use as templates for Secret data.

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap#items
        '''
        result = self._values.get("items")
        assert result is not None, "Required property 'items' is missing"
        return typing.cast(typing.List["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems"], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ConfigMap/Secret resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "template_as": "templateAs"},
)
class ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems:
    def __init__(
        self,
        *,
        key: builtins.str,
        template_as: typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItemsTemplateAs"] = None,
    ) -> None:
        '''
        :param key: A key in the ConfigMap/Secret.
        :param template_as: 

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4cea9f6b57f176e25de456cef3b2ecab038f70307e22ed475c43feffc210d187)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument template_as", value=template_as, expected_type=type_hints["template_as"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
        }
        if template_as is not None:
            self._values["template_as"] = template_as

    @builtins.property
    def key(self) -> builtins.str:
        '''A key in the ConfigMap/Secret.

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def template_as(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItemsTemplateAs"]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems#templateAs
        '''
        result = self._values.get("template_as")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItemsTemplateAs"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItemsTemplateAs"
)
class ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItemsTemplateAs(
    enum.Enum,
):
    '''
    :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItemsTemplateAs
    '''

    VALUES = "VALUES"
    '''Values.'''
    KEYS_AND_VALUES = "KEYS_AND_VALUES"
    '''KeysAndValues.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret",
    jsii_struct_bases=[],
    name_mapping={"items": "items", "name": "name"},
)
class ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret:
    def __init__(
        self,
        *,
        items: typing.Sequence[typing.Union["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems", typing.Dict[builtins.str, typing.Any]]],
        name: builtins.str,
    ) -> None:
        '''
        :param items: A list of keys in the ConfigMap/Secret to use as templates for Secret data.
        :param name: The name of the ConfigMap/Secret resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__57da7f59eff3d4d95d8055111305c41a7897499965ce955542ca053061957d87)
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "items": items,
            "name": name,
        }

    @builtins.property
    def items(
        self,
    ) -> typing.List["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems"]:
        '''A list of keys in the ConfigMap/Secret to use as templates for Secret data.

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret#items
        '''
        result = self._values.get("items")
        assert result is not None, "Required property 'items' is missing"
        return typing.cast(typing.List["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems"], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ConfigMap/Secret resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "template_as": "templateAs"},
)
class ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems:
    def __init__(
        self,
        *,
        key: builtins.str,
        template_as: typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItemsTemplateAs"] = None,
    ) -> None:
        '''
        :param key: A key in the ConfigMap/Secret.
        :param template_as: 

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__679753049e28b5f77ae12540862ccff4cbfe346de1a2af57688741fa5517fdcf)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument template_as", value=template_as, expected_type=type_hints["template_as"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
        }
        if template_as is not None:
            self._values["template_as"] = template_as

    @builtins.property
    def key(self) -> builtins.str:
        '''A key in the ConfigMap/Secret.

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def template_as(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItemsTemplateAs"]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems#templateAs
        '''
        result = self._values.get("template_as")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItemsTemplateAs"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItemsTemplateAs"
)
class ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItemsTemplateAs(
    enum.Enum,
):
    '''
    :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItemsTemplateAs
    '''

    VALUES = "VALUES"
    '''Values.'''
    KEYS_AND_VALUES = "KEYS_AND_VALUES"
    '''KeysAndValues.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromTarget"
)
class ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromTarget(
    enum.Enum,
):
    '''
    :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromTarget
    '''

    DATA = "DATA"
    '''Data.'''
    ANNOTATIONS = "ANNOTATIONS"
    '''Annotations.'''
    LABELS = "LABELS"
    '''Labels.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterExternalSecretSpecNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterExternalSecretSpecNamespaceSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''The labels to select by to find the Namespaces to create the ExternalSecrets in.

        Deprecated: Use NamespaceSelectors instead.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterExternalSecretSpecNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e67e15ae7413ec89e9e1b028ba41fd1a6808fa4799949e1144033db1bce9375f)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterExternalSecretSpecNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterExternalSecretSpecNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterExternalSecretSpecNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterExternalSecretSpecNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterExternalSecretSpecNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterExternalSecretSpecNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29a0c54f3edfd70da195fb2028a37b74ef6137c8c5c102801f6e46ea8544e824)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterExternalSecretSpecNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterExternalSecretSpecNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: ClusterExternalSecretSpecNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecNamespaceSelectors",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterExternalSecretSpecNamespaceSelectors:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''A label selector is a label query over a set of resources.

        The result of matchLabels and
        matchExpressions are ANDed. An empty label selector matches all objects. A null
        label selector matches no objects.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterExternalSecretSpecNamespaceSelectors
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__63f9a14423beda1e46223e279f4c160319ad2adb6f5680b3a0eddf15e36a736e)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterExternalSecretSpecNamespaceSelectors#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterExternalSecretSpecNamespaceSelectors#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecNamespaceSelectors(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d206e1e151bff3e2c286fdc18e8127271e514c58791c38b149828428eb62bf7)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ClusterSecretStore(
    _cdk8s_d3d9af27.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="ioexternal-secrets.ClusterSecretStore",
):
    '''ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of ``storeRef`` fields.

    :schema: ClusterSecretStore
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ClusterSecretStoreSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a "ClusterSecretStore" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8dd63b4b951d1c0f1810393f2ea2739eb3c8df2dbba5c1c17c9369fa23105354)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ClusterSecretStoreProps(metadata=metadata, spec=spec)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest")
    @builtins.classmethod
    def manifest(
        cls,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ClusterSecretStoreSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> typing.Any:
        '''Renders a Kubernetes manifest for "ClusterSecretStore".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.
        '''
        props = ClusterSecretStoreProps(metadata=metadata, spec=spec)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''Renders the object to Kubernetes JSON.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> _cdk8s_d3d9af27.GroupVersionKind:
        '''Returns the apiVersion and kind for "ClusterSecretStore".'''
        return typing.cast(_cdk8s_d3d9af27.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreProps",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class ClusterSecretStoreProps:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ClusterSecretStoreSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of ``storeRef`` fields.

        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.

        :schema: ClusterSecretStore
        '''
        if isinstance(metadata, dict):
            metadata = _cdk8s_d3d9af27.ApiObjectMetadata(**metadata)
        if isinstance(spec, dict):
            spec = ClusterSecretStoreSpec(**spec)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e52cd74f3e3dc5a6f5e0e0439c1ee7ea1bd2ae23d61a00f1d7d48f492e9adc87)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(self) -> typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata]:
        '''
        :schema: ClusterSecretStore#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata], result)

    @builtins.property
    def spec(self) -> typing.Optional["ClusterSecretStoreSpec"]:
        '''SecretStoreSpec defines the desired state of SecretStore.

        :schema: ClusterSecretStore#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["ClusterSecretStoreSpec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpec",
    jsii_struct_bases=[],
    name_mapping={
        "provider": "provider",
        "controller": "controller",
        "retry_settings": "retrySettings",
    },
)
class ClusterSecretStoreSpec:
    def __init__(
        self,
        *,
        provider: typing.Union["ClusterSecretStoreSpecProvider", typing.Dict[builtins.str, typing.Any]],
        controller: typing.Optional[builtins.str] = None,
        retry_settings: typing.Optional[typing.Union["ClusterSecretStoreSpecRetrySettings", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''SecretStoreSpec defines the desired state of SecretStore.

        :param provider: Used to configure the provider. Only one provider may be set
        :param controller: Used to select the correct ESO controller (think: ingress.ingressClassName) The ESO controller is instantiated with a specific controller name and filters ES based on this property.
        :param retry_settings: Used to configure http retries if failed.

        :schema: ClusterSecretStoreSpec
        '''
        if isinstance(provider, dict):
            provider = ClusterSecretStoreSpecProvider(**provider)
        if isinstance(retry_settings, dict):
            retry_settings = ClusterSecretStoreSpecRetrySettings(**retry_settings)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__57b6b1dbca3a9f2481bd32974c96162d85bfa5e7fd9e1324c70c72f4c047323e)
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument controller", value=controller, expected_type=type_hints["controller"])
            check_type(argname="argument retry_settings", value=retry_settings, expected_type=type_hints["retry_settings"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "provider": provider,
        }
        if controller is not None:
            self._values["controller"] = controller
        if retry_settings is not None:
            self._values["retry_settings"] = retry_settings

    @builtins.property
    def provider(self) -> "ClusterSecretStoreSpecProvider":
        '''Used to configure the provider.

        Only one provider may be set

        :schema: ClusterSecretStoreSpec#provider
        '''
        result = self._values.get("provider")
        assert result is not None, "Required property 'provider' is missing"
        return typing.cast("ClusterSecretStoreSpecProvider", result)

    @builtins.property
    def controller(self) -> typing.Optional[builtins.str]:
        '''Used to select the correct ESO controller (think: ingress.ingressClassName) The ESO controller is instantiated with a specific controller name and filters ES based on this property.

        :schema: ClusterSecretStoreSpec#controller
        '''
        result = self._values.get("controller")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def retry_settings(self) -> typing.Optional["ClusterSecretStoreSpecRetrySettings"]:
        '''Used to configure http retries if failed.

        :schema: ClusterSecretStoreSpec#retrySettings
        '''
        result = self._values.get("retry_settings")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecRetrySettings"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProvider",
    jsii_struct_bases=[],
    name_mapping={
        "akeyless": "akeyless",
        "alibaba": "alibaba",
        "aws": "aws",
        "azurekv": "azurekv",
        "fake": "fake",
        "gcpsm": "gcpsm",
        "gitlab": "gitlab",
        "ibm": "ibm",
        "kubernetes": "kubernetes",
        "oracle": "oracle",
        "passworddepot": "passworddepot",
        "vault": "vault",
        "webhook": "webhook",
        "yandexlockbox": "yandexlockbox",
    },
)
class ClusterSecretStoreSpecProvider:
    def __init__(
        self,
        *,
        akeyless: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAkeyless", typing.Dict[builtins.str, typing.Any]]] = None,
        alibaba: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAlibaba", typing.Dict[builtins.str, typing.Any]]] = None,
        aws: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAws", typing.Dict[builtins.str, typing.Any]]] = None,
        azurekv: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAzurekv", typing.Dict[builtins.str, typing.Any]]] = None,
        fake: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderFake", typing.Dict[builtins.str, typing.Any]]] = None,
        gcpsm: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderGcpsm", typing.Dict[builtins.str, typing.Any]]] = None,
        gitlab: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderGitlab", typing.Dict[builtins.str, typing.Any]]] = None,
        ibm: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderIbm", typing.Dict[builtins.str, typing.Any]]] = None,
        kubernetes: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderKubernetes", typing.Dict[builtins.str, typing.Any]]] = None,
        oracle: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderOracle", typing.Dict[builtins.str, typing.Any]]] = None,
        passworddepot: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderPassworddepot", typing.Dict[builtins.str, typing.Any]]] = None,
        vault: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVault", typing.Dict[builtins.str, typing.Any]]] = None,
        webhook: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderWebhook", typing.Dict[builtins.str, typing.Any]]] = None,
        yandexlockbox: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderYandexlockbox", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Used to configure the provider.

        Only one provider may be set

        :param akeyless: Akeyless configures this store to sync secrets using Akeyless Vault provider.
        :param alibaba: Alibaba configures this store to sync secrets using Alibaba Cloud provider.
        :param aws: AWS configures this store to sync secrets using AWS Secret Manager provider.
        :param azurekv: AzureKV configures this store to sync secrets using Azure Key Vault provider.
        :param fake: Fake configures a store with static key/value pairs.
        :param gcpsm: GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.
        :param gitlab: GitLab configures this store to sync secrets using GitLab Variables provider.
        :param ibm: IBM configures this store to sync secrets using IBM Cloud provider.
        :param kubernetes: Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.
        :param oracle: Oracle configures this store to sync secrets using Oracle Vault provider.
        :param passworddepot: Configures a store to sync secrets with a Password Depot instance.
        :param vault: Vault configures this store to sync secrets using Hashi provider.
        :param webhook: Webhook configures this store to sync secrets using a generic templated webhook.
        :param yandexlockbox: YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :schema: ClusterSecretStoreSpecProvider
        '''
        if isinstance(akeyless, dict):
            akeyless = ClusterSecretStoreSpecProviderAkeyless(**akeyless)
        if isinstance(alibaba, dict):
            alibaba = ClusterSecretStoreSpecProviderAlibaba(**alibaba)
        if isinstance(aws, dict):
            aws = ClusterSecretStoreSpecProviderAws(**aws)
        if isinstance(azurekv, dict):
            azurekv = ClusterSecretStoreSpecProviderAzurekv(**azurekv)
        if isinstance(fake, dict):
            fake = ClusterSecretStoreSpecProviderFake(**fake)
        if isinstance(gcpsm, dict):
            gcpsm = ClusterSecretStoreSpecProviderGcpsm(**gcpsm)
        if isinstance(gitlab, dict):
            gitlab = ClusterSecretStoreSpecProviderGitlab(**gitlab)
        if isinstance(ibm, dict):
            ibm = ClusterSecretStoreSpecProviderIbm(**ibm)
        if isinstance(kubernetes, dict):
            kubernetes = ClusterSecretStoreSpecProviderKubernetes(**kubernetes)
        if isinstance(oracle, dict):
            oracle = ClusterSecretStoreSpecProviderOracle(**oracle)
        if isinstance(passworddepot, dict):
            passworddepot = ClusterSecretStoreSpecProviderPassworddepot(**passworddepot)
        if isinstance(vault, dict):
            vault = ClusterSecretStoreSpecProviderVault(**vault)
        if isinstance(webhook, dict):
            webhook = ClusterSecretStoreSpecProviderWebhook(**webhook)
        if isinstance(yandexlockbox, dict):
            yandexlockbox = ClusterSecretStoreSpecProviderYandexlockbox(**yandexlockbox)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b577f0ccbbef07f08ad1ab52f92fc2ed139f3591354a8294c647ea76a6470491)
            check_type(argname="argument akeyless", value=akeyless, expected_type=type_hints["akeyless"])
            check_type(argname="argument alibaba", value=alibaba, expected_type=type_hints["alibaba"])
            check_type(argname="argument aws", value=aws, expected_type=type_hints["aws"])
            check_type(argname="argument azurekv", value=azurekv, expected_type=type_hints["azurekv"])
            check_type(argname="argument fake", value=fake, expected_type=type_hints["fake"])
            check_type(argname="argument gcpsm", value=gcpsm, expected_type=type_hints["gcpsm"])
            check_type(argname="argument gitlab", value=gitlab, expected_type=type_hints["gitlab"])
            check_type(argname="argument ibm", value=ibm, expected_type=type_hints["ibm"])
            check_type(argname="argument kubernetes", value=kubernetes, expected_type=type_hints["kubernetes"])
            check_type(argname="argument oracle", value=oracle, expected_type=type_hints["oracle"])
            check_type(argname="argument passworddepot", value=passworddepot, expected_type=type_hints["passworddepot"])
            check_type(argname="argument vault", value=vault, expected_type=type_hints["vault"])
            check_type(argname="argument webhook", value=webhook, expected_type=type_hints["webhook"])
            check_type(argname="argument yandexlockbox", value=yandexlockbox, expected_type=type_hints["yandexlockbox"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if akeyless is not None:
            self._values["akeyless"] = akeyless
        if alibaba is not None:
            self._values["alibaba"] = alibaba
        if aws is not None:
            self._values["aws"] = aws
        if azurekv is not None:
            self._values["azurekv"] = azurekv
        if fake is not None:
            self._values["fake"] = fake
        if gcpsm is not None:
            self._values["gcpsm"] = gcpsm
        if gitlab is not None:
            self._values["gitlab"] = gitlab
        if ibm is not None:
            self._values["ibm"] = ibm
        if kubernetes is not None:
            self._values["kubernetes"] = kubernetes
        if oracle is not None:
            self._values["oracle"] = oracle
        if passworddepot is not None:
            self._values["passworddepot"] = passworddepot
        if vault is not None:
            self._values["vault"] = vault
        if webhook is not None:
            self._values["webhook"] = webhook
        if yandexlockbox is not None:
            self._values["yandexlockbox"] = yandexlockbox

    @builtins.property
    def akeyless(self) -> typing.Optional["ClusterSecretStoreSpecProviderAkeyless"]:
        '''Akeyless configures this store to sync secrets using Akeyless Vault provider.

        :schema: ClusterSecretStoreSpecProvider#akeyless
        '''
        result = self._values.get("akeyless")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAkeyless"], result)

    @builtins.property
    def alibaba(self) -> typing.Optional["ClusterSecretStoreSpecProviderAlibaba"]:
        '''Alibaba configures this store to sync secrets using Alibaba Cloud provider.

        :schema: ClusterSecretStoreSpecProvider#alibaba
        '''
        result = self._values.get("alibaba")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAlibaba"], result)

    @builtins.property
    def aws(self) -> typing.Optional["ClusterSecretStoreSpecProviderAws"]:
        '''AWS configures this store to sync secrets using AWS Secret Manager provider.

        :schema: ClusterSecretStoreSpecProvider#aws
        '''
        result = self._values.get("aws")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAws"], result)

    @builtins.property
    def azurekv(self) -> typing.Optional["ClusterSecretStoreSpecProviderAzurekv"]:
        '''AzureKV configures this store to sync secrets using Azure Key Vault provider.

        :schema: ClusterSecretStoreSpecProvider#azurekv
        '''
        result = self._values.get("azurekv")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAzurekv"], result)

    @builtins.property
    def fake(self) -> typing.Optional["ClusterSecretStoreSpecProviderFake"]:
        '''Fake configures a store with static key/value pairs.

        :schema: ClusterSecretStoreSpecProvider#fake
        '''
        result = self._values.get("fake")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderFake"], result)

    @builtins.property
    def gcpsm(self) -> typing.Optional["ClusterSecretStoreSpecProviderGcpsm"]:
        '''GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.

        :schema: ClusterSecretStoreSpecProvider#gcpsm
        '''
        result = self._values.get("gcpsm")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderGcpsm"], result)

    @builtins.property
    def gitlab(self) -> typing.Optional["ClusterSecretStoreSpecProviderGitlab"]:
        '''GitLab configures this store to sync secrets using GitLab Variables provider.

        :schema: ClusterSecretStoreSpecProvider#gitlab
        '''
        result = self._values.get("gitlab")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderGitlab"], result)

    @builtins.property
    def ibm(self) -> typing.Optional["ClusterSecretStoreSpecProviderIbm"]:
        '''IBM configures this store to sync secrets using IBM Cloud provider.

        :schema: ClusterSecretStoreSpecProvider#ibm
        '''
        result = self._values.get("ibm")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderIbm"], result)

    @builtins.property
    def kubernetes(self) -> typing.Optional["ClusterSecretStoreSpecProviderKubernetes"]:
        '''Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.

        :schema: ClusterSecretStoreSpecProvider#kubernetes
        '''
        result = self._values.get("kubernetes")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderKubernetes"], result)

    @builtins.property
    def oracle(self) -> typing.Optional["ClusterSecretStoreSpecProviderOracle"]:
        '''Oracle configures this store to sync secrets using Oracle Vault provider.

        :schema: ClusterSecretStoreSpecProvider#oracle
        '''
        result = self._values.get("oracle")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderOracle"], result)

    @builtins.property
    def passworddepot(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderPassworddepot"]:
        '''Configures a store to sync secrets with a Password Depot instance.

        :schema: ClusterSecretStoreSpecProvider#passworddepot
        '''
        result = self._values.get("passworddepot")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderPassworddepot"], result)

    @builtins.property
    def vault(self) -> typing.Optional["ClusterSecretStoreSpecProviderVault"]:
        '''Vault configures this store to sync secrets using Hashi provider.

        :schema: ClusterSecretStoreSpecProvider#vault
        '''
        result = self._values.get("vault")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVault"], result)

    @builtins.property
    def webhook(self) -> typing.Optional["ClusterSecretStoreSpecProviderWebhook"]:
        '''Webhook configures this store to sync secrets using a generic templated webhook.

        :schema: ClusterSecretStoreSpecProvider#webhook
        '''
        result = self._values.get("webhook")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderWebhook"], result)

    @builtins.property
    def yandexlockbox(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderYandexlockbox"]:
        '''YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :schema: ClusterSecretStoreSpecProvider#yandexlockbox
        '''
        result = self._values.get("yandexlockbox")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderYandexlockbox"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAkeyless",
    jsii_struct_bases=[],
    name_mapping={
        "akeyless_gw_api_url": "akeylessGwApiUrl",
        "auth_secret_ref": "authSecretRef",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
    },
)
class ClusterSecretStoreSpecProviderAkeyless:
    def __init__(
        self,
        *,
        akeyless_gw_api_url: builtins.str,
        auth_secret_ref: typing.Union["ClusterSecretStoreSpecProviderAkeylessAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAkeylessCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Akeyless configures this store to sync secrets using Akeyless Vault provider.

        :param akeyless_gw_api_url: Akeyless GW API Url from which the secrets to be fetched from.
        :param auth_secret_ref: Auth configures how the operator authenticates with Akeyless.
        :param ca_bundle: PEM/base64 encoded CA bundle used to validate Akeyless Gateway certificate. Only used if the AkeylessGWApiURL URL is using HTTPS protocol. If not set the system root certificates are used to validate the TLS connection.
        :param ca_provider: The provider for the CA bundle to use to validate Akeyless Gateway certificate.

        :schema: ClusterSecretStoreSpecProviderAkeyless
        '''
        if isinstance(auth_secret_ref, dict):
            auth_secret_ref = ClusterSecretStoreSpecProviderAkeylessAuthSecretRef(**auth_secret_ref)
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreSpecProviderAkeylessCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb1f3b613f8eb456b5c2efddbc3a0dcaaa7290a58a21df5ba0e0ad6d189c7245)
            check_type(argname="argument akeyless_gw_api_url", value=akeyless_gw_api_url, expected_type=type_hints["akeyless_gw_api_url"])
            check_type(argname="argument auth_secret_ref", value=auth_secret_ref, expected_type=type_hints["auth_secret_ref"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "akeyless_gw_api_url": akeyless_gw_api_url,
            "auth_secret_ref": auth_secret_ref,
        }
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider

    @builtins.property
    def akeyless_gw_api_url(self) -> builtins.str:
        '''Akeyless GW API Url from which the secrets to be fetched from.

        :schema: ClusterSecretStoreSpecProviderAkeyless#akeylessGWApiURL
        '''
        result = self._values.get("akeyless_gw_api_url")
        assert result is not None, "Required property 'akeyless_gw_api_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth_secret_ref(self) -> "ClusterSecretStoreSpecProviderAkeylessAuthSecretRef":
        '''Auth configures how the operator authenticates with Akeyless.

        :schema: ClusterSecretStoreSpecProviderAkeyless#authSecretRef
        '''
        result = self._values.get("auth_secret_ref")
        assert result is not None, "Required property 'auth_secret_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderAkeylessAuthSecretRef", result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''PEM/base64 encoded CA bundle used to validate Akeyless Gateway certificate.

        Only used
        if the AkeylessGWApiURL URL is using HTTPS protocol. If not set the system root certificates
        are used to validate the TLS connection.

        :schema: ClusterSecretStoreSpecProviderAkeyless#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAkeylessCaProvider"]:
        '''The provider for the CA bundle to use to validate Akeyless Gateway certificate.

        :schema: ClusterSecretStoreSpecProviderAkeyless#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAkeylessCaProvider"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAkeyless(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAkeylessAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"kubernetes_auth": "kubernetesAuth", "secret_ref": "secretRef"},
)
class ClusterSecretStoreSpecProviderAkeylessAuthSecretRef:
    def __init__(
        self,
        *,
        kubernetes_auth: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how the operator authenticates with Akeyless.

        :param kubernetes_auth: Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
        :param secret_ref: Reference to a Secret that contains the details to authenticate with Akeyless.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRef
        '''
        if isinstance(kubernetes_auth, dict):
            kubernetes_auth = ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth(**kubernetes_auth)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a1add6ad905d4b2103c32761e6970d8d214a73ed5201b1a98c08d00a43c853f7)
            check_type(argname="argument kubernetes_auth", value=kubernetes_auth, expected_type=type_hints["kubernetes_auth"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if kubernetes_auth is not None:
            self._values["kubernetes_auth"] = kubernetes_auth
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def kubernetes_auth(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth"]:
        '''Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRef#kubernetesAuth
        '''
        result = self._values.get("kubernetes_auth")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef"]:
        '''Reference to a Secret that contains the details to authenticate with Akeyless.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRef#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAkeylessAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth",
    jsii_struct_bases=[],
    name_mapping={
        "access_id": "accessId",
        "k8_s_conf_name": "k8SConfName",
        "secret_ref": "secretRef",
        "service_account_ref": "serviceAccountRef",
    },
)
class ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth:
    def __init__(
        self,
        *,
        access_id: builtins.str,
        k8_s_conf_name: builtins.str,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.

        :param access_id: the Akeyless Kubernetes auth-method access-id.
        :param k8_s_conf_name: Kubernetes-auth configuration name in Akeyless-Gateway.
        :param secret_ref: Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.
        :param service_account_ref: Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(**secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__09e802798f87b8377e20a5baa142f3095f97079a62d35b23ac9b89263cbfac51)
            check_type(argname="argument access_id", value=access_id, expected_type=type_hints["access_id"])
            check_type(argname="argument k8_s_conf_name", value=k8_s_conf_name, expected_type=type_hints["k8_s_conf_name"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "access_id": access_id,
            "k8_s_conf_name": k8_s_conf_name,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def access_id(self) -> builtins.str:
        '''the Akeyless Kubernetes auth-method access-id.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#accessID
        '''
        result = self._values.get("access_id")
        assert result is not None, "Required property 'access_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def k8_s_conf_name(self) -> builtins.str:
        '''Kubernetes-auth configuration name in Akeyless-Gateway.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#k8sConfName
        '''
        result = self._values.get("k8_s_conf_name")
        assert result is not None, "Required property 'k8_s_conf_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef"]:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless.

        If a name is specified without a key,
        ``token`` is the default. If one is not specified, the one bound to
        the controller will be used.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef"]:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used
        for authenticating with Akeyless. If the service account selector is not supplied,
        the secretRef will be used instead.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless.

        If a name is specified without a key,
        ``token`` is the default. If one is not specified, the one bound to
        the controller will be used.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe2322d9ce4d70c2c6498168db62dc60ec37d6d55fbdb7b4595d224eadbb7f4d)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used
        for authenticating with Akeyless. If the service account selector is not supplied,
        the secretRef will be used instead.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c89202b1ec979b714ae00fcaa502eaf9b609424705834f082bf349b7f789d59)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_id": "accessId",
        "access_type": "accessType",
        "access_type_param": "accessTypeParam",
    },
)
class ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef:
    def __init__(
        self,
        *,
        access_id: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId", typing.Dict[builtins.str, typing.Any]]] = None,
        access_type: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType", typing.Dict[builtins.str, typing.Any]]] = None,
        access_type_param: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Reference to a Secret that contains the details to authenticate with Akeyless.

        :param access_id: The SecretAccessID is used for authentication.
        :param access_type: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param access_type_param: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef
        '''
        if isinstance(access_id, dict):
            access_id = ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId(**access_id)
        if isinstance(access_type, dict):
            access_type = ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType(**access_type)
        if isinstance(access_type_param, dict):
            access_type_param = ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(**access_type_param)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__035cb6945bc194f917abd47ca70a68244da344a68f14f7f033c3b028e0dee454)
            check_type(argname="argument access_id", value=access_id, expected_type=type_hints["access_id"])
            check_type(argname="argument access_type", value=access_type, expected_type=type_hints["access_type"])
            check_type(argname="argument access_type_param", value=access_type_param, expected_type=type_hints["access_type_param"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if access_id is not None:
            self._values["access_id"] = access_id
        if access_type is not None:
            self._values["access_type"] = access_type
        if access_type_param is not None:
            self._values["access_type_param"] = access_type_param

    @builtins.property
    def access_id(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId"]:
        '''The SecretAccessID is used for authentication.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessID
        '''
        result = self._values.get("access_id")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId"], result)

    @builtins.property
    def access_type(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessType
        '''
        result = self._values.get("access_type")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType"], result)

    @builtins.property
    def access_type_param(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessTypeParam
        '''
        result = self._values.get("access_type_param")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessID is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a938d7a10afd24ef476da4a5595b2a159a6ff353311720640d3183cab2237e9b)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__762aa62305da5c5cd7def193e14a6fa135c8f017f035428cf738add22df97bc8)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2dcf00eb7f5ff015d34783bafe7aaa9f134a7caabbca3827419d5ae0205adbc9)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAkeylessCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class ClusterSecretStoreSpecProviderAkeylessCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "ClusterSecretStoreSpecProviderAkeylessCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Akeyless Gateway certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in.

        :schema: ClusterSecretStoreSpecProviderAkeylessCaProvider
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c007e96589ec6b2844631ca03619f1b0870c03d301b7192f5f353c30385f176)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: ClusterSecretStoreSpecProviderAkeylessCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "ClusterSecretStoreSpecProviderAkeylessCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: ClusterSecretStoreSpecProviderAkeylessCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderAkeylessCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: ClusterSecretStoreSpecProviderAkeylessCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        :schema: ClusterSecretStoreSpecProviderAkeylessCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAkeylessCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAkeylessCaProviderType"
)
class ClusterSecretStoreSpecProviderAkeylessCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: ClusterSecretStoreSpecProviderAkeylessCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAlibaba",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "region_id": "regionId"},
)
class ClusterSecretStoreSpecProviderAlibaba:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreSpecProviderAlibabaAuth", typing.Dict[builtins.str, typing.Any]],
        region_id: builtins.str,
    ) -> None:
        '''Alibaba configures this store to sync secrets using Alibaba Cloud provider.

        :param auth: AlibabaAuth contains a secretRef for credentials.
        :param region_id: Alibaba Region to be used for the provider.

        :schema: ClusterSecretStoreSpecProviderAlibaba
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreSpecProviderAlibabaAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a5ff624b83768ab7e3f6981bd9dbaf0c920598597111dc90a49f4e43af854503)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument region_id", value=region_id, expected_type=type_hints["region_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "region_id": region_id,
        }

    @builtins.property
    def auth(self) -> "ClusterSecretStoreSpecProviderAlibabaAuth":
        '''AlibabaAuth contains a secretRef for credentials.

        :schema: ClusterSecretStoreSpecProviderAlibaba#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderAlibabaAuth", result)

    @builtins.property
    def region_id(self) -> builtins.str:
        '''Alibaba Region to be used for the provider.

        :schema: ClusterSecretStoreSpecProviderAlibaba#regionID
        '''
        result = self._values.get("region_id")
        assert result is not None, "Required property 'region_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAlibaba(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAlibabaAuth",
    jsii_struct_bases=[],
    name_mapping={"rrsa": "rrsa", "secret_ref": "secretRef"},
)
class ClusterSecretStoreSpecProviderAlibabaAuth:
    def __init__(
        self,
        *,
        rrsa: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAlibabaAuthRrsa", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAlibabaAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''AlibabaAuth contains a secretRef for credentials.

        :param rrsa: Authenticate against Alibaba using RRSA.
        :param secret_ref: AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuth
        '''
        if isinstance(rrsa, dict):
            rrsa = ClusterSecretStoreSpecProviderAlibabaAuthRrsa(**rrsa)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderAlibabaAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a3e71811aee1daf711f7bac2275e4c3a683aa7203798d77f39b0ef34d5bd4d8f)
            check_type(argname="argument rrsa", value=rrsa, expected_type=type_hints["rrsa"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if rrsa is not None:
            self._values["rrsa"] = rrsa
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def rrsa(self) -> typing.Optional["ClusterSecretStoreSpecProviderAlibabaAuthRrsa"]:
        '''Authenticate against Alibaba using RRSA.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuth#rrsa
        '''
        result = self._values.get("rrsa")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAlibabaAuthRrsa"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAlibabaAuthSecretRef"]:
        '''AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAlibabaAuthSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAlibabaAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAlibabaAuthRrsa",
    jsii_struct_bases=[],
    name_mapping={
        "oidc_provider_arn": "oidcProviderArn",
        "oidc_token_file_path": "oidcTokenFilePath",
        "role_arn": "roleArn",
        "session_name": "sessionName",
    },
)
class ClusterSecretStoreSpecProviderAlibabaAuthRrsa:
    def __init__(
        self,
        *,
        oidc_provider_arn: builtins.str,
        oidc_token_file_path: builtins.str,
        role_arn: builtins.str,
        session_name: builtins.str,
    ) -> None:
        '''Authenticate against Alibaba using RRSA.

        :param oidc_provider_arn: 
        :param oidc_token_file_path: 
        :param role_arn: 
        :param session_name: 

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthRrsa
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c9b387e718990c982ab8ed3bda219992a33a3611431a7be98fa20bfdec2d8004)
            check_type(argname="argument oidc_provider_arn", value=oidc_provider_arn, expected_type=type_hints["oidc_provider_arn"])
            check_type(argname="argument oidc_token_file_path", value=oidc_token_file_path, expected_type=type_hints["oidc_token_file_path"])
            check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            check_type(argname="argument session_name", value=session_name, expected_type=type_hints["session_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "oidc_provider_arn": oidc_provider_arn,
            "oidc_token_file_path": oidc_token_file_path,
            "role_arn": role_arn,
            "session_name": session_name,
        }

    @builtins.property
    def oidc_provider_arn(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreSpecProviderAlibabaAuthRrsa#oidcProviderArn
        '''
        result = self._values.get("oidc_provider_arn")
        assert result is not None, "Required property 'oidc_provider_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def oidc_token_file_path(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreSpecProviderAlibabaAuthRrsa#oidcTokenFilePath
        '''
        result = self._values.get("oidc_token_file_path")
        assert result is not None, "Required property 'oidc_token_file_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role_arn(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreSpecProviderAlibabaAuthRrsa#roleArn
        '''
        result = self._values.get("role_arn")
        assert result is not None, "Required property 'role_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def session_name(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreSpecProviderAlibabaAuthRrsa#sessionName
        '''
        result = self._values.get("session_name")
        assert result is not None, "Required property 'session_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAlibabaAuthRrsa(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAlibabaAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_key_id_secret_ref": "accessKeyIdSecretRef",
        "access_key_secret_secret_ref": "accessKeySecretSecretRef",
    },
)
class ClusterSecretStoreSpecProviderAlibabaAuthSecretRef:
    def __init__(
        self,
        *,
        access_key_id_secret_ref: typing.Union["ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef", typing.Dict[builtins.str, typing.Any]],
        access_key_secret_secret_ref: typing.Union["ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :param access_key_id_secret_ref: The AccessKeyID is used for authentication.
        :param access_key_secret_secret_ref: The AccessKeySecret is used for authentication.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRef
        '''
        if isinstance(access_key_id_secret_ref, dict):
            access_key_id_secret_ref = ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(**access_key_id_secret_ref)
        if isinstance(access_key_secret_secret_ref, dict):
            access_key_secret_secret_ref = ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(**access_key_secret_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__91e926199bf20fc1a102ce65ad3b639e0398edcf53243008995020f063edf9ab)
            check_type(argname="argument access_key_id_secret_ref", value=access_key_id_secret_ref, expected_type=type_hints["access_key_id_secret_ref"])
            check_type(argname="argument access_key_secret_secret_ref", value=access_key_secret_secret_ref, expected_type=type_hints["access_key_secret_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "access_key_id_secret_ref": access_key_id_secret_ref,
            "access_key_secret_secret_ref": access_key_secret_secret_ref,
        }

    @builtins.property
    def access_key_id_secret_ref(
        self,
    ) -> "ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef":
        '''The AccessKeyID is used for authentication.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRef#accessKeyIDSecretRef
        '''
        result = self._values.get("access_key_id_secret_ref")
        assert result is not None, "Required property 'access_key_id_secret_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef", result)

    @builtins.property
    def access_key_secret_secret_ref(
        self,
    ) -> "ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef":
        '''The AccessKeySecret is used for authentication.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRef#accessKeySecretSecretRef
        '''
        result = self._values.get("access_key_secret_secret_ref")
        assert result is not None, "Required property 'access_key_secret_secret_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAlibabaAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeyID is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__577c863fea491e359b51abf5fe73e1d4acc1c81ea7401361e1c6cd8c07c011ee)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeySecret is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__48b18145fd0d8fe181e65bd8874d2e03b8e44f3a00137400c5dc630d92c474bb)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAws",
    jsii_struct_bases=[],
    name_mapping={
        "region": "region",
        "service": "service",
        "auth": "auth",
        "role": "role",
    },
)
class ClusterSecretStoreSpecProviderAws:
    def __init__(
        self,
        *,
        region: builtins.str,
        service: "ClusterSecretStoreSpecProviderAwsService",
        auth: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAwsAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        role: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AWS configures this store to sync secrets using AWS Secret Manager provider.

        :param region: AWS Region to be used for the provider.
        :param service: Service defines which service should be used to fetch the secrets.
        :param auth: Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.
        :param role: Role is a Role ARN which the SecretManager provider will assume.

        :schema: ClusterSecretStoreSpecProviderAws
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreSpecProviderAwsAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b890d76e5f0d682e477d7b20c0020358b39d98bd01a9432e52c7c4a8ac616f0)
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "region": region,
            "service": service,
        }
        if auth is not None:
            self._values["auth"] = auth
        if role is not None:
            self._values["role"] = role

    @builtins.property
    def region(self) -> builtins.str:
        '''AWS Region to be used for the provider.

        :schema: ClusterSecretStoreSpecProviderAws#region
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service(self) -> "ClusterSecretStoreSpecProviderAwsService":
        '''Service defines which service should be used to fetch the secrets.

        :schema: ClusterSecretStoreSpecProviderAws#service
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderAwsService", result)

    @builtins.property
    def auth(self) -> typing.Optional["ClusterSecretStoreSpecProviderAwsAuth"]:
        '''Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.

        :schema: ClusterSecretStoreSpecProviderAws#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAwsAuth"], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a Role ARN which the SecretManager provider will assume.

        :schema: ClusterSecretStoreSpecProviderAws#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAws(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAwsAuth",
    jsii_struct_bases=[],
    name_mapping={"jwt": "jwt", "secret_ref": "secretRef"},
)
class ClusterSecretStoreSpecProviderAwsAuth:
    def __init__(
        self,
        *,
        jwt: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAwsAuthJwt", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAwsAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.

        :param jwt: Authenticate against AWS using service account tokens.
        :param secret_ref: AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :schema: ClusterSecretStoreSpecProviderAwsAuth
        '''
        if isinstance(jwt, dict):
            jwt = ClusterSecretStoreSpecProviderAwsAuthJwt(**jwt)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderAwsAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a6dd72e093e44f4d176c7ac71615a880705b99b630555e7ce1e4ea69742c5efb)
            check_type(argname="argument jwt", value=jwt, expected_type=type_hints["jwt"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if jwt is not None:
            self._values["jwt"] = jwt
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def jwt(self) -> typing.Optional["ClusterSecretStoreSpecProviderAwsAuthJwt"]:
        '''Authenticate against AWS using service account tokens.

        :schema: ClusterSecretStoreSpecProviderAwsAuth#jwt
        '''
        result = self._values.get("jwt")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAwsAuthJwt"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAwsAuthSecretRef"]:
        '''AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :schema: ClusterSecretStoreSpecProviderAwsAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAwsAuthSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAwsAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAwsAuthJwt",
    jsii_struct_bases=[],
    name_mapping={"service_account_ref": "serviceAccountRef"},
)
class ClusterSecretStoreSpecProviderAwsAuthJwt:
    def __init__(
        self,
        *,
        service_account_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Authenticate against AWS using service account tokens.

        :param service_account_ref: A reference to a ServiceAccount resource.

        :schema: ClusterSecretStoreSpecProviderAwsAuthJwt
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e7d772d91778f286ba674c40734f79974636800252dcb80ba3aedb4417ec64cb)
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef"]:
        '''A reference to a ServiceAccount resource.

        :schema: ClusterSecretStoreSpecProviderAwsAuthJwt#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAwsAuthJwt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de10cf2ddb938d6fc92b26c35d489e4b0afd1f528224b33c4acedc8f7b7c55d4)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAwsAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_key_id_secret_ref": "accessKeyIdSecretRef",
        "secret_access_key_secret_ref": "secretAccessKeySecretRef",
    },
)
class ClusterSecretStoreSpecProviderAwsAuthSecretRef:
    def __init__(
        self,
        *,
        access_key_id_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_access_key_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :param access_key_id_secret_ref: The AccessKeyID is used for authentication.
        :param secret_access_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRef
        '''
        if isinstance(access_key_id_secret_ref, dict):
            access_key_id_secret_ref = ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(**access_key_id_secret_ref)
        if isinstance(secret_access_key_secret_ref, dict):
            secret_access_key_secret_ref = ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(**secret_access_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__382d054259503c641b10cacac05db506fe361c058f5e49c99de7f0f9505e7137)
            check_type(argname="argument access_key_id_secret_ref", value=access_key_id_secret_ref, expected_type=type_hints["access_key_id_secret_ref"])
            check_type(argname="argument secret_access_key_secret_ref", value=secret_access_key_secret_ref, expected_type=type_hints["secret_access_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if access_key_id_secret_ref is not None:
            self._values["access_key_id_secret_ref"] = access_key_id_secret_ref
        if secret_access_key_secret_ref is not None:
            self._values["secret_access_key_secret_ref"] = secret_access_key_secret_ref

    @builtins.property
    def access_key_id_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef"]:
        '''The AccessKeyID is used for authentication.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRef#accessKeyIDSecretRef
        '''
        result = self._values.get("access_key_id_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef"], result)

    @builtins.property
    def secret_access_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRef#secretAccessKeySecretRef
        '''
        result = self._values.get("secret_access_key_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAwsAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeyID is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6651cda229033cd18398fe288cd6b6e8a7837eb3b8dcacc21b46f1303f7ab9fb)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__14d2105b0a56fd40c4ef74beca49699465299985a43951d9b6c98760df53d36d)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAwsService")
class ClusterSecretStoreSpecProviderAwsService(enum.Enum):
    '''Service defines which service should be used to fetch the secrets.

    :schema: ClusterSecretStoreSpecProviderAwsService
    '''

    SECRETS_MANAGER = "SECRETS_MANAGER"
    '''SecretsManager.'''
    PARAMETER_STORE = "PARAMETER_STORE"
    '''ParameterStore.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAzurekv",
    jsii_struct_bases=[],
    name_mapping={
        "vault_url": "vaultUrl",
        "auth_secret_ref": "authSecretRef",
        "auth_type": "authType",
        "identity_id": "identityId",
        "service_account_ref": "serviceAccountRef",
        "tenant_id": "tenantId",
    },
)
class ClusterSecretStoreSpecProviderAzurekv:
    def __init__(
        self,
        *,
        vault_url: builtins.str,
        auth_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAzurekvAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        auth_type: typing.Optional["ClusterSecretStoreSpecProviderAzurekvAuthType"] = None,
        identity_id: typing.Optional[builtins.str] = None,
        service_account_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAzurekvServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
        tenant_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AzureKV configures this store to sync secrets using Azure Key Vault provider.

        :param vault_url: Vault Url from which the secrets to be fetched from.
        :param auth_secret_ref: Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type.
        :param auth_type: Auth type defines how to authenticate to the keyvault service. Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
        :param identity_id: If multiple Managed Identity is assigned to the pod, you can select the one to be used.
        :param service_account_ref: ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
        :param tenant_id: TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type.

        :schema: ClusterSecretStoreSpecProviderAzurekv
        '''
        if isinstance(auth_secret_ref, dict):
            auth_secret_ref = ClusterSecretStoreSpecProviderAzurekvAuthSecretRef(**auth_secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreSpecProviderAzurekvServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c241f0bdca3970aef7e1768427fdaa91976bc172e6a9adf9266bf73940958d82)
            check_type(argname="argument vault_url", value=vault_url, expected_type=type_hints["vault_url"])
            check_type(argname="argument auth_secret_ref", value=auth_secret_ref, expected_type=type_hints["auth_secret_ref"])
            check_type(argname="argument auth_type", value=auth_type, expected_type=type_hints["auth_type"])
            check_type(argname="argument identity_id", value=identity_id, expected_type=type_hints["identity_id"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument tenant_id", value=tenant_id, expected_type=type_hints["tenant_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vault_url": vault_url,
        }
        if auth_secret_ref is not None:
            self._values["auth_secret_ref"] = auth_secret_ref
        if auth_type is not None:
            self._values["auth_type"] = auth_type
        if identity_id is not None:
            self._values["identity_id"] = identity_id
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref
        if tenant_id is not None:
            self._values["tenant_id"] = tenant_id

    @builtins.property
    def vault_url(self) -> builtins.str:
        '''Vault Url from which the secrets to be fetched from.

        :schema: ClusterSecretStoreSpecProviderAzurekv#vaultUrl
        '''
        result = self._values.get("vault_url")
        assert result is not None, "Required property 'vault_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAzurekvAuthSecretRef"]:
        '''Auth configures how the operator authenticates with Azure.

        Required for ServicePrincipal auth type.

        :schema: ClusterSecretStoreSpecProviderAzurekv#authSecretRef
        '''
        result = self._values.get("auth_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAzurekvAuthSecretRef"], result)

    @builtins.property
    def auth_type(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAzurekvAuthType"]:
        '''Auth type defines how to authenticate to the keyvault service.

        Valid values are:

        - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret)
        - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)

        :schema: ClusterSecretStoreSpecProviderAzurekv#authType
        '''
        result = self._values.get("auth_type")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAzurekvAuthType"], result)

    @builtins.property
    def identity_id(self) -> typing.Optional[builtins.str]:
        '''If multiple Managed Identity is assigned to the pod, you can select the one to be used.

        :schema: ClusterSecretStoreSpecProviderAzurekv#identityId
        '''
        result = self._values.get("identity_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAzurekvServiceAccountRef"]:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :schema: ClusterSecretStoreSpecProviderAzurekv#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAzurekvServiceAccountRef"], result)

    @builtins.property
    def tenant_id(self) -> typing.Optional[builtins.str]:
        '''TenantID configures the Azure Tenant to send requests to.

        Required for ServicePrincipal auth type.

        :schema: ClusterSecretStoreSpecProviderAzurekv#tenantId
        '''
        result = self._values.get("tenant_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAzurekv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAzurekvAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"client_id": "clientId", "client_secret": "clientSecret"},
)
class ClusterSecretStoreSpecProviderAzurekvAuthSecretRef:
    def __init__(
        self,
        *,
        client_id: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId", typing.Dict[builtins.str, typing.Any]]] = None,
        client_secret: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how the operator authenticates with Azure.

        Required for ServicePrincipal auth type.

        :param client_id: The Azure clientId of the service principle used for authentication.
        :param client_secret: The Azure ClientSecret of the service principle used for authentication.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRef
        '''
        if isinstance(client_id, dict):
            client_id = ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId(**client_id)
        if isinstance(client_secret, dict):
            client_secret = ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret(**client_secret)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__50107c061e058c695ef89a240623f5c9f9c8bdec05e3550652703edc1613a9d6)
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret", value=client_secret, expected_type=type_hints["client_secret"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if client_id is not None:
            self._values["client_id"] = client_id
        if client_secret is not None:
            self._values["client_secret"] = client_secret

    @builtins.property
    def client_id(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId"]:
        '''The Azure clientId of the service principle used for authentication.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRef#clientId
        '''
        result = self._values.get("client_id")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId"], result)

    @builtins.property
    def client_secret(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret"]:
        '''The Azure ClientSecret of the service principle used for authentication.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRef#clientSecret
        '''
        result = self._values.get("client_secret")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAzurekvAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Azure clientId of the service principle used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__07b0ecddeaed41a84aa2643dd718d462b1146ec6772530b4f5c3c47e1b733cf5)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Azure ClientSecret of the service principle used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__68559f3a5d6b2b8a93dcb32624f88b8d3a6cfd24de8ffe4e2e190efd3965eba4)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAzurekvAuthType"
)
class ClusterSecretStoreSpecProviderAzurekvAuthType(enum.Enum):
    '''Auth type defines how to authenticate to the keyvault service.

    Valid values are:

    - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret)
    - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)

    :schema: ClusterSecretStoreSpecProviderAzurekvAuthType
    '''

    SERVICE_PRINCIPAL = "SERVICE_PRINCIPAL"
    '''ServicePrincipal.'''
    MANAGED_IDENTITY = "MANAGED_IDENTITY"
    '''ManagedIdentity.'''
    WORKLOAD_IDENTITY = "WORKLOAD_IDENTITY"
    '''WorkloadIdentity.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAzurekvServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAzurekvServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAzurekvServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f9bc3908e702dbfc1f5487ab0c0ab8d9ac9fbe77dc944911fa425330ed9bf8c)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAzurekvServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreSpecProviderAzurekvServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAzurekvServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAzurekvServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderFake",
    jsii_struct_bases=[],
    name_mapping={"data": "data"},
)
class ClusterSecretStoreSpecProviderFake:
    def __init__(
        self,
        *,
        data: typing.Sequence[typing.Union["ClusterSecretStoreSpecProviderFakeData", typing.Dict[builtins.str, typing.Any]]],
    ) -> None:
        '''Fake configures a store with static key/value pairs.

        :param data: 

        :schema: ClusterSecretStoreSpecProviderFake
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f2d1b2afe891f49350ca0f79d38693b672edb585eb22bca05a5a2a9cc67c77a0)
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "data": data,
        }

    @builtins.property
    def data(self) -> typing.List["ClusterSecretStoreSpecProviderFakeData"]:
        '''
        :schema: ClusterSecretStoreSpecProviderFake#data
        '''
        result = self._values.get("data")
        assert result is not None, "Required property 'data' is missing"
        return typing.cast(typing.List["ClusterSecretStoreSpecProviderFakeData"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderFake(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderFakeData",
    jsii_struct_bases=[],
    name_mapping={
        "key": "key",
        "value": "value",
        "value_map": "valueMap",
        "version": "version",
    },
)
class ClusterSecretStoreSpecProviderFakeData:
    def __init__(
        self,
        *,
        key: builtins.str,
        value: typing.Optional[builtins.str] = None,
        value_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param key: 
        :param value: 
        :param value_map: 
        :param version: 

        :schema: ClusterSecretStoreSpecProviderFakeData
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06c3a06c0205d70bc5e04befc5fa15e0d81efb1d139829a1b10122852ccddee3)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            check_type(argname="argument value_map", value=value_map, expected_type=type_hints["value_map"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
        }
        if value is not None:
            self._values["value"] = value
        if value_map is not None:
            self._values["value_map"] = value_map
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreSpecProviderFakeData#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreSpecProviderFakeData#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value_map(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ClusterSecretStoreSpecProviderFakeData#valueMap
        '''
        result = self._values.get("value_map")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreSpecProviderFakeData#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderFakeData(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderGcpsm",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "project_id": "projectId"},
)
class ClusterSecretStoreSpecProviderGcpsm:
    def __init__(
        self,
        *,
        auth: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderGcpsmAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        project_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.

        :param auth: Auth defines the information necessary to authenticate against GCP.
        :param project_id: ProjectID project where secret is located.

        :schema: ClusterSecretStoreSpecProviderGcpsm
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreSpecProviderGcpsmAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fc3cec52aba3dbdf7d2c68d2cdddb38491fbe4a67b6aa1610ba59832fa6a4e41)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if auth is not None:
            self._values["auth"] = auth
        if project_id is not None:
            self._values["project_id"] = project_id

    @builtins.property
    def auth(self) -> typing.Optional["ClusterSecretStoreSpecProviderGcpsmAuth"]:
        '''Auth defines the information necessary to authenticate against GCP.

        :schema: ClusterSecretStoreSpecProviderGcpsm#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderGcpsmAuth"], result)

    @builtins.property
    def project_id(self) -> typing.Optional[builtins.str]:
        '''ProjectID project where secret is located.

        :schema: ClusterSecretStoreSpecProviderGcpsm#projectID
        '''
        result = self._values.get("project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderGcpsm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderGcpsmAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "workload_identity": "workloadIdentity"},
)
class ClusterSecretStoreSpecProviderGcpsmAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderGcpsmAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        workload_identity: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against GCP.

        :param secret_ref: 
        :param workload_identity: 

        :schema: ClusterSecretStoreSpecProviderGcpsmAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderGcpsmAuthSecretRef(**secret_ref)
        if isinstance(workload_identity, dict):
            workload_identity = ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity(**workload_identity)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2178385ff92d231b452c07f1848576db93a846b578537d723ad23942c8b8f59)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument workload_identity", value=workload_identity, expected_type=type_hints["workload_identity"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if workload_identity is not None:
            self._values["workload_identity"] = workload_identity

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderGcpsmAuthSecretRef"]:
        '''
        :schema: ClusterSecretStoreSpecProviderGcpsmAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderGcpsmAuthSecretRef"], result)

    @builtins.property
    def workload_identity(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity"]:
        '''
        :schema: ClusterSecretStoreSpecProviderGcpsmAuth#workloadIdentity
        '''
        result = self._values.get("workload_identity")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderGcpsmAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderGcpsmAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"secret_access_key_secret_ref": "secretAccessKeySecretRef"},
)
class ClusterSecretStoreSpecProviderGcpsmAuthSecretRef:
    def __init__(
        self,
        *,
        secret_access_key_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param secret_access_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthSecretRef
        '''
        if isinstance(secret_access_key_secret_ref, dict):
            secret_access_key_secret_ref = ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(**secret_access_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8b68c9d3be6662c6d5127a4f57c77b4fa8ec1231c6761283310dd0437fa26405)
            check_type(argname="argument secret_access_key_secret_ref", value=secret_access_key_secret_ref, expected_type=type_hints["secret_access_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_access_key_secret_ref is not None:
            self._values["secret_access_key_secret_ref"] = secret_access_key_secret_ref

    @builtins.property
    def secret_access_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthSecretRef#secretAccessKeySecretRef
        '''
        result = self._values.get("secret_access_key_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderGcpsmAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1ae3e18a30bbb404e9e981c4110af8ad2c78dced856b1094667d4d8757f4bea3)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity",
    jsii_struct_bases=[],
    name_mapping={
        "cluster_location": "clusterLocation",
        "cluster_name": "clusterName",
        "service_account_ref": "serviceAccountRef",
        "cluster_project_id": "clusterProjectId",
    },
)
class ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity:
    def __init__(
        self,
        *,
        cluster_location: builtins.str,
        cluster_name: builtins.str,
        service_account_ref: typing.Union["ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef", typing.Dict[builtins.str, typing.Any]],
        cluster_project_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param cluster_location: 
        :param cluster_name: 
        :param service_account_ref: A reference to a ServiceAccount resource.
        :param cluster_project_id: 

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__998b6e77f1f37298ed0da77f6068e5d0e918cf71ed7b2bfdbcba34ba026e718a)
            check_type(argname="argument cluster_location", value=cluster_location, expected_type=type_hints["cluster_location"])
            check_type(argname="argument cluster_name", value=cluster_name, expected_type=type_hints["cluster_name"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument cluster_project_id", value=cluster_project_id, expected_type=type_hints["cluster_project_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cluster_location": cluster_location,
            "cluster_name": cluster_name,
            "service_account_ref": service_account_ref,
        }
        if cluster_project_id is not None:
            self._values["cluster_project_id"] = cluster_project_id

    @builtins.property
    def cluster_location(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterLocation
        '''
        result = self._values.get("cluster_location")
        assert result is not None, "Required property 'cluster_location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cluster_name(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterName
        '''
        result = self._values.get("cluster_name")
        assert result is not None, "Required property 'cluster_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> "ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef":
        '''A reference to a ServiceAccount resource.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        assert result is not None, "Required property 'service_account_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef", result)

    @builtins.property
    def cluster_project_id(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterProjectID
        '''
        result = self._values.get("cluster_project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__99dacaa9d9ab0fbbdd69de40485d6ea7f5b6f30154d2c2f17a52d025fcda16dc)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderGitlab",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "project_id": "projectId", "url": "url"},
)
class ClusterSecretStoreSpecProviderGitlab:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreSpecProviderGitlabAuth", typing.Dict[builtins.str, typing.Any]],
        project_id: typing.Optional[builtins.str] = None,
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''GitLab configures this store to sync secrets using GitLab Variables provider.

        :param auth: Auth configures how secret-manager authenticates with a GitLab instance.
        :param project_id: ProjectID specifies a project where secrets are located.
        :param url: URL configures the GitLab instance URL. Defaults to https://gitlab.com/. Default: https://gitlab.com/.

        :schema: ClusterSecretStoreSpecProviderGitlab
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreSpecProviderGitlabAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cd6c28ce03a61453b779c63be95c17f14c569df7b7901767be17f3b916f7b7b9)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
        }
        if project_id is not None:
            self._values["project_id"] = project_id
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def auth(self) -> "ClusterSecretStoreSpecProviderGitlabAuth":
        '''Auth configures how secret-manager authenticates with a GitLab instance.

        :schema: ClusterSecretStoreSpecProviderGitlab#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderGitlabAuth", result)

    @builtins.property
    def project_id(self) -> typing.Optional[builtins.str]:
        '''ProjectID specifies a project where secrets are located.

        :schema: ClusterSecretStoreSpecProviderGitlab#projectID
        '''
        result = self._values.get("project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''URL configures the GitLab instance URL.

        Defaults to https://gitlab.com/.

        :default: https://gitlab.com/.

        :schema: ClusterSecretStoreSpecProviderGitlab#url
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderGitlab(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderGitlabAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class ClusterSecretStoreSpecProviderGitlabAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreSpecProviderGitlabAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth configures how secret-manager authenticates with a GitLab instance.

        :param secret_ref: 

        :schema: ClusterSecretStoreSpecProviderGitlabAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderGitlabAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d971866ec4831049f0c5995bf4f89457244b6a35dbd74909afa8f7d95a5fc3b6)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "ClusterSecretStoreSpecProviderGitlabAuthSecretRef":
        '''
        :schema: ClusterSecretStoreSpecProviderGitlabAuth#SecretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderGitlabAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderGitlabAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderGitlabAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"access_token": "accessToken"},
)
class ClusterSecretStoreSpecProviderGitlabAuthSecretRef:
    def __init__(
        self,
        *,
        access_token: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param access_token: AccessToken is used for authentication.

        :schema: ClusterSecretStoreSpecProviderGitlabAuthSecretRef
        '''
        if isinstance(access_token, dict):
            access_token = ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken(**access_token)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__adda72bd6677360eef05f5b60cec8e46b4703afb4f11ce2fe2c17d0af65b64f9)
            check_type(argname="argument access_token", value=access_token, expected_type=type_hints["access_token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if access_token is not None:
            self._values["access_token"] = access_token

    @builtins.property
    def access_token(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken"]:
        '''AccessToken is used for authentication.

        :schema: ClusterSecretStoreSpecProviderGitlabAuthSecretRef#accessToken
        '''
        result = self._values.get("access_token")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderGitlabAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AccessToken is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__511067b3b8641da6fae0b888268797929d1d7d4597ddb24ebbdc23c763a8daf5)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderIbm",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "service_url": "serviceUrl"},
)
class ClusterSecretStoreSpecProviderIbm:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreSpecProviderIbmAuth", typing.Dict[builtins.str, typing.Any]],
        service_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''IBM configures this store to sync secrets using IBM Cloud provider.

        :param auth: Auth configures how secret-manager authenticates with the IBM secrets manager.
        :param service_url: ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance.

        :schema: ClusterSecretStoreSpecProviderIbm
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreSpecProviderIbmAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__568b57667a8f87d52e74f6c92542b41178d303a303d0f63f1ad0201e4e4f6e85)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument service_url", value=service_url, expected_type=type_hints["service_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
        }
        if service_url is not None:
            self._values["service_url"] = service_url

    @builtins.property
    def auth(self) -> "ClusterSecretStoreSpecProviderIbmAuth":
        '''Auth configures how secret-manager authenticates with the IBM secrets manager.

        :schema: ClusterSecretStoreSpecProviderIbm#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderIbmAuth", result)

    @builtins.property
    def service_url(self) -> typing.Optional[builtins.str]:
        '''ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance.

        :schema: ClusterSecretStoreSpecProviderIbm#serviceUrl
        '''
        result = self._values.get("service_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderIbm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderIbmAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class ClusterSecretStoreSpecProviderIbmAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreSpecProviderIbmAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth configures how secret-manager authenticates with the IBM secrets manager.

        :param secret_ref: 

        :schema: ClusterSecretStoreSpecProviderIbmAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderIbmAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b8ba31df5a3dec6ffb4e43109f3b738a61dd208cf1d49917f4a5d9e2ed7016ba)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "ClusterSecretStoreSpecProviderIbmAuthSecretRef":
        '''
        :schema: ClusterSecretStoreSpecProviderIbmAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderIbmAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderIbmAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderIbmAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"secret_api_key_secret_ref": "secretApiKeySecretRef"},
)
class ClusterSecretStoreSpecProviderIbmAuthSecretRef:
    def __init__(
        self,
        *,
        secret_api_key_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param secret_api_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreSpecProviderIbmAuthSecretRef
        '''
        if isinstance(secret_api_key_secret_ref, dict):
            secret_api_key_secret_ref = ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef(**secret_api_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d26bdf357d63f5060f85dd85dfff97aea5186ba28331fba88305c92f7bf2bee)
            check_type(argname="argument secret_api_key_secret_ref", value=secret_api_key_secret_ref, expected_type=type_hints["secret_api_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_api_key_secret_ref is not None:
            self._values["secret_api_key_secret_ref"] = secret_api_key_secret_ref

    @builtins.property
    def secret_api_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreSpecProviderIbmAuthSecretRef#secretApiKeySecretRef
        '''
        result = self._values.get("secret_api_key_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderIbmAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f2338fd96004be09c4ba23dde6c13751a616732acd950c786cd2d83bf1b80e0)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetes",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "remote_namespace": "remoteNamespace",
        "server": "server",
    },
)
class ClusterSecretStoreSpecProviderKubernetes:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreSpecProviderKubernetesAuth", typing.Dict[builtins.str, typing.Any]],
        remote_namespace: typing.Optional[builtins.str] = None,
        server: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderKubernetesServer", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.

        :param auth: Auth configures how secret-manager authenticates with a Kubernetes instance.
        :param remote_namespace: Remote namespace to fetch the secrets from.
        :param server: configures the Kubernetes server Address.

        :schema: ClusterSecretStoreSpecProviderKubernetes
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreSpecProviderKubernetesAuth(**auth)
        if isinstance(server, dict):
            server = ClusterSecretStoreSpecProviderKubernetesServer(**server)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a875c33cb733cde737d2ea40684faf938dd9c5fcfe7ad0f13f5323f4fc03599)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument remote_namespace", value=remote_namespace, expected_type=type_hints["remote_namespace"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
        }
        if remote_namespace is not None:
            self._values["remote_namespace"] = remote_namespace
        if server is not None:
            self._values["server"] = server

    @builtins.property
    def auth(self) -> "ClusterSecretStoreSpecProviderKubernetesAuth":
        '''Auth configures how secret-manager authenticates with a Kubernetes instance.

        :schema: ClusterSecretStoreSpecProviderKubernetes#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderKubernetesAuth", result)

    @builtins.property
    def remote_namespace(self) -> typing.Optional[builtins.str]:
        '''Remote namespace to fetch the secrets from.

        :schema: ClusterSecretStoreSpecProviderKubernetes#remoteNamespace
        '''
        result = self._values.get("remote_namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def server(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderKubernetesServer"]:
        '''configures the Kubernetes server Address.

        :schema: ClusterSecretStoreSpecProviderKubernetes#server
        '''
        result = self._values.get("server")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderKubernetesServer"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesAuth",
    jsii_struct_bases=[],
    name_mapping={
        "cert": "cert",
        "service_account": "serviceAccount",
        "token": "token",
    },
)
class ClusterSecretStoreSpecProviderKubernetesAuth:
    def __init__(
        self,
        *,
        cert: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderKubernetesAuthCert", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount", typing.Dict[builtins.str, typing.Any]]] = None,
        token: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderKubernetesAuthToken", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how secret-manager authenticates with a Kubernetes instance.

        :param cert: has both clientCert and clientKey as secretKeySelector.
        :param service_account: points to a service account that should be used for authentication.
        :param token: use static token to authenticate with.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuth
        '''
        if isinstance(cert, dict):
            cert = ClusterSecretStoreSpecProviderKubernetesAuthCert(**cert)
        if isinstance(service_account, dict):
            service_account = ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount(**service_account)
        if isinstance(token, dict):
            token = ClusterSecretStoreSpecProviderKubernetesAuthToken(**token)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e4a87865577536425d7db2b507a944df25c5643ebce9d8f972d9d17bf404d2a)
            check_type(argname="argument cert", value=cert, expected_type=type_hints["cert"])
            check_type(argname="argument service_account", value=service_account, expected_type=type_hints["service_account"])
            check_type(argname="argument token", value=token, expected_type=type_hints["token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cert is not None:
            self._values["cert"] = cert
        if service_account is not None:
            self._values["service_account"] = service_account
        if token is not None:
            self._values["token"] = token

    @builtins.property
    def cert(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthCert"]:
        '''has both clientCert and clientKey as secretKeySelector.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuth#cert
        '''
        result = self._values.get("cert")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthCert"], result)

    @builtins.property
    def service_account(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount"]:
        '''points to a service account that should be used for authentication.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuth#serviceAccount
        '''
        result = self._values.get("service_account")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount"], result)

    @builtins.property
    def token(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthToken"]:
        '''use static token to authenticate with.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuth#token
        '''
        result = self._values.get("token")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetesAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesAuthCert",
    jsii_struct_bases=[],
    name_mapping={"client_cert": "clientCert", "client_key": "clientKey"},
)
class ClusterSecretStoreSpecProviderKubernetesAuthCert:
    def __init__(
        self,
        *,
        client_cert: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert", typing.Dict[builtins.str, typing.Any]]] = None,
        client_key: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''has both clientCert and clientKey as secretKeySelector.

        :param client_cert: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param client_key: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCert
        '''
        if isinstance(client_cert, dict):
            client_cert = ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert(**client_cert)
        if isinstance(client_key, dict):
            client_key = ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey(**client_key)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cc095c5099a968982782878a596ee1c32a31cf4bdb1595995f7aa2fd8ff43b5b)
            check_type(argname="argument client_cert", value=client_cert, expected_type=type_hints["client_cert"])
            check_type(argname="argument client_key", value=client_key, expected_type=type_hints["client_key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if client_cert is not None:
            self._values["client_cert"] = client_cert
        if client_key is not None:
            self._values["client_key"] = client_key

    @builtins.property
    def client_cert(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCert#clientCert
        '''
        result = self._values.get("client_cert")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert"], result)

    @builtins.property
    def client_key(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCert#clientKey
        '''
        result = self._values.get("client_key")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetesAuthCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__503bdfbb632686635165459120fcc39e2961fcc53fedf28a69b21f187ec6435c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f49b9d81a293f0e46cea1637a6e7534771c88694becfeb4b3af69ee54782ec9c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount",
    jsii_struct_bases=[],
    name_mapping={"service_account": "serviceAccount"},
)
class ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount:
    def __init__(
        self,
        *,
        service_account: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''points to a service account that should be used for authentication.

        :param service_account: A reference to a ServiceAccount resource.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount
        '''
        if isinstance(service_account, dict):
            service_account = ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount(**service_account)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ebcfbd9e4143ba94379ca90a47ef3b5d8e1544a99ce7a639bbd61a7e7c6b4666)
            check_type(argname="argument service_account", value=service_account, expected_type=type_hints["service_account"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if service_account is not None:
            self._values["service_account"] = service_account

    @builtins.property
    def service_account(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount"]:
        '''A reference to a ServiceAccount resource.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount#serviceAccount
        '''
        result = self._values.get("service_account")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be61c3feb305ef226f10dab3e8225b282e360f0182870360ffdbca079919d353)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesAuthToken",
    jsii_struct_bases=[],
    name_mapping={"bearer_token": "bearerToken"},
)
class ClusterSecretStoreSpecProviderKubernetesAuthToken:
    def __init__(
        self,
        *,
        bearer_token: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''use static token to authenticate with.

        :param bearer_token: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthToken
        '''
        if isinstance(bearer_token, dict):
            bearer_token = ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken(**bearer_token)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1ba41a3478e9d8ac767c1a13cc7dd298a12d94292b029f7fa8368b3d3e44096b)
            check_type(argname="argument bearer_token", value=bearer_token, expected_type=type_hints["bearer_token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if bearer_token is not None:
            self._values["bearer_token"] = bearer_token

    @builtins.property
    def bearer_token(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthToken#bearerToken
        '''
        result = self._values.get("bearer_token")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetesAuthToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df798fd077691a5778cc00f1de4848673a52dac5d0d5ebe0d03af6720cbc95d2)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesServer",
    jsii_struct_bases=[],
    name_mapping={"ca_bundle": "caBundle", "ca_provider": "caProvider", "url": "url"},
)
class ClusterSecretStoreSpecProviderKubernetesServer:
    def __init__(
        self,
        *,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderKubernetesServerCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''configures the Kubernetes server Address.

        :param ca_bundle: CABundle is a base64-encoded CA certificate.
        :param ca_provider: see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.
        :param url: configures the Kubernetes server Address.

        :schema: ClusterSecretStoreSpecProviderKubernetesServer
        '''
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreSpecProviderKubernetesServerCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29f1d40a83933b0205abc121837f1b6a50b2409b7fb1e5f58dade818e3e3a609)
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''CABundle is a base64-encoded CA certificate.

        :schema: ClusterSecretStoreSpecProviderKubernetesServer#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderKubernetesServerCaProvider"]:
        '''see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.

        :schema: ClusterSecretStoreSpecProviderKubernetesServer#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderKubernetesServerCaProvider"], result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''configures the Kubernetes server Address.

        :schema: ClusterSecretStoreSpecProviderKubernetesServer#url
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetesServer(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesServerCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class ClusterSecretStoreSpecProviderKubernetesServerCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "ClusterSecretStoreSpecProviderKubernetesServerCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in.

        :schema: ClusterSecretStoreSpecProviderKubernetesServerCaProvider
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df516d591cd72e3ccea6b112524dbfa0323479fb2ee403ab24a5bbaddb4efd8c)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: ClusterSecretStoreSpecProviderKubernetesServerCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "ClusterSecretStoreSpecProviderKubernetesServerCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: ClusterSecretStoreSpecProviderKubernetesServerCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderKubernetesServerCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: ClusterSecretStoreSpecProviderKubernetesServerCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        :schema: ClusterSecretStoreSpecProviderKubernetesServerCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetesServerCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesServerCaProviderType"
)
class ClusterSecretStoreSpecProviderKubernetesServerCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: ClusterSecretStoreSpecProviderKubernetesServerCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderOracle",
    jsii_struct_bases=[],
    name_mapping={
        "region": "region",
        "vault": "vault",
        "auth": "auth",
        "compartment": "compartment",
        "encryption_key": "encryptionKey",
        "principal_type": "principalType",
        "service_account_ref": "serviceAccountRef",
    },
)
class ClusterSecretStoreSpecProviderOracle:
    def __init__(
        self,
        *,
        region: builtins.str,
        vault: builtins.str,
        auth: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderOracleAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        compartment: typing.Optional[builtins.str] = None,
        encryption_key: typing.Optional[builtins.str] = None,
        principal_type: typing.Optional["ClusterSecretStoreSpecProviderOraclePrincipalType"] = None,
        service_account_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderOracleServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Oracle configures this store to sync secrets using Oracle Vault provider.

        :param region: Region is the region where vault is located.
        :param vault: Vault is the vault's OCID of the specific vault where secret is located.
        :param auth: Auth configures how secret-manager authenticates with the Oracle Vault. If empty, instance principal is used. Optionally, the authenticating principal type and/or user data may be supplied for the use of workload identity and user principal.
        :param compartment: Compartment is the vault compartment OCID. Required for PushSecret
        :param encryption_key: EncryptionKey is the OCID of the encryption key within the vault. Required for PushSecret
        :param principal_type: The type of principal to use for authentication. If left blank, the Auth struct will determine the principal type. This optional field must be specified if using workload identity.
        :param service_account_ref: ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :schema: ClusterSecretStoreSpecProviderOracle
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreSpecProviderOracleAuth(**auth)
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreSpecProviderOracleServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d51df236a603c6f74a911105acff1a4f51f5d893faa22fc50dae2e587588ebc8)
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument vault", value=vault, expected_type=type_hints["vault"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument compartment", value=compartment, expected_type=type_hints["compartment"])
            check_type(argname="argument encryption_key", value=encryption_key, expected_type=type_hints["encryption_key"])
            check_type(argname="argument principal_type", value=principal_type, expected_type=type_hints["principal_type"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "region": region,
            "vault": vault,
        }
        if auth is not None:
            self._values["auth"] = auth
        if compartment is not None:
            self._values["compartment"] = compartment
        if encryption_key is not None:
            self._values["encryption_key"] = encryption_key
        if principal_type is not None:
            self._values["principal_type"] = principal_type
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def region(self) -> builtins.str:
        '''Region is the region where vault is located.

        :schema: ClusterSecretStoreSpecProviderOracle#region
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vault(self) -> builtins.str:
        '''Vault is the vault's OCID of the specific vault where secret is located.

        :schema: ClusterSecretStoreSpecProviderOracle#vault
        '''
        result = self._values.get("vault")
        assert result is not None, "Required property 'vault' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth(self) -> typing.Optional["ClusterSecretStoreSpecProviderOracleAuth"]:
        '''Auth configures how secret-manager authenticates with the Oracle Vault.

        If empty, instance principal is used. Optionally, the authenticating principal type
        and/or user data may be supplied for the use of workload identity and user principal.

        :schema: ClusterSecretStoreSpecProviderOracle#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderOracleAuth"], result)

    @builtins.property
    def compartment(self) -> typing.Optional[builtins.str]:
        '''Compartment is the vault compartment OCID.

        Required for PushSecret

        :schema: ClusterSecretStoreSpecProviderOracle#compartment
        '''
        result = self._values.get("compartment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def encryption_key(self) -> typing.Optional[builtins.str]:
        '''EncryptionKey is the OCID of the encryption key within the vault.

        Required for PushSecret

        :schema: ClusterSecretStoreSpecProviderOracle#encryptionKey
        '''
        result = self._values.get("encryption_key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def principal_type(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderOraclePrincipalType"]:
        '''The type of principal to use for authentication.

        If left blank, the Auth struct will
        determine the principal type. This optional field must be specified if using
        workload identity.

        :schema: ClusterSecretStoreSpecProviderOracle#principalType
        '''
        result = self._values.get("principal_type")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderOraclePrincipalType"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderOracleServiceAccountRef"]:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :schema: ClusterSecretStoreSpecProviderOracle#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderOracleServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderOracle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderOracleAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "tenancy": "tenancy", "user": "user"},
)
class ClusterSecretStoreSpecProviderOracleAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreSpecProviderOracleAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
        tenancy: builtins.str,
        user: builtins.str,
    ) -> None:
        '''Auth configures how secret-manager authenticates with the Oracle Vault.

        If empty, instance principal is used. Optionally, the authenticating principal type
        and/or user data may be supplied for the use of workload identity and user principal.

        :param secret_ref: SecretRef to pass through sensitive information.
        :param tenancy: Tenancy is the tenancy OCID where user is located.
        :param user: User is an access OCID specific to the account.

        :schema: ClusterSecretStoreSpecProviderOracleAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderOracleAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8747f797eb13c03383ce6b0134915d891783a8be5d68b6ee24b3c6cb9fbd4985)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument tenancy", value=tenancy, expected_type=type_hints["tenancy"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
            "tenancy": tenancy,
            "user": user,
        }

    @builtins.property
    def secret_ref(self) -> "ClusterSecretStoreSpecProviderOracleAuthSecretRef":
        '''SecretRef to pass through sensitive information.

        :schema: ClusterSecretStoreSpecProviderOracleAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderOracleAuthSecretRef", result)

    @builtins.property
    def tenancy(self) -> builtins.str:
        '''Tenancy is the tenancy OCID where user is located.

        :schema: ClusterSecretStoreSpecProviderOracleAuth#tenancy
        '''
        result = self._values.get("tenancy")
        assert result is not None, "Required property 'tenancy' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def user(self) -> builtins.str:
        '''User is an access OCID specific to the account.

        :schema: ClusterSecretStoreSpecProviderOracleAuth#user
        '''
        result = self._values.get("user")
        assert result is not None, "Required property 'user' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderOracleAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderOracleAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"fingerprint": "fingerprint", "privatekey": "privatekey"},
)
class ClusterSecretStoreSpecProviderOracleAuthSecretRef:
    def __init__(
        self,
        *,
        fingerprint: typing.Union["ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint", typing.Dict[builtins.str, typing.Any]],
        privatekey: typing.Union["ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''SecretRef to pass through sensitive information.

        :param fingerprint: Fingerprint is the fingerprint of the API private key.
        :param privatekey: PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRef
        '''
        if isinstance(fingerprint, dict):
            fingerprint = ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint(**fingerprint)
        if isinstance(privatekey, dict):
            privatekey = ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey(**privatekey)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c97225be105acf4e293cecfb2d1feaa37ea94578c86cdf4d2e336b439a2559a)
            check_type(argname="argument fingerprint", value=fingerprint, expected_type=type_hints["fingerprint"])
            check_type(argname="argument privatekey", value=privatekey, expected_type=type_hints["privatekey"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "fingerprint": fingerprint,
            "privatekey": privatekey,
        }

    @builtins.property
    def fingerprint(
        self,
    ) -> "ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint":
        '''Fingerprint is the fingerprint of the API private key.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRef#fingerprint
        '''
        result = self._values.get("fingerprint")
        assert result is not None, "Required property 'fingerprint' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint", result)

    @builtins.property
    def privatekey(
        self,
    ) -> "ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey":
        '''PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRef#privatekey
        '''
        result = self._values.get("privatekey")
        assert result is not None, "Required property 'privatekey' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderOracleAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Fingerprint is the fingerprint of the API private key.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c531d2ca3bee95d25c32bb91772fb25d1b2643838ab4bc843e512cb39e63bb61)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f4eb6469dd176c588e8c4a9bd39111e7f84482a99f9af9e62ed077924beaf37f)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderOraclePrincipalType"
)
class ClusterSecretStoreSpecProviderOraclePrincipalType(enum.Enum):
    '''The type of principal to use for authentication.

    If left blank, the Auth struct will
    determine the principal type. This optional field must be specified if using
    workload identity.

    :schema: ClusterSecretStoreSpecProviderOraclePrincipalType
    '''

    USER_PRINCIPAL = "USER_PRINCIPAL"
    '''UserPrincipal.'''
    INSTANCE_PRINCIPAL = "INSTANCE_PRINCIPAL"
    '''InstancePrincipal.'''
    WORKLOAD = "WORKLOAD"
    '''Workload.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderOracleServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderOracleServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderOracleServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b2c2b61ca17414c8f7ada351a498ac1a2d985e403dcc1fe15eef63e22d74207a)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreSpecProviderOracleServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreSpecProviderOracleServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderOracleServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderOracleServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderPassworddepot",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "database": "database", "host": "host"},
)
class ClusterSecretStoreSpecProviderPassworddepot:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreSpecProviderPassworddepotAuth", typing.Dict[builtins.str, typing.Any]],
        database: builtins.str,
        host: builtins.str,
    ) -> None:
        '''Configures a store to sync secrets with a Password Depot instance.

        :param auth: Auth configures how secret-manager authenticates with a Password Depot instance.
        :param database: Database to use as source.
        :param host: URL configures the Password Depot instance URL.

        :schema: ClusterSecretStoreSpecProviderPassworddepot
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreSpecProviderPassworddepotAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__72d2dda8f33fd1e3871450460f964c43585b0825137f24072af76f387fdb8f53)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument database", value=database, expected_type=type_hints["database"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "database": database,
            "host": host,
        }

    @builtins.property
    def auth(self) -> "ClusterSecretStoreSpecProviderPassworddepotAuth":
        '''Auth configures how secret-manager authenticates with a Password Depot instance.

        :schema: ClusterSecretStoreSpecProviderPassworddepot#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderPassworddepotAuth", result)

    @builtins.property
    def database(self) -> builtins.str:
        '''Database to use as source.

        :schema: ClusterSecretStoreSpecProviderPassworddepot#database
        '''
        result = self._values.get("database")
        assert result is not None, "Required property 'database' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def host(self) -> builtins.str:
        '''URL configures the Password Depot instance URL.

        :schema: ClusterSecretStoreSpecProviderPassworddepot#host
        '''
        result = self._values.get("host")
        assert result is not None, "Required property 'host' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderPassworddepot(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderPassworddepotAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class ClusterSecretStoreSpecProviderPassworddepotAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreSpecProviderPassworddepotAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth configures how secret-manager authenticates with a Password Depot instance.

        :param secret_ref: 

        :schema: ClusterSecretStoreSpecProviderPassworddepotAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderPassworddepotAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b6b6ea9a2b87f39442403b43f12453ef96e7f78fd325509788386688440d487b)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "ClusterSecretStoreSpecProviderPassworddepotAuthSecretRef":
        '''
        :schema: ClusterSecretStoreSpecProviderPassworddepotAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderPassworddepotAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderPassworddepotAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderPassworddepotAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"credentials": "credentials"},
)
class ClusterSecretStoreSpecProviderPassworddepotAuthSecretRef:
    def __init__(
        self,
        *,
        credentials: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param credentials: Username / Password is used for authentication.

        :schema: ClusterSecretStoreSpecProviderPassworddepotAuthSecretRef
        '''
        if isinstance(credentials, dict):
            credentials = ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials(**credentials)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9d6e961d14c0b06bf046bf2b304ec7d6ec46e370ab98ee8caa1ead22a914088)
            check_type(argname="argument credentials", value=credentials, expected_type=type_hints["credentials"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if credentials is not None:
            self._values["credentials"] = credentials

    @builtins.property
    def credentials(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials"]:
        '''Username / Password is used for authentication.

        :schema: ClusterSecretStoreSpecProviderPassworddepotAuthSecretRef#credentials
        '''
        result = self._values.get("credentials")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderPassworddepotAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Username / Password is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4dc2de537e242a05d9395953fcfbf59daabc5a55a600ae989930d018a6751dd6)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVault",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "server": "server",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
        "forward_inconsistent": "forwardInconsistent",
        "namespace": "namespace",
        "path": "path",
        "read_your_writes": "readYourWrites",
        "version": "version",
    },
)
class ClusterSecretStoreSpecProviderVault:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreSpecProviderVaultAuth", typing.Dict[builtins.str, typing.Any]],
        server: builtins.str,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
        forward_inconsistent: typing.Optional[builtins.bool] = None,
        namespace: typing.Optional[builtins.str] = None,
        path: typing.Optional[builtins.str] = None,
        read_your_writes: typing.Optional[builtins.bool] = None,
        version: typing.Optional["ClusterSecretStoreSpecProviderVaultVersion"] = None,
    ) -> None:
        '''Vault configures this store to sync secrets using Hashi provider.

        :param auth: Auth configures how secret-manager authenticates with the Vault server.
        :param server: Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
        :param ca_bundle: PEM encoded CA bundle used to validate Vault server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
        :param ca_provider: The provider for the CA bundle to use to validate Vault server certificate.
        :param forward_inconsistent: ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop. This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
        :param namespace: Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
        :param path: Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.
        :param read_your_writes: ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request. More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency
        :param version: Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".

        :schema: ClusterSecretStoreSpecProviderVault
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreSpecProviderVaultAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreSpecProviderVaultCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ef68b3d001dc894733c01b794ca1a457786564b75fec9c23ebf82feb51a68d1c)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument forward_inconsistent", value=forward_inconsistent, expected_type=type_hints["forward_inconsistent"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument read_your_writes", value=read_your_writes, expected_type=type_hints["read_your_writes"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "server": server,
        }
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if forward_inconsistent is not None:
            self._values["forward_inconsistent"] = forward_inconsistent
        if namespace is not None:
            self._values["namespace"] = namespace
        if path is not None:
            self._values["path"] = path
        if read_your_writes is not None:
            self._values["read_your_writes"] = read_your_writes
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def auth(self) -> "ClusterSecretStoreSpecProviderVaultAuth":
        '''Auth configures how secret-manager authenticates with the Vault server.

        :schema: ClusterSecretStoreSpecProviderVault#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderVaultAuth", result)

    @builtins.property
    def server(self) -> builtins.str:
        '''Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".

        :schema: ClusterSecretStoreSpecProviderVault#server
        '''
        result = self._values.get("server")
        assert result is not None, "Required property 'server' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''PEM encoded CA bundle used to validate Vault server certificate.

        Only used
        if the Server URL is using HTTPS protocol. This parameter is ignored for
        plain HTTP protocol connection. If not set the system root certificates
        are used to validate the TLS connection.

        :schema: ClusterSecretStoreSpecProviderVault#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultCaProvider"]:
        '''The provider for the CA bundle to use to validate Vault server certificate.

        :schema: ClusterSecretStoreSpecProviderVault#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultCaProvider"], result)

    @builtins.property
    def forward_inconsistent(self) -> typing.Optional[builtins.bool]:
        '''ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop.

        This can increase performance if
        the option is enabled serverside.
        https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header

        :schema: ClusterSecretStoreSpecProviderVault#forwardInconsistent
        '''
        result = self._values.get("forward_inconsistent")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Name of the vault namespace.

        Namespaces is a set of features within Vault Enterprise that allows
        Vault environments to support Secure Multi-tenancy. e.g: "ns1".
        More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces

        :schema: ClusterSecretStoreSpecProviderVault#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.

        :schema: ClusterSecretStoreSpecProviderVault#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_your_writes(self) -> typing.Optional[builtins.bool]:
        '''ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request.

        More information about eventual consistency in Vault can be found here
        https://www.vaultproject.io/docs/enterprise/consistency

        :schema: ClusterSecretStoreSpecProviderVault#readYourWrites
        '''
        result = self._values.get("read_your_writes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def version(self) -> typing.Optional["ClusterSecretStoreSpecProviderVaultVersion"]:
        '''Version is the Vault KV secret engine version.

        This can be either "v1" or
        "v2". Version defaults to "v2".

        :schema: ClusterSecretStoreSpecProviderVault#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultVersion"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVault(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuth",
    jsii_struct_bases=[],
    name_mapping={
        "app_role": "appRole",
        "cert": "cert",
        "jwt": "jwt",
        "kubernetes": "kubernetes",
        "ldap": "ldap",
        "token_secret_ref": "tokenSecretRef",
    },
)
class ClusterSecretStoreSpecProviderVaultAuth:
    def __init__(
        self,
        *,
        app_role: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthAppRole", typing.Dict[builtins.str, typing.Any]]] = None,
        cert: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthCert", typing.Dict[builtins.str, typing.Any]]] = None,
        jwt: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthJwt", typing.Dict[builtins.str, typing.Any]]] = None,
        kubernetes: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthKubernetes", typing.Dict[builtins.str, typing.Any]]] = None,
        ldap: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthLdap", typing.Dict[builtins.str, typing.Any]]] = None,
        token_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how secret-manager authenticates with the Vault server.

        :param app_role: AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
        :param cert: Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.
        :param jwt: Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.
        :param kubernetes: Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
        :param ldap: Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.
        :param token_secret_ref: TokenSecretRef authenticates with Vault by presenting a token.

        :schema: ClusterSecretStoreSpecProviderVaultAuth
        '''
        if isinstance(app_role, dict):
            app_role = ClusterSecretStoreSpecProviderVaultAuthAppRole(**app_role)
        if isinstance(cert, dict):
            cert = ClusterSecretStoreSpecProviderVaultAuthCert(**cert)
        if isinstance(jwt, dict):
            jwt = ClusterSecretStoreSpecProviderVaultAuthJwt(**jwt)
        if isinstance(kubernetes, dict):
            kubernetes = ClusterSecretStoreSpecProviderVaultAuthKubernetes(**kubernetes)
        if isinstance(ldap, dict):
            ldap = ClusterSecretStoreSpecProviderVaultAuthLdap(**ldap)
        if isinstance(token_secret_ref, dict):
            token_secret_ref = ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef(**token_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__edca367d70e999e0f4d8dd93f60480965022b2731a2804bfea499b897354fe2e)
            check_type(argname="argument app_role", value=app_role, expected_type=type_hints["app_role"])
            check_type(argname="argument cert", value=cert, expected_type=type_hints["cert"])
            check_type(argname="argument jwt", value=jwt, expected_type=type_hints["jwt"])
            check_type(argname="argument kubernetes", value=kubernetes, expected_type=type_hints["kubernetes"])
            check_type(argname="argument ldap", value=ldap, expected_type=type_hints["ldap"])
            check_type(argname="argument token_secret_ref", value=token_secret_ref, expected_type=type_hints["token_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if app_role is not None:
            self._values["app_role"] = app_role
        if cert is not None:
            self._values["cert"] = cert
        if jwt is not None:
            self._values["jwt"] = jwt
        if kubernetes is not None:
            self._values["kubernetes"] = kubernetes
        if ldap is not None:
            self._values["ldap"] = ldap
        if token_secret_ref is not None:
            self._values["token_secret_ref"] = token_secret_ref

    @builtins.property
    def app_role(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthAppRole"]:
        '''AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.

        :schema: ClusterSecretStoreSpecProviderVaultAuth#appRole
        '''
        result = self._values.get("app_role")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthAppRole"], result)

    @builtins.property
    def cert(self) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthCert"]:
        '''Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuth#cert
        '''
        result = self._values.get("cert")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthCert"], result)

    @builtins.property
    def jwt(self) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthJwt"]:
        '''Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuth#jwt
        '''
        result = self._values.get("jwt")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthJwt"], result)

    @builtins.property
    def kubernetes(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthKubernetes"]:
        '''Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.

        :schema: ClusterSecretStoreSpecProviderVaultAuth#kubernetes
        '''
        result = self._values.get("kubernetes")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthKubernetes"], result)

    @builtins.property
    def ldap(self) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthLdap"]:
        '''Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuth#ldap
        '''
        result = self._values.get("ldap")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthLdap"], result)

    @builtins.property
    def token_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef"]:
        '''TokenSecretRef authenticates with Vault by presenting a token.

        :schema: ClusterSecretStoreSpecProviderVaultAuth#tokenSecretRef
        '''
        result = self._values.get("token_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthAppRole",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "role_id": "roleId", "secret_ref": "secretRef"},
)
class ClusterSecretStoreSpecProviderVaultAuthAppRole:
    def __init__(
        self,
        *,
        path: builtins.str,
        role_id: builtins.str,
        secret_ref: typing.Union["ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.

        :param path: Path where the App Role authentication backend is mounted in Vault, e.g: "approle".
        :param role_id: RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.
        :param secret_ref: Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The ``key`` field must be specified and denotes which entry within the Secret resource is used as the app role secret.

        :schema: ClusterSecretStoreSpecProviderVaultAuthAppRole
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d653069145d43079e69f7719f5cc231f7e70d871ff44e92d01049340d8bb524)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument role_id", value=role_id, expected_type=type_hints["role_id"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
            "role_id": role_id,
            "secret_ref": secret_ref,
        }

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the App Role authentication backend is mounted in Vault, e.g: "approle".

        :schema: ClusterSecretStoreSpecProviderVaultAuthAppRole#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role_id(self) -> builtins.str:
        '''RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.

        :schema: ClusterSecretStoreSpecProviderVaultAuthAppRole#roleId
        '''
        result = self._values.get("role_id")
        assert result is not None, "Required property 'role_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(self) -> "ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef":
        '''Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret
        resource is used as the app role secret.

        :schema: ClusterSecretStoreSpecProviderVaultAuthAppRole#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthAppRole(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret
        resource is used as the app role secret.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f35712d423d432dfcb07ff112a69b3cfbd19b55783043b4a29d483f336f4a433)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthCert",
    jsii_struct_bases=[],
    name_mapping={"client_cert": "clientCert", "secret_ref": "secretRef"},
)
class ClusterSecretStoreSpecProviderVaultAuthCert:
    def __init__(
        self,
        *,
        client_cert: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthCertClientCert", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthCertSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.

        :param client_cert: ClientCert is a certificate to authenticate using the Cert Vault authentication method.
        :param secret_ref: SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCert
        '''
        if isinstance(client_cert, dict):
            client_cert = ClusterSecretStoreSpecProviderVaultAuthCertClientCert(**client_cert)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderVaultAuthCertSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__07ecf610e8623a95c7882b7b3820871610e76bb4497f36c406038735e020e9dd)
            check_type(argname="argument client_cert", value=client_cert, expected_type=type_hints["client_cert"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if client_cert is not None:
            self._values["client_cert"] = client_cert
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def client_cert(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthCertClientCert"]:
        '''ClientCert is a certificate to authenticate using the Cert Vault authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCert#clientCert
        '''
        result = self._values.get("client_cert")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthCertClientCert"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthCertSecretRef"]:
        '''SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCert#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthCertSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthCertClientCert",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderVaultAuthCertClientCert:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ClientCert is a certificate to authenticate using the Cert Vault authentication method.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCertClientCert
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4b68473b3bece52963e18111c31aa00fc82a8ebd6235ce6cdc6d52305f88978b)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCertClientCert#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCertClientCert#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCertClientCert#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthCertClientCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderVaultAuthCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCertSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__297cfe9ec7b6f0ff6acb7be39420d3c9df2218f1bf1753129109b58cb815db1c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthJwt",
    jsii_struct_bases=[],
    name_mapping={
        "path": "path",
        "kubernetes_service_account_token": "kubernetesServiceAccountToken",
        "role": "role",
        "secret_ref": "secretRef",
    },
)
class ClusterSecretStoreSpecProviderVaultAuthJwt:
    def __init__(
        self,
        *,
        path: builtins.str,
        kubernetes_service_account_token: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken", typing.Dict[builtins.str, typing.Any]]] = None,
        role: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.

        :param path: Path where the JWT authentication backend is mounted in Vault, e.g: "jwt".
        :param kubernetes_service_account_token: Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.
        :param role: Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method.
        :param secret_ref: Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwt
        '''
        if isinstance(kubernetes_service_account_token, dict):
            kubernetes_service_account_token = ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken(**kubernetes_service_account_token)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c70b5f2d0d755f91281254925c299e6b7812ab873f8af74181b9bed9ddf549d3)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument kubernetes_service_account_token", value=kubernetes_service_account_token, expected_type=type_hints["kubernetes_service_account_token"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
        }
        if kubernetes_service_account_token is not None:
            self._values["kubernetes_service_account_token"] = kubernetes_service_account_token
        if role is not None:
            self._values["role"] = role
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the JWT authentication backend is mounted in Vault, e.g: "jwt".

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwt#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def kubernetes_service_account_token(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken"]:
        '''Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwt#kubernetesServiceAccountToken
        '''
        result = self._values.get("kubernetes_service_account_token")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken"], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwt#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef"]:
        '''Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwt#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthJwt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken",
    jsii_struct_bases=[],
    name_mapping={
        "service_account_ref": "serviceAccountRef",
        "audiences": "audiences",
        "expiration_seconds": "expirationSeconds",
    },
)
class ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken:
    def __init__(
        self,
        *,
        service_account_ref: typing.Union["ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef", typing.Dict[builtins.str, typing.Any]],
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        expiration_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :param service_account_ref: Service account field containing the name of a kubernetes ServiceAccount.
        :param audiences: Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``. Defaults to a single audience ``vault`` it not specified. Default: a single audience ``vault`` it not specified.
        :param expiration_seconds: Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``. Defaults to 10 minutes. Default: 10 minutes.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__079c46fff0c57b42b35cdf20bd2601cdf20258393616adf107cd21057b8a5756)
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument expiration_seconds", value=expiration_seconds, expected_type=type_hints["expiration_seconds"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "service_account_ref": service_account_ref,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if expiration_seconds is not None:
            self._values["expiration_seconds"] = expiration_seconds

    @builtins.property
    def service_account_ref(
        self,
    ) -> "ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef":
        '''Service account field containing the name of a kubernetes ServiceAccount.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        assert result is not None, "Required property 'service_account_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef", result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``.

        Defaults to a single audience ``vault`` it not specified.

        :default: a single audience ``vault`` it not specified.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def expiration_seconds(self) -> typing.Optional[jsii.Number]:
        '''Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``.

        Defaults to 10 minutes.

        :default: 10 minutes.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#expirationSeconds
        '''
        result = self._values.get("expiration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Service account field containing the name of a kubernetes ServiceAccount.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf1afed0cbd44ce1e181c71dfbce5c80cec5b966a2a854753d10efa060ee9f6f)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a340df94e1a417e5d884f82e933c5560f15f85713299092866951369e007294)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthKubernetes",
    jsii_struct_bases=[],
    name_mapping={
        "mount_path": "mountPath",
        "role": "role",
        "secret_ref": "secretRef",
        "service_account_ref": "serviceAccountRef",
    },
)
class ClusterSecretStoreSpecProviderVaultAuthKubernetes:
    def __init__(
        self,
        *,
        mount_path: builtins.str,
        role: builtins.str,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.

        :param mount_path: Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes".
        :param role: A required field containing the Vault Role to assume. A Role binds a Kubernetes ServiceAccount with a set of Vault policies.
        :param secret_ref: Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.
        :param service_account_ref: Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetes
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef(**secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e0431af4eda83f334246027b08a06ec6fc9a31808931500a0447cbf67873dc8)
            check_type(argname="argument mount_path", value=mount_path, expected_type=type_hints["mount_path"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "mount_path": mount_path,
            "role": role,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def mount_path(self) -> builtins.str:
        '''Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes".

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetes#mountPath
        '''
        result = self._values.get("mount_path")
        assert result is not None, "Required property 'mount_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role(self) -> builtins.str:
        '''A required field containing the Vault Role to assume.

        A Role binds a
        Kubernetes ServiceAccount with a set of Vault policies.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetes#role
        '''
        result = self._values.get("role")
        assert result is not None, "Required property 'role' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef"]:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault.

        If a name is specified without a key,
        ``token`` is the default. If one is not specified, the one bound to
        the controller will be used.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetes#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef"]:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used
        for authenticating with Vault. If the service account selector is not supplied,
        the secretRef will be used instead.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetes#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthKubernetes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault.

        If a name is specified without a key,
        ``token`` is the default. If one is not specified, the one bound to
        the controller will be used.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7378e072626052b95a87646e5ef2b5aff3fbcb23a3222fc3bdb7a5423e66529)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used
        for authenticating with Vault. If the service account selector is not supplied,
        the secretRef will be used instead.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e39b709ef4e009ad2207ce73f97c37c051ea9f48db9c0406f1c522ebaacfb7ca)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthLdap",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "username": "username", "secret_ref": "secretRef"},
)
class ClusterSecretStoreSpecProviderVaultAuthLdap:
    def __init__(
        self,
        *,
        path: builtins.str,
        username: builtins.str,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.

        :param path: Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap".
        :param username: Username is a LDAP user name used to authenticate using the LDAP Vault authentication method.
        :param secret_ref: SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuthLdap
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8666d1368531371d385fa490f9ec11641fb095a166fb9e1b592dcc40182fa86b)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
            "username": username,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap".

        :schema: ClusterSecretStoreSpecProviderVaultAuthLdap#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def username(self) -> builtins.str:
        '''Username is a LDAP user name used to authenticate using the LDAP Vault authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuthLdap#username
        '''
        result = self._values.get("username")
        assert result is not None, "Required property 'username' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef"]:
        '''SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuthLdap#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthLdap(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__55cf6198c624abda137c052d1dc014ca36b71dd2d46492befe116265455ee36d)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''TokenSecretRef authenticates with Vault by presenting a token.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__19291a9702423000e44c226f201a482aea5e992dd47a71153ebb3070b6856b2d)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class ClusterSecretStoreSpecProviderVaultCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "ClusterSecretStoreSpecProviderVaultCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Vault server certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in.

        :schema: ClusterSecretStoreSpecProviderVaultCaProvider
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__595609c1cb77ac8d0172cebab30d5f44428ed4331922d82d47b326431302591b)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: ClusterSecretStoreSpecProviderVaultCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "ClusterSecretStoreSpecProviderVaultCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: ClusterSecretStoreSpecProviderVaultCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderVaultCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: ClusterSecretStoreSpecProviderVaultCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        :schema: ClusterSecretStoreSpecProviderVaultCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultCaProviderType"
)
class ClusterSecretStoreSpecProviderVaultCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: ClusterSecretStoreSpecProviderVaultCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.enum(jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultVersion")
class ClusterSecretStoreSpecProviderVaultVersion(enum.Enum):
    '''Version is the Vault KV secret engine version.

    This can be either "v1" or
    "v2". Version defaults to "v2".

    :schema: ClusterSecretStoreSpecProviderVaultVersion
    '''

    V1 = "V1"
    '''v1.'''
    V2 = "V2"
    '''v2.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderWebhook",
    jsii_struct_bases=[],
    name_mapping={
        "result": "result",
        "url": "url",
        "body": "body",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
        "headers": "headers",
        "method": "method",
        "secrets": "secrets",
        "timeout": "timeout",
    },
)
class ClusterSecretStoreSpecProviderWebhook:
    def __init__(
        self,
        *,
        result: typing.Union["ClusterSecretStoreSpecProviderWebhookResult", typing.Dict[builtins.str, typing.Any]],
        url: builtins.str,
        body: typing.Optional[builtins.str] = None,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderWebhookCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
        headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        method: typing.Optional[builtins.str] = None,
        secrets: typing.Optional[typing.Sequence[typing.Union["ClusterSecretStoreSpecProviderWebhookSecrets", typing.Dict[builtins.str, typing.Any]]]] = None,
        timeout: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Webhook configures this store to sync secrets using a generic templated webhook.

        :param result: Result formatting.
        :param url: Webhook url to call.
        :param body: Body.
        :param ca_bundle: PEM encoded CA bundle used to validate webhook server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
        :param ca_provider: The provider for the CA bundle to use to validate webhook server certificate.
        :param headers: Headers.
        :param method: Webhook Method.
        :param secrets: Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name.
        :param timeout: Timeout.

        :schema: ClusterSecretStoreSpecProviderWebhook
        '''
        if isinstance(result, dict):
            result = ClusterSecretStoreSpecProviderWebhookResult(**result)
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreSpecProviderWebhookCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__567875e5230d606c5c4ae9dfad288f18e0d73f5564ac4e3e6ec54c667c14e548)
            check_type(argname="argument result", value=result, expected_type=type_hints["result"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
            check_type(argname="argument body", value=body, expected_type=type_hints["body"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument headers", value=headers, expected_type=type_hints["headers"])
            check_type(argname="argument method", value=method, expected_type=type_hints["method"])
            check_type(argname="argument secrets", value=secrets, expected_type=type_hints["secrets"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "result": result,
            "url": url,
        }
        if body is not None:
            self._values["body"] = body
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if headers is not None:
            self._values["headers"] = headers
        if method is not None:
            self._values["method"] = method
        if secrets is not None:
            self._values["secrets"] = secrets
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def result(self) -> "ClusterSecretStoreSpecProviderWebhookResult":
        '''Result formatting.

        :schema: ClusterSecretStoreSpecProviderWebhook#result
        '''
        result = self._values.get("result")
        assert result is not None, "Required property 'result' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderWebhookResult", result)

    @builtins.property
    def url(self) -> builtins.str:
        '''Webhook url to call.

        :schema: ClusterSecretStoreSpecProviderWebhook#url
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def body(self) -> typing.Optional[builtins.str]:
        '''Body.

        :schema: ClusterSecretStoreSpecProviderWebhook#body
        '''
        result = self._values.get("body")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''PEM encoded CA bundle used to validate webhook server certificate.

        Only used
        if the Server URL is using HTTPS protocol. This parameter is ignored for
        plain HTTP protocol connection. If not set the system root certificates
        are used to validate the TLS connection.

        :schema: ClusterSecretStoreSpecProviderWebhook#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderWebhookCaProvider"]:
        '''The provider for the CA bundle to use to validate webhook server certificate.

        :schema: ClusterSecretStoreSpecProviderWebhook#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderWebhookCaProvider"], result)

    @builtins.property
    def headers(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Headers.

        :schema: ClusterSecretStoreSpecProviderWebhook#headers
        '''
        result = self._values.get("headers")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def method(self) -> typing.Optional[builtins.str]:
        '''Webhook Method.

        :schema: ClusterSecretStoreSpecProviderWebhook#method
        '''
        result = self._values.get("method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secrets(
        self,
    ) -> typing.Optional[typing.List["ClusterSecretStoreSpecProviderWebhookSecrets"]]:
        '''Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name.

        :schema: ClusterSecretStoreSpecProviderWebhook#secrets
        '''
        result = self._values.get("secrets")
        return typing.cast(typing.Optional[typing.List["ClusterSecretStoreSpecProviderWebhookSecrets"]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[builtins.str]:
        '''Timeout.

        :schema: ClusterSecretStoreSpecProviderWebhook#timeout
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderWebhook(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderWebhookCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class ClusterSecretStoreSpecProviderWebhookCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "ClusterSecretStoreSpecProviderWebhookCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate webhook server certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in.

        :schema: ClusterSecretStoreSpecProviderWebhookCaProvider
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6af71527adcfa428fc129c129960c07c67fa441f1545f10e5dcefc09fca81c33)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: ClusterSecretStoreSpecProviderWebhookCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "ClusterSecretStoreSpecProviderWebhookCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: ClusterSecretStoreSpecProviderWebhookCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderWebhookCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: ClusterSecretStoreSpecProviderWebhookCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        :schema: ClusterSecretStoreSpecProviderWebhookCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderWebhookCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderWebhookCaProviderType"
)
class ClusterSecretStoreSpecProviderWebhookCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: ClusterSecretStoreSpecProviderWebhookCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderWebhookResult",
    jsii_struct_bases=[],
    name_mapping={"json_path": "jsonPath"},
)
class ClusterSecretStoreSpecProviderWebhookResult:
    def __init__(self, *, json_path: typing.Optional[builtins.str] = None) -> None:
        '''Result formatting.

        :param json_path: Json path of return value.

        :schema: ClusterSecretStoreSpecProviderWebhookResult
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb7bc09013491f073871fae2ceecbef13b45de0131befa24ed148a2477ce78d4)
            check_type(argname="argument json_path", value=json_path, expected_type=type_hints["json_path"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if json_path is not None:
            self._values["json_path"] = json_path

    @builtins.property
    def json_path(self) -> typing.Optional[builtins.str]:
        '''Json path of return value.

        :schema: ClusterSecretStoreSpecProviderWebhookResult#jsonPath
        '''
        result = self._values.get("json_path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderWebhookResult(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderWebhookSecrets",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "secret_ref": "secretRef"},
)
class ClusterSecretStoreSpecProviderWebhookSecrets:
    def __init__(
        self,
        *,
        name: builtins.str,
        secret_ref: typing.Union["ClusterSecretStoreSpecProviderWebhookSecretsSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param name: Name of this secret in templates.
        :param secret_ref: Secret ref to fill in credentials.

        :schema: ClusterSecretStoreSpecProviderWebhookSecrets
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderWebhookSecretsSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d5b27c62208713fb27769c2499653451dbf2faa38b53342a2fb2e0a38cb9b74)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "secret_ref": secret_ref,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of this secret in templates.

        :schema: ClusterSecretStoreSpecProviderWebhookSecrets#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(self) -> "ClusterSecretStoreSpecProviderWebhookSecretsSecretRef":
        '''Secret ref to fill in credentials.

        :schema: ClusterSecretStoreSpecProviderWebhookSecrets#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderWebhookSecretsSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderWebhookSecrets(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderWebhookSecretsSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderWebhookSecretsSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Secret ref to fill in credentials.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderWebhookSecretsSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2cb2e940c5c2aaaf9bab8c136ca4833e3d43a06ef0d1472d9c82372927475b73)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderWebhookSecretsSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderWebhookSecretsSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderWebhookSecretsSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderWebhookSecretsSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderYandexlockbox",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "api_endpoint": "apiEndpoint",
        "ca_provider": "caProvider",
    },
)
class ClusterSecretStoreSpecProviderYandexlockbox:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreSpecProviderYandexlockboxAuth", typing.Dict[builtins.str, typing.Any]],
        api_endpoint: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderYandexlockboxCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :param auth: Auth defines the information necessary to authenticate against Yandex Lockbox.
        :param api_endpoint: Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').
        :param ca_provider: The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: ClusterSecretStoreSpecProviderYandexlockbox
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreSpecProviderYandexlockboxAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreSpecProviderYandexlockboxCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2c07a0a205f8c8fe18207380dcf1b0dfd37eee884a6e932cd28cc4f665d658d7)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument api_endpoint", value=api_endpoint, expected_type=type_hints["api_endpoint"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
        }
        if api_endpoint is not None:
            self._values["api_endpoint"] = api_endpoint
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider

    @builtins.property
    def auth(self) -> "ClusterSecretStoreSpecProviderYandexlockboxAuth":
        '''Auth defines the information necessary to authenticate against Yandex Lockbox.

        :schema: ClusterSecretStoreSpecProviderYandexlockbox#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderYandexlockboxAuth", result)

    @builtins.property
    def api_endpoint(self) -> typing.Optional[builtins.str]:
        '''Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').

        :schema: ClusterSecretStoreSpecProviderYandexlockbox#apiEndpoint
        '''
        result = self._values.get("api_endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderYandexlockboxCaProvider"]:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: ClusterSecretStoreSpecProviderYandexlockbox#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderYandexlockboxCaProvider"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderYandexlockbox(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderYandexlockboxAuth",
    jsii_struct_bases=[],
    name_mapping={"authorized_key_secret_ref": "authorizedKeySecretRef"},
)
class ClusterSecretStoreSpecProviderYandexlockboxAuth:
    def __init__(
        self,
        *,
        authorized_key_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against Yandex Lockbox.

        :param authorized_key_secret_ref: The authorized key used for authentication.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxAuth
        '''
        if isinstance(authorized_key_secret_ref, dict):
            authorized_key_secret_ref = ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef(**authorized_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f7af5ccd38a738e138a4da5ed3536313b5fe188c2b865f812b232b7860654d44)
            check_type(argname="argument authorized_key_secret_ref", value=authorized_key_secret_ref, expected_type=type_hints["authorized_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if authorized_key_secret_ref is not None:
            self._values["authorized_key_secret_ref"] = authorized_key_secret_ref

    @builtins.property
    def authorized_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef"]:
        '''The authorized key used for authentication.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxAuth#authorizedKeySecretRef
        '''
        result = self._values.get("authorized_key_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderYandexlockboxAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The authorized key used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__84df0d5ae303fe803ec5407c1564c124f89ce2f877cf951164b5346e358facc7)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderYandexlockboxCaProvider",
    jsii_struct_bases=[],
    name_mapping={"cert_secret_ref": "certSecretRef"},
)
class ClusterSecretStoreSpecProviderYandexlockboxCaProvider:
    def __init__(
        self,
        *,
        cert_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :param cert_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxCaProvider
        '''
        if isinstance(cert_secret_ref, dict):
            cert_secret_ref = ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef(**cert_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__76304aa64a9b969f7e70594f92303a19605c96d6cc52a1e762c1f60949328f79)
            check_type(argname="argument cert_secret_ref", value=cert_secret_ref, expected_type=type_hints["cert_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cert_secret_ref is not None:
            self._values["cert_secret_ref"] = cert_secret_ref

    @builtins.property
    def cert_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxCaProvider#certSecretRef
        '''
        result = self._values.get("cert_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderYandexlockboxCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bdd207953372b8d88637204be9363b54f139d39e52bca9557f9caf7bd4d55bc8)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecRetrySettings",
    jsii_struct_bases=[],
    name_mapping={"max_retries": "maxRetries", "retry_interval": "retryInterval"},
)
class ClusterSecretStoreSpecRetrySettings:
    def __init__(
        self,
        *,
        max_retries: typing.Optional[jsii.Number] = None,
        retry_interval: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Used to configure http retries if failed.

        :param max_retries: 
        :param retry_interval: 

        :schema: ClusterSecretStoreSpecRetrySettings
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e47d412c07158576d9f7496f0a0011a69595d8febfe76d46ed415887b59df8a3)
            check_type(argname="argument max_retries", value=max_retries, expected_type=type_hints["max_retries"])
            check_type(argname="argument retry_interval", value=retry_interval, expected_type=type_hints["retry_interval"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if max_retries is not None:
            self._values["max_retries"] = max_retries
        if retry_interval is not None:
            self._values["retry_interval"] = retry_interval

    @builtins.property
    def max_retries(self) -> typing.Optional[jsii.Number]:
        '''
        :schema: ClusterSecretStoreSpecRetrySettings#maxRetries
        '''
        result = self._values.get("max_retries")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def retry_interval(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreSpecRetrySettings#retryInterval
        '''
        result = self._values.get("retry_interval")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecRetrySettings(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ClusterSecretStoreV1Beta1(
    _cdk8s_d3d9af27.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1",
):
    '''ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of ``storeRef`` fields.

    :schema: ClusterSecretStoreV1Beta1
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1Spec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a "ClusterSecretStoreV1Beta1" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8dc69ba83ec04594930db7e5543a7852c705a1ef67b59aa2efb6d2f5fad31ca0)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ClusterSecretStoreV1Beta1Props(metadata=metadata, spec=spec)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest")
    @builtins.classmethod
    def manifest(
        cls,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1Spec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> typing.Any:
        '''Renders a Kubernetes manifest for "ClusterSecretStoreV1Beta1".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.
        '''
        props = ClusterSecretStoreV1Beta1Props(metadata=metadata, spec=spec)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''Renders the object to Kubernetes JSON.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> _cdk8s_d3d9af27.GroupVersionKind:
        '''Returns the apiVersion and kind for "ClusterSecretStoreV1Beta1".'''
        return typing.cast(_cdk8s_d3d9af27.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1Props",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class ClusterSecretStoreV1Beta1Props:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1Spec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of ``storeRef`` fields.

        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.

        :schema: ClusterSecretStoreV1Beta1
        '''
        if isinstance(metadata, dict):
            metadata = _cdk8s_d3d9af27.ApiObjectMetadata(**metadata)
        if isinstance(spec, dict):
            spec = ClusterSecretStoreV1Beta1Spec(**spec)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__37dcaec4116fd103182a4f47c276c1a112b670414846040cdef450a01c9e5a73)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(self) -> typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata]:
        '''
        :schema: ClusterSecretStoreV1Beta1#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata], result)

    @builtins.property
    def spec(self) -> typing.Optional["ClusterSecretStoreV1Beta1Spec"]:
        '''SecretStoreSpec defines the desired state of SecretStore.

        :schema: ClusterSecretStoreV1Beta1#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1Spec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1Props(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1Spec",
    jsii_struct_bases=[],
    name_mapping={
        "provider": "provider",
        "conditions": "conditions",
        "controller": "controller",
        "refresh_interval": "refreshInterval",
        "retry_settings": "retrySettings",
    },
)
class ClusterSecretStoreV1Beta1Spec:
    def __init__(
        self,
        *,
        provider: typing.Union["ClusterSecretStoreV1Beta1SpecProvider", typing.Dict[builtins.str, typing.Any]],
        conditions: typing.Optional[typing.Sequence[typing.Union["ClusterSecretStoreV1Beta1SpecConditions", typing.Dict[builtins.str, typing.Any]]]] = None,
        controller: typing.Optional[builtins.str] = None,
        refresh_interval: typing.Optional[jsii.Number] = None,
        retry_settings: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecRetrySettings", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''SecretStoreSpec defines the desired state of SecretStore.

        :param provider: Used to configure the provider. Only one provider may be set
        :param conditions: Used to constraint a ClusterSecretStore to specific namespaces. Relevant only to ClusterSecretStore
        :param controller: Used to select the correct ESO controller (think: ingress.ingressClassName) The ESO controller is instantiated with a specific controller name and filters ES based on this property.
        :param refresh_interval: Used to configure store refresh interval in seconds. Empty or 0 will default to the controller config.
        :param retry_settings: Used to configure http retries if failed.

        :schema: ClusterSecretStoreV1Beta1Spec
        '''
        if isinstance(provider, dict):
            provider = ClusterSecretStoreV1Beta1SpecProvider(**provider)
        if isinstance(retry_settings, dict):
            retry_settings = ClusterSecretStoreV1Beta1SpecRetrySettings(**retry_settings)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__96137c80a93e24eeba29fafca095a8203971811207350934aeba8d7893de9dc3)
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument conditions", value=conditions, expected_type=type_hints["conditions"])
            check_type(argname="argument controller", value=controller, expected_type=type_hints["controller"])
            check_type(argname="argument refresh_interval", value=refresh_interval, expected_type=type_hints["refresh_interval"])
            check_type(argname="argument retry_settings", value=retry_settings, expected_type=type_hints["retry_settings"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "provider": provider,
        }
        if conditions is not None:
            self._values["conditions"] = conditions
        if controller is not None:
            self._values["controller"] = controller
        if refresh_interval is not None:
            self._values["refresh_interval"] = refresh_interval
        if retry_settings is not None:
            self._values["retry_settings"] = retry_settings

    @builtins.property
    def provider(self) -> "ClusterSecretStoreV1Beta1SpecProvider":
        '''Used to configure the provider.

        Only one provider may be set

        :schema: ClusterSecretStoreV1Beta1Spec#provider
        '''
        result = self._values.get("provider")
        assert result is not None, "Required property 'provider' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProvider", result)

    @builtins.property
    def conditions(
        self,
    ) -> typing.Optional[typing.List["ClusterSecretStoreV1Beta1SpecConditions"]]:
        '''Used to constraint a ClusterSecretStore to specific namespaces.

        Relevant only to ClusterSecretStore

        :schema: ClusterSecretStoreV1Beta1Spec#conditions
        '''
        result = self._values.get("conditions")
        return typing.cast(typing.Optional[typing.List["ClusterSecretStoreV1Beta1SpecConditions"]], result)

    @builtins.property
    def controller(self) -> typing.Optional[builtins.str]:
        '''Used to select the correct ESO controller (think: ingress.ingressClassName) The ESO controller is instantiated with a specific controller name and filters ES based on this property.

        :schema: ClusterSecretStoreV1Beta1Spec#controller
        '''
        result = self._values.get("controller")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def refresh_interval(self) -> typing.Optional[jsii.Number]:
        '''Used to configure store refresh interval in seconds.

        Empty or 0 will default to the controller config.

        :schema: ClusterSecretStoreV1Beta1Spec#refreshInterval
        '''
        result = self._values.get("refresh_interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def retry_settings(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecRetrySettings"]:
        '''Used to configure http retries if failed.

        :schema: ClusterSecretStoreV1Beta1Spec#retrySettings
        '''
        result = self._values.get("retry_settings")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecRetrySettings"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1Spec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecConditions",
    jsii_struct_bases=[],
    name_mapping={
        "namespace_regexes": "namespaceRegexes",
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
    },
)
class ClusterSecretStoreV1Beta1SpecConditions:
    def __init__(
        self,
        *,
        namespace_regexes: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''ClusterSecretStoreCondition describes a condition by which to choose namespaces to process ExternalSecrets in for a ClusterSecretStore instance.

        :param namespace_regexes: Choose namespaces by using regex matching.
        :param namespaces: Choose namespaces by name.
        :param namespace_selector: Choose namespace using a labelSelector.

        :schema: ClusterSecretStoreV1Beta1SpecConditions
        '''
        if isinstance(namespace_selector, dict):
            namespace_selector = ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a0202bb2fa72e90fc4694fed122e588c991e624b62e6209c28dc3a91ec50c85)
            check_type(argname="argument namespace_regexes", value=namespace_regexes, expected_type=type_hints["namespace_regexes"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if namespace_regexes is not None:
            self._values["namespace_regexes"] = namespace_regexes
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector

    @builtins.property
    def namespace_regexes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Choose namespaces by using regex matching.

        :schema: ClusterSecretStoreV1Beta1SpecConditions#namespaceRegexes
        '''
        result = self._values.get("namespace_regexes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Choose namespaces by name.

        :schema: ClusterSecretStoreV1Beta1SpecConditions#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector"]:
        '''Choose namespace using a labelSelector.

        :schema: ClusterSecretStoreV1Beta1SpecConditions#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecConditions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Choose namespace using a labelSelector.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__60d6e4eff1efa2b67d55a0694a4bc3737bb79c33a7e3ef1e953aded7c9e48b6a)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f6837a7309a755123acc2e7f78d1774390ea2fa5b1b52a1281d7fe46f9b6fa9)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProvider",
    jsii_struct_bases=[],
    name_mapping={
        "akeyless": "akeyless",
        "alibaba": "alibaba",
        "aws": "aws",
        "azurekv": "azurekv",
        "beyondtrust": "beyondtrust",
        "bitwardensecretsmanager": "bitwardensecretsmanager",
        "chef": "chef",
        "conjur": "conjur",
        "delinea": "delinea",
        "device42": "device42",
        "doppler": "doppler",
        "fake": "fake",
        "fortanix": "fortanix",
        "gcpsm": "gcpsm",
        "gitlab": "gitlab",
        "ibm": "ibm",
        "infisical": "infisical",
        "keepersecurity": "keepersecurity",
        "kubernetes": "kubernetes",
        "onboardbase": "onboardbase",
        "onepassword": "onepassword",
        "oracle": "oracle",
        "passbolt": "passbolt",
        "passworddepot": "passworddepot",
        "previder": "previder",
        "pulumi": "pulumi",
        "scaleway": "scaleway",
        "secretserver": "secretserver",
        "senhasegura": "senhasegura",
        "vault": "vault",
        "webhook": "webhook",
        "yandexcertificatemanager": "yandexcertificatemanager",
        "yandexlockbox": "yandexlockbox",
    },
)
class ClusterSecretStoreV1Beta1SpecProvider:
    def __init__(
        self,
        *,
        akeyless: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAkeyless", typing.Dict[builtins.str, typing.Any]]] = None,
        alibaba: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAlibaba", typing.Dict[builtins.str, typing.Any]]] = None,
        aws: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAws", typing.Dict[builtins.str, typing.Any]]] = None,
        azurekv: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAzurekv", typing.Dict[builtins.str, typing.Any]]] = None,
        beyondtrust: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderBeyondtrust", typing.Dict[builtins.str, typing.Any]]] = None,
        bitwardensecretsmanager: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager", typing.Dict[builtins.str, typing.Any]]] = None,
        chef: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderChef", typing.Dict[builtins.str, typing.Any]]] = None,
        conjur: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderConjur", typing.Dict[builtins.str, typing.Any]]] = None,
        delinea: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderDelinea", typing.Dict[builtins.str, typing.Any]]] = None,
        device42: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderDevice42", typing.Dict[builtins.str, typing.Any]]] = None,
        doppler: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderDoppler", typing.Dict[builtins.str, typing.Any]]] = None,
        fake: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderFake", typing.Dict[builtins.str, typing.Any]]] = None,
        fortanix: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderFortanix", typing.Dict[builtins.str, typing.Any]]] = None,
        gcpsm: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderGcpsm", typing.Dict[builtins.str, typing.Any]]] = None,
        gitlab: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderGitlab", typing.Dict[builtins.str, typing.Any]]] = None,
        ibm: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderIbm", typing.Dict[builtins.str, typing.Any]]] = None,
        infisical: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderInfisical", typing.Dict[builtins.str, typing.Any]]] = None,
        keepersecurity: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKeepersecurity", typing.Dict[builtins.str, typing.Any]]] = None,
        kubernetes: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetes", typing.Dict[builtins.str, typing.Any]]] = None,
        onboardbase: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderOnboardbase", typing.Dict[builtins.str, typing.Any]]] = None,
        onepassword: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderOnepassword", typing.Dict[builtins.str, typing.Any]]] = None,
        oracle: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderOracle", typing.Dict[builtins.str, typing.Any]]] = None,
        passbolt: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderPassbolt", typing.Dict[builtins.str, typing.Any]]] = None,
        passworddepot: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderPassworddepot", typing.Dict[builtins.str, typing.Any]]] = None,
        previder: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderPrevider", typing.Dict[builtins.str, typing.Any]]] = None,
        pulumi: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderPulumi", typing.Dict[builtins.str, typing.Any]]] = None,
        scaleway: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderScaleway", typing.Dict[builtins.str, typing.Any]]] = None,
        secretserver: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderSecretserver", typing.Dict[builtins.str, typing.Any]]] = None,
        senhasegura: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderSenhasegura", typing.Dict[builtins.str, typing.Any]]] = None,
        vault: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVault", typing.Dict[builtins.str, typing.Any]]] = None,
        webhook: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderWebhook", typing.Dict[builtins.str, typing.Any]]] = None,
        yandexcertificatemanager: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager", typing.Dict[builtins.str, typing.Any]]] = None,
        yandexlockbox: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderYandexlockbox", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Used to configure the provider.

        Only one provider may be set

        :param akeyless: Akeyless configures this store to sync secrets using Akeyless Vault provider.
        :param alibaba: Alibaba configures this store to sync secrets using Alibaba Cloud provider.
        :param aws: AWS configures this store to sync secrets using AWS Secret Manager provider.
        :param azurekv: AzureKV configures this store to sync secrets using Azure Key Vault provider.
        :param beyondtrust: Beyondtrust configures this store to sync secrets using Password Safe provider.
        :param bitwardensecretsmanager: BitwardenSecretsManager configures this store to sync secrets using BitwardenSecretsManager provider.
        :param chef: Chef configures this store to sync secrets with chef server.
        :param conjur: Conjur configures this store to sync secrets using conjur provider.
        :param delinea: Delinea DevOps Secrets Vault https://docs.delinea.com/online-help/products/devops-secrets-vault/current.
        :param device42: Device42 configures this store to sync secrets using the Device42 provider.
        :param doppler: Doppler configures this store to sync secrets using the Doppler provider.
        :param fake: Fake configures a store with static key/value pairs.
        :param fortanix: Fortanix configures this store to sync secrets using the Fortanix provider.
        :param gcpsm: GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.
        :param gitlab: GitLab configures this store to sync secrets using GitLab Variables provider.
        :param ibm: IBM configures this store to sync secrets using IBM Cloud provider.
        :param infisical: Infisical configures this store to sync secrets using the Infisical provider.
        :param keepersecurity: KeeperSecurity configures this store to sync secrets using the KeeperSecurity provider.
        :param kubernetes: Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.
        :param onboardbase: Onboardbase configures this store to sync secrets using the Onboardbase provider.
        :param onepassword: OnePassword configures this store to sync secrets using the 1Password Cloud provider.
        :param oracle: Oracle configures this store to sync secrets using Oracle Vault provider.
        :param passbolt: 
        :param passworddepot: Configures a store to sync secrets with a Password Depot instance.
        :param previder: Previder configures this store to sync secrets using the Previder provider.
        :param pulumi: Pulumi configures this store to sync secrets using the Pulumi provider.
        :param scaleway: Scaleway.
        :param secretserver: SecretServer configures this store to sync secrets using SecretServer provider https://docs.delinea.com/online-help/secret-server/start.htm.
        :param senhasegura: Senhasegura configures this store to sync secrets using senhasegura provider.
        :param vault: Vault configures this store to sync secrets using Hashi provider.
        :param webhook: Webhook configures this store to sync secrets using a generic templated webhook.
        :param yandexcertificatemanager: YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider.
        :param yandexlockbox: YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider
        '''
        if isinstance(akeyless, dict):
            akeyless = ClusterSecretStoreV1Beta1SpecProviderAkeyless(**akeyless)
        if isinstance(alibaba, dict):
            alibaba = ClusterSecretStoreV1Beta1SpecProviderAlibaba(**alibaba)
        if isinstance(aws, dict):
            aws = ClusterSecretStoreV1Beta1SpecProviderAws(**aws)
        if isinstance(azurekv, dict):
            azurekv = ClusterSecretStoreV1Beta1SpecProviderAzurekv(**azurekv)
        if isinstance(beyondtrust, dict):
            beyondtrust = ClusterSecretStoreV1Beta1SpecProviderBeyondtrust(**beyondtrust)
        if isinstance(bitwardensecretsmanager, dict):
            bitwardensecretsmanager = ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager(**bitwardensecretsmanager)
        if isinstance(chef, dict):
            chef = ClusterSecretStoreV1Beta1SpecProviderChef(**chef)
        if isinstance(conjur, dict):
            conjur = ClusterSecretStoreV1Beta1SpecProviderConjur(**conjur)
        if isinstance(delinea, dict):
            delinea = ClusterSecretStoreV1Beta1SpecProviderDelinea(**delinea)
        if isinstance(device42, dict):
            device42 = ClusterSecretStoreV1Beta1SpecProviderDevice42(**device42)
        if isinstance(doppler, dict):
            doppler = ClusterSecretStoreV1Beta1SpecProviderDoppler(**doppler)
        if isinstance(fake, dict):
            fake = ClusterSecretStoreV1Beta1SpecProviderFake(**fake)
        if isinstance(fortanix, dict):
            fortanix = ClusterSecretStoreV1Beta1SpecProviderFortanix(**fortanix)
        if isinstance(gcpsm, dict):
            gcpsm = ClusterSecretStoreV1Beta1SpecProviderGcpsm(**gcpsm)
        if isinstance(gitlab, dict):
            gitlab = ClusterSecretStoreV1Beta1SpecProviderGitlab(**gitlab)
        if isinstance(ibm, dict):
            ibm = ClusterSecretStoreV1Beta1SpecProviderIbm(**ibm)
        if isinstance(infisical, dict):
            infisical = ClusterSecretStoreV1Beta1SpecProviderInfisical(**infisical)
        if isinstance(keepersecurity, dict):
            keepersecurity = ClusterSecretStoreV1Beta1SpecProviderKeepersecurity(**keepersecurity)
        if isinstance(kubernetes, dict):
            kubernetes = ClusterSecretStoreV1Beta1SpecProviderKubernetes(**kubernetes)
        if isinstance(onboardbase, dict):
            onboardbase = ClusterSecretStoreV1Beta1SpecProviderOnboardbase(**onboardbase)
        if isinstance(onepassword, dict):
            onepassword = ClusterSecretStoreV1Beta1SpecProviderOnepassword(**onepassword)
        if isinstance(oracle, dict):
            oracle = ClusterSecretStoreV1Beta1SpecProviderOracle(**oracle)
        if isinstance(passbolt, dict):
            passbolt = ClusterSecretStoreV1Beta1SpecProviderPassbolt(**passbolt)
        if isinstance(passworddepot, dict):
            passworddepot = ClusterSecretStoreV1Beta1SpecProviderPassworddepot(**passworddepot)
        if isinstance(previder, dict):
            previder = ClusterSecretStoreV1Beta1SpecProviderPrevider(**previder)
        if isinstance(pulumi, dict):
            pulumi = ClusterSecretStoreV1Beta1SpecProviderPulumi(**pulumi)
        if isinstance(scaleway, dict):
            scaleway = ClusterSecretStoreV1Beta1SpecProviderScaleway(**scaleway)
        if isinstance(secretserver, dict):
            secretserver = ClusterSecretStoreV1Beta1SpecProviderSecretserver(**secretserver)
        if isinstance(senhasegura, dict):
            senhasegura = ClusterSecretStoreV1Beta1SpecProviderSenhasegura(**senhasegura)
        if isinstance(vault, dict):
            vault = ClusterSecretStoreV1Beta1SpecProviderVault(**vault)
        if isinstance(webhook, dict):
            webhook = ClusterSecretStoreV1Beta1SpecProviderWebhook(**webhook)
        if isinstance(yandexcertificatemanager, dict):
            yandexcertificatemanager = ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager(**yandexcertificatemanager)
        if isinstance(yandexlockbox, dict):
            yandexlockbox = ClusterSecretStoreV1Beta1SpecProviderYandexlockbox(**yandexlockbox)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__68ba9e9c4c46e5f6c6fca915ad8c80109c0ed4a1cdb61ca84e474072d126bde6)
            check_type(argname="argument akeyless", value=akeyless, expected_type=type_hints["akeyless"])
            check_type(argname="argument alibaba", value=alibaba, expected_type=type_hints["alibaba"])
            check_type(argname="argument aws", value=aws, expected_type=type_hints["aws"])
            check_type(argname="argument azurekv", value=azurekv, expected_type=type_hints["azurekv"])
            check_type(argname="argument beyondtrust", value=beyondtrust, expected_type=type_hints["beyondtrust"])
            check_type(argname="argument bitwardensecretsmanager", value=bitwardensecretsmanager, expected_type=type_hints["bitwardensecretsmanager"])
            check_type(argname="argument chef", value=chef, expected_type=type_hints["chef"])
            check_type(argname="argument conjur", value=conjur, expected_type=type_hints["conjur"])
            check_type(argname="argument delinea", value=delinea, expected_type=type_hints["delinea"])
            check_type(argname="argument device42", value=device42, expected_type=type_hints["device42"])
            check_type(argname="argument doppler", value=doppler, expected_type=type_hints["doppler"])
            check_type(argname="argument fake", value=fake, expected_type=type_hints["fake"])
            check_type(argname="argument fortanix", value=fortanix, expected_type=type_hints["fortanix"])
            check_type(argname="argument gcpsm", value=gcpsm, expected_type=type_hints["gcpsm"])
            check_type(argname="argument gitlab", value=gitlab, expected_type=type_hints["gitlab"])
            check_type(argname="argument ibm", value=ibm, expected_type=type_hints["ibm"])
            check_type(argname="argument infisical", value=infisical, expected_type=type_hints["infisical"])
            check_type(argname="argument keepersecurity", value=keepersecurity, expected_type=type_hints["keepersecurity"])
            check_type(argname="argument kubernetes", value=kubernetes, expected_type=type_hints["kubernetes"])
            check_type(argname="argument onboardbase", value=onboardbase, expected_type=type_hints["onboardbase"])
            check_type(argname="argument onepassword", value=onepassword, expected_type=type_hints["onepassword"])
            check_type(argname="argument oracle", value=oracle, expected_type=type_hints["oracle"])
            check_type(argname="argument passbolt", value=passbolt, expected_type=type_hints["passbolt"])
            check_type(argname="argument passworddepot", value=passworddepot, expected_type=type_hints["passworddepot"])
            check_type(argname="argument previder", value=previder, expected_type=type_hints["previder"])
            check_type(argname="argument pulumi", value=pulumi, expected_type=type_hints["pulumi"])
            check_type(argname="argument scaleway", value=scaleway, expected_type=type_hints["scaleway"])
            check_type(argname="argument secretserver", value=secretserver, expected_type=type_hints["secretserver"])
            check_type(argname="argument senhasegura", value=senhasegura, expected_type=type_hints["senhasegura"])
            check_type(argname="argument vault", value=vault, expected_type=type_hints["vault"])
            check_type(argname="argument webhook", value=webhook, expected_type=type_hints["webhook"])
            check_type(argname="argument yandexcertificatemanager", value=yandexcertificatemanager, expected_type=type_hints["yandexcertificatemanager"])
            check_type(argname="argument yandexlockbox", value=yandexlockbox, expected_type=type_hints["yandexlockbox"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if akeyless is not None:
            self._values["akeyless"] = akeyless
        if alibaba is not None:
            self._values["alibaba"] = alibaba
        if aws is not None:
            self._values["aws"] = aws
        if azurekv is not None:
            self._values["azurekv"] = azurekv
        if beyondtrust is not None:
            self._values["beyondtrust"] = beyondtrust
        if bitwardensecretsmanager is not None:
            self._values["bitwardensecretsmanager"] = bitwardensecretsmanager
        if chef is not None:
            self._values["chef"] = chef
        if conjur is not None:
            self._values["conjur"] = conjur
        if delinea is not None:
            self._values["delinea"] = delinea
        if device42 is not None:
            self._values["device42"] = device42
        if doppler is not None:
            self._values["doppler"] = doppler
        if fake is not None:
            self._values["fake"] = fake
        if fortanix is not None:
            self._values["fortanix"] = fortanix
        if gcpsm is not None:
            self._values["gcpsm"] = gcpsm
        if gitlab is not None:
            self._values["gitlab"] = gitlab
        if ibm is not None:
            self._values["ibm"] = ibm
        if infisical is not None:
            self._values["infisical"] = infisical
        if keepersecurity is not None:
            self._values["keepersecurity"] = keepersecurity
        if kubernetes is not None:
            self._values["kubernetes"] = kubernetes
        if onboardbase is not None:
            self._values["onboardbase"] = onboardbase
        if onepassword is not None:
            self._values["onepassword"] = onepassword
        if oracle is not None:
            self._values["oracle"] = oracle
        if passbolt is not None:
            self._values["passbolt"] = passbolt
        if passworddepot is not None:
            self._values["passworddepot"] = passworddepot
        if previder is not None:
            self._values["previder"] = previder
        if pulumi is not None:
            self._values["pulumi"] = pulumi
        if scaleway is not None:
            self._values["scaleway"] = scaleway
        if secretserver is not None:
            self._values["secretserver"] = secretserver
        if senhasegura is not None:
            self._values["senhasegura"] = senhasegura
        if vault is not None:
            self._values["vault"] = vault
        if webhook is not None:
            self._values["webhook"] = webhook
        if yandexcertificatemanager is not None:
            self._values["yandexcertificatemanager"] = yandexcertificatemanager
        if yandexlockbox is not None:
            self._values["yandexlockbox"] = yandexlockbox

    @builtins.property
    def akeyless(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeyless"]:
        '''Akeyless configures this store to sync secrets using Akeyless Vault provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#akeyless
        '''
        result = self._values.get("akeyless")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeyless"], result)

    @builtins.property
    def alibaba(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAlibaba"]:
        '''Alibaba configures this store to sync secrets using Alibaba Cloud provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#alibaba
        '''
        result = self._values.get("alibaba")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAlibaba"], result)

    @builtins.property
    def aws(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAws"]:
        '''AWS configures this store to sync secrets using AWS Secret Manager provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#aws
        '''
        result = self._values.get("aws")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAws"], result)

    @builtins.property
    def azurekv(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekv"]:
        '''AzureKV configures this store to sync secrets using Azure Key Vault provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#azurekv
        '''
        result = self._values.get("azurekv")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekv"], result)

    @builtins.property
    def beyondtrust(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrust"]:
        '''Beyondtrust configures this store to sync secrets using Password Safe provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#beyondtrust
        '''
        result = self._values.get("beyondtrust")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrust"], result)

    @builtins.property
    def bitwardensecretsmanager(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager"]:
        '''BitwardenSecretsManager configures this store to sync secrets using BitwardenSecretsManager provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#bitwardensecretsmanager
        '''
        result = self._values.get("bitwardensecretsmanager")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager"], result)

    @builtins.property
    def chef(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderChef"]:
        '''Chef configures this store to sync secrets with chef server.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#chef
        '''
        result = self._values.get("chef")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderChef"], result)

    @builtins.property
    def conjur(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderConjur"]:
        '''Conjur configures this store to sync secrets using conjur provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#conjur
        '''
        result = self._values.get("conjur")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderConjur"], result)

    @builtins.property
    def delinea(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDelinea"]:
        '''Delinea DevOps Secrets Vault https://docs.delinea.com/online-help/products/devops-secrets-vault/current.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#delinea
        '''
        result = self._values.get("delinea")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDelinea"], result)

    @builtins.property
    def device42(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDevice42"]:
        '''Device42 configures this store to sync secrets using the Device42 provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#device42
        '''
        result = self._values.get("device42")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDevice42"], result)

    @builtins.property
    def doppler(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDoppler"]:
        '''Doppler configures this store to sync secrets using the Doppler provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#doppler
        '''
        result = self._values.get("doppler")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDoppler"], result)

    @builtins.property
    def fake(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderFake"]:
        '''Fake configures a store with static key/value pairs.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#fake
        '''
        result = self._values.get("fake")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderFake"], result)

    @builtins.property
    def fortanix(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderFortanix"]:
        '''Fortanix configures this store to sync secrets using the Fortanix provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#fortanix
        '''
        result = self._values.get("fortanix")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderFortanix"], result)

    @builtins.property
    def gcpsm(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGcpsm"]:
        '''GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#gcpsm
        '''
        result = self._values.get("gcpsm")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGcpsm"], result)

    @builtins.property
    def gitlab(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGitlab"]:
        '''GitLab configures this store to sync secrets using GitLab Variables provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#gitlab
        '''
        result = self._values.get("gitlab")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGitlab"], result)

    @builtins.property
    def ibm(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderIbm"]:
        '''IBM configures this store to sync secrets using IBM Cloud provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#ibm
        '''
        result = self._values.get("ibm")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderIbm"], result)

    @builtins.property
    def infisical(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderInfisical"]:
        '''Infisical configures this store to sync secrets using the Infisical provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#infisical
        '''
        result = self._values.get("infisical")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderInfisical"], result)

    @builtins.property
    def keepersecurity(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKeepersecurity"]:
        '''KeeperSecurity configures this store to sync secrets using the KeeperSecurity provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#keepersecurity
        '''
        result = self._values.get("keepersecurity")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKeepersecurity"], result)

    @builtins.property
    def kubernetes(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetes"]:
        '''Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#kubernetes
        '''
        result = self._values.get("kubernetes")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetes"], result)

    @builtins.property
    def onboardbase(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderOnboardbase"]:
        '''Onboardbase configures this store to sync secrets using the Onboardbase provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#onboardbase
        '''
        result = self._values.get("onboardbase")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderOnboardbase"], result)

    @builtins.property
    def onepassword(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderOnepassword"]:
        '''OnePassword configures this store to sync secrets using the 1Password Cloud provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#onepassword
        '''
        result = self._values.get("onepassword")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderOnepassword"], result)

    @builtins.property
    def oracle(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderOracle"]:
        '''Oracle configures this store to sync secrets using Oracle Vault provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#oracle
        '''
        result = self._values.get("oracle")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderOracle"], result)

    @builtins.property
    def passbolt(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderPassbolt"]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProvider#passbolt
        '''
        result = self._values.get("passbolt")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderPassbolt"], result)

    @builtins.property
    def passworddepot(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderPassworddepot"]:
        '''Configures a store to sync secrets with a Password Depot instance.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#passworddepot
        '''
        result = self._values.get("passworddepot")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderPassworddepot"], result)

    @builtins.property
    def previder(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderPrevider"]:
        '''Previder configures this store to sync secrets using the Previder provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#previder
        '''
        result = self._values.get("previder")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderPrevider"], result)

    @builtins.property
    def pulumi(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderPulumi"]:
        '''Pulumi configures this store to sync secrets using the Pulumi provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#pulumi
        '''
        result = self._values.get("pulumi")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderPulumi"], result)

    @builtins.property
    def scaleway(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderScaleway"]:
        '''Scaleway.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#scaleway
        '''
        result = self._values.get("scaleway")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderScaleway"], result)

    @builtins.property
    def secretserver(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderSecretserver"]:
        '''SecretServer configures this store to sync secrets using SecretServer provider https://docs.delinea.com/online-help/secret-server/start.htm.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#secretserver
        '''
        result = self._values.get("secretserver")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderSecretserver"], result)

    @builtins.property
    def senhasegura(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderSenhasegura"]:
        '''Senhasegura configures this store to sync secrets using senhasegura provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#senhasegura
        '''
        result = self._values.get("senhasegura")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderSenhasegura"], result)

    @builtins.property
    def vault(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVault"]:
        '''Vault configures this store to sync secrets using Hashi provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#vault
        '''
        result = self._values.get("vault")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVault"], result)

    @builtins.property
    def webhook(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderWebhook"]:
        '''Webhook configures this store to sync secrets using a generic templated webhook.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#webhook
        '''
        result = self._values.get("webhook")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderWebhook"], result)

    @builtins.property
    def yandexcertificatemanager(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager"]:
        '''YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#yandexcertificatemanager
        '''
        result = self._values.get("yandexcertificatemanager")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager"], result)

    @builtins.property
    def yandexlockbox(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexlockbox"]:
        '''YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#yandexlockbox
        '''
        result = self._values.get("yandexlockbox")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexlockbox"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAkeyless",
    jsii_struct_bases=[],
    name_mapping={
        "akeyless_gw_api_url": "akeylessGwApiUrl",
        "auth_secret_ref": "authSecretRef",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderAkeyless:
    def __init__(
        self,
        *,
        akeyless_gw_api_url: builtins.str,
        auth_secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Akeyless configures this store to sync secrets using Akeyless Vault provider.

        :param akeyless_gw_api_url: Akeyless GW API Url from which the secrets to be fetched from.
        :param auth_secret_ref: Auth configures how the operator authenticates with Akeyless.
        :param ca_bundle: PEM/base64 encoded CA bundle used to validate Akeyless Gateway certificate. Only used if the AkeylessGWApiURL URL is using HTTPS protocol. If not set the system root certificates are used to validate the TLS connection.
        :param ca_provider: The provider for the CA bundle to use to validate Akeyless Gateway certificate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeyless
        '''
        if isinstance(auth_secret_ref, dict):
            auth_secret_ref = ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef(**auth_secret_ref)
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df929457145ba1be8a095a8bc3301089b349253206306ae5f336cd315970c692)
            check_type(argname="argument akeyless_gw_api_url", value=akeyless_gw_api_url, expected_type=type_hints["akeyless_gw_api_url"])
            check_type(argname="argument auth_secret_ref", value=auth_secret_ref, expected_type=type_hints["auth_secret_ref"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "akeyless_gw_api_url": akeyless_gw_api_url,
            "auth_secret_ref": auth_secret_ref,
        }
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider

    @builtins.property
    def akeyless_gw_api_url(self) -> builtins.str:
        '''Akeyless GW API Url from which the secrets to be fetched from.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeyless#akeylessGWApiURL
        '''
        result = self._values.get("akeyless_gw_api_url")
        assert result is not None, "Required property 'akeyless_gw_api_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth_secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef":
        '''Auth configures how the operator authenticates with Akeyless.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeyless#authSecretRef
        '''
        result = self._values.get("auth_secret_ref")
        assert result is not None, "Required property 'auth_secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef", result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''PEM/base64 encoded CA bundle used to validate Akeyless Gateway certificate.

        Only used
        if the AkeylessGWApiURL URL is using HTTPS protocol. If not set the system root certificates
        are used to validate the TLS connection.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeyless#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider"]:
        '''The provider for the CA bundle to use to validate Akeyless Gateway certificate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeyless#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAkeyless(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"kubernetes_auth": "kubernetesAuth", "secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef:
    def __init__(
        self,
        *,
        kubernetes_auth: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how the operator authenticates with Akeyless.

        :param kubernetes_auth: Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
        :param secret_ref: Reference to a Secret that contains the details to authenticate with Akeyless.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef
        '''
        if isinstance(kubernetes_auth, dict):
            kubernetes_auth = ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth(**kubernetes_auth)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__abebeff323eca27bea60a3ac92c48bbbc7420eab45f346bf2c362df8bbb1c671)
            check_type(argname="argument kubernetes_auth", value=kubernetes_auth, expected_type=type_hints["kubernetes_auth"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if kubernetes_auth is not None:
            self._values["kubernetes_auth"] = kubernetes_auth
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def kubernetes_auth(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth"]:
        '''Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef#kubernetesAuth
        '''
        result = self._values.get("kubernetes_auth")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef"]:
        '''Reference to a Secret that contains the details to authenticate with Akeyless.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth",
    jsii_struct_bases=[],
    name_mapping={
        "access_id": "accessId",
        "k8_s_conf_name": "k8SConfName",
        "secret_ref": "secretRef",
        "service_account_ref": "serviceAccountRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth:
    def __init__(
        self,
        *,
        access_id: builtins.str,
        k8_s_conf_name: builtins.str,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.

        :param access_id: the Akeyless Kubernetes auth-method access-id.
        :param k8_s_conf_name: Kubernetes-auth configuration name in Akeyless-Gateway.
        :param secret_ref: Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.
        :param service_account_ref: Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(**secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__192a0fd934e6a1d07615d2afd0795c3df7c4aa34d47ff452bedf3fc29fa86266)
            check_type(argname="argument access_id", value=access_id, expected_type=type_hints["access_id"])
            check_type(argname="argument k8_s_conf_name", value=k8_s_conf_name, expected_type=type_hints["k8_s_conf_name"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "access_id": access_id,
            "k8_s_conf_name": k8_s_conf_name,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def access_id(self) -> builtins.str:
        '''the Akeyless Kubernetes auth-method access-id.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#accessID
        '''
        result = self._values.get("access_id")
        assert result is not None, "Required property 'access_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def k8_s_conf_name(self) -> builtins.str:
        '''Kubernetes-auth configuration name in Akeyless-Gateway.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#k8sConfName
        '''
        result = self._values.get("k8_s_conf_name")
        assert result is not None, "Required property 'k8_s_conf_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef"]:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless.

        If a name is specified without a key,
        ``token`` is the default. If one is not specified, the one bound to
        the controller will be used.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef"]:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used
        for authenticating with Akeyless. If the service account selector is not supplied,
        the secretRef will be used instead.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless.

        If a name is specified without a key,
        ``token`` is the default. If one is not specified, the one bound to
        the controller will be used.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c14314d094e94d395d2ccff2cf0206fe712c51cc34cb705d9bc8551ecd029b3)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used
        for authenticating with Akeyless. If the service account selector is not supplied,
        the secretRef will be used instead.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4f478b9b41d5e678b636bd675c0ec2c7f55c4865d490d5fcc185441264c97d93)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_id": "accessId",
        "access_type": "accessType",
        "access_type_param": "accessTypeParam",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef:
    def __init__(
        self,
        *,
        access_id: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId", typing.Dict[builtins.str, typing.Any]]] = None,
        access_type: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType", typing.Dict[builtins.str, typing.Any]]] = None,
        access_type_param: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Reference to a Secret that contains the details to authenticate with Akeyless.

        :param access_id: The SecretAccessID is used for authentication.
        :param access_type: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param access_type_param: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef
        '''
        if isinstance(access_id, dict):
            access_id = ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId(**access_id)
        if isinstance(access_type, dict):
            access_type = ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType(**access_type)
        if isinstance(access_type_param, dict):
            access_type_param = ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(**access_type_param)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__60e63983e9ec9d9bfcca0afd0a14c5370b8a8c7b94a6b979643b8044b38aa115)
            check_type(argname="argument access_id", value=access_id, expected_type=type_hints["access_id"])
            check_type(argname="argument access_type", value=access_type, expected_type=type_hints["access_type"])
            check_type(argname="argument access_type_param", value=access_type_param, expected_type=type_hints["access_type_param"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if access_id is not None:
            self._values["access_id"] = access_id
        if access_type is not None:
            self._values["access_type"] = access_type
        if access_type_param is not None:
            self._values["access_type_param"] = access_type_param

    @builtins.property
    def access_id(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId"]:
        '''The SecretAccessID is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessID
        '''
        result = self._values.get("access_id")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId"], result)

    @builtins.property
    def access_type(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessType
        '''
        result = self._values.get("access_type")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType"], result)

    @builtins.property
    def access_type_param(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessTypeParam
        '''
        result = self._values.get("access_type_param")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessID is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__590589c4f0ffc4f7a23fc7be01fd06b9606c7490a060d9b41f3fce96cd350a4b)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6833336a565db04ecd89b0aa463de48ce00c5f1b845b44dd43ce9dab14465672)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d06232497d385b58bfbdd183ed5f662b436ad66cd940f49635d36c2df433b70d)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Akeyless Gateway certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9cc55aad529f682a5ebb094a2bfdb40ac255aabd37ddb0785bbd5aaff3c48947)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        Can only be defined when used in a ClusterSecretStore.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProviderType"
)
class ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAlibaba",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "region_id": "regionId"},
)
class ClusterSecretStoreV1Beta1SpecProviderAlibaba:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth", typing.Dict[builtins.str, typing.Any]],
        region_id: builtins.str,
    ) -> None:
        '''Alibaba configures this store to sync secrets using Alibaba Cloud provider.

        :param auth: AlibabaAuth contains a secretRef for credentials.
        :param region_id: Alibaba Region to be used for the provider.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibaba
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3eb80c03d9d589e644cb87d2292cd9b0100e384bc2944213b7aa5376062baa73)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument region_id", value=region_id, expected_type=type_hints["region_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "region_id": region_id,
        }

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth":
        '''AlibabaAuth contains a secretRef for credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibaba#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth", result)

    @builtins.property
    def region_id(self) -> builtins.str:
        '''Alibaba Region to be used for the provider.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibaba#regionID
        '''
        result = self._values.get("region_id")
        assert result is not None, "Required property 'region_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAlibaba(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth",
    jsii_struct_bases=[],
    name_mapping={"rrsa": "rrsa", "secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth:
    def __init__(
        self,
        *,
        rrsa: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''AlibabaAuth contains a secretRef for credentials.

        :param rrsa: Authenticate against Alibaba using RRSA.
        :param secret_ref: AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth
        '''
        if isinstance(rrsa, dict):
            rrsa = ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa(**rrsa)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f66b02e4c9c411cbc556b143e0d872bfef186a37724247912aa8fcc440a97ef5)
            check_type(argname="argument rrsa", value=rrsa, expected_type=type_hints["rrsa"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if rrsa is not None:
            self._values["rrsa"] = rrsa
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def rrsa(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa"]:
        '''Authenticate against Alibaba using RRSA.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth#rrsa
        '''
        result = self._values.get("rrsa")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef"]:
        '''AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa",
    jsii_struct_bases=[],
    name_mapping={
        "oidc_provider_arn": "oidcProviderArn",
        "oidc_token_file_path": "oidcTokenFilePath",
        "role_arn": "roleArn",
        "session_name": "sessionName",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa:
    def __init__(
        self,
        *,
        oidc_provider_arn: builtins.str,
        oidc_token_file_path: builtins.str,
        role_arn: builtins.str,
        session_name: builtins.str,
    ) -> None:
        '''Authenticate against Alibaba using RRSA.

        :param oidc_provider_arn: 
        :param oidc_token_file_path: 
        :param role_arn: 
        :param session_name: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6fe999b1094de39ca60a20138e20aa8cb22ff83d307bc0d4cce40257546baddb)
            check_type(argname="argument oidc_provider_arn", value=oidc_provider_arn, expected_type=type_hints["oidc_provider_arn"])
            check_type(argname="argument oidc_token_file_path", value=oidc_token_file_path, expected_type=type_hints["oidc_token_file_path"])
            check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            check_type(argname="argument session_name", value=session_name, expected_type=type_hints["session_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "oidc_provider_arn": oidc_provider_arn,
            "oidc_token_file_path": oidc_token_file_path,
            "role_arn": role_arn,
            "session_name": session_name,
        }

    @builtins.property
    def oidc_provider_arn(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#oidcProviderArn
        '''
        result = self._values.get("oidc_provider_arn")
        assert result is not None, "Required property 'oidc_provider_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def oidc_token_file_path(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#oidcTokenFilePath
        '''
        result = self._values.get("oidc_token_file_path")
        assert result is not None, "Required property 'oidc_token_file_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role_arn(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#roleArn
        '''
        result = self._values.get("role_arn")
        assert result is not None, "Required property 'role_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def session_name(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#sessionName
        '''
        result = self._values.get("session_name")
        assert result is not None, "Required property 'session_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_key_id_secret_ref": "accessKeyIdSecretRef",
        "access_key_secret_secret_ref": "accessKeySecretSecretRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef:
    def __init__(
        self,
        *,
        access_key_id_secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef", typing.Dict[builtins.str, typing.Any]],
        access_key_secret_secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :param access_key_id_secret_ref: The AccessKeyID is used for authentication.
        :param access_key_secret_secret_ref: The AccessKeySecret is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef
        '''
        if isinstance(access_key_id_secret_ref, dict):
            access_key_id_secret_ref = ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(**access_key_id_secret_ref)
        if isinstance(access_key_secret_secret_ref, dict):
            access_key_secret_secret_ref = ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(**access_key_secret_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9952ed78896c2d9e3124276209d8d30534064f05539cbe262b52dc19a0d35935)
            check_type(argname="argument access_key_id_secret_ref", value=access_key_id_secret_ref, expected_type=type_hints["access_key_id_secret_ref"])
            check_type(argname="argument access_key_secret_secret_ref", value=access_key_secret_secret_ref, expected_type=type_hints["access_key_secret_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "access_key_id_secret_ref": access_key_id_secret_ref,
            "access_key_secret_secret_ref": access_key_secret_secret_ref,
        }

    @builtins.property
    def access_key_id_secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef":
        '''The AccessKeyID is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef#accessKeyIDSecretRef
        '''
        result = self._values.get("access_key_id_secret_ref")
        assert result is not None, "Required property 'access_key_id_secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef", result)

    @builtins.property
    def access_key_secret_secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef":
        '''The AccessKeySecret is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef#accessKeySecretSecretRef
        '''
        result = self._values.get("access_key_secret_secret_ref")
        assert result is not None, "Required property 'access_key_secret_secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeyID is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a0a97c63b2968bfb08081c4620d8d386f9d89e66db4ee38df5e4cc06736a7481)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeySecret is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0b830df319081a50f248ad0423e39dc55ca4f62f813b541532fe44af6c0cb6c5)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAws",
    jsii_struct_bases=[],
    name_mapping={
        "region": "region",
        "service": "service",
        "additional_roles": "additionalRoles",
        "auth": "auth",
        "external_id": "externalId",
        "prefix": "prefix",
        "role": "role",
        "secrets_manager": "secretsManager",
        "session_tags": "sessionTags",
        "transitive_tag_keys": "transitiveTagKeys",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderAws:
    def __init__(
        self,
        *,
        region: builtins.str,
        service: "ClusterSecretStoreV1Beta1SpecProviderAwsService",
        additional_roles: typing.Optional[typing.Sequence[builtins.str]] = None,
        auth: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAwsAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        external_id: typing.Optional[builtins.str] = None,
        prefix: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        secrets_manager: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager", typing.Dict[builtins.str, typing.Any]]] = None,
        session_tags: typing.Optional[typing.Sequence[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags", typing.Dict[builtins.str, typing.Any]]]] = None,
        transitive_tag_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''AWS configures this store to sync secrets using AWS Secret Manager provider.

        :param region: AWS Region to be used for the provider.
        :param service: Service defines which service should be used to fetch the secrets.
        :param additional_roles: AdditionalRoles is a chained list of Role ARNs which the provider will sequentially assume before assuming the Role.
        :param auth: Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.
        :param external_id: AWS External ID set on assumed IAM roles.
        :param prefix: Prefix adds a prefix to all retrieved values.
        :param role: Role is a Role ARN which the provider will assume.
        :param secrets_manager: SecretsManager defines how the provider behaves when interacting with AWS SecretsManager.
        :param session_tags: AWS STS assume role session tags.
        :param transitive_tag_keys: AWS STS assume role transitive session tags. Required when multiple rules are used with the provider

        :schema: ClusterSecretStoreV1Beta1SpecProviderAws
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderAwsAuth(**auth)
        if isinstance(secrets_manager, dict):
            secrets_manager = ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager(**secrets_manager)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6627988073d9ff383a854cf295ddb2aa2cfe69af584935d6041de0fd6369c2f2)
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument additional_roles", value=additional_roles, expected_type=type_hints["additional_roles"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument external_id", value=external_id, expected_type=type_hints["external_id"])
            check_type(argname="argument prefix", value=prefix, expected_type=type_hints["prefix"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secrets_manager", value=secrets_manager, expected_type=type_hints["secrets_manager"])
            check_type(argname="argument session_tags", value=session_tags, expected_type=type_hints["session_tags"])
            check_type(argname="argument transitive_tag_keys", value=transitive_tag_keys, expected_type=type_hints["transitive_tag_keys"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "region": region,
            "service": service,
        }
        if additional_roles is not None:
            self._values["additional_roles"] = additional_roles
        if auth is not None:
            self._values["auth"] = auth
        if external_id is not None:
            self._values["external_id"] = external_id
        if prefix is not None:
            self._values["prefix"] = prefix
        if role is not None:
            self._values["role"] = role
        if secrets_manager is not None:
            self._values["secrets_manager"] = secrets_manager
        if session_tags is not None:
            self._values["session_tags"] = session_tags
        if transitive_tag_keys is not None:
            self._values["transitive_tag_keys"] = transitive_tag_keys

    @builtins.property
    def region(self) -> builtins.str:
        '''AWS Region to be used for the provider.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAws#region
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service(self) -> "ClusterSecretStoreV1Beta1SpecProviderAwsService":
        '''Service defines which service should be used to fetch the secrets.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAws#service
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderAwsService", result)

    @builtins.property
    def additional_roles(self) -> typing.Optional[typing.List[builtins.str]]:
        '''AdditionalRoles is a chained list of Role ARNs which the provider will sequentially assume before assuming the Role.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAws#additionalRoles
        '''
        result = self._values.get("additional_roles")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def auth(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuth"]:
        '''Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAws#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuth"], result)

    @builtins.property
    def external_id(self) -> typing.Optional[builtins.str]:
        '''AWS External ID set on assumed IAM roles.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAws#externalID
        '''
        result = self._values.get("external_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def prefix(self) -> typing.Optional[builtins.str]:
        '''Prefix adds a prefix to all retrieved values.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAws#prefix
        '''
        result = self._values.get("prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a Role ARN which the provider will assume.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAws#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secrets_manager(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager"]:
        '''SecretsManager defines how the provider behaves when interacting with AWS SecretsManager.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAws#secretsManager
        '''
        result = self._values.get("secrets_manager")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager"], result)

    @builtins.property
    def session_tags(
        self,
    ) -> typing.Optional[typing.List["ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags"]]:
        '''AWS STS assume role session tags.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAws#sessionTags
        '''
        result = self._values.get("session_tags")
        return typing.cast(typing.Optional[typing.List["ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags"]], result)

    @builtins.property
    def transitive_tag_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''AWS STS assume role transitive session tags.

        Required when multiple rules are used with the provider

        :schema: ClusterSecretStoreV1Beta1SpecProviderAws#transitiveTagKeys
        '''
        result = self._values.get("transitive_tag_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAws(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAwsAuth",
    jsii_struct_bases=[],
    name_mapping={"jwt": "jwt", "secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderAwsAuth:
    def __init__(
        self,
        *,
        jwt: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.

        :param jwt: Authenticate against AWS using service account tokens.
        :param secret_ref: AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuth
        '''
        if isinstance(jwt, dict):
            jwt = ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt(**jwt)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9edc5295784c46ee0e2ea751f45dd384e14e357e55ab66dbd253a053803e6150)
            check_type(argname="argument jwt", value=jwt, expected_type=type_hints["jwt"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if jwt is not None:
            self._values["jwt"] = jwt
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def jwt(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt"]:
        '''Authenticate against AWS using service account tokens.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuth#jwt
        '''
        result = self._values.get("jwt")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef"]:
        '''AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAwsAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt",
    jsii_struct_bases=[],
    name_mapping={"service_account_ref": "serviceAccountRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt:
    def __init__(
        self,
        *,
        service_account_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Authenticate against AWS using service account tokens.

        :param service_account_ref: A reference to a ServiceAccount resource.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9184e71a5ae0b63160a31c441f3e767c7e9fe4ccdeb7eb6d0313b1e446630e7c)
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef"]:
        '''A reference to a ServiceAccount resource.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__870111368203389e739228502d0d717a15cc9b15fa8225662b2e8b801afa6d57)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_key_id_secret_ref": "accessKeyIdSecretRef",
        "secret_access_key_secret_ref": "secretAccessKeySecretRef",
        "session_token_secret_ref": "sessionTokenSecretRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef:
    def __init__(
        self,
        *,
        access_key_id_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_access_key_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        session_token_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :param access_key_id_secret_ref: The AccessKeyID is used for authentication.
        :param secret_access_key_secret_ref: The SecretAccessKey is used for authentication.
        :param session_token_secret_ref: The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef
        '''
        if isinstance(access_key_id_secret_ref, dict):
            access_key_id_secret_ref = ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(**access_key_id_secret_ref)
        if isinstance(secret_access_key_secret_ref, dict):
            secret_access_key_secret_ref = ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(**secret_access_key_secret_ref)
        if isinstance(session_token_secret_ref, dict):
            session_token_secret_ref = ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef(**session_token_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e52b02bc80a06882a9b54890d7cfecec33b6ea34945389922ff0d8635877f5c5)
            check_type(argname="argument access_key_id_secret_ref", value=access_key_id_secret_ref, expected_type=type_hints["access_key_id_secret_ref"])
            check_type(argname="argument secret_access_key_secret_ref", value=secret_access_key_secret_ref, expected_type=type_hints["secret_access_key_secret_ref"])
            check_type(argname="argument session_token_secret_ref", value=session_token_secret_ref, expected_type=type_hints["session_token_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if access_key_id_secret_ref is not None:
            self._values["access_key_id_secret_ref"] = access_key_id_secret_ref
        if secret_access_key_secret_ref is not None:
            self._values["secret_access_key_secret_ref"] = secret_access_key_secret_ref
        if session_token_secret_ref is not None:
            self._values["session_token_secret_ref"] = session_token_secret_ref

    @builtins.property
    def access_key_id_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef"]:
        '''The AccessKeyID is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef#accessKeyIDSecretRef
        '''
        result = self._values.get("access_key_id_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef"], result)

    @builtins.property
    def secret_access_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef#secretAccessKeySecretRef
        '''
        result = self._values.get("secret_access_key_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef"], result)

    @builtins.property
    def session_token_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef"]:
        '''The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef#sessionTokenSecretRef
        '''
        result = self._values.get("session_token_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeyID is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ce640ed09fb68e1ec7ffae5b6f1bdeeb3b0254c8fe3a3a1ca738807848e9bef)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__594f5480cf09e605b57bbf933433bc689ecce1570797dbdf19a46e8f5ddf16c1)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3912a4e98840489edf6e5dfa8970de8ea9724ef8f4ceffd39602443613a6428e)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager",
    jsii_struct_bases=[],
    name_mapping={
        "force_delete_without_recovery": "forceDeleteWithoutRecovery",
        "recovery_window_in_days": "recoveryWindowInDays",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager:
    def __init__(
        self,
        *,
        force_delete_without_recovery: typing.Optional[builtins.bool] = None,
        recovery_window_in_days: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''SecretsManager defines how the provider behaves when interacting with AWS SecretsManager.

        :param force_delete_without_recovery: Specifies whether to delete the secret without any recovery window. You can't use both this parameter and RecoveryWindowInDays in the same call. If you don't use either, then by default Secrets Manager uses a 30 day recovery window. see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-ForceDeleteWithoutRecovery
        :param recovery_window_in_days: The number of days from 7 to 30 that Secrets Manager waits before permanently deleting the secret. You can't use both this parameter and ForceDeleteWithoutRecovery in the same call. If you don't use either, then by default Secrets Manager uses a 30 day recovery window. see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-RecoveryWindowInDays

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__48c5a27c67d8d807c1dae77d0c9163e10b98d1c6749b78b57aafbce00783830e)
            check_type(argname="argument force_delete_without_recovery", value=force_delete_without_recovery, expected_type=type_hints["force_delete_without_recovery"])
            check_type(argname="argument recovery_window_in_days", value=recovery_window_in_days, expected_type=type_hints["recovery_window_in_days"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if force_delete_without_recovery is not None:
            self._values["force_delete_without_recovery"] = force_delete_without_recovery
        if recovery_window_in_days is not None:
            self._values["recovery_window_in_days"] = recovery_window_in_days

    @builtins.property
    def force_delete_without_recovery(self) -> typing.Optional[builtins.bool]:
        '''Specifies whether to delete the secret without any recovery window.

        You
        can't use both this parameter and RecoveryWindowInDays in the same call.
        If you don't use either, then by default Secrets Manager uses a 30 day
        recovery window.
        see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-ForceDeleteWithoutRecovery

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager#forceDeleteWithoutRecovery
        '''
        result = self._values.get("force_delete_without_recovery")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def recovery_window_in_days(self) -> typing.Optional[jsii.Number]:
        '''The number of days from 7 to 30 that Secrets Manager waits before permanently deleting the secret.

        You can't use both this parameter and
        ForceDeleteWithoutRecovery in the same call. If you don't use either,
        then by default Secrets Manager uses a 30 day recovery window.
        see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-RecoveryWindowInDays

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager#recoveryWindowInDays
        '''
        result = self._values.get("recovery_window_in_days")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAwsService"
)
class ClusterSecretStoreV1Beta1SpecProviderAwsService(enum.Enum):
    '''Service defines which service should be used to fetch the secrets.

    :schema: ClusterSecretStoreV1Beta1SpecProviderAwsService
    '''

    SECRETS_MANAGER = "SECRETS_MANAGER"
    '''SecretsManager.'''
    PARAMETER_STORE = "PARAMETER_STORE"
    '''ParameterStore.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "value": "value"},
)
class ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags:
    def __init__(self, *, key: builtins.str, value: builtins.str) -> None:
        '''
        :param key: 
        :param value: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ca4d5f8d4561743bd341a8ef02e3fe43606734481120c4be650df99a50ee88ad)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "value": value,
        }

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAzurekv",
    jsii_struct_bases=[],
    name_mapping={
        "vault_url": "vaultUrl",
        "auth_secret_ref": "authSecretRef",
        "auth_type": "authType",
        "environment_type": "environmentType",
        "identity_id": "identityId",
        "service_account_ref": "serviceAccountRef",
        "tenant_id": "tenantId",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderAzurekv:
    def __init__(
        self,
        *,
        vault_url: builtins.str,
        auth_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        auth_type: typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType"] = None,
        environment_type: typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType"] = None,
        identity_id: typing.Optional[builtins.str] = None,
        service_account_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
        tenant_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AzureKV configures this store to sync secrets using Azure Key Vault provider.

        :param vault_url: Vault Url from which the secrets to be fetched from.
        :param auth_secret_ref: Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type. Optional for WorkloadIdentity.
        :param auth_type: Auth type defines how to authenticate to the keyvault service. Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
        :param environment_type: EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint. The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152 PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
        :param identity_id: If multiple Managed Identity is assigned to the pod, you can select the one to be used.
        :param service_account_ref: ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
        :param tenant_id: TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type. Optional for WorkloadIdentity.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekv
        '''
        if isinstance(auth_secret_ref, dict):
            auth_secret_ref = ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef(**auth_secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__abf7c19186023102b0e55132e0eeb8f816d43879e662f9fc61393882d66c7d54)
            check_type(argname="argument vault_url", value=vault_url, expected_type=type_hints["vault_url"])
            check_type(argname="argument auth_secret_ref", value=auth_secret_ref, expected_type=type_hints["auth_secret_ref"])
            check_type(argname="argument auth_type", value=auth_type, expected_type=type_hints["auth_type"])
            check_type(argname="argument environment_type", value=environment_type, expected_type=type_hints["environment_type"])
            check_type(argname="argument identity_id", value=identity_id, expected_type=type_hints["identity_id"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument tenant_id", value=tenant_id, expected_type=type_hints["tenant_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vault_url": vault_url,
        }
        if auth_secret_ref is not None:
            self._values["auth_secret_ref"] = auth_secret_ref
        if auth_type is not None:
            self._values["auth_type"] = auth_type
        if environment_type is not None:
            self._values["environment_type"] = environment_type
        if identity_id is not None:
            self._values["identity_id"] = identity_id
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref
        if tenant_id is not None:
            self._values["tenant_id"] = tenant_id

    @builtins.property
    def vault_url(self) -> builtins.str:
        '''Vault Url from which the secrets to be fetched from.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekv#vaultUrl
        '''
        result = self._values.get("vault_url")
        assert result is not None, "Required property 'vault_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef"]:
        '''Auth configures how the operator authenticates with Azure.

        Required for ServicePrincipal auth type. Optional for WorkloadIdentity.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekv#authSecretRef
        '''
        result = self._values.get("auth_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef"], result)

    @builtins.property
    def auth_type(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType"]:
        '''Auth type defines how to authenticate to the keyvault service.

        Valid values are:

        - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret)
        - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekv#authType
        '''
        result = self._values.get("auth_type")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType"], result)

    @builtins.property
    def environment_type(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType"]:
        '''EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure.

        By default it points to the public cloud AAD endpoint.
        The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152
        PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekv#environmentType
        '''
        result = self._values.get("environment_type")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType"], result)

    @builtins.property
    def identity_id(self) -> typing.Optional[builtins.str]:
        '''If multiple Managed Identity is assigned to the pod, you can select the one to be used.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekv#identityId
        '''
        result = self._values.get("identity_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef"]:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekv#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef"], result)

    @builtins.property
    def tenant_id(self) -> typing.Optional[builtins.str]:
        '''TenantID configures the Azure Tenant to send requests to.

        Required for ServicePrincipal auth type. Optional for WorkloadIdentity.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekv#tenantId
        '''
        result = self._values.get("tenant_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAzurekv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "client_certificate": "clientCertificate",
        "client_id": "clientId",
        "client_secret": "clientSecret",
        "tenant_id": "tenantId",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef:
    def __init__(
        self,
        *,
        client_certificate: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate", typing.Dict[builtins.str, typing.Any]]] = None,
        client_id: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId", typing.Dict[builtins.str, typing.Any]]] = None,
        client_secret: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret", typing.Dict[builtins.str, typing.Any]]] = None,
        tenant_id: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how the operator authenticates with Azure.

        Required for ServicePrincipal auth type. Optional for WorkloadIdentity.

        :param client_certificate: The Azure ClientCertificate of the service principle used for authentication.
        :param client_id: The Azure clientId of the service principle or managed identity used for authentication.
        :param client_secret: The Azure ClientSecret of the service principle used for authentication.
        :param tenant_id: The Azure tenantId of the managed identity used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef
        '''
        if isinstance(client_certificate, dict):
            client_certificate = ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate(**client_certificate)
        if isinstance(client_id, dict):
            client_id = ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId(**client_id)
        if isinstance(client_secret, dict):
            client_secret = ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret(**client_secret)
        if isinstance(tenant_id, dict):
            tenant_id = ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId(**tenant_id)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5b5c6576dd0bcff847eb542793197cccaed967a7895b6800a3297ababb2258a6)
            check_type(argname="argument client_certificate", value=client_certificate, expected_type=type_hints["client_certificate"])
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret", value=client_secret, expected_type=type_hints["client_secret"])
            check_type(argname="argument tenant_id", value=tenant_id, expected_type=type_hints["tenant_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if client_certificate is not None:
            self._values["client_certificate"] = client_certificate
        if client_id is not None:
            self._values["client_id"] = client_id
        if client_secret is not None:
            self._values["client_secret"] = client_secret
        if tenant_id is not None:
            self._values["tenant_id"] = tenant_id

    @builtins.property
    def client_certificate(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate"]:
        '''The Azure ClientCertificate of the service principle used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientCertificate
        '''
        result = self._values.get("client_certificate")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate"], result)

    @builtins.property
    def client_id(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId"]:
        '''The Azure clientId of the service principle or managed identity used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientId
        '''
        result = self._values.get("client_id")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId"], result)

    @builtins.property
    def client_secret(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret"]:
        '''The Azure ClientSecret of the service principle used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientSecret
        '''
        result = self._values.get("client_secret")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret"], result)

    @builtins.property
    def tenant_id(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId"]:
        '''The Azure tenantId of the managed identity used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#tenantId
        '''
        result = self._values.get("tenant_id")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Azure ClientCertificate of the service principle used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a020b2caecfdbe5ac6df9941e14be21d70df6d9ac4b30816931e54e3377ba0fd)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Azure clientId of the service principle or managed identity used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c666df2b9f723e3fa73884c25af477951655f8afbb53d585a2431dff1d9219de)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Azure ClientSecret of the service principle used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__00f7e356b48005cce89b72ead3be30d457b3e32c2e5bcf50f43bdf1678d0c242)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Azure tenantId of the managed identity used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e4429b736687abdfd285a8c1cb74d70991015d3ce65c34dc4a97d594505bd73c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType"
)
class ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType(enum.Enum):
    '''Auth type defines how to authenticate to the keyvault service.

    Valid values are:

    - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret)
    - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)

    :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType
    '''

    SERVICE_PRINCIPAL = "SERVICE_PRINCIPAL"
    '''ServicePrincipal.'''
    MANAGED_IDENTITY = "MANAGED_IDENTITY"
    '''ManagedIdentity.'''
    WORKLOAD_IDENTITY = "WORKLOAD_IDENTITY"
    '''WorkloadIdentity.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType"
)
class ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType(enum.Enum):
    '''EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure.

    By default it points to the public cloud AAD endpoint.
    The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152
    PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud

    :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType
    '''

    PUBLIC_CLOUD = "PUBLIC_CLOUD"
    '''PublicCloud.'''
    US_GOVERNMENT_CLOUD = "US_GOVERNMENT_CLOUD"
    '''USGovernmentCloud.'''
    CHINA_CLOUD = "CHINA_CLOUD"
    '''ChinaCloud.'''
    GERMAN_CLOUD = "GERMAN_CLOUD"
    '''GermanCloud.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__99524d6c465621fc67233b99280c814ee97e0c6e2aaad7b7fb19183628a5f5f4)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderBeyondtrust",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "server": "server"},
)
class ClusterSecretStoreV1Beta1SpecProviderBeyondtrust:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth", typing.Dict[builtins.str, typing.Any]],
        server: typing.Union["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Beyondtrust configures this store to sync secrets using Password Safe provider.

        :param auth: Auth configures how the operator authenticates with Beyondtrust.
        :param server: Auth configures how API server works.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrust
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth(**auth)
        if isinstance(server, dict):
            server = ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer(**server)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d644083390ae86be080b7b78b4a9c7b7aa264b442a65dbf9a388d197bc165a1d)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "server": server,
        }

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth":
        '''Auth configures how the operator authenticates with Beyondtrust.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrust#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth", result)

    @builtins.property
    def server(self) -> "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer":
        '''Auth configures how API server works.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrust#server
        '''
        result = self._values.get("server")
        assert result is not None, "Required property 'server' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderBeyondtrust(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth",
    jsii_struct_bases=[],
    name_mapping={
        "api_key": "apiKey",
        "certificate": "certificate",
        "certificate_key": "certificateKey",
        "client_id": "clientId",
        "client_secret": "clientSecret",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth:
    def __init__(
        self,
        *,
        api_key: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey", typing.Dict[builtins.str, typing.Any]]] = None,
        certificate: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate", typing.Dict[builtins.str, typing.Any]]] = None,
        certificate_key: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey", typing.Dict[builtins.str, typing.Any]]] = None,
        client_id: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId", typing.Dict[builtins.str, typing.Any]]] = None,
        client_secret: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how the operator authenticates with Beyondtrust.

        :param api_key: APIKey If not provided then ClientID/ClientSecret become required.
        :param certificate: Certificate (cert.pem) for use when authenticating with an OAuth client Id using a Client Certificate.
        :param certificate_key: Certificate private key (key.pem). For use when authenticating with an OAuth client Id.
        :param client_id: ClientID is the API OAuth Client ID.
        :param client_secret: ClientSecret is the API OAuth Client Secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth
        '''
        if isinstance(api_key, dict):
            api_key = ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey(**api_key)
        if isinstance(certificate, dict):
            certificate = ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate(**certificate)
        if isinstance(certificate_key, dict):
            certificate_key = ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey(**certificate_key)
        if isinstance(client_id, dict):
            client_id = ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId(**client_id)
        if isinstance(client_secret, dict):
            client_secret = ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret(**client_secret)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__633161e913a2859366f023110b06233f7cf1844be7aef44152fa242ca4621b09)
            check_type(argname="argument api_key", value=api_key, expected_type=type_hints["api_key"])
            check_type(argname="argument certificate", value=certificate, expected_type=type_hints["certificate"])
            check_type(argname="argument certificate_key", value=certificate_key, expected_type=type_hints["certificate_key"])
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret", value=client_secret, expected_type=type_hints["client_secret"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if api_key is not None:
            self._values["api_key"] = api_key
        if certificate is not None:
            self._values["certificate"] = certificate
        if certificate_key is not None:
            self._values["certificate_key"] = certificate_key
        if client_id is not None:
            self._values["client_id"] = client_id
        if client_secret is not None:
            self._values["client_secret"] = client_secret

    @builtins.property
    def api_key(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey"]:
        '''APIKey If not provided then ClientID/ClientSecret become required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth#apiKey
        '''
        result = self._values.get("api_key")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey"], result)

    @builtins.property
    def certificate(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate"]:
        '''Certificate (cert.pem) for use when authenticating with an OAuth client Id using a Client Certificate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth#certificate
        '''
        result = self._values.get("certificate")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate"], result)

    @builtins.property
    def certificate_key(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey"]:
        '''Certificate private key (key.pem). For use when authenticating with an OAuth client Id.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth#certificateKey
        '''
        result = self._values.get("certificate_key")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey"], result)

    @builtins.property
    def client_id(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId"]:
        '''ClientID is the API OAuth Client ID.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth#clientId
        '''
        result = self._values.get("client_id")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId"], result)

    @builtins.property
    def client_secret(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret"]:
        '''ClientSecret is the API OAuth Client Secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth#clientSecret
        '''
        result = self._values.get("client_secret")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''APIKey If not provided then ClientID/ClientSecret become required.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8d9d7143675bb5d0e9087d8f6f37cccc9cc6c95a6f1574de2d135f9b1463497c)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__948205cc7184f02cd4534675d47617eefccf3104d8165f307f28740db0defffd)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Certificate (cert.pem) for use when authenticating with an OAuth client Id using a Client Certificate.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__975e1de3279673de7785d9b68c3942b01752e64b62905ea701ddb2b6f2739f32)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Certificate private key (key.pem). For use when authenticating with an OAuth client Id.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f06f99a6a008040c5d148cb69c449b9d369d6e1ba95b780c3bc7a917970520f2)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee54b4a14c99f657cd27156f8aaa80f6c3cb0fb5db165fa6e6119b372c477ccf)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f3912a938c200533a74da924ad1dc5e0f108fdb412a0772177bd1e4c2cef79ae)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ClientID is the API OAuth Client ID.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9cd2d63679cfab15fe0a2bf8c273bc3355d8307c4c83345cca4ca88d305c3366)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c8e080233c8166cea6abb12bd265800513cbfafc45139268edd115e69544e72)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ClientSecret is the API OAuth Client Secret.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f9061130cc3bab5ac590ef17e5a1fd14e83b348557933868a465db939ea4706)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__82d267d257ce408851b390ddef2f738c01183df9901d1ffd9b84c1236c4b46d4)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer",
    jsii_struct_bases=[],
    name_mapping={
        "api_url": "apiUrl",
        "verify_ca": "verifyCa",
        "client_time_out_seconds": "clientTimeOutSeconds",
        "retrieval_type": "retrievalType",
        "separator": "separator",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer:
    def __init__(
        self,
        *,
        api_url: builtins.str,
        verify_ca: builtins.bool,
        client_time_out_seconds: typing.Optional[jsii.Number] = None,
        retrieval_type: typing.Optional[builtins.str] = None,
        separator: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Auth configures how API server works.

        :param api_url: 
        :param verify_ca: 
        :param client_time_out_seconds: Timeout specifies a time limit for requests made by this Client. The timeout includes connection time, any redirects, and reading the response body. Defaults to 45 seconds. Default: 45 seconds.
        :param retrieval_type: The secret retrieval type. SECRET = Secrets Safe (credential, text, file). MANAGED_ACCOUNT = Password Safe account associated with a system.
        :param separator: A character that separates the folder names.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4baad16e8885afc816e35320219242f427726fad7c713c13199df71c35bdef69)
            check_type(argname="argument api_url", value=api_url, expected_type=type_hints["api_url"])
            check_type(argname="argument verify_ca", value=verify_ca, expected_type=type_hints["verify_ca"])
            check_type(argname="argument client_time_out_seconds", value=client_time_out_seconds, expected_type=type_hints["client_time_out_seconds"])
            check_type(argname="argument retrieval_type", value=retrieval_type, expected_type=type_hints["retrieval_type"])
            check_type(argname="argument separator", value=separator, expected_type=type_hints["separator"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api_url": api_url,
            "verify_ca": verify_ca,
        }
        if client_time_out_seconds is not None:
            self._values["client_time_out_seconds"] = client_time_out_seconds
        if retrieval_type is not None:
            self._values["retrieval_type"] = retrieval_type
        if separator is not None:
            self._values["separator"] = separator

    @builtins.property
    def api_url(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer#apiUrl
        '''
        result = self._values.get("api_url")
        assert result is not None, "Required property 'api_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def verify_ca(self) -> builtins.bool:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer#verifyCA
        '''
        result = self._values.get("verify_ca")
        assert result is not None, "Required property 'verify_ca' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def client_time_out_seconds(self) -> typing.Optional[jsii.Number]:
        '''Timeout specifies a time limit for requests made by this Client.

        The timeout includes connection time, any redirects, and reading the response body. Defaults to 45 seconds.

        :default: 45 seconds.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer#clientTimeOutSeconds
        '''
        result = self._values.get("client_time_out_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def retrieval_type(self) -> typing.Optional[builtins.str]:
        '''The secret retrieval type.

        SECRET = Secrets Safe (credential, text, file). MANAGED_ACCOUNT = Password Safe account associated with a system.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer#retrievalType
        '''
        result = self._values.get("retrieval_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def separator(self) -> typing.Optional[builtins.str]:
        '''A character that separates the folder names.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer#separator
        '''
        result = self._values.get("separator")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "organization_id": "organizationId",
        "project_id": "projectId",
        "api_url": "apiUrl",
        "bitwarden_server_sdkurl": "bitwardenServerSdkurl",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
        "identity_url": "identityUrl",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth", typing.Dict[builtins.str, typing.Any]],
        organization_id: builtins.str,
        project_id: builtins.str,
        api_url: typing.Optional[builtins.str] = None,
        bitwarden_server_sdkurl: typing.Optional[builtins.str] = None,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
        identity_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''BitwardenSecretsManager configures this store to sync secrets using BitwardenSecretsManager provider.

        :param auth: Auth configures how secret-manager authenticates with a bitwarden machine account instance. Make sure that the token being used has permissions on the given secret.
        :param organization_id: OrganizationID determines which organization this secret store manages.
        :param project_id: ProjectID determines which project this secret store manages.
        :param api_url: 
        :param bitwarden_server_sdkurl: 
        :param ca_bundle: Base64 encoded certificate for the bitwarden server sdk. The sdk MUST run with HTTPS to make sure no MITM attack can be performed.
        :param ca_provider: see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider.
        :param identity_url: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b07a083bd35c1b15a717d8b98648c746372913d80ab988028269e75bcde9c07d)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument organization_id", value=organization_id, expected_type=type_hints["organization_id"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
            check_type(argname="argument api_url", value=api_url, expected_type=type_hints["api_url"])
            check_type(argname="argument bitwarden_server_sdkurl", value=bitwarden_server_sdkurl, expected_type=type_hints["bitwarden_server_sdkurl"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument identity_url", value=identity_url, expected_type=type_hints["identity_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "organization_id": organization_id,
            "project_id": project_id,
        }
        if api_url is not None:
            self._values["api_url"] = api_url
        if bitwarden_server_sdkurl is not None:
            self._values["bitwarden_server_sdkurl"] = bitwarden_server_sdkurl
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if identity_url is not None:
            self._values["identity_url"] = identity_url

    @builtins.property
    def auth(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth":
        '''Auth configures how secret-manager authenticates with a bitwarden machine account instance.

        Make sure that the token being used has permissions on the given secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth", result)

    @builtins.property
    def organization_id(self) -> builtins.str:
        '''OrganizationID determines which organization this secret store manages.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager#organizationID
        '''
        result = self._values.get("organization_id")
        assert result is not None, "Required property 'organization_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def project_id(self) -> builtins.str:
        '''ProjectID determines which project this secret store manages.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager#projectID
        '''
        result = self._values.get("project_id")
        assert result is not None, "Required property 'project_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_url(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager#apiURL
        '''
        result = self._values.get("api_url")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def bitwarden_server_sdkurl(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager#bitwardenServerSDKURL
        '''
        result = self._values.get("bitwarden_server_sdkurl")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''Base64 encoded certificate for the bitwarden server sdk.

        The sdk MUST run with HTTPS to make sure no MITM attack
        can be performed.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider"]:
        '''see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider"], result)

    @builtins.property
    def identity_url(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager#identityURL
        '''
        result = self._values.get("identity_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth configures how secret-manager authenticates with a bitwarden machine account instance.

        Make sure that the token being used has permissions on the given secret.

        :param secret_ref: BitwardenSecretsManagerSecretRef contains the credential ref to the bitwarden instance.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd4378a13039dccc79aeba3872fc79064498fda4999957b79a3f7a9a484e2f69)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef":
        '''BitwardenSecretsManagerSecretRef contains the credential ref to the bitwarden instance.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"credentials": "credentials"},
)
class ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef:
    def __init__(
        self,
        *,
        credentials: typing.Union["ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''BitwardenSecretsManagerSecretRef contains the credential ref to the bitwarden instance.

        :param credentials: AccessToken used for the bitwarden instance.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef
        '''
        if isinstance(credentials, dict):
            credentials = ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials(**credentials)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__52c242f39cff7fd6216a580f410e51eddafe9b1f9fb8c18c493093360a6fd2dd)
            check_type(argname="argument credentials", value=credentials, expected_type=type_hints["credentials"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "credentials": credentials,
        }

    @builtins.property
    def credentials(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials":
        '''AccessToken used for the bitwarden instance.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef#credentials
        '''
        result = self._values.get("credentials")
        assert result is not None, "Required property 'credentials' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AccessToken used for the bitwarden instance.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aa7d0e432a84d9e3f26b069e720b2909ccee1af438a93f280763dee4e58436e7)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a7cc5cae6f2ee50679b7aee052961c0b79b936ec2ce85c4cb7d8b7b081a102ac)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        Can only be defined when used in a ClusterSecretStore.

        :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType"
)
class ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType(
    enum.Enum,
):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderChef",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "server_url": "serverUrl", "username": "username"},
)
class ClusterSecretStoreV1Beta1SpecProviderChef:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderChefAuth", typing.Dict[builtins.str, typing.Any]],
        server_url: builtins.str,
        username: builtins.str,
    ) -> None:
        '''Chef configures this store to sync secrets with chef server.

        :param auth: Auth defines the information necessary to authenticate against chef Server.
        :param server_url: ServerURL is the chef server URL used to connect to. If using orgs you should include your org in the url and terminate the url with a "/"
        :param username: UserName should be the user ID on the chef server.

        :schema: ClusterSecretStoreV1Beta1SpecProviderChef
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderChefAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__88acac78c56cdf7d7b25b35249fe8c901d534be93b0484bde9c8d649b70de553)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument server_url", value=server_url, expected_type=type_hints["server_url"])
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "server_url": server_url,
            "username": username,
        }

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderChefAuth":
        '''Auth defines the information necessary to authenticate against chef Server.

        :schema: ClusterSecretStoreV1Beta1SpecProviderChef#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderChefAuth", result)

    @builtins.property
    def server_url(self) -> builtins.str:
        '''ServerURL is the chef server URL used to connect to.

        If using orgs you should include your org in the url and terminate the url with a "/"

        :schema: ClusterSecretStoreV1Beta1SpecProviderChef#serverUrl
        '''
        result = self._values.get("server_url")
        assert result is not None, "Required property 'server_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def username(self) -> builtins.str:
        '''UserName should be the user ID on the chef server.

        :schema: ClusterSecretStoreV1Beta1SpecProviderChef#username
        '''
        result = self._values.get("username")
        assert result is not None, "Required property 'username' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderChef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderChefAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderChefAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth defines the information necessary to authenticate against chef Server.

        :param secret_ref: ChefAuthSecretRef holds secret references for chef server login credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderChefAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b37a2cbd8da0cdf523622a0f633b0d18512951980846f004df6a950b8d7942b8)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRef":
        '''ChefAuthSecretRef holds secret references for chef server login credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderChefAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderChefAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"private_key_secret_ref": "privateKeySecretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRef:
    def __init__(
        self,
        *,
        private_key_secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''ChefAuthSecretRef holds secret references for chef server login credentials.

        :param private_key_secret_ref: SecretKey is the Signing Key in PEM format, used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRef
        '''
        if isinstance(private_key_secret_ref, dict):
            private_key_secret_ref = ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef(**private_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f25b6de66eaab11b8c4daae7eec60aebf678febadf1761328a10c1b73ed2feaa)
            check_type(argname="argument private_key_secret_ref", value=private_key_secret_ref, expected_type=type_hints["private_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "private_key_secret_ref": private_key_secret_ref,
        }

    @builtins.property
    def private_key_secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef":
        '''SecretKey is the Signing Key in PEM format, used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRef#privateKeySecretRef
        '''
        result = self._values.get("private_key_secret_ref")
        assert result is not None, "Required property 'private_key_secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretKey is the Signing Key in PEM format, used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83670b4c46a4338b8b67fec9e6cc81a8b7c03be59f98d76ae4db7578f48def37)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderConjur",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "url": "url",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderConjur:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderConjurAuth", typing.Dict[builtins.str, typing.Any]],
        url: builtins.str,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Conjur configures this store to sync secrets using conjur provider.

        :param auth: 
        :param url: 
        :param ca_bundle: 
        :param ca_provider: Used to provide custom certificate authority (CA) certificates for a secret store. The CAProvider points to a Secret or ConfigMap resource that contains a PEM-encoded certificate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjur
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderConjurAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd13f006bb522b34918dd83f7d4520b4c3e8918fa9caea1a889a5fcb2c0b858a)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "url": url,
        }
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderConjurAuth":
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderConjur#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderConjurAuth", result)

    @builtins.property
    def url(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderConjur#url
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderConjur#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider"]:
        '''Used to provide custom certificate authority (CA) certificates for a secret store.

        The CAProvider points to a Secret or ConfigMap resource
        that contains a PEM-encoded certificate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjur#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderConjur(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderConjurAuth",
    jsii_struct_bases=[],
    name_mapping={"apikey": "apikey", "jwt": "jwt"},
)
class ClusterSecretStoreV1Beta1SpecProviderConjurAuth:
    def __init__(
        self,
        *,
        apikey: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey", typing.Dict[builtins.str, typing.Any]]] = None,
        jwt: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param apikey: 
        :param jwt: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuth
        '''
        if isinstance(apikey, dict):
            apikey = ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey(**apikey)
        if isinstance(jwt, dict):
            jwt = ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt(**jwt)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4d3a7eca64b061adc53eed42df575bd0efc70846535a2435a0368c7b48c0eff1)
            check_type(argname="argument apikey", value=apikey, expected_type=type_hints["apikey"])
            check_type(argname="argument jwt", value=jwt, expected_type=type_hints["jwt"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if apikey is not None:
            self._values["apikey"] = apikey
        if jwt is not None:
            self._values["jwt"] = jwt

    @builtins.property
    def apikey(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey"]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuth#apikey
        '''
        result = self._values.get("apikey")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey"], result)

    @builtins.property
    def jwt(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt"]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuth#jwt
        '''
        result = self._values.get("jwt")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderConjurAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey",
    jsii_struct_bases=[],
    name_mapping={
        "account": "account",
        "api_key_ref": "apiKeyRef",
        "user_ref": "userRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey:
    def __init__(
        self,
        *,
        account: builtins.str,
        api_key_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef", typing.Dict[builtins.str, typing.Any]],
        user_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param account: 
        :param api_key_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param user_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey
        '''
        if isinstance(api_key_ref, dict):
            api_key_ref = ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef(**api_key_ref)
        if isinstance(user_ref, dict):
            user_ref = ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef(**user_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__38e11fae4b238e011d9b6fee89fbbae87134a2791c0867754810c1c576f12b1b)
            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
            check_type(argname="argument api_key_ref", value=api_key_ref, expected_type=type_hints["api_key_ref"])
            check_type(argname="argument user_ref", value=user_ref, expected_type=type_hints["user_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "account": account,
            "api_key_ref": api_key_ref,
            "user_ref": user_ref,
        }

    @builtins.property
    def account(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey#account
        '''
        result = self._values.get("account")
        assert result is not None, "Required property 'account' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_key_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey#apiKeyRef
        '''
        result = self._values.get("api_key_ref")
        assert result is not None, "Required property 'api_key_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef", result)

    @builtins.property
    def user_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey#userRef
        '''
        result = self._values.get("user_ref")
        assert result is not None, "Required property 'user_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83ce4c1e32adde35b044f533d42f205da4eea6cf33cc0897f609eb92e7ef6d1a)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c532b61284b3c9f148319362b064408e397299e4acc7f3b5161bd2c953ce1d3)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt",
    jsii_struct_bases=[],
    name_mapping={
        "account": "account",
        "service_id": "serviceId",
        "host_id": "hostId",
        "secret_ref": "secretRef",
        "service_account_ref": "serviceAccountRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt:
    def __init__(
        self,
        *,
        account: builtins.str,
        service_id: builtins.str,
        host_id: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param account: 
        :param service_id: The conjur authn jwt webservice id.
        :param host_id: Optional HostID for JWT authentication. This may be used depending on how the Conjur JWT authenticator policy is configured.
        :param secret_ref: Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Conjur using the JWT authentication method.
        :param service_account_ref: Optional ServiceAccountRef specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef(**secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__52b0f350eacc0c9b57a1b6713a56af5acafeba5eba98459f04a1fe98b1f41edb)
            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
            check_type(argname="argument service_id", value=service_id, expected_type=type_hints["service_id"])
            check_type(argname="argument host_id", value=host_id, expected_type=type_hints["host_id"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "account": account,
            "service_id": service_id,
        }
        if host_id is not None:
            self._values["host_id"] = host_id
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def account(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt#account
        '''
        result = self._values.get("account")
        assert result is not None, "Required property 'account' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service_id(self) -> builtins.str:
        '''The conjur authn jwt webservice id.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt#serviceID
        '''
        result = self._values.get("service_id")
        assert result is not None, "Required property 'service_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def host_id(self) -> typing.Optional[builtins.str]:
        '''Optional HostID for JWT authentication.

        This may be used depending
        on how the Conjur JWT authenticator policy is configured.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt#hostId
        '''
        result = self._values.get("host_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef"]:
        '''Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Conjur using the JWT authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef"]:
        '''Optional ServiceAccountRef specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Conjur using the JWT authentication method.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2477a088fdf273a37514328ebdad8069af4b5f06af6d86c3cb8020519cd3c403)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional ServiceAccountRef specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da5e48d7b0634d1d4a4d79c54da3733a03b4bef7c946793c4591d0a9a5b6ee8d)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "ClusterSecretStoreV1Beta1SpecProviderConjurCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Used to provide custom certificate authority (CA) certificates for a secret store.

        The CAProvider points to a Secret or ConfigMap resource
        that contains a PEM-encoded certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1347e7dc64bf4b13a7b4244986cd88a94b1dc46cc1f507df56bb3d0e3a2e2ce1)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "ClusterSecretStoreV1Beta1SpecProviderConjurCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderConjurCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        Can only be defined when used in a ClusterSecretStore.

        :schema: ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderConjurCaProviderType"
)
class ClusterSecretStoreV1Beta1SpecProviderConjurCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: ClusterSecretStoreV1Beta1SpecProviderConjurCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDelinea",
    jsii_struct_bases=[],
    name_mapping={
        "client_id": "clientId",
        "client_secret": "clientSecret",
        "tenant": "tenant",
        "tld": "tld",
        "url_template": "urlTemplate",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderDelinea:
    def __init__(
        self,
        *,
        client_id: typing.Union["ClusterSecretStoreV1Beta1SpecProviderDelineaClientId", typing.Dict[builtins.str, typing.Any]],
        client_secret: typing.Union["ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret", typing.Dict[builtins.str, typing.Any]],
        tenant: builtins.str,
        tld: typing.Optional[builtins.str] = None,
        url_template: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Delinea DevOps Secrets Vault https://docs.delinea.com/online-help/products/devops-secrets-vault/current.

        :param client_id: ClientID is the non-secret part of the credential.
        :param client_secret: ClientSecret is the secret part of the credential.
        :param tenant: Tenant is the chosen hostname / site name.
        :param tld: TLD is based on the server location that was chosen during provisioning. If unset, defaults to "com".
        :param url_template: URLTemplate If unset, defaults to "https://%s.secretsvaultcloud.%s/v1/%s%s".

        :schema: ClusterSecretStoreV1Beta1SpecProviderDelinea
        '''
        if isinstance(client_id, dict):
            client_id = ClusterSecretStoreV1Beta1SpecProviderDelineaClientId(**client_id)
        if isinstance(client_secret, dict):
            client_secret = ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret(**client_secret)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c9c22fd860711f10bf88c00390f6e46f0802ca37379946c521d4e9ebeb7cc7e)
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret", value=client_secret, expected_type=type_hints["client_secret"])
            check_type(argname="argument tenant", value=tenant, expected_type=type_hints["tenant"])
            check_type(argname="argument tld", value=tld, expected_type=type_hints["tld"])
            check_type(argname="argument url_template", value=url_template, expected_type=type_hints["url_template"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "client_id": client_id,
            "client_secret": client_secret,
            "tenant": tenant,
        }
        if tld is not None:
            self._values["tld"] = tld
        if url_template is not None:
            self._values["url_template"] = url_template

    @builtins.property
    def client_id(self) -> "ClusterSecretStoreV1Beta1SpecProviderDelineaClientId":
        '''ClientID is the non-secret part of the credential.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDelinea#clientId
        '''
        result = self._values.get("client_id")
        assert result is not None, "Required property 'client_id' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderDelineaClientId", result)

    @builtins.property
    def client_secret(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret":
        '''ClientSecret is the secret part of the credential.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDelinea#clientSecret
        '''
        result = self._values.get("client_secret")
        assert result is not None, "Required property 'client_secret' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret", result)

    @builtins.property
    def tenant(self) -> builtins.str:
        '''Tenant is the chosen hostname / site name.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDelinea#tenant
        '''
        result = self._values.get("tenant")
        assert result is not None, "Required property 'tenant' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tld(self) -> typing.Optional[builtins.str]:
        '''TLD is based on the server location that was chosen during provisioning.

        If unset, defaults to "com".

        :schema: ClusterSecretStoreV1Beta1SpecProviderDelinea#tld
        '''
        result = self._values.get("tld")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def url_template(self) -> typing.Optional[builtins.str]:
        '''URLTemplate If unset, defaults to "https://%s.secretsvaultcloud.%s/v1/%s%s".

        :schema: ClusterSecretStoreV1Beta1SpecProviderDelinea#urlTemplate
        '''
        result = self._values.get("url_template")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderDelinea(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDelineaClientId",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class ClusterSecretStoreV1Beta1SpecProviderDelineaClientId:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ClientID is the non-secret part of the credential.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDelineaClientId
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2ea7aae16245ad8cf9caf1186fa7177409c930575e68754a2252261c057c1ffa)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDelineaClientId#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDelineaClientId#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderDelineaClientId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9201b74bb763bb0bc6023542238fd42abe759b34ac2a2ec1d6310851edf2637)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ClientSecret is the secret part of the credential.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__66414b93ae21bb01c7e9b3c1db5dd435ea5fe139479f594cdc500ffa568fc722)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5908b4bc02092249d33dbcadae84f4a7d842359ffb9c4c89101a5b1f32935fc)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDevice42",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "host": "host"},
)
class ClusterSecretStoreV1Beta1SpecProviderDevice42:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderDevice42Auth", typing.Dict[builtins.str, typing.Any]],
        host: builtins.str,
    ) -> None:
        '''Device42 configures this store to sync secrets using the Device42 provider.

        :param auth: Auth configures how secret-manager authenticates with a Device42 instance.
        :param host: URL configures the Device42 instance URL.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDevice42
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderDevice42Auth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__732c32bec4317884277fa27eabf3d3de36118bbcdb3dfc58168326549400f0e0)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "host": host,
        }

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderDevice42Auth":
        '''Auth configures how secret-manager authenticates with a Device42 instance.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDevice42#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderDevice42Auth", result)

    @builtins.property
    def host(self) -> builtins.str:
        '''URL configures the Device42 instance URL.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDevice42#host
        '''
        result = self._values.get("host")
        assert result is not None, "Required property 'host' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderDevice42(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDevice42Auth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderDevice42Auth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth configures how secret-manager authenticates with a Device42 instance.

        :param secret_ref: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderDevice42Auth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a90242fb595b2168fa71b2d5cac81e56e8e5e75d8e8b81e5bfd3c11e5d47ce14)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRef":
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderDevice42Auth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderDevice42Auth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"credentials": "credentials"},
)
class ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRef:
    def __init__(
        self,
        *,
        credentials: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param credentials: Username / Password is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRef
        '''
        if isinstance(credentials, dict):
            credentials = ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials(**credentials)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__102e02c8a6c4f30acb49b5df90d4a0ed5d0a516908e54ac6bd941a1593776dab)
            check_type(argname="argument credentials", value=credentials, expected_type=type_hints["credentials"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if credentials is not None:
            self._values["credentials"] = credentials

    @builtins.property
    def credentials(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials"]:
        '''Username / Password is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRef#credentials
        '''
        result = self._values.get("credentials")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Username / Password is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cc60ef3c6f35b0553d188d1313416883a1f7116bc7a1b565ded5cd69652a0ecd)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDoppler",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "config": "config",
        "format": "format",
        "name_transformer": "nameTransformer",
        "project": "project",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderDoppler:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderDopplerAuth", typing.Dict[builtins.str, typing.Any]],
        config: typing.Optional[builtins.str] = None,
        format: typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDopplerFormat"] = None,
        name_transformer: typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer"] = None,
        project: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Doppler configures this store to sync secrets using the Doppler provider.

        :param auth: Auth configures how the Operator authenticates with the Doppler API.
        :param config: Doppler config (required if not using a Service Token).
        :param format: Format enables the downloading of secrets as a file (string).
        :param name_transformer: Environment variable compatible name transforms that change secret names to a different format.
        :param project: Doppler project (required if not using a Service Token).

        :schema: ClusterSecretStoreV1Beta1SpecProviderDoppler
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderDopplerAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d8dabb978cd9c207e6c33f6b87227d8fceb1a850813a315b0fb3daf464977a0e)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument config", value=config, expected_type=type_hints["config"])
            check_type(argname="argument format", value=format, expected_type=type_hints["format"])
            check_type(argname="argument name_transformer", value=name_transformer, expected_type=type_hints["name_transformer"])
            check_type(argname="argument project", value=project, expected_type=type_hints["project"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
        }
        if config is not None:
            self._values["config"] = config
        if format is not None:
            self._values["format"] = format
        if name_transformer is not None:
            self._values["name_transformer"] = name_transformer
        if project is not None:
            self._values["project"] = project

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderDopplerAuth":
        '''Auth configures how the Operator authenticates with the Doppler API.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDoppler#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderDopplerAuth", result)

    @builtins.property
    def config(self) -> typing.Optional[builtins.str]:
        '''Doppler config (required if not using a Service Token).

        :schema: ClusterSecretStoreV1Beta1SpecProviderDoppler#config
        '''
        result = self._values.get("config")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def format(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDopplerFormat"]:
        '''Format enables the downloading of secrets as a file (string).

        :schema: ClusterSecretStoreV1Beta1SpecProviderDoppler#format
        '''
        result = self._values.get("format")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDopplerFormat"], result)

    @builtins.property
    def name_transformer(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer"]:
        '''Environment variable compatible name transforms that change secret names to a different format.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDoppler#nameTransformer
        '''
        result = self._values.get("name_transformer")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer"], result)

    @builtins.property
    def project(self) -> typing.Optional[builtins.str]:
        '''Doppler project (required if not using a Service Token).

        :schema: ClusterSecretStoreV1Beta1SpecProviderDoppler#project
        '''
        result = self._values.get("project")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderDoppler(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDopplerAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderDopplerAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth configures how the Operator authenticates with the Doppler API.

        :param secret_ref: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderDopplerAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__562144337f6c00cb855087476ff46a1b6075c3696089e7f7cb03e95e120c00bf)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef":
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderDopplerAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderDopplerAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"doppler_token": "dopplerToken"},
)
class ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef:
    def __init__(
        self,
        *,
        doppler_token: typing.Union["ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param doppler_token: The DopplerToken is used for authentication. See https://docs.doppler.com/reference/api#authentication for auth token types. The Key attribute defaults to dopplerToken if not specified.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef
        '''
        if isinstance(doppler_token, dict):
            doppler_token = ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken(**doppler_token)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__00f6e9b3449566bea57b329f0ae730c49bd1c1c616b069d52c0775f572e041b5)
            check_type(argname="argument doppler_token", value=doppler_token, expected_type=type_hints["doppler_token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "doppler_token": doppler_token,
        }

    @builtins.property
    def doppler_token(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken":
        '''The DopplerToken is used for authentication.

        See https://docs.doppler.com/reference/api#authentication for auth token types.
        The Key attribute defaults to dopplerToken if not specified.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef#dopplerToken
        '''
        result = self._values.get("doppler_token")
        assert result is not None, "Required property 'doppler_token' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The DopplerToken is used for authentication.

        See https://docs.doppler.com/reference/api#authentication for auth token types.
        The Key attribute defaults to dopplerToken if not specified.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__77ea0d87e66e97c0e9723355f88c6c77c3cbfd9c14f230f8c829e375f9d83cee)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDopplerFormat"
)
class ClusterSecretStoreV1Beta1SpecProviderDopplerFormat(enum.Enum):
    '''Format enables the downloading of secrets as a file (string).

    :schema: ClusterSecretStoreV1Beta1SpecProviderDopplerFormat
    '''

    JSON = "JSON"
    '''json.'''
    DOTNET_HYPHEN_JSON = "DOTNET_HYPHEN_JSON"
    '''dotnet-json.'''
    ENV = "ENV"
    '''env.'''
    YAML = "YAML"
    '''yaml.'''
    DOCKER = "DOCKER"
    '''docker.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer"
)
class ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer(enum.Enum):
    '''Environment variable compatible name transforms that change secret names to a different format.

    :schema: ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer
    '''

    UPPER_HYPHEN_CAMEL = "UPPER_HYPHEN_CAMEL"
    '''upper-camel.'''
    CAMEL = "CAMEL"
    '''camel.'''
    LOWER_HYPHEN_SNAKE = "LOWER_HYPHEN_SNAKE"
    '''lower-snake.'''
    TF_HYPHEN_VAR = "TF_HYPHEN_VAR"
    '''tf-var.'''
    DOTNET_HYPHEN_ENV = "DOTNET_HYPHEN_ENV"
    '''dotnet-env.'''
    LOWER_HYPHEN_KEBAB = "LOWER_HYPHEN_KEBAB"
    '''lower-kebab.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderFake",
    jsii_struct_bases=[],
    name_mapping={"data": "data"},
)
class ClusterSecretStoreV1Beta1SpecProviderFake:
    def __init__(
        self,
        *,
        data: typing.Sequence[typing.Union["ClusterSecretStoreV1Beta1SpecProviderFakeData", typing.Dict[builtins.str, typing.Any]]],
    ) -> None:
        '''Fake configures a store with static key/value pairs.

        :param data: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderFake
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4a19fbd425ec3f1bcd367c838d58b4bccdcdecc7d9b6f0bb62ff3321bf204aa7)
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "data": data,
        }

    @builtins.property
    def data(self) -> typing.List["ClusterSecretStoreV1Beta1SpecProviderFakeData"]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderFake#data
        '''
        result = self._values.get("data")
        assert result is not None, "Required property 'data' is missing"
        return typing.cast(typing.List["ClusterSecretStoreV1Beta1SpecProviderFakeData"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderFake(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderFakeData",
    jsii_struct_bases=[],
    name_mapping={
        "key": "key",
        "value": "value",
        "value_map": "valueMap",
        "version": "version",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderFakeData:
    def __init__(
        self,
        *,
        key: builtins.str,
        value: typing.Optional[builtins.str] = None,
        value_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param key: 
        :param value: 
        :param value_map: Deprecated: ValueMap is deprecated and is intended to be removed in the future, use the ``value`` field instead.
        :param version: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderFakeData
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aecd81391352349eccc8183460b87996d0fb8c9e4bd5f75c376baf485f1b6934)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            check_type(argname="argument value_map", value=value_map, expected_type=type_hints["value_map"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
        }
        if value is not None:
            self._values["value"] = value
        if value_map is not None:
            self._values["value_map"] = value_map
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderFakeData#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderFakeData#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value_map(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Deprecated: ValueMap is deprecated and is intended to be removed in the future, use the ``value`` field instead.

        :schema: ClusterSecretStoreV1Beta1SpecProviderFakeData#valueMap
        '''
        result = self._values.get("value_map")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderFakeData#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderFakeData(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderFortanix",
    jsii_struct_bases=[],
    name_mapping={"api_key": "apiKey", "api_url": "apiUrl"},
)
class ClusterSecretStoreV1Beta1SpecProviderFortanix:
    def __init__(
        self,
        *,
        api_key: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderFortanixApiKey", typing.Dict[builtins.str, typing.Any]]] = None,
        api_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Fortanix configures this store to sync secrets using the Fortanix provider.

        :param api_key: APIKey is the API token to access SDKMS Applications.
        :param api_url: APIURL is the URL of SDKMS API. Defaults to ``sdkms.fortanix.com``. Default: sdkms.fortanix.com`.

        :schema: ClusterSecretStoreV1Beta1SpecProviderFortanix
        '''
        if isinstance(api_key, dict):
            api_key = ClusterSecretStoreV1Beta1SpecProviderFortanixApiKey(**api_key)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__23f53b5511de04a43eca076d3113fbd4876b859968943ded73579584b830281b)
            check_type(argname="argument api_key", value=api_key, expected_type=type_hints["api_key"])
            check_type(argname="argument api_url", value=api_url, expected_type=type_hints["api_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if api_key is not None:
            self._values["api_key"] = api_key
        if api_url is not None:
            self._values["api_url"] = api_url

    @builtins.property
    def api_key(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderFortanixApiKey"]:
        '''APIKey is the API token to access SDKMS Applications.

        :schema: ClusterSecretStoreV1Beta1SpecProviderFortanix#apiKey
        '''
        result = self._values.get("api_key")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderFortanixApiKey"], result)

    @builtins.property
    def api_url(self) -> typing.Optional[builtins.str]:
        '''APIURL is the URL of SDKMS API.

        Defaults to ``sdkms.fortanix.com``.

        :default: sdkms.fortanix.com`.

        :schema: ClusterSecretStoreV1Beta1SpecProviderFortanix#apiUrl
        '''
        result = self._values.get("api_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderFortanix(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderFortanixApiKey",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderFortanixApiKey:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''APIKey is the API token to access SDKMS Applications.

        :param secret_ref: SecretRef is a reference to a secret containing the SDKMS API Key.

        :schema: ClusterSecretStoreV1Beta1SpecProviderFortanixApiKey
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4d4be3708e44244dbee2a11e44eb789795cfe48c43302b71a8a433000e9efcc3)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef"]:
        '''SecretRef is a reference to a secret containing the SDKMS API Key.

        :schema: ClusterSecretStoreV1Beta1SpecProviderFortanixApiKey#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderFortanixApiKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef is a reference to a secret containing the SDKMS API Key.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__91961b519bcb0f662eabc09b7254758dc88f1b7138634b36f11b7124f01dd138)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderGcpsm",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "location": "location", "project_id": "projectId"},
)
class ClusterSecretStoreV1Beta1SpecProviderGcpsm:
    def __init__(
        self,
        *,
        auth: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        location: typing.Optional[builtins.str] = None,
        project_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.

        :param auth: Auth defines the information necessary to authenticate against GCP.
        :param location: Location optionally defines a location for a secret.
        :param project_id: ProjectID project where secret is located.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsm
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__611ca919961e90d0ef7f227bbac8c881013ca7cc44d14799bbb24bc4f0eb3677)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if auth is not None:
            self._values["auth"] = auth
        if location is not None:
            self._values["location"] = location
        if project_id is not None:
            self._values["project_id"] = project_id

    @builtins.property
    def auth(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth"]:
        '''Auth defines the information necessary to authenticate against GCP.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsm#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth"], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''Location optionally defines a location for a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsm#location
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def project_id(self) -> typing.Optional[builtins.str]:
        '''ProjectID project where secret is located.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsm#projectID
        '''
        result = self._values.get("project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderGcpsm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "workload_identity": "workloadIdentity"},
)
class ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        workload_identity: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against GCP.

        :param secret_ref: 
        :param workload_identity: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef(**secret_ref)
        if isinstance(workload_identity, dict):
            workload_identity = ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity(**workload_identity)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__24c1979ee54e5143d4359a3a275ddd182b9dd1799b60c36713217703ba84b3c8)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument workload_identity", value=workload_identity, expected_type=type_hints["workload_identity"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if workload_identity is not None:
            self._values["workload_identity"] = workload_identity

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef"]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef"], result)

    @builtins.property
    def workload_identity(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity"]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth#workloadIdentity
        '''
        result = self._values.get("workload_identity")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"secret_access_key_secret_ref": "secretAccessKeySecretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef:
    def __init__(
        self,
        *,
        secret_access_key_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param secret_access_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef
        '''
        if isinstance(secret_access_key_secret_ref, dict):
            secret_access_key_secret_ref = ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(**secret_access_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8d5ae13c791298e83966ee3151a839a5800890f0e978cc6f5f8bcbf799102c7d)
            check_type(argname="argument secret_access_key_secret_ref", value=secret_access_key_secret_ref, expected_type=type_hints["secret_access_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_access_key_secret_ref is not None:
            self._values["secret_access_key_secret_ref"] = secret_access_key_secret_ref

    @builtins.property
    def secret_access_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef#secretAccessKeySecretRef
        '''
        result = self._values.get("secret_access_key_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__befcc03dadc53716c9f45d6c64f5ca1f64c5c39f92273dce93970a6ea7cb2afc)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity",
    jsii_struct_bases=[],
    name_mapping={
        "cluster_location": "clusterLocation",
        "cluster_name": "clusterName",
        "service_account_ref": "serviceAccountRef",
        "cluster_project_id": "clusterProjectId",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity:
    def __init__(
        self,
        *,
        cluster_location: builtins.str,
        cluster_name: builtins.str,
        service_account_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef", typing.Dict[builtins.str, typing.Any]],
        cluster_project_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param cluster_location: 
        :param cluster_name: 
        :param service_account_ref: A reference to a ServiceAccount resource.
        :param cluster_project_id: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0ad5be2b93a35f2cf663f2139d82f10ed2303f6fd46bcd8be22dfb7c6d07ce9d)
            check_type(argname="argument cluster_location", value=cluster_location, expected_type=type_hints["cluster_location"])
            check_type(argname="argument cluster_name", value=cluster_name, expected_type=type_hints["cluster_name"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument cluster_project_id", value=cluster_project_id, expected_type=type_hints["cluster_project_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cluster_location": cluster_location,
            "cluster_name": cluster_name,
            "service_account_ref": service_account_ref,
        }
        if cluster_project_id is not None:
            self._values["cluster_project_id"] = cluster_project_id

    @builtins.property
    def cluster_location(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterLocation
        '''
        result = self._values.get("cluster_location")
        assert result is not None, "Required property 'cluster_location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cluster_name(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterName
        '''
        result = self._values.get("cluster_name")
        assert result is not None, "Required property 'cluster_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef":
        '''A reference to a ServiceAccount resource.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        assert result is not None, "Required property 'service_account_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef", result)

    @builtins.property
    def cluster_project_id(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterProjectID
        '''
        result = self._values.get("cluster_project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dbbfaf536015025ead4874e316b663e27b4c506f8792288c86be86d4e197205d)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderGitlab",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "environment": "environment",
        "group_i_ds": "groupIDs",
        "inherit_from_groups": "inheritFromGroups",
        "project_id": "projectId",
        "url": "url",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderGitlab:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderGitlabAuth", typing.Dict[builtins.str, typing.Any]],
        environment: typing.Optional[builtins.str] = None,
        group_i_ds: typing.Optional[typing.Sequence[builtins.str]] = None,
        inherit_from_groups: typing.Optional[builtins.bool] = None,
        project_id: typing.Optional[builtins.str] = None,
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''GitLab configures this store to sync secrets using GitLab Variables provider.

        :param auth: Auth configures how secret-manager authenticates with a GitLab instance.
        :param environment: Environment environment_scope of gitlab CI/CD variables (Please see https://docs.gitlab.com/ee/ci/environments/#create-a-static-environment on how to create environments).
        :param group_i_ds: GroupIDs specify, which gitlab groups to pull secrets from. Group secrets are read from left to right followed by the project variables.
        :param inherit_from_groups: InheritFromGroups specifies whether parent groups should be discovered and checked for secrets.
        :param project_id: ProjectID specifies a project where secrets are located.
        :param url: URL configures the GitLab instance URL. Defaults to https://gitlab.com/. Default: https://gitlab.com/.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlab
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderGitlabAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b842bc57f7fd92b2b56e655e52606a5bebb9bcb992f4ddde8e086b665b8aba49)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
            check_type(argname="argument group_i_ds", value=group_i_ds, expected_type=type_hints["group_i_ds"])
            check_type(argname="argument inherit_from_groups", value=inherit_from_groups, expected_type=type_hints["inherit_from_groups"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
        }
        if environment is not None:
            self._values["environment"] = environment
        if group_i_ds is not None:
            self._values["group_i_ds"] = group_i_ds
        if inherit_from_groups is not None:
            self._values["inherit_from_groups"] = inherit_from_groups
        if project_id is not None:
            self._values["project_id"] = project_id
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderGitlabAuth":
        '''Auth configures how secret-manager authenticates with a GitLab instance.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlab#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderGitlabAuth", result)

    @builtins.property
    def environment(self) -> typing.Optional[builtins.str]:
        '''Environment environment_scope of gitlab CI/CD variables (Please see https://docs.gitlab.com/ee/ci/environments/#create-a-static-environment on how to create environments).

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlab#environment
        '''
        result = self._values.get("environment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def group_i_ds(self) -> typing.Optional[typing.List[builtins.str]]:
        '''GroupIDs specify, which gitlab groups to pull secrets from.

        Group secrets are read from left to right followed by the project variables.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlab#groupIDs
        '''
        result = self._values.get("group_i_ds")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def inherit_from_groups(self) -> typing.Optional[builtins.bool]:
        '''InheritFromGroups specifies whether parent groups should be discovered and checked for secrets.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlab#inheritFromGroups
        '''
        result = self._values.get("inherit_from_groups")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def project_id(self) -> typing.Optional[builtins.str]:
        '''ProjectID specifies a project where secrets are located.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlab#projectID
        '''
        result = self._values.get("project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''URL configures the GitLab instance URL.

        Defaults to https://gitlab.com/.

        :default: https://gitlab.com/.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlab#url
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderGitlab(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderGitlabAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderGitlabAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth configures how secret-manager authenticates with a GitLab instance.

        :param secret_ref: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlabAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d5e2849acdcd3f4807f8b1d36de4a61ceec968c342a5f01c5a86f3125aecbb7)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef":
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlabAuth#SecretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderGitlabAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"access_token": "accessToken"},
)
class ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef:
    def __init__(
        self,
        *,
        access_token: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param access_token: AccessToken is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef
        '''
        if isinstance(access_token, dict):
            access_token = ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken(**access_token)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__04f95d713ed9c72c3c6ac92864bfa1ad99f6fdfbe237d224b272b47c56f183eb)
            check_type(argname="argument access_token", value=access_token, expected_type=type_hints["access_token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if access_token is not None:
            self._values["access_token"] = access_token

    @builtins.property
    def access_token(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken"]:
        '''AccessToken is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef#accessToken
        '''
        result = self._values.get("access_token")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AccessToken is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e80400499c318d990d15b26a86d2debab77bc685ec0bdf02963692ecfb1024b5)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderIbm",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "service_url": "serviceUrl"},
)
class ClusterSecretStoreV1Beta1SpecProviderIbm:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderIbmAuth", typing.Dict[builtins.str, typing.Any]],
        service_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''IBM configures this store to sync secrets using IBM Cloud provider.

        :param auth: Auth configures how secret-manager authenticates with the IBM secrets manager.
        :param service_url: ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbm
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderIbmAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f963142b89244cfeecfff807ef899252614263348620700809657bec1f530b9)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument service_url", value=service_url, expected_type=type_hints["service_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
        }
        if service_url is not None:
            self._values["service_url"] = service_url

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderIbmAuth":
        '''Auth configures how secret-manager authenticates with the IBM secrets manager.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbm#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderIbmAuth", result)

    @builtins.property
    def service_url(self) -> typing.Optional[builtins.str]:
        '''ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbm#serviceUrl
        '''
        result = self._values.get("service_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderIbm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderIbmAuth",
    jsii_struct_bases=[],
    name_mapping={"container_auth": "containerAuth", "secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderIbmAuth:
    def __init__(
        self,
        *,
        container_auth: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how secret-manager authenticates with the IBM secrets manager.

        :param container_auth: IBM Container-based auth with IAM Trusted Profile.
        :param secret_ref: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuth
        '''
        if isinstance(container_auth, dict):
            container_auth = ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth(**container_auth)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__89b06a143259e47bb87419627c763e0e429b891a2be7d13124c04b8311b2569a)
            check_type(argname="argument container_auth", value=container_auth, expected_type=type_hints["container_auth"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if container_auth is not None:
            self._values["container_auth"] = container_auth
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def container_auth(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth"]:
        '''IBM Container-based auth with IAM Trusted Profile.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuth#containerAuth
        '''
        result = self._values.get("container_auth")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef"]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderIbmAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth",
    jsii_struct_bases=[],
    name_mapping={
        "profile": "profile",
        "iam_endpoint": "iamEndpoint",
        "token_location": "tokenLocation",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth:
    def __init__(
        self,
        *,
        profile: builtins.str,
        iam_endpoint: typing.Optional[builtins.str] = None,
        token_location: typing.Optional[builtins.str] = None,
    ) -> None:
        '''IBM Container-based auth with IAM Trusted Profile.

        :param profile: the IBM Trusted Profile.
        :param iam_endpoint: 
        :param token_location: Location the token is mounted on the pod.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab7f9219b29d2442359e806a87ce2a170537b2e8f66c99292e852859d2d501e2)
            check_type(argname="argument profile", value=profile, expected_type=type_hints["profile"])
            check_type(argname="argument iam_endpoint", value=iam_endpoint, expected_type=type_hints["iam_endpoint"])
            check_type(argname="argument token_location", value=token_location, expected_type=type_hints["token_location"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "profile": profile,
        }
        if iam_endpoint is not None:
            self._values["iam_endpoint"] = iam_endpoint
        if token_location is not None:
            self._values["token_location"] = token_location

    @builtins.property
    def profile(self) -> builtins.str:
        '''the IBM Trusted Profile.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#profile
        '''
        result = self._values.get("profile")
        assert result is not None, "Required property 'profile' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def iam_endpoint(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#iamEndpoint
        '''
        result = self._values.get("iam_endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def token_location(self) -> typing.Optional[builtins.str]:
        '''Location the token is mounted on the pod.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#tokenLocation
        '''
        result = self._values.get("token_location")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"secret_api_key_secret_ref": "secretApiKeySecretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef:
    def __init__(
        self,
        *,
        secret_api_key_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param secret_api_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef
        '''
        if isinstance(secret_api_key_secret_ref, dict):
            secret_api_key_secret_ref = ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef(**secret_api_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__103f7d95032cc629e6d26292a6477d0ed74e34827b75d026c15ecc133c641e07)
            check_type(argname="argument secret_api_key_secret_ref", value=secret_api_key_secret_ref, expected_type=type_hints["secret_api_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_api_key_secret_ref is not None:
            self._values["secret_api_key_secret_ref"] = secret_api_key_secret_ref

    @builtins.property
    def secret_api_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef#secretApiKeySecretRef
        '''
        result = self._values.get("secret_api_key_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e5730dcd5a104ceac8cb1e536a747e8d4666a82d2bcfb90eaa96292a77009ea)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderInfisical",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "secrets_scope": "secretsScope",
        "host_api": "hostApi",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderInfisical:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderInfisicalAuth", typing.Dict[builtins.str, typing.Any]],
        secrets_scope: typing.Union["ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope", typing.Dict[builtins.str, typing.Any]],
        host_api: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Infisical configures this store to sync secrets using the Infisical provider.

        :param auth: Auth configures how the Operator authenticates with the Infisical API.
        :param secrets_scope: 
        :param host_api: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisical
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderInfisicalAuth(**auth)
        if isinstance(secrets_scope, dict):
            secrets_scope = ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope(**secrets_scope)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__433f40dccc25d4ea1ded25dfa0c8a7e2f2e1b2196f131019c9915b8405daf90d)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument secrets_scope", value=secrets_scope, expected_type=type_hints["secrets_scope"])
            check_type(argname="argument host_api", value=host_api, expected_type=type_hints["host_api"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "secrets_scope": secrets_scope,
        }
        if host_api is not None:
            self._values["host_api"] = host_api

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderInfisicalAuth":
        '''Auth configures how the Operator authenticates with the Infisical API.

        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisical#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderInfisicalAuth", result)

    @builtins.property
    def secrets_scope(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope":
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisical#secretsScope
        '''
        result = self._values.get("secrets_scope")
        assert result is not None, "Required property 'secrets_scope' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope", result)

    @builtins.property
    def host_api(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisical#hostAPI
        '''
        result = self._values.get("host_api")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderInfisical(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderInfisicalAuth",
    jsii_struct_bases=[],
    name_mapping={"universal_auth_credentials": "universalAuthCredentials"},
)
class ClusterSecretStoreV1Beta1SpecProviderInfisicalAuth:
    def __init__(
        self,
        *,
        universal_auth_credentials: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how the Operator authenticates with the Infisical API.

        :param universal_auth_credentials: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuth
        '''
        if isinstance(universal_auth_credentials, dict):
            universal_auth_credentials = ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials(**universal_auth_credentials)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8bf2f01b51b662801580545841b2829b0a1876bfec76fb7dec629e037d69034c)
            check_type(argname="argument universal_auth_credentials", value=universal_auth_credentials, expected_type=type_hints["universal_auth_credentials"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if universal_auth_credentials is not None:
            self._values["universal_auth_credentials"] = universal_auth_credentials

    @builtins.property
    def universal_auth_credentials(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials"]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuth#universalAuthCredentials
        '''
        result = self._values.get("universal_auth_credentials")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderInfisicalAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials",
    jsii_struct_bases=[],
    name_mapping={"client_id": "clientId", "client_secret": "clientSecret"},
)
class ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials:
    def __init__(
        self,
        *,
        client_id: typing.Union["ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId", typing.Dict[builtins.str, typing.Any]],
        client_secret: typing.Union["ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param client_id: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param client_secret: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials
        '''
        if isinstance(client_id, dict):
            client_id = ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId(**client_id)
        if isinstance(client_secret, dict):
            client_secret = ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret(**client_secret)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dcbc59bb27692d8e371d6c510a9c5f75543d6ea509762ca6584dc59eab9292a6)
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret", value=client_secret, expected_type=type_hints["client_secret"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "client_id": client_id,
            "client_secret": client_secret,
        }

    @builtins.property
    def client_id(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials#clientId
        '''
        result = self._values.get("client_id")
        assert result is not None, "Required property 'client_id' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId", result)

    @builtins.property
    def client_secret(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials#clientSecret
        '''
        result = self._values.get("client_secret")
        assert result is not None, "Required property 'client_secret' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__53cf2f6b49226b98a3669bbac517568bb383b82080fe36dea245ff7765eeec17)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a66cfd6286a33a8c66010c07dde69bfc97e9e160868c96a369aa7f7238be0309)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope",
    jsii_struct_bases=[],
    name_mapping={
        "environment_slug": "environmentSlug",
        "project_slug": "projectSlug",
        "recursive": "recursive",
        "secrets_path": "secretsPath",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope:
    def __init__(
        self,
        *,
        environment_slug: builtins.str,
        project_slug: builtins.str,
        recursive: typing.Optional[builtins.bool] = None,
        secrets_path: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param environment_slug: 
        :param project_slug: 
        :param recursive: 
        :param secrets_path: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12df93e3ea954e29712e9ad1f4243a67dc232cb13e920189ecdaacd7718aa991)
            check_type(argname="argument environment_slug", value=environment_slug, expected_type=type_hints["environment_slug"])
            check_type(argname="argument project_slug", value=project_slug, expected_type=type_hints["project_slug"])
            check_type(argname="argument recursive", value=recursive, expected_type=type_hints["recursive"])
            check_type(argname="argument secrets_path", value=secrets_path, expected_type=type_hints["secrets_path"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "environment_slug": environment_slug,
            "project_slug": project_slug,
        }
        if recursive is not None:
            self._values["recursive"] = recursive
        if secrets_path is not None:
            self._values["secrets_path"] = secrets_path

    @builtins.property
    def environment_slug(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope#environmentSlug
        '''
        result = self._values.get("environment_slug")
        assert result is not None, "Required property 'environment_slug' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def project_slug(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope#projectSlug
        '''
        result = self._values.get("project_slug")
        assert result is not None, "Required property 'project_slug' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def recursive(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope#recursive
        '''
        result = self._values.get("recursive")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def secrets_path(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope#secretsPath
        '''
        result = self._values.get("secrets_path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKeepersecurity",
    jsii_struct_bases=[],
    name_mapping={"auth_ref": "authRef", "folder_id": "folderId"},
)
class ClusterSecretStoreV1Beta1SpecProviderKeepersecurity:
    def __init__(
        self,
        *,
        auth_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef", typing.Dict[builtins.str, typing.Any]],
        folder_id: builtins.str,
    ) -> None:
        '''KeeperSecurity configures this store to sync secrets using the KeeperSecurity provider.

        :param auth_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param folder_id: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderKeepersecurity
        '''
        if isinstance(auth_ref, dict):
            auth_ref = ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef(**auth_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__065b85cf10ae98230a4d3cf137fb837a286a95931000e9c2a9ddf1fa0e5396d7)
            check_type(argname="argument auth_ref", value=auth_ref, expected_type=type_hints["auth_ref"])
            check_type(argname="argument folder_id", value=folder_id, expected_type=type_hints["folder_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth_ref": auth_ref,
            "folder_id": folder_id,
        }

    @builtins.property
    def auth_ref(self) -> "ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKeepersecurity#authRef
        '''
        result = self._values.get("auth_ref")
        assert result is not None, "Required property 'auth_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef", result)

    @builtins.property
    def folder_id(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderKeepersecurity#folderID
        '''
        result = self._values.get("folder_id")
        assert result is not None, "Required property 'folder_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKeepersecurity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2aa1a183ead69b64d91b71a278641ffca7b9351511afafd45bf2698b2e9a8cb3)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetes",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "auth_ref": "authRef",
        "remote_namespace": "remoteNamespace",
        "server": "server",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetes:
    def __init__(
        self,
        *,
        auth: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        auth_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef", typing.Dict[builtins.str, typing.Any]]] = None,
        remote_namespace: typing.Optional[builtins.str] = None,
        server: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetesServer", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.

        :param auth: Auth configures how secret-manager authenticates with a Kubernetes instance.
        :param auth_ref: A reference to a secret that contains the auth information.
        :param remote_namespace: Remote namespace to fetch the secrets from.
        :param server: configures the Kubernetes server Address.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetes
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth(**auth)
        if isinstance(auth_ref, dict):
            auth_ref = ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef(**auth_ref)
        if isinstance(server, dict):
            server = ClusterSecretStoreV1Beta1SpecProviderKubernetesServer(**server)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__649ae35e91afd368380d7dcf6b83dcb17d871a308c44fa3c417593e5eb164998)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument auth_ref", value=auth_ref, expected_type=type_hints["auth_ref"])
            check_type(argname="argument remote_namespace", value=remote_namespace, expected_type=type_hints["remote_namespace"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if auth is not None:
            self._values["auth"] = auth
        if auth_ref is not None:
            self._values["auth_ref"] = auth_ref
        if remote_namespace is not None:
            self._values["remote_namespace"] = remote_namespace
        if server is not None:
            self._values["server"] = server

    @builtins.property
    def auth(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth"]:
        '''Auth configures how secret-manager authenticates with a Kubernetes instance.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetes#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth"], result)

    @builtins.property
    def auth_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef"]:
        '''A reference to a secret that contains the auth information.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetes#authRef
        '''
        result = self._values.get("auth_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef"], result)

    @builtins.property
    def remote_namespace(self) -> typing.Optional[builtins.str]:
        '''Remote namespace to fetch the secrets from.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetes#remoteNamespace
        '''
        result = self._values.get("remote_namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def server(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesServer"]:
        '''configures the Kubernetes server Address.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetes#server
        '''
        result = self._values.get("server")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesServer"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth",
    jsii_struct_bases=[],
    name_mapping={
        "cert": "cert",
        "service_account": "serviceAccount",
        "token": "token",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth:
    def __init__(
        self,
        *,
        cert: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount", typing.Dict[builtins.str, typing.Any]]] = None,
        token: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how secret-manager authenticates with a Kubernetes instance.

        :param cert: has both clientCert and clientKey as secretKeySelector.
        :param service_account: points to a service account that should be used for authentication.
        :param token: use static token to authenticate with.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth
        '''
        if isinstance(cert, dict):
            cert = ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert(**cert)
        if isinstance(service_account, dict):
            service_account = ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount(**service_account)
        if isinstance(token, dict):
            token = ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken(**token)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aa84d767397938230357c9460f0da92fd27caf2560c4febd4db2b1946dbc1a5a)
            check_type(argname="argument cert", value=cert, expected_type=type_hints["cert"])
            check_type(argname="argument service_account", value=service_account, expected_type=type_hints["service_account"])
            check_type(argname="argument token", value=token, expected_type=type_hints["token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cert is not None:
            self._values["cert"] = cert
        if service_account is not None:
            self._values["service_account"] = service_account
        if token is not None:
            self._values["token"] = token

    @builtins.property
    def cert(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert"]:
        '''has both clientCert and clientKey as secretKeySelector.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth#cert
        '''
        result = self._values.get("cert")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert"], result)

    @builtins.property
    def service_account(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount"]:
        '''points to a service account that should be used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth#serviceAccount
        '''
        result = self._values.get("service_account")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount"], result)

    @builtins.property
    def token(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken"]:
        '''use static token to authenticate with.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth#token
        '''
        result = self._values.get("token")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert",
    jsii_struct_bases=[],
    name_mapping={"client_cert": "clientCert", "client_key": "clientKey"},
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert:
    def __init__(
        self,
        *,
        client_cert: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert", typing.Dict[builtins.str, typing.Any]]] = None,
        client_key: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''has both clientCert and clientKey as secretKeySelector.

        :param client_cert: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param client_key: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert
        '''
        if isinstance(client_cert, dict):
            client_cert = ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert(**client_cert)
        if isinstance(client_key, dict):
            client_key = ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey(**client_key)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__575fe398163e0264fc9cc318f5b63077e40822b1e8607c6f85b40057e5a91186)
            check_type(argname="argument client_cert", value=client_cert, expected_type=type_hints["client_cert"])
            check_type(argname="argument client_key", value=client_key, expected_type=type_hints["client_key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if client_cert is not None:
            self._values["client_cert"] = client_cert
        if client_key is not None:
            self._values["client_key"] = client_key

    @builtins.property
    def client_cert(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert#clientCert
        '''
        result = self._values.get("client_cert")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert"], result)

    @builtins.property
    def client_key(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert#clientKey
        '''
        result = self._values.get("client_key")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__221783d76f7a636012233fe6be08a91a99912dd5418e80c4f5e22a44a9b16cf3)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6dfe1da476f2ed826b423e04e21f7ee460e7f9163e2c8242f2cb83e8ff997e81)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a secret that contains the auth information.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b3f63c6cffd29f4a4808e7fd7ad6778b84f6572853a314c62266537b7e9c1738)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''points to a service account that should be used for authentication.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0efc0826b2f3217518a7e2c85f96d8b9872418b61e028eac0ae806c4e580bb3d)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken",
    jsii_struct_bases=[],
    name_mapping={"bearer_token": "bearerToken"},
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken:
    def __init__(
        self,
        *,
        bearer_token: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''use static token to authenticate with.

        :param bearer_token: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken
        '''
        if isinstance(bearer_token, dict):
            bearer_token = ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken(**bearer_token)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__db5aaa410704bbf457b4dcbf24af03e4aaab852ef8f192060599932d0d94ed2f)
            check_type(argname="argument bearer_token", value=bearer_token, expected_type=type_hints["bearer_token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if bearer_token is not None:
            self._values["bearer_token"] = bearer_token

    @builtins.property
    def bearer_token(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken#bearerToken
        '''
        result = self._values.get("bearer_token")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f8a74ed4d0d51a9d802908b11ac516af3b90bbe5e93a70c4f766f84a2b3d33a8)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesServer",
    jsii_struct_bases=[],
    name_mapping={"ca_bundle": "caBundle", "ca_provider": "caProvider", "url": "url"},
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesServer:
    def __init__(
        self,
        *,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''configures the Kubernetes server Address.

        :param ca_bundle: CABundle is a base64-encoded CA certificate.
        :param ca_provider: see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.
        :param url: configures the Kubernetes server Address.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesServer
        '''
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__334ade9bed56e5f41ca8625f7989056de67a4ab314b2d286d7c305cef1d84b45)
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''CABundle is a base64-encoded CA certificate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesServer#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider"]:
        '''see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesServer#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider"], result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''configures the Kubernetes server Address.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesServer#url
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetesServer(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b4e3f7f956c039a12dbeed25ac8b12f48c513e3306b05774406b2ce6fe2661f7)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        Can only be defined when used in a ClusterSecretStore.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType"
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOnboardbase",
    jsii_struct_bases=[],
    name_mapping={
        "api_host": "apiHost",
        "auth": "auth",
        "environment": "environment",
        "project": "project",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderOnboardbase:
    def __init__(
        self,
        *,
        api_host: builtins.str,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth", typing.Dict[builtins.str, typing.Any]],
        environment: builtins.str,
        project: builtins.str,
    ) -> None:
        '''Onboardbase configures this store to sync secrets using the Onboardbase provider.

        :param api_host: APIHost use this to configure the host url for the API for selfhosted installation, default is https://public.onboardbase.com/api/v1/.
        :param auth: Auth configures how the Operator authenticates with the Onboardbase API.
        :param environment: Environment is the name of an environmnent within a project to pull the secrets from.
        :param project: Project is an onboardbase project that the secrets should be pulled from.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnboardbase
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fef0fe20d06010db0b115f64a6faaeae6035afd6ee50023dd2905ba6edb385d9)
            check_type(argname="argument api_host", value=api_host, expected_type=type_hints["api_host"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
            check_type(argname="argument project", value=project, expected_type=type_hints["project"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api_host": api_host,
            "auth": auth,
            "environment": environment,
            "project": project,
        }

    @builtins.property
    def api_host(self) -> builtins.str:
        '''APIHost use this to configure the host url for the API for selfhosted installation, default is https://public.onboardbase.com/api/v1/.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnboardbase#apiHost
        '''
        result = self._values.get("api_host")
        assert result is not None, "Required property 'api_host' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth":
        '''Auth configures how the Operator authenticates with the Onboardbase API.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnboardbase#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth", result)

    @builtins.property
    def environment(self) -> builtins.str:
        '''Environment is the name of an environmnent within a project to pull the secrets from.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnboardbase#environment
        '''
        result = self._values.get("environment")
        assert result is not None, "Required property 'environment' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def project(self) -> builtins.str:
        '''Project is an onboardbase project that the secrets should be pulled from.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnboardbase#project
        '''
        result = self._values.get("project")
        assert result is not None, "Required property 'project' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOnboardbase(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth",
    jsii_struct_bases=[],
    name_mapping={"api_key_ref": "apiKeyRef", "passcode_ref": "passcodeRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth:
    def __init__(
        self,
        *,
        api_key_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef", typing.Dict[builtins.str, typing.Any]],
        passcode_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth configures how the Operator authenticates with the Onboardbase API.

        :param api_key_ref: OnboardbaseAPIKey is the APIKey generated by an admin account. It is used to recognize and authorize access to a project and environment within onboardbase
        :param passcode_ref: OnboardbasePasscode is the passcode attached to the API Key.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth
        '''
        if isinstance(api_key_ref, dict):
            api_key_ref = ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef(**api_key_ref)
        if isinstance(passcode_ref, dict):
            passcode_ref = ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef(**passcode_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d1cbb2018cddeec517a9daacbd3efacd9e12b372cdda0ccf5f1c4e390b0a3187)
            check_type(argname="argument api_key_ref", value=api_key_ref, expected_type=type_hints["api_key_ref"])
            check_type(argname="argument passcode_ref", value=passcode_ref, expected_type=type_hints["passcode_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api_key_ref": api_key_ref,
            "passcode_ref": passcode_ref,
        }

    @builtins.property
    def api_key_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef":
        '''OnboardbaseAPIKey is the APIKey generated by an admin account.

        It is used to recognize and authorize access to a project and environment within onboardbase

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth#apiKeyRef
        '''
        result = self._values.get("api_key_ref")
        assert result is not None, "Required property 'api_key_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef", result)

    @builtins.property
    def passcode_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef":
        '''OnboardbasePasscode is the passcode attached to the API Key.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth#passcodeRef
        '''
        result = self._values.get("passcode_ref")
        assert result is not None, "Required property 'passcode_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''OnboardbaseAPIKey is the APIKey generated by an admin account.

        It is used to recognize and authorize access to a project and environment within onboardbase

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e48908cdfeadc38509946151999d447e24d1ae1619cc7a9071c10f1e788238b0)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''OnboardbasePasscode is the passcode attached to the API Key.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__96c99d992290dc70599e2af41c3bea41966ab99f0af0c5260d74a5302466d420)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOnepassword",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "connect_host": "connectHost", "vaults": "vaults"},
)
class ClusterSecretStoreV1Beta1SpecProviderOnepassword:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth", typing.Dict[builtins.str, typing.Any]],
        connect_host: builtins.str,
        vaults: typing.Mapping[builtins.str, jsii.Number],
    ) -> None:
        '''OnePassword configures this store to sync secrets using the 1Password Cloud provider.

        :param auth: Auth defines the information necessary to authenticate against OnePassword Connect Server.
        :param connect_host: ConnectHost defines the OnePassword Connect Server to connect to.
        :param vaults: Vaults defines which OnePassword vaults to search in which order.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepassword
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e7023e452cdb4cf6a57594c3ae644dd93fd67ddecc86ef9bcc979edb5f9aebe4)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument connect_host", value=connect_host, expected_type=type_hints["connect_host"])
            check_type(argname="argument vaults", value=vaults, expected_type=type_hints["vaults"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "connect_host": connect_host,
            "vaults": vaults,
        }

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth":
        '''Auth defines the information necessary to authenticate against OnePassword Connect Server.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepassword#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth", result)

    @builtins.property
    def connect_host(self) -> builtins.str:
        '''ConnectHost defines the OnePassword Connect Server to connect to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepassword#connectHost
        '''
        result = self._values.get("connect_host")
        assert result is not None, "Required property 'connect_host' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vaults(self) -> typing.Mapping[builtins.str, jsii.Number]:
        '''Vaults defines which OnePassword vaults to search in which order.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepassword#vaults
        '''
        result = self._values.get("vaults")
        assert result is not None, "Required property 'vaults' is missing"
        return typing.cast(typing.Mapping[builtins.str, jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOnepassword(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth defines the information necessary to authenticate against OnePassword Connect Server.

        :param secret_ref: OnePasswordAuthSecretRef holds secret references for 1Password credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__774fac14fd73ee729045af64d77ecd440ce05c35c3e5a53f860c8d58b15dc3e1)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef":
        '''OnePasswordAuthSecretRef holds secret references for 1Password credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"connect_token_secret_ref": "connectTokenSecretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef:
    def __init__(
        self,
        *,
        connect_token_secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''OnePasswordAuthSecretRef holds secret references for 1Password credentials.

        :param connect_token_secret_ref: The ConnectToken is used for authentication to a 1Password Connect Server.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef
        '''
        if isinstance(connect_token_secret_ref, dict):
            connect_token_secret_ref = ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(**connect_token_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d3aba248a06dd8137580c089c2215674acf58e010721b05475ec86c4c4a00214)
            check_type(argname="argument connect_token_secret_ref", value=connect_token_secret_ref, expected_type=type_hints["connect_token_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "connect_token_secret_ref": connect_token_secret_ref,
        }

    @builtins.property
    def connect_token_secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef":
        '''The ConnectToken is used for authentication to a 1Password Connect Server.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef#connectTokenSecretRef
        '''
        result = self._values.get("connect_token_secret_ref")
        assert result is not None, "Required property 'connect_token_secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The ConnectToken is used for authentication to a 1Password Connect Server.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e77c7583da6824bee3f7242200e93b841cf55888927c6900b619907c5e020884)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOracle",
    jsii_struct_bases=[],
    name_mapping={
        "region": "region",
        "vault": "vault",
        "auth": "auth",
        "compartment": "compartment",
        "encryption_key": "encryptionKey",
        "principal_type": "principalType",
        "service_account_ref": "serviceAccountRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderOracle:
    def __init__(
        self,
        *,
        region: builtins.str,
        vault: builtins.str,
        auth: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderOracleAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        compartment: typing.Optional[builtins.str] = None,
        encryption_key: typing.Optional[builtins.str] = None,
        principal_type: typing.Optional["ClusterSecretStoreV1Beta1SpecProviderOraclePrincipalType"] = None,
        service_account_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Oracle configures this store to sync secrets using Oracle Vault provider.

        :param region: Region is the region where vault is located.
        :param vault: Vault is the vault's OCID of the specific vault where secret is located.
        :param auth: Auth configures how secret-manager authenticates with the Oracle Vault. If empty, use the instance principal, otherwise the user credentials specified in Auth.
        :param compartment: Compartment is the vault compartment OCID. Required for PushSecret
        :param encryption_key: EncryptionKey is the OCID of the encryption key within the vault. Required for PushSecret
        :param principal_type: The type of principal to use for authentication. If left blank, the Auth struct will determine the principal type. This optional field must be specified if using workload identity.
        :param service_account_ref: ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracle
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderOracleAuth(**auth)
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8799a207c6f9af8f59bb32f362d3937320020eec54a1cc499d831392110f8a7a)
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument vault", value=vault, expected_type=type_hints["vault"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument compartment", value=compartment, expected_type=type_hints["compartment"])
            check_type(argname="argument encryption_key", value=encryption_key, expected_type=type_hints["encryption_key"])
            check_type(argname="argument principal_type", value=principal_type, expected_type=type_hints["principal_type"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "region": region,
            "vault": vault,
        }
        if auth is not None:
            self._values["auth"] = auth
        if compartment is not None:
            self._values["compartment"] = compartment
        if encryption_key is not None:
            self._values["encryption_key"] = encryption_key
        if principal_type is not None:
            self._values["principal_type"] = principal_type
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def region(self) -> builtins.str:
        '''Region is the region where vault is located.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracle#region
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vault(self) -> builtins.str:
        '''Vault is the vault's OCID of the specific vault where secret is located.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracle#vault
        '''
        result = self._values.get("vault")
        assert result is not None, "Required property 'vault' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderOracleAuth"]:
        '''Auth configures how secret-manager authenticates with the Oracle Vault.

        If empty, use the instance principal, otherwise the user credentials specified in Auth.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracle#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderOracleAuth"], result)

    @builtins.property
    def compartment(self) -> typing.Optional[builtins.str]:
        '''Compartment is the vault compartment OCID.

        Required for PushSecret

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracle#compartment
        '''
        result = self._values.get("compartment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def encryption_key(self) -> typing.Optional[builtins.str]:
        '''EncryptionKey is the OCID of the encryption key within the vault.

        Required for PushSecret

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracle#encryptionKey
        '''
        result = self._values.get("encryption_key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def principal_type(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderOraclePrincipalType"]:
        '''The type of principal to use for authentication.

        If left blank, the Auth struct will
        determine the principal type. This optional field must be specified if using
        workload identity.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracle#principalType
        '''
        result = self._values.get("principal_type")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderOraclePrincipalType"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef"]:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracle#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOracle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOracleAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "tenancy": "tenancy", "user": "user"},
)
class ClusterSecretStoreV1Beta1SpecProviderOracleAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
        tenancy: builtins.str,
        user: builtins.str,
    ) -> None:
        '''Auth configures how secret-manager authenticates with the Oracle Vault.

        If empty, use the instance principal, otherwise the user credentials specified in Auth.

        :param secret_ref: SecretRef to pass through sensitive information.
        :param tenancy: Tenancy is the tenancy OCID where user is located.
        :param user: User is an access OCID specific to the account.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1059d0e050af9730791fb51609c13da6c9e6644134ff8920a849b11fc9530224)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument tenancy", value=tenancy, expected_type=type_hints["tenancy"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
            "tenancy": tenancy,
            "user": user,
        }

    @builtins.property
    def secret_ref(self) -> "ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef":
        '''SecretRef to pass through sensitive information.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef", result)

    @builtins.property
    def tenancy(self) -> builtins.str:
        '''Tenancy is the tenancy OCID where user is located.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuth#tenancy
        '''
        result = self._values.get("tenancy")
        assert result is not None, "Required property 'tenancy' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def user(self) -> builtins.str:
        '''User is an access OCID specific to the account.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuth#user
        '''
        result = self._values.get("user")
        assert result is not None, "Required property 'user' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOracleAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"fingerprint": "fingerprint", "privatekey": "privatekey"},
)
class ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef:
    def __init__(
        self,
        *,
        fingerprint: typing.Union["ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint", typing.Dict[builtins.str, typing.Any]],
        privatekey: typing.Union["ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''SecretRef to pass through sensitive information.

        :param fingerprint: Fingerprint is the fingerprint of the API private key.
        :param privatekey: PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef
        '''
        if isinstance(fingerprint, dict):
            fingerprint = ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint(**fingerprint)
        if isinstance(privatekey, dict):
            privatekey = ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey(**privatekey)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6066dd054248d30379dd581e24cbdc9afe6660138d4ad8fa3fc38af7347a3990)
            check_type(argname="argument fingerprint", value=fingerprint, expected_type=type_hints["fingerprint"])
            check_type(argname="argument privatekey", value=privatekey, expected_type=type_hints["privatekey"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "fingerprint": fingerprint,
            "privatekey": privatekey,
        }

    @builtins.property
    def fingerprint(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint":
        '''Fingerprint is the fingerprint of the API private key.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef#fingerprint
        '''
        result = self._values.get("fingerprint")
        assert result is not None, "Required property 'fingerprint' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint", result)

    @builtins.property
    def privatekey(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey":
        '''PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef#privatekey
        '''
        result = self._values.get("privatekey")
        assert result is not None, "Required property 'privatekey' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Fingerprint is the fingerprint of the API private key.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__287e9ae6268a6e788ae12f7ac12e8fbb9c885f4ff3d45a0caf28cd5b8d169176)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5ef933a14bdabe16081013d01aaf091a9b526ae2581143345eefebbda8c252e6)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOraclePrincipalType"
)
class ClusterSecretStoreV1Beta1SpecProviderOraclePrincipalType(enum.Enum):
    '''The type of principal to use for authentication.

    If left blank, the Auth struct will
    determine the principal type. This optional field must be specified if using
    workload identity.

    :schema: ClusterSecretStoreV1Beta1SpecProviderOraclePrincipalType
    '''

    USER_PRINCIPAL = "USER_PRINCIPAL"
    '''UserPrincipal.'''
    INSTANCE_PRINCIPAL = "INSTANCE_PRINCIPAL"
    '''InstancePrincipal.'''
    WORKLOAD = "WORKLOAD"
    '''Workload.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bdc362d2dc657faa25b2dd71b2ac7510e47044f7a095df7486825735173be01e)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderPassbolt",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "host": "host"},
)
class ClusterSecretStoreV1Beta1SpecProviderPassbolt:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderPassboltAuth", typing.Dict[builtins.str, typing.Any]],
        host: builtins.str,
    ) -> None:
        '''
        :param auth: Auth defines the information necessary to authenticate against Passbolt Server.
        :param host: Host defines the Passbolt Server to connect to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassbolt
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderPassboltAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a5bdf2a0b57968765bc44e2884c1669c82fec7a7708fe5dca91387ae68da08e)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "host": host,
        }

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderPassboltAuth":
        '''Auth defines the information necessary to authenticate against Passbolt Server.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassbolt#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderPassboltAuth", result)

    @builtins.property
    def host(self) -> builtins.str:
        '''Host defines the Passbolt Server to connect to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassbolt#host
        '''
        result = self._values.get("host")
        assert result is not None, "Required property 'host' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderPassbolt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderPassboltAuth",
    jsii_struct_bases=[],
    name_mapping={
        "password_secret_ref": "passwordSecretRef",
        "private_key_secret_ref": "privateKeySecretRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderPassboltAuth:
    def __init__(
        self,
        *,
        password_secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef", typing.Dict[builtins.str, typing.Any]],
        private_key_secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth defines the information necessary to authenticate against Passbolt Server.

        :param password_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param private_key_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassboltAuth
        '''
        if isinstance(password_secret_ref, dict):
            password_secret_ref = ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef(**password_secret_ref)
        if isinstance(private_key_secret_ref, dict):
            private_key_secret_ref = ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef(**private_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__483cad95d0042cdbab9a60c81b20980557e0b60689450c8717896ab6c1d6e15f)
            check_type(argname="argument password_secret_ref", value=password_secret_ref, expected_type=type_hints["password_secret_ref"])
            check_type(argname="argument private_key_secret_ref", value=private_key_secret_ref, expected_type=type_hints["private_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "password_secret_ref": password_secret_ref,
            "private_key_secret_ref": private_key_secret_ref,
        }

    @builtins.property
    def password_secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassboltAuth#passwordSecretRef
        '''
        result = self._values.get("password_secret_ref")
        assert result is not None, "Required property 'password_secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef", result)

    @builtins.property
    def private_key_secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassboltAuth#privateKeySecretRef
        '''
        result = self._values.get("private_key_secret_ref")
        assert result is not None, "Required property 'private_key_secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderPassboltAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__642fd1ce8f6dea3187f6aee48bbbe2e1933e1c9c53f560119d3d1841066fbc78)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__59ae23d4cc00631d4f90cb043b7bc74c3052fd82a2664116f490110123809074)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderPassworddepot",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "database": "database", "host": "host"},
)
class ClusterSecretStoreV1Beta1SpecProviderPassworddepot:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuth", typing.Dict[builtins.str, typing.Any]],
        database: builtins.str,
        host: builtins.str,
    ) -> None:
        '''Configures a store to sync secrets with a Password Depot instance.

        :param auth: Auth configures how secret-manager authenticates with a Password Depot instance.
        :param database: Database to use as source.
        :param host: URL configures the Password Depot instance URL.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassworddepot
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b3e4ac61bac2d763c98707b1962c58667b9ac61ee2b2dea402f347b1c481fb79)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument database", value=database, expected_type=type_hints["database"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "database": database,
            "host": host,
        }

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuth":
        '''Auth configures how secret-manager authenticates with a Password Depot instance.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassworddepot#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuth", result)

    @builtins.property
    def database(self) -> builtins.str:
        '''Database to use as source.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassworddepot#database
        '''
        result = self._values.get("database")
        assert result is not None, "Required property 'database' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def host(self) -> builtins.str:
        '''URL configures the Password Depot instance URL.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassworddepot#host
        '''
        result = self._values.get("host")
        assert result is not None, "Required property 'host' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderPassworddepot(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth configures how secret-manager authenticates with a Password Depot instance.

        :param secret_ref: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__05c65e058ced4bdb5cef3641cc9e5cfaae0387cd9db325478de3ddeda13003c7)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef":
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"credentials": "credentials"},
)
class ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef:
    def __init__(
        self,
        *,
        credentials: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param credentials: Username / Password is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef
        '''
        if isinstance(credentials, dict):
            credentials = ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials(**credentials)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6de977b5878b841de2449126618c6a83ce9e9bea33c1d98d8a99425cdf649481)
            check_type(argname="argument credentials", value=credentials, expected_type=type_hints["credentials"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if credentials is not None:
            self._values["credentials"] = credentials

    @builtins.property
    def credentials(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials"]:
        '''Username / Password is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef#credentials
        '''
        result = self._values.get("credentials")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Username / Password is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2ed80b8a0ccff8d950eb589785a3db8eda34428f58f04ec1844c28d4d1b9dd2a)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderPrevider",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "base_uri": "baseUri"},
)
class ClusterSecretStoreV1Beta1SpecProviderPrevider:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderPreviderAuth", typing.Dict[builtins.str, typing.Any]],
        base_uri: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Previder configures this store to sync secrets using the Previder provider.

        :param auth: PreviderAuth contains a secretRef for credentials.
        :param base_uri: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderPrevider
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderPreviderAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__924872030e44d3ecd52de749e7dfc24284bd7a32d6106c1c35a38e9a05bd53d0)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument base_uri", value=base_uri, expected_type=type_hints["base_uri"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
        }
        if base_uri is not None:
            self._values["base_uri"] = base_uri

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderPreviderAuth":
        '''PreviderAuth contains a secretRef for credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPrevider#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderPreviderAuth", result)

    @builtins.property
    def base_uri(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderPrevider#baseUri
        '''
        result = self._values.get("base_uri")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderPrevider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderPreviderAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderPreviderAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''PreviderAuth contains a secretRef for credentials.

        :param secret_ref: PreviderAuthSecretRef holds secret references for Previder Vault credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPreviderAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b84707fdc9bd6eb9bd787c836e511a5a7292d579ed9f7e3ea2bdf76b803be5e1)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRef"]:
        '''PreviderAuthSecretRef holds secret references for Previder Vault credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPreviderAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderPreviderAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"access_token": "accessToken"},
)
class ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRef:
    def __init__(
        self,
        *,
        access_token: typing.Union["ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''PreviderAuthSecretRef holds secret references for Previder Vault credentials.

        :param access_token: The AccessToken is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRef
        '''
        if isinstance(access_token, dict):
            access_token = ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken(**access_token)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7d35b300a5d3d17a972507e059cf1b7c7ce5dc548d7626f4b72592c159e7577)
            check_type(argname="argument access_token", value=access_token, expected_type=type_hints["access_token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "access_token": access_token,
        }

    @builtins.property
    def access_token(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken":
        '''The AccessToken is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRef#accessToken
        '''
        result = self._values.get("access_token")
        assert result is not None, "Required property 'access_token' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessToken is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c23e7cae4da282bd243d4f801f0019cbfbcec800546fb8976422c523e4d82deb)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderPulumi",
    jsii_struct_bases=[],
    name_mapping={
        "access_token": "accessToken",
        "environment": "environment",
        "organization": "organization",
        "project": "project",
        "api_url": "apiUrl",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderPulumi:
    def __init__(
        self,
        *,
        access_token: typing.Union["ClusterSecretStoreV1Beta1SpecProviderPulumiAccessToken", typing.Dict[builtins.str, typing.Any]],
        environment: builtins.str,
        organization: builtins.str,
        project: builtins.str,
        api_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Pulumi configures this store to sync secrets using the Pulumi provider.

        :param access_token: AccessToken is the access tokens to sign in to the Pulumi Cloud Console.
        :param environment: Environment are YAML documents composed of static key-value pairs, programmatic expressions, dynamically retrieved values from supported providers including all major clouds, and other Pulumi ESC environments. To create a new environment, visit https://www.pulumi.com/docs/esc/environments/ for more information.
        :param organization: Organization are a space to collaborate on shared projects and stacks. To create a new organization, visit https://app.pulumi.com/ and click "New Organization".
        :param project: Project is the name of the Pulumi ESC project the environment belongs to.
        :param api_url: APIURL is the URL of the Pulumi API.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPulumi
        '''
        if isinstance(access_token, dict):
            access_token = ClusterSecretStoreV1Beta1SpecProviderPulumiAccessToken(**access_token)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a3d514f7841dfe014761e2c7d90549223f920bae7e524a1516bfa510a96c06f)
            check_type(argname="argument access_token", value=access_token, expected_type=type_hints["access_token"])
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
            check_type(argname="argument organization", value=organization, expected_type=type_hints["organization"])
            check_type(argname="argument project", value=project, expected_type=type_hints["project"])
            check_type(argname="argument api_url", value=api_url, expected_type=type_hints["api_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "access_token": access_token,
            "environment": environment,
            "organization": organization,
            "project": project,
        }
        if api_url is not None:
            self._values["api_url"] = api_url

    @builtins.property
    def access_token(self) -> "ClusterSecretStoreV1Beta1SpecProviderPulumiAccessToken":
        '''AccessToken is the access tokens to sign in to the Pulumi Cloud Console.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPulumi#accessToken
        '''
        result = self._values.get("access_token")
        assert result is not None, "Required property 'access_token' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderPulumiAccessToken", result)

    @builtins.property
    def environment(self) -> builtins.str:
        '''Environment are YAML documents composed of static key-value pairs, programmatic expressions, dynamically retrieved values from supported providers including all major clouds, and other Pulumi ESC environments.

        To create a new environment, visit https://www.pulumi.com/docs/esc/environments/ for more information.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPulumi#environment
        '''
        result = self._values.get("environment")
        assert result is not None, "Required property 'environment' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def organization(self) -> builtins.str:
        '''Organization are a space to collaborate on shared projects and stacks.

        To create a new organization, visit https://app.pulumi.com/ and click "New Organization".

        :schema: ClusterSecretStoreV1Beta1SpecProviderPulumi#organization
        '''
        result = self._values.get("organization")
        assert result is not None, "Required property 'organization' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def project(self) -> builtins.str:
        '''Project is the name of the Pulumi ESC project the environment belongs to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPulumi#project
        '''
        result = self._values.get("project")
        assert result is not None, "Required property 'project' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_url(self) -> typing.Optional[builtins.str]:
        '''APIURL is the URL of the Pulumi API.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPulumi#apiUrl
        '''
        result = self._values.get("api_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderPulumi(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderPulumiAccessToken",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderPulumiAccessToken:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''AccessToken is the access tokens to sign in to the Pulumi Cloud Console.

        :param secret_ref: SecretRef is a reference to a secret containing the Pulumi API token.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPulumiAccessToken
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8ce20bfd85695402dc2849f6d7d6aa51cffd3b4566344bb15cb2a217d2c57995)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef"]:
        '''SecretRef is a reference to a secret containing the Pulumi API token.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPulumiAccessToken#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderPulumiAccessToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef is a reference to a secret containing the Pulumi API token.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__803f54068a7a9a3d2dd582de1857a6521e55ab7acbd0a7fd47cda1cd02fd01af)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderScaleway",
    jsii_struct_bases=[],
    name_mapping={
        "access_key": "accessKey",
        "project_id": "projectId",
        "region": "region",
        "secret_key": "secretKey",
        "api_url": "apiUrl",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderScaleway:
    def __init__(
        self,
        *,
        access_key: typing.Union["ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey", typing.Dict[builtins.str, typing.Any]],
        project_id: builtins.str,
        region: builtins.str,
        secret_key: typing.Union["ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey", typing.Dict[builtins.str, typing.Any]],
        api_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Scaleway.

        :param access_key: AccessKey is the non-secret part of the api key.
        :param project_id: ProjectID is the id of your project, which you can find in the console: https://console.scaleway.com/project/settings.
        :param region: Region where your secrets are located: https://developers.scaleway.com/en/quickstart/#region-and-zone.
        :param secret_key: SecretKey is the non-secret part of the api key.
        :param api_url: APIURL is the url of the api to use. Defaults to https://api.scaleway.com Default: https://api.scaleway.com

        :schema: ClusterSecretStoreV1Beta1SpecProviderScaleway
        '''
        if isinstance(access_key, dict):
            access_key = ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey(**access_key)
        if isinstance(secret_key, dict):
            secret_key = ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey(**secret_key)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__34a650bc4b0a2bc1f9f27e56bc55b81edf43ce63c03c1f2688ccfcb6c0edb300)
            check_type(argname="argument access_key", value=access_key, expected_type=type_hints["access_key"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument secret_key", value=secret_key, expected_type=type_hints["secret_key"])
            check_type(argname="argument api_url", value=api_url, expected_type=type_hints["api_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "access_key": access_key,
            "project_id": project_id,
            "region": region,
            "secret_key": secret_key,
        }
        if api_url is not None:
            self._values["api_url"] = api_url

    @builtins.property
    def access_key(self) -> "ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey":
        '''AccessKey is the non-secret part of the api key.

        :schema: ClusterSecretStoreV1Beta1SpecProviderScaleway#accessKey
        '''
        result = self._values.get("access_key")
        assert result is not None, "Required property 'access_key' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey", result)

    @builtins.property
    def project_id(self) -> builtins.str:
        '''ProjectID is the id of your project, which you can find in the console: https://console.scaleway.com/project/settings.

        :schema: ClusterSecretStoreV1Beta1SpecProviderScaleway#projectId
        '''
        result = self._values.get("project_id")
        assert result is not None, "Required property 'project_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def region(self) -> builtins.str:
        '''Region where your secrets are located: https://developers.scaleway.com/en/quickstart/#region-and-zone.

        :schema: ClusterSecretStoreV1Beta1SpecProviderScaleway#region
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_key(self) -> "ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey":
        '''SecretKey is the non-secret part of the api key.

        :schema: ClusterSecretStoreV1Beta1SpecProviderScaleway#secretKey
        '''
        result = self._values.get("secret_key")
        assert result is not None, "Required property 'secret_key' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey", result)

    @builtins.property
    def api_url(self) -> typing.Optional[builtins.str]:
        '''APIURL is the url of the api to use.

        Defaults to https://api.scaleway.com

        :default: https://api.scaleway.com

        :schema: ClusterSecretStoreV1Beta1SpecProviderScaleway#apiUrl
        '''
        result = self._values.get("api_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderScaleway(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AccessKey is the non-secret part of the api key.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f30cfa9a739a56c761461f061f73a9b640a983d8a1a701a1fefe3d789730c70)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f9043fea830d3be2007d12b48e16e9e86cda92767498fdfdd2ccb99c9219cc6)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretKey is the non-secret part of the api key.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eace41394372d69255d6903c1697729bd6838c548cb8800015bc9ef27ebafc6c)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2416ae63f6956e1362be588c0f9dcd24e011f9246db6e363300071963649becf)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderSecretserver",
    jsii_struct_bases=[],
    name_mapping={
        "password": "password",
        "server_url": "serverUrl",
        "username": "username",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderSecretserver:
    def __init__(
        self,
        *,
        password: typing.Union["ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword", typing.Dict[builtins.str, typing.Any]],
        server_url: builtins.str,
        username: typing.Union["ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''SecretServer configures this store to sync secrets using SecretServer provider https://docs.delinea.com/online-help/secret-server/start.htm.

        :param password: Password is the secret server account password.
        :param server_url: ServerURL URL to your secret server installation.
        :param username: Username is the secret server account username.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSecretserver
        '''
        if isinstance(password, dict):
            password = ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword(**password)
        if isinstance(username, dict):
            username = ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername(**username)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e5cc7e570ee07bfa3e1df100121363b4e855684c4d46acc2a6f13f8134621e29)
            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
            check_type(argname="argument server_url", value=server_url, expected_type=type_hints["server_url"])
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "password": password,
            "server_url": server_url,
            "username": username,
        }

    @builtins.property
    def password(self) -> "ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword":
        '''Password is the secret server account password.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSecretserver#password
        '''
        result = self._values.get("password")
        assert result is not None, "Required property 'password' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword", result)

    @builtins.property
    def server_url(self) -> builtins.str:
        '''ServerURL URL to your secret server installation.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSecretserver#serverURL
        '''
        result = self._values.get("server_url")
        assert result is not None, "Required property 'server_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def username(self) -> "ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername":
        '''Username is the secret server account username.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSecretserver#username
        '''
        result = self._values.get("username")
        assert result is not None, "Required property 'username' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderSecretserver(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Password is the secret server account password.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__abd70d527f4be3d9bdaae30b0afbc845b6c753bf4e3a173d3bac4b31e8d276eb)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e84cb0430452796bee1e109b2a29e189b02433f3d46fe2e69304fedebde1caf)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Username is the secret server account username.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4792ee1a300e27f94432d14b0d25bdd28980ab37a7f9d1d9965a80e89ba55a81)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__42005e28034a3b0e045aca385b095bf85d822a6601f9d62cee4d6f22d42af191)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderSenhasegura",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "module": "module",
        "url": "url",
        "ignore_ssl_certificate": "ignoreSslCertificate",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderSenhasegura:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth", typing.Dict[builtins.str, typing.Any]],
        module: builtins.str,
        url: builtins.str,
        ignore_ssl_certificate: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Senhasegura configures this store to sync secrets using senhasegura provider.

        :param auth: Auth defines parameters to authenticate in senhasegura.
        :param module: Module defines which senhasegura module should be used to get secrets.
        :param url: URL of senhasegura.
        :param ignore_ssl_certificate: IgnoreSslCertificate defines if SSL certificate must be ignored.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhasegura
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__784088abfe52d375c8846da70040ac2e8a3a7fa8b88275b3433f77ed7167b0bb)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument module", value=module, expected_type=type_hints["module"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
            check_type(argname="argument ignore_ssl_certificate", value=ignore_ssl_certificate, expected_type=type_hints["ignore_ssl_certificate"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "module": module,
            "url": url,
        }
        if ignore_ssl_certificate is not None:
            self._values["ignore_ssl_certificate"] = ignore_ssl_certificate

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth":
        '''Auth defines parameters to authenticate in senhasegura.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhasegura#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth", result)

    @builtins.property
    def module(self) -> builtins.str:
        '''Module defines which senhasegura module should be used to get secrets.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhasegura#module
        '''
        result = self._values.get("module")
        assert result is not None, "Required property 'module' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def url(self) -> builtins.str:
        '''URL of senhasegura.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhasegura#url
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ignore_ssl_certificate(self) -> typing.Optional[builtins.bool]:
        '''IgnoreSslCertificate defines if SSL certificate must be ignored.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhasegura#ignoreSslCertificate
        '''
        result = self._values.get("ignore_ssl_certificate")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderSenhasegura(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth",
    jsii_struct_bases=[],
    name_mapping={
        "client_id": "clientId",
        "client_secret_secret_ref": "clientSecretSecretRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth:
    def __init__(
        self,
        *,
        client_id: builtins.str,
        client_secret_secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth defines parameters to authenticate in senhasegura.

        :param client_id: 
        :param client_secret_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth
        '''
        if isinstance(client_secret_secret_ref, dict):
            client_secret_secret_ref = ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef(**client_secret_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0968cf6c587cfe7e19f4d78b9bfccbab47ad4922f6924b0e57fee2840889975f)
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret_secret_ref", value=client_secret_secret_ref, expected_type=type_hints["client_secret_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "client_id": client_id,
            "client_secret_secret_ref": client_secret_secret_ref,
        }

    @builtins.property
    def client_id(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth#clientId
        '''
        result = self._values.get("client_id")
        assert result is not None, "Required property 'client_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def client_secret_secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth#clientSecretSecretRef
        '''
        result = self._values.get("client_secret_secret_ref")
        assert result is not None, "Required property 'client_secret_secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e46f714e97c2c006c0dbdfdddca33d85e4f65fd4e9785f239d767d95af2ea339)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVault",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "server": "server",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
        "forward_inconsistent": "forwardInconsistent",
        "headers": "headers",
        "namespace": "namespace",
        "path": "path",
        "read_your_writes": "readYourWrites",
        "tls": "tls",
        "version": "version",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderVault:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuth", typing.Dict[builtins.str, typing.Any]],
        server: builtins.str,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
        forward_inconsistent: typing.Optional[builtins.bool] = None,
        headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
        path: typing.Optional[builtins.str] = None,
        read_your_writes: typing.Optional[builtins.bool] = None,
        tls: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultTls", typing.Dict[builtins.str, typing.Any]]] = None,
        version: typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultVersion"] = None,
    ) -> None:
        '''Vault configures this store to sync secrets using Hashi provider.

        :param auth: Auth configures how secret-manager authenticates with the Vault server.
        :param server: Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
        :param ca_bundle: PEM encoded CA bundle used to validate Vault server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
        :param ca_provider: The provider for the CA bundle to use to validate Vault server certificate.
        :param forward_inconsistent: ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop. This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
        :param headers: Headers to be added in Vault request.
        :param namespace: Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
        :param path: Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.
        :param read_your_writes: ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request. More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency
        :param tls: The configuration used for client side related TLS communication, when the Vault server requires mutual authentication. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. It's worth noting this configuration is different from the "TLS certificates auth method", which is available under the ``auth.cert`` section.
        :param version: Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderVaultAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider(**ca_provider)
        if isinstance(tls, dict):
            tls = ClusterSecretStoreV1Beta1SpecProviderVaultTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d1ed82d254940b706af74554873fa54b86cd8804d7fee8da566eedeb386d5b29)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument forward_inconsistent", value=forward_inconsistent, expected_type=type_hints["forward_inconsistent"])
            check_type(argname="argument headers", value=headers, expected_type=type_hints["headers"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument read_your_writes", value=read_your_writes, expected_type=type_hints["read_your_writes"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "server": server,
        }
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if forward_inconsistent is not None:
            self._values["forward_inconsistent"] = forward_inconsistent
        if headers is not None:
            self._values["headers"] = headers
        if namespace is not None:
            self._values["namespace"] = namespace
        if path is not None:
            self._values["path"] = path
        if read_your_writes is not None:
            self._values["read_your_writes"] = read_your_writes
        if tls is not None:
            self._values["tls"] = tls
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderVaultAuth":
        '''Auth configures how secret-manager authenticates with the Vault server.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderVaultAuth", result)

    @builtins.property
    def server(self) -> builtins.str:
        '''Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault#server
        '''
        result = self._values.get("server")
        assert result is not None, "Required property 'server' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''PEM encoded CA bundle used to validate Vault server certificate.

        Only used
        if the Server URL is using HTTPS protocol. This parameter is ignored for
        plain HTTP protocol connection. If not set the system root certificates
        are used to validate the TLS connection.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider"]:
        '''The provider for the CA bundle to use to validate Vault server certificate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider"], result)

    @builtins.property
    def forward_inconsistent(self) -> typing.Optional[builtins.bool]:
        '''ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop.

        This can increase performance if
        the option is enabled serverside.
        https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault#forwardInconsistent
        '''
        result = self._values.get("forward_inconsistent")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def headers(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Headers to be added in Vault request.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault#headers
        '''
        result = self._values.get("headers")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Name of the vault namespace.

        Namespaces is a set of features within Vault Enterprise that allows
        Vault environments to support Secure Multi-tenancy. e.g: "ns1".
        More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_your_writes(self) -> typing.Optional[builtins.bool]:
        '''ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request.

        More information about eventual consistency in Vault can be found here
        https://www.vaultproject.io/docs/enterprise/consistency

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault#readYourWrites
        '''
        result = self._values.get("read_your_writes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def tls(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultTls"]:
        '''The configuration used for client side related TLS communication, when the Vault server requires mutual authentication.

        Only used if the Server URL is using HTTPS protocol.
        This parameter is ignored for plain HTTP protocol connection.
        It's worth noting this configuration is different from the "TLS certificates auth method",
        which is available under the ``auth.cert`` section.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault#tls
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultTls"], result)

    @builtins.property
    def version(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultVersion"]:
        '''Version is the Vault KV secret engine version.

        This can be either "v1" or
        "v2". Version defaults to "v2".

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultVersion"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVault(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuth",
    jsii_struct_bases=[],
    name_mapping={
        "app_role": "appRole",
        "cert": "cert",
        "iam": "iam",
        "jwt": "jwt",
        "kubernetes": "kubernetes",
        "ldap": "ldap",
        "namespace": "namespace",
        "token_secret_ref": "tokenSecretRef",
        "user_pass": "userPass",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuth:
    def __init__(
        self,
        *,
        app_role: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole", typing.Dict[builtins.str, typing.Any]]] = None,
        cert: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert", typing.Dict[builtins.str, typing.Any]]] = None,
        iam: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam", typing.Dict[builtins.str, typing.Any]]] = None,
        jwt: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt", typing.Dict[builtins.str, typing.Any]]] = None,
        kubernetes: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes", typing.Dict[builtins.str, typing.Any]]] = None,
        ldap: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap", typing.Dict[builtins.str, typing.Any]]] = None,
        namespace: typing.Optional[builtins.str] = None,
        token_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        user_pass: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how secret-manager authenticates with the Vault server.

        :param app_role: AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
        :param cert: Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.
        :param iam: Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials AWS IAM authentication method.
        :param jwt: Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.
        :param kubernetes: Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
        :param ldap: Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.
        :param namespace: Name of the vault namespace to authenticate to. This can be different than the namespace your secret is in. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces This will default to Vault.Namespace field if set, or empty otherwise
        :param token_secret_ref: TokenSecretRef authenticates with Vault by presenting a token.
        :param user_pass: UserPass authenticates with Vault by passing username/password pair.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuth
        '''
        if isinstance(app_role, dict):
            app_role = ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole(**app_role)
        if isinstance(cert, dict):
            cert = ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert(**cert)
        if isinstance(iam, dict):
            iam = ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam(**iam)
        if isinstance(jwt, dict):
            jwt = ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt(**jwt)
        if isinstance(kubernetes, dict):
            kubernetes = ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes(**kubernetes)
        if isinstance(ldap, dict):
            ldap = ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap(**ldap)
        if isinstance(token_secret_ref, dict):
            token_secret_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef(**token_secret_ref)
        if isinstance(user_pass, dict):
            user_pass = ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass(**user_pass)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fa1611c7ca8d9fedadb92afb290e6c41419ad09bd43146b4bdf9c1d75b8a578a)
            check_type(argname="argument app_role", value=app_role, expected_type=type_hints["app_role"])
            check_type(argname="argument cert", value=cert, expected_type=type_hints["cert"])
            check_type(argname="argument iam", value=iam, expected_type=type_hints["iam"])
            check_type(argname="argument jwt", value=jwt, expected_type=type_hints["jwt"])
            check_type(argname="argument kubernetes", value=kubernetes, expected_type=type_hints["kubernetes"])
            check_type(argname="argument ldap", value=ldap, expected_type=type_hints["ldap"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument token_secret_ref", value=token_secret_ref, expected_type=type_hints["token_secret_ref"])
            check_type(argname="argument user_pass", value=user_pass, expected_type=type_hints["user_pass"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if app_role is not None:
            self._values["app_role"] = app_role
        if cert is not None:
            self._values["cert"] = cert
        if iam is not None:
            self._values["iam"] = iam
        if jwt is not None:
            self._values["jwt"] = jwt
        if kubernetes is not None:
            self._values["kubernetes"] = kubernetes
        if ldap is not None:
            self._values["ldap"] = ldap
        if namespace is not None:
            self._values["namespace"] = namespace
        if token_secret_ref is not None:
            self._values["token_secret_ref"] = token_secret_ref
        if user_pass is not None:
            self._values["user_pass"] = user_pass

    @builtins.property
    def app_role(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole"]:
        '''AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuth#appRole
        '''
        result = self._values.get("app_role")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole"], result)

    @builtins.property
    def cert(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert"]:
        '''Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuth#cert
        '''
        result = self._values.get("cert")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert"], result)

    @builtins.property
    def iam(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam"]:
        '''Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials AWS IAM authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuth#iam
        '''
        result = self._values.get("iam")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam"], result)

    @builtins.property
    def jwt(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt"]:
        '''Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuth#jwt
        '''
        result = self._values.get("jwt")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt"], result)

    @builtins.property
    def kubernetes(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes"]:
        '''Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuth#kubernetes
        '''
        result = self._values.get("kubernetes")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes"], result)

    @builtins.property
    def ldap(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap"]:
        '''Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuth#ldap
        '''
        result = self._values.get("ldap")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap"], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Name of the vault namespace to authenticate to.

        This can be different than the namespace your secret is in.
        Namespaces is a set of features within Vault Enterprise that allows
        Vault environments to support Secure Multi-tenancy. e.g: "ns1".
        More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
        This will default to Vault.Namespace field if set, or empty otherwise

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuth#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def token_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef"]:
        '''TokenSecretRef authenticates with Vault by presenting a token.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuth#tokenSecretRef
        '''
        result = self._values.get("token_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef"], result)

    @builtins.property
    def user_pass(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass"]:
        '''UserPass authenticates with Vault by passing username/password pair.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuth#userPass
        '''
        result = self._values.get("user_pass")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole",
    jsii_struct_bases=[],
    name_mapping={
        "path": "path",
        "secret_ref": "secretRef",
        "role_id": "roleId",
        "role_ref": "roleRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole:
    def __init__(
        self,
        *,
        path: builtins.str,
        secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef", typing.Dict[builtins.str, typing.Any]],
        role_id: typing.Optional[builtins.str] = None,
        role_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.

        :param path: Path where the App Role authentication backend is mounted in Vault, e.g: "approle".
        :param secret_ref: Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The ``key`` field must be specified and denotes which entry within the Secret resource is used as the app role secret.
        :param role_id: RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.
        :param role_ref: Reference to a key in a Secret that contains the App Role ID used to authenticate with Vault. The ``key`` field must be specified and denotes which entry within the Secret resource is used as the app role id.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef(**secret_ref)
        if isinstance(role_ref, dict):
            role_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef(**role_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__37344579b6c7a990af00af0b70741d46bed82ecd50a1667f46a0a209f98d358e)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument role_id", value=role_id, expected_type=type_hints["role_id"])
            check_type(argname="argument role_ref", value=role_ref, expected_type=type_hints["role_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
            "secret_ref": secret_ref,
        }
        if role_id is not None:
            self._values["role_id"] = role_id
        if role_ref is not None:
            self._values["role_ref"] = role_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the App Role authentication backend is mounted in Vault, e.g: "approle".

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef":
        '''Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret
        resource is used as the app role secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef", result)

    @builtins.property
    def role_id(self) -> typing.Optional[builtins.str]:
        '''RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole#roleId
        '''
        result = self._values.get("role_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef"]:
        '''Reference to a key in a Secret that contains the App Role ID used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret
        resource is used as the app role id.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole#roleRef
        '''
        result = self._values.get("role_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to a key in a Secret that contains the App Role ID used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret
        resource is used as the app role id.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3c591a929d806d0bc633717d6ac586352f779f400859e5e98ed0ce52f7af3792)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret
        resource is used as the app role secret.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1a567a5819c4a04fddc6a249b2d5873b97787e972002e493d8366c84cf35e833)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert",
    jsii_struct_bases=[],
    name_mapping={"client_cert": "clientCert", "secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert:
    def __init__(
        self,
        *,
        client_cert: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.

        :param client_cert: ClientCert is a certificate to authenticate using the Cert Vault authentication method.
        :param secret_ref: SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert
        '''
        if isinstance(client_cert, dict):
            client_cert = ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert(**client_cert)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f25011ba998dabb5c8c1b1408c88fa08a117eed82a2c013e79cfb8818779b7df)
            check_type(argname="argument client_cert", value=client_cert, expected_type=type_hints["client_cert"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if client_cert is not None:
            self._values["client_cert"] = client_cert
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def client_cert(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert"]:
        '''ClientCert is a certificate to authenticate using the Cert Vault authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert#clientCert
        '''
        result = self._values.get("client_cert")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef"]:
        '''SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ClientCert is a certificate to authenticate using the Cert Vault authentication method.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c2ad4618f79f3d33c7e840b1487a7f1d766d69e4eb44fdf9127c82a83ab3cd28)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2be91ee51069c6922509e3c0ea70cb74f2e82e7f7a28829a95990ebbe870adf0)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam",
    jsii_struct_bases=[],
    name_mapping={
        "vault_role": "vaultRole",
        "external_id": "externalId",
        "jwt": "jwt",
        "path": "path",
        "region": "region",
        "role": "role",
        "secret_ref": "secretRef",
        "vault_aws_iam_server_id": "vaultAwsIamServerId",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam:
    def __init__(
        self,
        *,
        vault_role: builtins.str,
        external_id: typing.Optional[builtins.str] = None,
        jwt: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt", typing.Dict[builtins.str, typing.Any]]] = None,
        path: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        vault_aws_iam_server_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials AWS IAM authentication method.

        :param vault_role: Vault Role. In vault, a role describes an identity with a set of permissions, groups, or policies you want to attach a user of the secrets engine
        :param external_id: AWS External ID set on assumed IAM roles.
        :param jwt: Specify a service account with IRSA enabled.
        :param path: Path where the AWS auth method is enabled in Vault, e.g: "aws".
        :param region: AWS region.
        :param role: This is the AWS role to be assumed before talking to vault.
        :param secret_ref: Specify credentials in a Secret object.
        :param vault_aws_iam_server_id: X-Vault-AWS-IAM-Server-ID is an additional header used by Vault IAM auth method to mitigate against different types of replay attacks. More details here: https://developer.hashicorp.com/vault/docs/auth/aws

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam
        '''
        if isinstance(jwt, dict):
            jwt = ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt(**jwt)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b9b3df7c0ff0150a6463318d5b62350d5d7e04d3b1eb897eebbdd93e18a98cbf)
            check_type(argname="argument vault_role", value=vault_role, expected_type=type_hints["vault_role"])
            check_type(argname="argument external_id", value=external_id, expected_type=type_hints["external_id"])
            check_type(argname="argument jwt", value=jwt, expected_type=type_hints["jwt"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument vault_aws_iam_server_id", value=vault_aws_iam_server_id, expected_type=type_hints["vault_aws_iam_server_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vault_role": vault_role,
        }
        if external_id is not None:
            self._values["external_id"] = external_id
        if jwt is not None:
            self._values["jwt"] = jwt
        if path is not None:
            self._values["path"] = path
        if region is not None:
            self._values["region"] = region
        if role is not None:
            self._values["role"] = role
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if vault_aws_iam_server_id is not None:
            self._values["vault_aws_iam_server_id"] = vault_aws_iam_server_id

    @builtins.property
    def vault_role(self) -> builtins.str:
        '''Vault Role.

        In vault, a role describes an identity with a set of permissions, groups, or policies you want to attach a user of the secrets engine

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#vaultRole
        '''
        result = self._values.get("vault_role")
        assert result is not None, "Required property 'vault_role' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def external_id(self) -> typing.Optional[builtins.str]:
        '''AWS External ID set on assumed IAM roles.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#externalID
        '''
        result = self._values.get("external_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def jwt(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt"]:
        '''Specify a service account with IRSA enabled.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#jwt
        '''
        result = self._values.get("jwt")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt"], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''Path where the AWS auth method is enabled in Vault, e.g: "aws".

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''AWS region.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#region
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''This is the AWS role to be assumed before talking to vault.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef"]:
        '''Specify credentials in a Secret object.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef"], result)

    @builtins.property
    def vault_aws_iam_server_id(self) -> typing.Optional[builtins.str]:
        '''X-Vault-AWS-IAM-Server-ID is an additional header used by Vault IAM auth method to mitigate against different types of replay attacks.

        More details here: https://developer.hashicorp.com/vault/docs/auth/aws

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#vaultAwsIamServerID
        '''
        result = self._values.get("vault_aws_iam_server_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt",
    jsii_struct_bases=[],
    name_mapping={"service_account_ref": "serviceAccountRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt:
    def __init__(
        self,
        *,
        service_account_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Specify a service account with IRSA enabled.

        :param service_account_ref: A reference to a ServiceAccount resource.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__019f3c4eab657ae326a7dd6cf588d6c0e7fc7cd0100d6597235c2daf872a8828)
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef"]:
        '''A reference to a ServiceAccount resource.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1e4339e57d4fc718d534d25d88487de69ddec8b14087869cf5f6ec3356ac95a2)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_key_id_secret_ref": "accessKeyIdSecretRef",
        "secret_access_key_secret_ref": "secretAccessKeySecretRef",
        "session_token_secret_ref": "sessionTokenSecretRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef:
    def __init__(
        self,
        *,
        access_key_id_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_access_key_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        session_token_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Specify credentials in a Secret object.

        :param access_key_id_secret_ref: The AccessKeyID is used for authentication.
        :param secret_access_key_secret_ref: The SecretAccessKey is used for authentication.
        :param session_token_secret_ref: The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef
        '''
        if isinstance(access_key_id_secret_ref, dict):
            access_key_id_secret_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef(**access_key_id_secret_ref)
        if isinstance(secret_access_key_secret_ref, dict):
            secret_access_key_secret_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef(**secret_access_key_secret_ref)
        if isinstance(session_token_secret_ref, dict):
            session_token_secret_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef(**session_token_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4e26debb848eba1761e7a29aa1f5c26d6bb051db041f63f3fffb358634fb771f)
            check_type(argname="argument access_key_id_secret_ref", value=access_key_id_secret_ref, expected_type=type_hints["access_key_id_secret_ref"])
            check_type(argname="argument secret_access_key_secret_ref", value=secret_access_key_secret_ref, expected_type=type_hints["secret_access_key_secret_ref"])
            check_type(argname="argument session_token_secret_ref", value=session_token_secret_ref, expected_type=type_hints["session_token_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if access_key_id_secret_ref is not None:
            self._values["access_key_id_secret_ref"] = access_key_id_secret_ref
        if secret_access_key_secret_ref is not None:
            self._values["secret_access_key_secret_ref"] = secret_access_key_secret_ref
        if session_token_secret_ref is not None:
            self._values["session_token_secret_ref"] = session_token_secret_ref

    @builtins.property
    def access_key_id_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef"]:
        '''The AccessKeyID is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#accessKeyIDSecretRef
        '''
        result = self._values.get("access_key_id_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef"], result)

    @builtins.property
    def secret_access_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#secretAccessKeySecretRef
        '''
        result = self._values.get("secret_access_key_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef"], result)

    @builtins.property
    def session_token_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef"]:
        '''The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#sessionTokenSecretRef
        '''
        result = self._values.get("session_token_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeyID is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d4d492e83e6ee1993a1214e3829da5aee6ad02ebea107b47c4588ecc8720551)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29972b8bca5810c125c0e9273056ab82c6ff7aff2213cf3b23262d6e8ef82bff)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__547a0f0f9de6f03c6e61437c6cfeb30ebe2cf91ea045878f7bdb09680145ecb3)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt",
    jsii_struct_bases=[],
    name_mapping={
        "path": "path",
        "kubernetes_service_account_token": "kubernetesServiceAccountToken",
        "role": "role",
        "secret_ref": "secretRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt:
    def __init__(
        self,
        *,
        path: builtins.str,
        kubernetes_service_account_token: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken", typing.Dict[builtins.str, typing.Any]]] = None,
        role: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.

        :param path: Path where the JWT authentication backend is mounted in Vault, e.g: "jwt".
        :param kubernetes_service_account_token: Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.
        :param role: Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method.
        :param secret_ref: Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt
        '''
        if isinstance(kubernetes_service_account_token, dict):
            kubernetes_service_account_token = ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken(**kubernetes_service_account_token)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0516f9862f945b4b6129c24cc3a1ecb2da2a492e6c162dc238992faf6ad42566)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument kubernetes_service_account_token", value=kubernetes_service_account_token, expected_type=type_hints["kubernetes_service_account_token"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
        }
        if kubernetes_service_account_token is not None:
            self._values["kubernetes_service_account_token"] = kubernetes_service_account_token
        if role is not None:
            self._values["role"] = role
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the JWT authentication backend is mounted in Vault, e.g: "jwt".

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def kubernetes_service_account_token(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken"]:
        '''Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt#kubernetesServiceAccountToken
        '''
        result = self._values.get("kubernetes_service_account_token")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken"], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef"]:
        '''Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken",
    jsii_struct_bases=[],
    name_mapping={
        "service_account_ref": "serviceAccountRef",
        "audiences": "audiences",
        "expiration_seconds": "expirationSeconds",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken:
    def __init__(
        self,
        *,
        service_account_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef", typing.Dict[builtins.str, typing.Any]],
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        expiration_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :param service_account_ref: Service account field containing the name of a kubernetes ServiceAccount.
        :param audiences: Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``. Defaults to a single audience ``vault`` it not specified. Deprecated: use serviceAccountRef.Audiences instead Default: a single audience ``vault`` it not specified.
        :param expiration_seconds: Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``. Deprecated: this will be removed in the future. Defaults to 10 minutes. Default: 10 minutes.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9635b4909e716c335632ee7fbb0defc729d2aa215fa0e2ecf9b58c670ed974b)
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument expiration_seconds", value=expiration_seconds, expected_type=type_hints["expiration_seconds"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "service_account_ref": service_account_ref,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if expiration_seconds is not None:
            self._values["expiration_seconds"] = expiration_seconds

    @builtins.property
    def service_account_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef":
        '''Service account field containing the name of a kubernetes ServiceAccount.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        assert result is not None, "Required property 'service_account_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef", result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``.

        Defaults to a single audience ``vault`` it not specified.
        Deprecated: use serviceAccountRef.Audiences instead

        :default: a single audience ``vault`` it not specified.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def expiration_seconds(self) -> typing.Optional[jsii.Number]:
        '''Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``.

        Deprecated: this will be removed in the future.
        Defaults to 10 minutes.

        :default: 10 minutes.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#expirationSeconds
        '''
        result = self._values.get("expiration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Service account field containing the name of a kubernetes ServiceAccount.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__503a402a2f8a60f71248b4d66efb68127bb876fab9dc95581f2ab8c3dc6766f7)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__27456e5e3297f3a6c07e214fd809cfe592c755afe64370c36586faf0b4ff536a)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes",
    jsii_struct_bases=[],
    name_mapping={
        "mount_path": "mountPath",
        "role": "role",
        "secret_ref": "secretRef",
        "service_account_ref": "serviceAccountRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes:
    def __init__(
        self,
        *,
        mount_path: builtins.str,
        role: builtins.str,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.

        :param mount_path: Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes".
        :param role: A required field containing the Vault Role to assume. A Role binds a Kubernetes ServiceAccount with a set of Vault policies.
        :param secret_ref: Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.
        :param service_account_ref: Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef(**secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e3234a480af19889bfdd0bcf31963e9ffcca79ad4549d1c673c3d21aa0be1f89)
            check_type(argname="argument mount_path", value=mount_path, expected_type=type_hints["mount_path"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "mount_path": mount_path,
            "role": role,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def mount_path(self) -> builtins.str:
        '''Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes".

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes#mountPath
        '''
        result = self._values.get("mount_path")
        assert result is not None, "Required property 'mount_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role(self) -> builtins.str:
        '''A required field containing the Vault Role to assume.

        A Role binds a
        Kubernetes ServiceAccount with a set of Vault policies.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes#role
        '''
        result = self._values.get("role")
        assert result is not None, "Required property 'role' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef"]:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault.

        If a name is specified without a key,
        ``token`` is the default. If one is not specified, the one bound to
        the controller will be used.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef"]:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used
        for authenticating with Vault. If the service account selector is not supplied,
        the secretRef will be used instead.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault.

        If a name is specified without a key,
        ``token`` is the default. If one is not specified, the one bound to
        the controller will be used.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a7c01ad25d6903e2b94170c5306163dc83c37d167d03d2e947b8dfbce92360c9)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used
        for authenticating with Vault. If the service account selector is not supplied,
        the secretRef will be used instead.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__68e19fd3a505ed8443bd824708b4f25994c9d40acb32b52b89a503ed39bc5c8e)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "username": "username", "secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap:
    def __init__(
        self,
        *,
        path: builtins.str,
        username: builtins.str,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.

        :param path: Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap".
        :param username: Username is a LDAP user name used to authenticate using the LDAP Vault authentication method.
        :param secret_ref: SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e8f4902f761c246ffc6f920fc8bd963e2f8140fd3d65b4da75c7025dcec6765c)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
            "username": username,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap".

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def username(self) -> builtins.str:
        '''Username is a LDAP user name used to authenticate using the LDAP Vault authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap#username
        '''
        result = self._values.get("username")
        assert result is not None, "Required property 'username' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef"]:
        '''SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a061597668e45a3b5881fb989859fa9ba9fa59812f88447e7d1fb50d91d4578c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''TokenSecretRef authenticates with Vault by presenting a token.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f030b58112bf019c388c92034c3321dfa7a6cf28ed27ede3f4de94d581d5035b)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "username": "username", "secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass:
    def __init__(
        self,
        *,
        path: builtins.str,
        username: builtins.str,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''UserPass authenticates with Vault by passing username/password pair.

        :param path: Path where the UserPassword authentication backend is mounted in Vault, e.g: "user".
        :param username: Username is a user name used to authenticate using the UserPass Vault authentication method.
        :param secret_ref: SecretRef to a key in a Secret resource containing password for the user used to authenticate with Vault using the UserPass authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c0b94cc77dbc9bf5d277f712c6c780f02d800403f0170161b6ce6b1c7f0fb83)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
            "username": username,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the UserPassword authentication backend is mounted in Vault, e.g: "user".

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def username(self) -> builtins.str:
        '''Username is a user name used to authenticate using the UserPass Vault authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass#username
        '''
        result = self._values.get("username")
        assert result is not None, "Required property 'username' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef"]:
        '''SecretRef to a key in a Secret resource containing password for the user used to authenticate with Vault using the UserPass authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef to a key in a Secret resource containing password for the user used to authenticate with Vault using the UserPass authentication method.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e305806b5153df3a1a44c0688c27cfc4e9ac43a5df5c628abb8767da22caba6d)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Vault server certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__614ead02a45818d7b842fdb84071c31ffdc2fa1b565a7ebdc48c6a9773ceeb9e)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        Can only be defined when used in a ClusterSecretStore.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType"
)
class ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultTls",
    jsii_struct_bases=[],
    name_mapping={
        "cert_secret_ref": "certSecretRef",
        "key_secret_ref": "keySecretRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderVaultTls:
    def __init__(
        self,
        *,
        cert_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        key_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''The configuration used for client side related TLS communication, when the Vault server requires mutual authentication.

        Only used if the Server URL is using HTTPS protocol.
        This parameter is ignored for plain HTTP protocol connection.
        It's worth noting this configuration is different from the "TLS certificates auth method",
        which is available under the ``auth.cert`` section.

        :param cert_secret_ref: CertSecretRef is a certificate added to the transport layer when communicating with the Vault server. If no key for the Secret is specified, external-secret will default to 'tls.crt'.
        :param key_secret_ref: KeySecretRef to a key in a Secret resource containing client private key added to the transport layer when communicating with the Vault server. If no key for the Secret is specified, external-secret will default to 'tls.key'.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultTls
        '''
        if isinstance(cert_secret_ref, dict):
            cert_secret_ref = ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef(**cert_secret_ref)
        if isinstance(key_secret_ref, dict):
            key_secret_ref = ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef(**key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__60e9db85165a8f05f9caf59c9ac1e9d32997804e3ffd2311317fbadc5f4781a4)
            check_type(argname="argument cert_secret_ref", value=cert_secret_ref, expected_type=type_hints["cert_secret_ref"])
            check_type(argname="argument key_secret_ref", value=key_secret_ref, expected_type=type_hints["key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cert_secret_ref is not None:
            self._values["cert_secret_ref"] = cert_secret_ref
        if key_secret_ref is not None:
            self._values["key_secret_ref"] = key_secret_ref

    @builtins.property
    def cert_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef"]:
        '''CertSecretRef is a certificate added to the transport layer when communicating with the Vault server.

        If no key for the Secret is specified, external-secret will default to 'tls.crt'.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultTls#certSecretRef
        '''
        result = self._values.get("cert_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef"], result)

    @builtins.property
    def key_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef"]:
        '''KeySecretRef to a key in a Secret resource containing client private key added to the transport layer when communicating with the Vault server.

        If no key for the Secret is specified, external-secret will default to 'tls.key'.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultTls#keySecretRef
        '''
        result = self._values.get("key_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''CertSecretRef is a certificate added to the transport layer when communicating with the Vault server.

        If no key for the Secret is specified, external-secret will default to 'tls.crt'.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__01682b1e5411c8e610560ab926f0f147190ed85dfac508657bb97191c51301b8)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''KeySecretRef to a key in a Secret resource containing client private key added to the transport layer when communicating with the Vault server.

        If no key for the Secret is specified, external-secret will default to 'tls.key'.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__be1cc6ff896b92e00f1824eb023193a80c1e140bd11b60acb0549f8bb4fd2523)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultVersion"
)
class ClusterSecretStoreV1Beta1SpecProviderVaultVersion(enum.Enum):
    '''Version is the Vault KV secret engine version.

    This can be either "v1" or
    "v2". Version defaults to "v2".

    :schema: ClusterSecretStoreV1Beta1SpecProviderVaultVersion
    '''

    V1 = "V1"
    '''v1.'''
    V2 = "V2"
    '''v2.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderWebhook",
    jsii_struct_bases=[],
    name_mapping={
        "result": "result",
        "url": "url",
        "body": "body",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
        "headers": "headers",
        "method": "method",
        "secrets": "secrets",
        "timeout": "timeout",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderWebhook:
    def __init__(
        self,
        *,
        result: typing.Union["ClusterSecretStoreV1Beta1SpecProviderWebhookResult", typing.Dict[builtins.str, typing.Any]],
        url: builtins.str,
        body: typing.Optional[builtins.str] = None,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
        headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        method: typing.Optional[builtins.str] = None,
        secrets: typing.Optional[typing.Sequence[typing.Union["ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets", typing.Dict[builtins.str, typing.Any]]]] = None,
        timeout: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Webhook configures this store to sync secrets using a generic templated webhook.

        :param result: Result formatting.
        :param url: Webhook url to call.
        :param body: Body.
        :param ca_bundle: PEM encoded CA bundle used to validate webhook server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
        :param ca_provider: The provider for the CA bundle to use to validate webhook server certificate.
        :param headers: Headers.
        :param method: Webhook Method.
        :param secrets: Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name.
        :param timeout: Timeout.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhook
        '''
        if isinstance(result, dict):
            result = ClusterSecretStoreV1Beta1SpecProviderWebhookResult(**result)
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__541a85086d1f97223810cca4d54c92f289ed5a73007e8e7009b98285d97578ca)
            check_type(argname="argument result", value=result, expected_type=type_hints["result"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
            check_type(argname="argument body", value=body, expected_type=type_hints["body"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument headers", value=headers, expected_type=type_hints["headers"])
            check_type(argname="argument method", value=method, expected_type=type_hints["method"])
            check_type(argname="argument secrets", value=secrets, expected_type=type_hints["secrets"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "result": result,
            "url": url,
        }
        if body is not None:
            self._values["body"] = body
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if headers is not None:
            self._values["headers"] = headers
        if method is not None:
            self._values["method"] = method
        if secrets is not None:
            self._values["secrets"] = secrets
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def result(self) -> "ClusterSecretStoreV1Beta1SpecProviderWebhookResult":
        '''Result formatting.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhook#result
        '''
        result = self._values.get("result")
        assert result is not None, "Required property 'result' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderWebhookResult", result)

    @builtins.property
    def url(self) -> builtins.str:
        '''Webhook url to call.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhook#url
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def body(self) -> typing.Optional[builtins.str]:
        '''Body.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhook#body
        '''
        result = self._values.get("body")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''PEM encoded CA bundle used to validate webhook server certificate.

        Only used
        if the Server URL is using HTTPS protocol. This parameter is ignored for
        plain HTTP protocol connection. If not set the system root certificates
        are used to validate the TLS connection.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhook#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider"]:
        '''The provider for the CA bundle to use to validate webhook server certificate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhook#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider"], result)

    @builtins.property
    def headers(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Headers.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhook#headers
        '''
        result = self._values.get("headers")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def method(self) -> typing.Optional[builtins.str]:
        '''Webhook Method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhook#method
        '''
        result = self._values.get("method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secrets(
        self,
    ) -> typing.Optional[typing.List["ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets"]]:
        '''Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhook#secrets
        '''
        result = self._values.get("secrets")
        return typing.cast(typing.Optional[typing.List["ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets"]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[builtins.str]:
        '''Timeout.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhook#timeout
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderWebhook(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate webhook server certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__68283da0c213c61ac76c8b9dc18fd6a446a8666903a6779c4e450ffbb7638d41)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType"
)
class ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderWebhookResult",
    jsii_struct_bases=[],
    name_mapping={"json_path": "jsonPath"},
)
class ClusterSecretStoreV1Beta1SpecProviderWebhookResult:
    def __init__(self, *, json_path: typing.Optional[builtins.str] = None) -> None:
        '''Result formatting.

        :param json_path: Json path of return value.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookResult
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ffe032a875d453ef67efba038253b55e781313fcf9727a2e190e0f07bc7a7781)
            check_type(argname="argument json_path", value=json_path, expected_type=type_hints["json_path"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if json_path is not None:
            self._values["json_path"] = json_path

    @builtins.property
    def json_path(self) -> typing.Optional[builtins.str]:
        '''Json path of return value.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookResult#jsonPath
        '''
        result = self._values.get("json_path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderWebhookResult(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets:
    def __init__(
        self,
        *,
        name: builtins.str,
        secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param name: Name of this secret in templates.
        :param secret_ref: Secret ref to fill in credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a4adfaf99cc3249a4b88e7b23a2ff492e444c10ff063c6260a50441d20189774)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "secret_ref": secret_ref,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of this secret in templates.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef":
        '''Secret ref to fill in credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Secret ref to fill in credentials.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b04a124282f6cc28a9350a757f666203390ebbfddda7e54a523fdeba3026ceaa)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "api_endpoint": "apiEndpoint",
        "ca_provider": "caProvider",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth", typing.Dict[builtins.str, typing.Any]],
        api_endpoint: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider.

        :param auth: Auth defines the information necessary to authenticate against Yandex Certificate Manager.
        :param api_endpoint: Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').
        :param ca_provider: The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ff9cd98361d4846493719df1ded33affcd4d8eace2485af38ef75d671c1dfbb)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument api_endpoint", value=api_endpoint, expected_type=type_hints["api_endpoint"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
        }
        if api_endpoint is not None:
            self._values["api_endpoint"] = api_endpoint
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider

    @builtins.property
    def auth(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth":
        '''Auth defines the information necessary to authenticate against Yandex Certificate Manager.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth", result)

    @builtins.property
    def api_endpoint(self) -> typing.Optional[builtins.str]:
        '''Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager#apiEndpoint
        '''
        result = self._values.get("api_endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider"]:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth",
    jsii_struct_bases=[],
    name_mapping={"authorized_key_secret_ref": "authorizedKeySecretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth:
    def __init__(
        self,
        *,
        authorized_key_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against Yandex Certificate Manager.

        :param authorized_key_secret_ref: The authorized key used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth
        '''
        if isinstance(authorized_key_secret_ref, dict):
            authorized_key_secret_ref = ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(**authorized_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__51a1a90bc0ea5f1d7006ba171eeb03cabe219c2e3b1a59e18c03f47111a2886e)
            check_type(argname="argument authorized_key_secret_ref", value=authorized_key_secret_ref, expected_type=type_hints["authorized_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if authorized_key_secret_ref is not None:
            self._values["authorized_key_secret_ref"] = authorized_key_secret_ref

    @builtins.property
    def authorized_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef"]:
        '''The authorized key used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth#authorizedKeySecretRef
        '''
        result = self._values.get("authorized_key_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The authorized key used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c5002745ef7984d16f7c455def03b6a31678dc133c5daf8bf4c6847270703834)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider",
    jsii_struct_bases=[],
    name_mapping={"cert_secret_ref": "certSecretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider:
    def __init__(
        self,
        *,
        cert_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :param cert_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider
        '''
        if isinstance(cert_secret_ref, dict):
            cert_secret_ref = ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef(**cert_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb4082ecd7921b9fbfec3f37b117a6e5cbf96687643a0da1deb5e9606facb5cb)
            check_type(argname="argument cert_secret_ref", value=cert_secret_ref, expected_type=type_hints["cert_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cert_secret_ref is not None:
            self._values["cert_secret_ref"] = cert_secret_ref

    @builtins.property
    def cert_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider#certSecretRef
        '''
        result = self._values.get("cert_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__031cafe781180219b4b5259d9846e47719fde28b6e66b15223a100bd6914f19f)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderYandexlockbox",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "api_endpoint": "apiEndpoint",
        "ca_provider": "caProvider",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderYandexlockbox:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth", typing.Dict[builtins.str, typing.Any]],
        api_endpoint: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :param auth: Auth defines the information necessary to authenticate against Yandex Lockbox.
        :param api_endpoint: Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').
        :param ca_provider: The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockbox
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d723d21a6c0b24e7b6edf9808d7e46ac0dbf01d99571c220621355462524b02)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument api_endpoint", value=api_endpoint, expected_type=type_hints["api_endpoint"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
        }
        if api_endpoint is not None:
            self._values["api_endpoint"] = api_endpoint
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth":
        '''Auth defines the information necessary to authenticate against Yandex Lockbox.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockbox#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth", result)

    @builtins.property
    def api_endpoint(self) -> typing.Optional[builtins.str]:
        '''Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockbox#apiEndpoint
        '''
        result = self._values.get("api_endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider"]:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockbox#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderYandexlockbox(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth",
    jsii_struct_bases=[],
    name_mapping={"authorized_key_secret_ref": "authorizedKeySecretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth:
    def __init__(
        self,
        *,
        authorized_key_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against Yandex Lockbox.

        :param authorized_key_secret_ref: The authorized key used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth
        '''
        if isinstance(authorized_key_secret_ref, dict):
            authorized_key_secret_ref = ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef(**authorized_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__550fc853f971ebf114ea0c29cde1e781f93eb593ff32b6f1d018ad5990e4710f)
            check_type(argname="argument authorized_key_secret_ref", value=authorized_key_secret_ref, expected_type=type_hints["authorized_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if authorized_key_secret_ref is not None:
            self._values["authorized_key_secret_ref"] = authorized_key_secret_ref

    @builtins.property
    def authorized_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef"]:
        '''The authorized key used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth#authorizedKeySecretRef
        '''
        result = self._values.get("authorized_key_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The authorized key used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c3f7bb16b26a20247381202a6e31627cab93618b40ec15086c087dff5bf26be9)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider",
    jsii_struct_bases=[],
    name_mapping={"cert_secret_ref": "certSecretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider:
    def __init__(
        self,
        *,
        cert_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :param cert_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider
        '''
        if isinstance(cert_secret_ref, dict):
            cert_secret_ref = ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef(**cert_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64744aa417489ee5da00031086b34f8bb9d5d1e2842de076efd366b85e968725)
            check_type(argname="argument cert_secret_ref", value=cert_secret_ref, expected_type=type_hints["cert_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cert_secret_ref is not None:
            self._values["cert_secret_ref"] = cert_secret_ref

    @builtins.property
    def cert_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider#certSecretRef
        '''
        result = self._values.get("cert_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e64f2aba41167a866d087c9b87db2a78c49a3c78a857f4d63a3332b8dc04c173)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecRetrySettings",
    jsii_struct_bases=[],
    name_mapping={"max_retries": "maxRetries", "retry_interval": "retryInterval"},
)
class ClusterSecretStoreV1Beta1SpecRetrySettings:
    def __init__(
        self,
        *,
        max_retries: typing.Optional[jsii.Number] = None,
        retry_interval: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Used to configure http retries if failed.

        :param max_retries: 
        :param retry_interval: 

        :schema: ClusterSecretStoreV1Beta1SpecRetrySettings
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6cfd20d24fce68320069ccd4f9b78ce19df25d0bfb6d04f99d46f3caf0d6c97e)
            check_type(argname="argument max_retries", value=max_retries, expected_type=type_hints["max_retries"])
            check_type(argname="argument retry_interval", value=retry_interval, expected_type=type_hints["retry_interval"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if max_retries is not None:
            self._values["max_retries"] = max_retries
        if retry_interval is not None:
            self._values["retry_interval"] = retry_interval

    @builtins.property
    def max_retries(self) -> typing.Optional[jsii.Number]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecRetrySettings#maxRetries
        '''
        result = self._values.get("max_retries")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def retry_interval(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecRetrySettings#retryInterval
        '''
        result = self._values.get("retry_interval")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecRetrySettings(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ExternalSecret(
    _cdk8s_d3d9af27.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="ioexternal-secrets.ExternalSecret",
):
    '''ExternalSecret is the Schema for the external-secrets API.

    :schema: ExternalSecret
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ExternalSecretSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a "ExternalSecret" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param metadata: 
        :param spec: ExternalSecretSpec defines the desired state of ExternalSecret.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c3b70f22c7723f819f402a6957ab71e8991db57a58ba85047be7a2faaad81e0)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ExternalSecretProps(metadata=metadata, spec=spec)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest")
    @builtins.classmethod
    def manifest(
        cls,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ExternalSecretSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> typing.Any:
        '''Renders a Kubernetes manifest for "ExternalSecret".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param metadata: 
        :param spec: ExternalSecretSpec defines the desired state of ExternalSecret.
        '''
        props = ExternalSecretProps(metadata=metadata, spec=spec)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''Renders the object to Kubernetes JSON.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> _cdk8s_d3d9af27.GroupVersionKind:
        '''Returns the apiVersion and kind for "ExternalSecret".'''
        return typing.cast(_cdk8s_d3d9af27.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretProps",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class ExternalSecretProps:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ExternalSecretSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''ExternalSecret is the Schema for the external-secrets API.

        :param metadata: 
        :param spec: ExternalSecretSpec defines the desired state of ExternalSecret.

        :schema: ExternalSecret
        '''
        if isinstance(metadata, dict):
            metadata = _cdk8s_d3d9af27.ApiObjectMetadata(**metadata)
        if isinstance(spec, dict):
            spec = ExternalSecretSpec(**spec)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__37e904970e3dbc8f880d53222da8b9d6ad0e642ffbccba70fe72cb9cdfbe3289)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(self) -> typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata]:
        '''
        :schema: ExternalSecret#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata], result)

    @builtins.property
    def spec(self) -> typing.Optional["ExternalSecretSpec"]:
        '''ExternalSecretSpec defines the desired state of ExternalSecret.

        :schema: ExternalSecret#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["ExternalSecretSpec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpec",
    jsii_struct_bases=[],
    name_mapping={
        "secret_store_ref": "secretStoreRef",
        "target": "target",
        "data": "data",
        "data_from": "dataFrom",
        "refresh_interval": "refreshInterval",
    },
)
class ExternalSecretSpec:
    def __init__(
        self,
        *,
        secret_store_ref: typing.Union["ExternalSecretSpecSecretStoreRef", typing.Dict[builtins.str, typing.Any]],
        target: typing.Union["ExternalSecretSpecTarget", typing.Dict[builtins.str, typing.Any]],
        data: typing.Optional[typing.Sequence[typing.Union["ExternalSecretSpecData", typing.Dict[builtins.str, typing.Any]]]] = None,
        data_from: typing.Optional[typing.Sequence[typing.Union["ExternalSecretSpecDataFrom", typing.Dict[builtins.str, typing.Any]]]] = None,
        refresh_interval: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ExternalSecretSpec defines the desired state of ExternalSecret.

        :param secret_store_ref: SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
        :param target: ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.
        :param data: Data defines the connection between the Kubernetes Secret keys and the Provider data.
        :param data_from: DataFrom is used to fetch all properties from a specific Provider data If multiple entries are specified, the Secret keys are merged in the specified order.
        :param refresh_interval: RefreshInterval is the amount of time before the values are read again from the SecretStore provider Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h" May be set to zero to fetch and create it once. Defaults to 1h. Default: 1h.

        :schema: ExternalSecretSpec
        '''
        if isinstance(secret_store_ref, dict):
            secret_store_ref = ExternalSecretSpecSecretStoreRef(**secret_store_ref)
        if isinstance(target, dict):
            target = ExternalSecretSpecTarget(**target)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__074b53f8506e2f7772a36a26ed9736680e0342754c5f0ccf2218c6fef874937d)
            check_type(argname="argument secret_store_ref", value=secret_store_ref, expected_type=type_hints["secret_store_ref"])
            check_type(argname="argument target", value=target, expected_type=type_hints["target"])
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
            check_type(argname="argument data_from", value=data_from, expected_type=type_hints["data_from"])
            check_type(argname="argument refresh_interval", value=refresh_interval, expected_type=type_hints["refresh_interval"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_store_ref": secret_store_ref,
            "target": target,
        }
        if data is not None:
            self._values["data"] = data
        if data_from is not None:
            self._values["data_from"] = data_from
        if refresh_interval is not None:
            self._values["refresh_interval"] = refresh_interval

    @builtins.property
    def secret_store_ref(self) -> "ExternalSecretSpecSecretStoreRef":
        '''SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :schema: ExternalSecretSpec#secretStoreRef
        '''
        result = self._values.get("secret_store_ref")
        assert result is not None, "Required property 'secret_store_ref' is missing"
        return typing.cast("ExternalSecretSpecSecretStoreRef", result)

    @builtins.property
    def target(self) -> "ExternalSecretSpecTarget":
        '''ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.

        :schema: ExternalSecretSpec#target
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast("ExternalSecretSpecTarget", result)

    @builtins.property
    def data(self) -> typing.Optional[typing.List["ExternalSecretSpecData"]]:
        '''Data defines the connection between the Kubernetes Secret keys and the Provider data.

        :schema: ExternalSecretSpec#data
        '''
        result = self._values.get("data")
        return typing.cast(typing.Optional[typing.List["ExternalSecretSpecData"]], result)

    @builtins.property
    def data_from(self) -> typing.Optional[typing.List["ExternalSecretSpecDataFrom"]]:
        '''DataFrom is used to fetch all properties from a specific Provider data If multiple entries are specified, the Secret keys are merged in the specified order.

        :schema: ExternalSecretSpec#dataFrom
        '''
        result = self._values.get("data_from")
        return typing.cast(typing.Optional[typing.List["ExternalSecretSpecDataFrom"]], result)

    @builtins.property
    def refresh_interval(self) -> typing.Optional[builtins.str]:
        '''RefreshInterval is the amount of time before the values are read again from the SecretStore provider Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h" May be set to zero to fetch and create it once.

        Defaults to 1h.

        :default: 1h.

        :schema: ExternalSecretSpec#refreshInterval
        '''
        result = self._values.get("refresh_interval")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecData",
    jsii_struct_bases=[],
    name_mapping={"remote_ref": "remoteRef", "secret_key": "secretKey"},
)
class ExternalSecretSpecData:
    def __init__(
        self,
        *,
        remote_ref: typing.Union["ExternalSecretSpecDataRemoteRef", typing.Dict[builtins.str, typing.Any]],
        secret_key: builtins.str,
    ) -> None:
        '''ExternalSecretData defines the connection between the Kubernetes Secret key (spec.data.) and the Provider data.

        :param remote_ref: ExternalSecretDataRemoteRef defines Provider data location.
        :param secret_key: The key in the Kubernetes Secret to store the value.

        :schema: ExternalSecretSpecData
        '''
        if isinstance(remote_ref, dict):
            remote_ref = ExternalSecretSpecDataRemoteRef(**remote_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__475d807ac9fbc706d9ba6234ed898b602897f6af687b51a5cfabc7a77de0d4ce)
            check_type(argname="argument remote_ref", value=remote_ref, expected_type=type_hints["remote_ref"])
            check_type(argname="argument secret_key", value=secret_key, expected_type=type_hints["secret_key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "remote_ref": remote_ref,
            "secret_key": secret_key,
        }

    @builtins.property
    def remote_ref(self) -> "ExternalSecretSpecDataRemoteRef":
        '''ExternalSecretDataRemoteRef defines Provider data location.

        :schema: ExternalSecretSpecData#remoteRef
        '''
        result = self._values.get("remote_ref")
        assert result is not None, "Required property 'remote_ref' is missing"
        return typing.cast("ExternalSecretSpecDataRemoteRef", result)

    @builtins.property
    def secret_key(self) -> builtins.str:
        '''The key in the Kubernetes Secret to store the value.

        :schema: ExternalSecretSpecData#secretKey
        '''
        result = self._values.get("secret_key")
        assert result is not None, "Required property 'secret_key' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecData(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecDataFrom",
    jsii_struct_bases=[],
    name_mapping={
        "key": "key",
        "conversion_strategy": "conversionStrategy",
        "property": "property",
        "version": "version",
    },
)
class ExternalSecretSpecDataFrom:
    def __init__(
        self,
        *,
        key: builtins.str,
        conversion_strategy: typing.Optional["ExternalSecretSpecDataFromConversionStrategy"] = None,
        property: typing.Optional[builtins.str] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ExternalSecretDataRemoteRef defines Provider data location.

        :param key: Key is the key used in the Provider, mandatory.
        :param conversion_strategy: Used to define a conversion Strategy.
        :param property: Used to select a specific property of the Provider value (if a map), if supported.
        :param version: Used to select a specific version of the Provider value, if supported.

        :schema: ExternalSecretSpecDataFrom
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5652c1cf0894311801be60a13dd81647750db80e32bc8f49fe3e8235021c6c91)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument conversion_strategy", value=conversion_strategy, expected_type=type_hints["conversion_strategy"])
            check_type(argname="argument property", value=property, expected_type=type_hints["property"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
        }
        if conversion_strategy is not None:
            self._values["conversion_strategy"] = conversion_strategy
        if property is not None:
            self._values["property"] = property
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def key(self) -> builtins.str:
        '''Key is the key used in the Provider, mandatory.

        :schema: ExternalSecretSpecDataFrom#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def conversion_strategy(
        self,
    ) -> typing.Optional["ExternalSecretSpecDataFromConversionStrategy"]:
        '''Used to define a conversion Strategy.

        :schema: ExternalSecretSpecDataFrom#conversionStrategy
        '''
        result = self._values.get("conversion_strategy")
        return typing.cast(typing.Optional["ExternalSecretSpecDataFromConversionStrategy"], result)

    @builtins.property
    def property(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific property of the Provider value (if a map), if supported.

        :schema: ExternalSecretSpecDataFrom#property
        '''
        result = self._values.get("property")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific version of the Provider value, if supported.

        :schema: ExternalSecretSpecDataFrom#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecDataFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.ExternalSecretSpecDataFromConversionStrategy")
class ExternalSecretSpecDataFromConversionStrategy(enum.Enum):
    '''Used to define a conversion Strategy.

    :schema: ExternalSecretSpecDataFromConversionStrategy
    '''

    DEFAULT = "DEFAULT"
    '''Default.'''
    UNICODE = "UNICODE"
    '''Unicode.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecDataRemoteRef",
    jsii_struct_bases=[],
    name_mapping={
        "key": "key",
        "conversion_strategy": "conversionStrategy",
        "property": "property",
        "version": "version",
    },
)
class ExternalSecretSpecDataRemoteRef:
    def __init__(
        self,
        *,
        key: builtins.str,
        conversion_strategy: typing.Optional["ExternalSecretSpecDataRemoteRefConversionStrategy"] = None,
        property: typing.Optional[builtins.str] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ExternalSecretDataRemoteRef defines Provider data location.

        :param key: Key is the key used in the Provider, mandatory.
        :param conversion_strategy: Used to define a conversion Strategy.
        :param property: Used to select a specific property of the Provider value (if a map), if supported.
        :param version: Used to select a specific version of the Provider value, if supported.

        :schema: ExternalSecretSpecDataRemoteRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8fa135eb71c3b0e514a59fb4221d3694ecf54b320c828591b0435c574fdfb02c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument conversion_strategy", value=conversion_strategy, expected_type=type_hints["conversion_strategy"])
            check_type(argname="argument property", value=property, expected_type=type_hints["property"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
        }
        if conversion_strategy is not None:
            self._values["conversion_strategy"] = conversion_strategy
        if property is not None:
            self._values["property"] = property
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def key(self) -> builtins.str:
        '''Key is the key used in the Provider, mandatory.

        :schema: ExternalSecretSpecDataRemoteRef#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def conversion_strategy(
        self,
    ) -> typing.Optional["ExternalSecretSpecDataRemoteRefConversionStrategy"]:
        '''Used to define a conversion Strategy.

        :schema: ExternalSecretSpecDataRemoteRef#conversionStrategy
        '''
        result = self._values.get("conversion_strategy")
        return typing.cast(typing.Optional["ExternalSecretSpecDataRemoteRefConversionStrategy"], result)

    @builtins.property
    def property(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific property of the Provider value (if a map), if supported.

        :schema: ExternalSecretSpecDataRemoteRef#property
        '''
        result = self._values.get("property")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific version of the Provider value, if supported.

        :schema: ExternalSecretSpecDataRemoteRef#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecDataRemoteRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretSpecDataRemoteRefConversionStrategy"
)
class ExternalSecretSpecDataRemoteRefConversionStrategy(enum.Enum):
    '''Used to define a conversion Strategy.

    :schema: ExternalSecretSpecDataRemoteRefConversionStrategy
    '''

    DEFAULT = "DEFAULT"
    '''Default.'''
    UNICODE = "UNICODE"
    '''Unicode.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecSecretStoreRef",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "name": "name"},
)
class ExternalSecretSpecSecretStoreRef:
    def __init__(
        self,
        *,
        kind: typing.Optional["ExternalSecretSpecSecretStoreRefKind"] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :param kind: Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``. Default: SecretStore`
        :param name: Name of the SecretStore resource.

        :schema: ExternalSecretSpecSecretStoreRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6387a5fae9528a5204090c40d2c2889305f5e0931cd3c9f56f16b857a47f6aab)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if kind is not None:
            self._values["kind"] = kind
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def kind(self) -> typing.Optional["ExternalSecretSpecSecretStoreRefKind"]:
        '''Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``.

        :default: SecretStore`

        :schema: ExternalSecretSpecSecretStoreRef#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional["ExternalSecretSpecSecretStoreRefKind"], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the SecretStore resource.

        :schema: ExternalSecretSpecSecretStoreRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecSecretStoreRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.ExternalSecretSpecSecretStoreRefKind")
class ExternalSecretSpecSecretStoreRefKind(enum.Enum):
    '''Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``.

    :default: SecretStore`

    :schema: ExternalSecretSpecSecretStoreRefKind
    '''

    SECRET_STORE = "SECRET_STORE"
    '''SecretStore.'''
    CLUSTER_SECRET_STORE = "CLUSTER_SECRET_STORE"
    '''ClusterSecretStore.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecTarget",
    jsii_struct_bases=[],
    name_mapping={
        "creation_policy": "creationPolicy",
        "immutable": "immutable",
        "name": "name",
        "template": "template",
    },
)
class ExternalSecretSpecTarget:
    def __init__(
        self,
        *,
        creation_policy: typing.Optional["ExternalSecretSpecTargetCreationPolicy"] = None,
        immutable: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
        template: typing.Optional[typing.Union["ExternalSecretSpecTargetTemplate", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.

        :param creation_policy: CreationPolicy defines rules on how to create the resulting Secret. Defaults to "Owner" Default: Owner"
        :param immutable: Immutable defines if the final secret will be immutable.
        :param name: The name of the Secret resource to be managed. Defaults to the .metadata.name of the ExternalSecret resource Default: the .metadata.name of the ExternalSecret resource
        :param template: Template defines a blueprint for the created Secret resource.

        :schema: ExternalSecretSpecTarget
        '''
        if isinstance(template, dict):
            template = ExternalSecretSpecTargetTemplate(**template)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__827bc50a1daa2c072beabe447d39f5aa425b2533370b434284005378aa9a35c4)
            check_type(argname="argument creation_policy", value=creation_policy, expected_type=type_hints["creation_policy"])
            check_type(argname="argument immutable", value=immutable, expected_type=type_hints["immutable"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument template", value=template, expected_type=type_hints["template"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if creation_policy is not None:
            self._values["creation_policy"] = creation_policy
        if immutable is not None:
            self._values["immutable"] = immutable
        if name is not None:
            self._values["name"] = name
        if template is not None:
            self._values["template"] = template

    @builtins.property
    def creation_policy(
        self,
    ) -> typing.Optional["ExternalSecretSpecTargetCreationPolicy"]:
        '''CreationPolicy defines rules on how to create the resulting Secret.

        Defaults to "Owner"

        :default: Owner"

        :schema: ExternalSecretSpecTarget#creationPolicy
        '''
        result = self._values.get("creation_policy")
        return typing.cast(typing.Optional["ExternalSecretSpecTargetCreationPolicy"], result)

    @builtins.property
    def immutable(self) -> typing.Optional[builtins.bool]:
        '''Immutable defines if the final secret will be immutable.

        :schema: ExternalSecretSpecTarget#immutable
        '''
        result = self._values.get("immutable")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource to be managed.

        Defaults to the .metadata.name of the ExternalSecret resource

        :default: the .metadata.name of the ExternalSecret resource

        :schema: ExternalSecretSpecTarget#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def template(self) -> typing.Optional["ExternalSecretSpecTargetTemplate"]:
        '''Template defines a blueprint for the created Secret resource.

        :schema: ExternalSecretSpecTarget#template
        '''
        result = self._values.get("template")
        return typing.cast(typing.Optional["ExternalSecretSpecTargetTemplate"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecTarget(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.ExternalSecretSpecTargetCreationPolicy")
class ExternalSecretSpecTargetCreationPolicy(enum.Enum):
    '''CreationPolicy defines rules on how to create the resulting Secret.

    Defaults to "Owner"

    :default: Owner"

    :schema: ExternalSecretSpecTargetCreationPolicy
    '''

    OWNER = "OWNER"
    '''Owner.'''
    MERGE = "MERGE"
    '''Merge.'''
    NONE = "NONE"
    '''None.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecTargetTemplate",
    jsii_struct_bases=[],
    name_mapping={
        "data": "data",
        "engine_version": "engineVersion",
        "metadata": "metadata",
        "template_from": "templateFrom",
        "type": "type",
    },
)
class ExternalSecretSpecTargetTemplate:
    def __init__(
        self,
        *,
        data: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        engine_version: typing.Optional["ExternalSecretSpecTargetTemplateEngineVersion"] = None,
        metadata: typing.Optional[typing.Union["ExternalSecretSpecTargetTemplateMetadata", typing.Dict[builtins.str, typing.Any]]] = None,
        template_from: typing.Optional[typing.Sequence[typing.Union["ExternalSecretSpecTargetTemplateTemplateFrom", typing.Dict[builtins.str, typing.Any]]]] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Template defines a blueprint for the created Secret resource.

        :param data: 
        :param engine_version: EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].
        :param metadata: ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
        :param template_from: 
        :param type: 

        :schema: ExternalSecretSpecTargetTemplate
        '''
        if isinstance(metadata, dict):
            metadata = ExternalSecretSpecTargetTemplateMetadata(**metadata)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8a97a9d748a88e76340582885a47a889666e169b36bf601e948fa8fbaf8eacb8)
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
            check_type(argname="argument engine_version", value=engine_version, expected_type=type_hints["engine_version"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument template_from", value=template_from, expected_type=type_hints["template_from"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if data is not None:
            self._values["data"] = data
        if engine_version is not None:
            self._values["engine_version"] = engine_version
        if metadata is not None:
            self._values["metadata"] = metadata
        if template_from is not None:
            self._values["template_from"] = template_from
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def data(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ExternalSecretSpecTargetTemplate#data
        '''
        result = self._values.get("data")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def engine_version(
        self,
    ) -> typing.Optional["ExternalSecretSpecTargetTemplateEngineVersion"]:
        '''EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].

        :schema: ExternalSecretSpecTargetTemplate#engineVersion
        '''
        result = self._values.get("engine_version")
        return typing.cast(typing.Optional["ExternalSecretSpecTargetTemplateEngineVersion"], result)

    @builtins.property
    def metadata(self) -> typing.Optional["ExternalSecretSpecTargetTemplateMetadata"]:
        '''ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.

        :schema: ExternalSecretSpecTargetTemplate#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["ExternalSecretSpecTargetTemplateMetadata"], result)

    @builtins.property
    def template_from(
        self,
    ) -> typing.Optional[typing.List["ExternalSecretSpecTargetTemplateTemplateFrom"]]:
        '''
        :schema: ExternalSecretSpecTargetTemplate#templateFrom
        '''
        result = self._values.get("template_from")
        return typing.cast(typing.Optional[typing.List["ExternalSecretSpecTargetTemplateTemplateFrom"]], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ExternalSecretSpecTargetTemplate#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecTargetTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretSpecTargetTemplateEngineVersion"
)
class ExternalSecretSpecTargetTemplateEngineVersion(enum.Enum):
    '''EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].

    :schema: ExternalSecretSpecTargetTemplateEngineVersion
    '''

    V1 = "V1"
    '''v1.'''
    V2 = "V2"
    '''v2.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecTargetTemplateMetadata",
    jsii_struct_bases=[],
    name_mapping={"annotations": "annotations", "labels": "labels"},
)
class ExternalSecretSpecTargetTemplateMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.

        :param annotations: 
        :param labels: 

        :schema: ExternalSecretSpecTargetTemplateMetadata
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fd5588a79e0c2ae668496ad557535214d7832b67410c55764b5ebcb0df34aa6e)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if labels is not None:
            self._values["labels"] = labels

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ExternalSecretSpecTargetTemplateMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ExternalSecretSpecTargetTemplateMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecTargetTemplateMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecTargetTemplateTemplateFrom",
    jsii_struct_bases=[],
    name_mapping={"config_map": "configMap", "secret": "secret"},
)
class ExternalSecretSpecTargetTemplateTemplateFrom:
    def __init__(
        self,
        *,
        config_map: typing.Optional[typing.Union["ExternalSecretSpecTargetTemplateTemplateFromConfigMap", typing.Dict[builtins.str, typing.Any]]] = None,
        secret: typing.Optional[typing.Union["ExternalSecretSpecTargetTemplateTemplateFromSecret", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param config_map: 
        :param secret: 

        :schema: ExternalSecretSpecTargetTemplateTemplateFrom
        '''
        if isinstance(config_map, dict):
            config_map = ExternalSecretSpecTargetTemplateTemplateFromConfigMap(**config_map)
        if isinstance(secret, dict):
            secret = ExternalSecretSpecTargetTemplateTemplateFromSecret(**secret)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__31faa86a5c98b99d6ee0e61c7febcb6d057f4f2d66a77088ff59e58fd22c0e21)
            check_type(argname="argument config_map", value=config_map, expected_type=type_hints["config_map"])
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if config_map is not None:
            self._values["config_map"] = config_map
        if secret is not None:
            self._values["secret"] = secret

    @builtins.property
    def config_map(
        self,
    ) -> typing.Optional["ExternalSecretSpecTargetTemplateTemplateFromConfigMap"]:
        '''
        :schema: ExternalSecretSpecTargetTemplateTemplateFrom#configMap
        '''
        result = self._values.get("config_map")
        return typing.cast(typing.Optional["ExternalSecretSpecTargetTemplateTemplateFromConfigMap"], result)

    @builtins.property
    def secret(
        self,
    ) -> typing.Optional["ExternalSecretSpecTargetTemplateTemplateFromSecret"]:
        '''
        :schema: ExternalSecretSpecTargetTemplateTemplateFrom#secret
        '''
        result = self._values.get("secret")
        return typing.cast(typing.Optional["ExternalSecretSpecTargetTemplateTemplateFromSecret"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecTargetTemplateTemplateFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecTargetTemplateTemplateFromConfigMap",
    jsii_struct_bases=[],
    name_mapping={"items": "items", "name": "name"},
)
class ExternalSecretSpecTargetTemplateTemplateFromConfigMap:
    def __init__(
        self,
        *,
        items: typing.Sequence[typing.Union["ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems", typing.Dict[builtins.str, typing.Any]]],
        name: builtins.str,
    ) -> None:
        '''
        :param items: A list of keys in the ConfigMap/Secret to use as templates for Secret data.
        :param name: The name of the ConfigMap/Secret resource.

        :schema: ExternalSecretSpecTargetTemplateTemplateFromConfigMap
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__02bb153304316c1d27d8cc2666b4bffdf0b5ee46f914eb90f501ff4d279aff79)
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "items": items,
            "name": name,
        }

    @builtins.property
    def items(
        self,
    ) -> typing.List["ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems"]:
        '''A list of keys in the ConfigMap/Secret to use as templates for Secret data.

        :schema: ExternalSecretSpecTargetTemplateTemplateFromConfigMap#items
        '''
        result = self._values.get("items")
        assert result is not None, "Required property 'items' is missing"
        return typing.cast(typing.List["ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems"], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ConfigMap/Secret resource.

        :schema: ExternalSecretSpecTargetTemplateTemplateFromConfigMap#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecTargetTemplateTemplateFromConfigMap(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key"},
)
class ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems:
    def __init__(self, *, key: builtins.str) -> None:
        '''
        :param key: A key in the ConfigMap/Secret.

        :schema: ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__183828d27464f0cb7be30c7fcfa871d537b68ad5d70c9895876220619c3ee123)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
        }

    @builtins.property
    def key(self) -> builtins.str:
        '''A key in the ConfigMap/Secret.

        :schema: ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecTargetTemplateTemplateFromSecret",
    jsii_struct_bases=[],
    name_mapping={"items": "items", "name": "name"},
)
class ExternalSecretSpecTargetTemplateTemplateFromSecret:
    def __init__(
        self,
        *,
        items: typing.Sequence[typing.Union["ExternalSecretSpecTargetTemplateTemplateFromSecretItems", typing.Dict[builtins.str, typing.Any]]],
        name: builtins.str,
    ) -> None:
        '''
        :param items: A list of keys in the ConfigMap/Secret to use as templates for Secret data.
        :param name: The name of the ConfigMap/Secret resource.

        :schema: ExternalSecretSpecTargetTemplateTemplateFromSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a0091308b64027190e4220f919c8b9fe8606081a83a7cac89b8d6f66850f27d9)
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "items": items,
            "name": name,
        }

    @builtins.property
    def items(
        self,
    ) -> typing.List["ExternalSecretSpecTargetTemplateTemplateFromSecretItems"]:
        '''A list of keys in the ConfigMap/Secret to use as templates for Secret data.

        :schema: ExternalSecretSpecTargetTemplateTemplateFromSecret#items
        '''
        result = self._values.get("items")
        assert result is not None, "Required property 'items' is missing"
        return typing.cast(typing.List["ExternalSecretSpecTargetTemplateTemplateFromSecretItems"], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ConfigMap/Secret resource.

        :schema: ExternalSecretSpecTargetTemplateTemplateFromSecret#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecTargetTemplateTemplateFromSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecTargetTemplateTemplateFromSecretItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key"},
)
class ExternalSecretSpecTargetTemplateTemplateFromSecretItems:
    def __init__(self, *, key: builtins.str) -> None:
        '''
        :param key: A key in the ConfigMap/Secret.

        :schema: ExternalSecretSpecTargetTemplateTemplateFromSecretItems
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd62afc90b918a7a93df148a8f114e0416daaaa6276fbdd86d8d0b7a8b3a5886)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
        }

    @builtins.property
    def key(self) -> builtins.str:
        '''A key in the ConfigMap/Secret.

        :schema: ExternalSecretSpecTargetTemplateTemplateFromSecretItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecTargetTemplateTemplateFromSecretItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ExternalSecretV1Beta1(
    _cdk8s_d3d9af27.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1",
):
    '''ExternalSecret is the Schema for the external-secrets API.

    :schema: ExternalSecretV1Beta1
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ExternalSecretV1Beta1Spec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a "ExternalSecretV1Beta1" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param metadata: 
        :param spec: ExternalSecretSpec defines the desired state of ExternalSecret.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cfd09e377328d190f8f7b77670ab85f29c4518dcbb58d06f05a9a27a25809189)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ExternalSecretV1Beta1Props(metadata=metadata, spec=spec)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest")
    @builtins.classmethod
    def manifest(
        cls,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ExternalSecretV1Beta1Spec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> typing.Any:
        '''Renders a Kubernetes manifest for "ExternalSecretV1Beta1".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param metadata: 
        :param spec: ExternalSecretSpec defines the desired state of ExternalSecret.
        '''
        props = ExternalSecretV1Beta1Props(metadata=metadata, spec=spec)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''Renders the object to Kubernetes JSON.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> _cdk8s_d3d9af27.GroupVersionKind:
        '''Returns the apiVersion and kind for "ExternalSecretV1Beta1".'''
        return typing.cast(_cdk8s_d3d9af27.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1Props",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class ExternalSecretV1Beta1Props:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ExternalSecretV1Beta1Spec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''ExternalSecret is the Schema for the external-secrets API.

        :param metadata: 
        :param spec: ExternalSecretSpec defines the desired state of ExternalSecret.

        :schema: ExternalSecretV1Beta1
        '''
        if isinstance(metadata, dict):
            metadata = _cdk8s_d3d9af27.ApiObjectMetadata(**metadata)
        if isinstance(spec, dict):
            spec = ExternalSecretV1Beta1Spec(**spec)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__461761ed0edddc73d403b793c8ed04d0bc0a2534dd95e8eae4158f95cf880b21)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(self) -> typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata]:
        '''
        :schema: ExternalSecretV1Beta1#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata], result)

    @builtins.property
    def spec(self) -> typing.Optional["ExternalSecretV1Beta1Spec"]:
        '''ExternalSecretSpec defines the desired state of ExternalSecret.

        :schema: ExternalSecretV1Beta1#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1Spec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1Props(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1Spec",
    jsii_struct_bases=[],
    name_mapping={
        "data": "data",
        "data_from": "dataFrom",
        "refresh_interval": "refreshInterval",
        "secret_store_ref": "secretStoreRef",
        "target": "target",
    },
)
class ExternalSecretV1Beta1Spec:
    def __init__(
        self,
        *,
        data: typing.Optional[typing.Sequence[typing.Union["ExternalSecretV1Beta1SpecData", typing.Dict[builtins.str, typing.Any]]]] = None,
        data_from: typing.Optional[typing.Sequence[typing.Union["ExternalSecretV1Beta1SpecDataFrom", typing.Dict[builtins.str, typing.Any]]]] = None,
        refresh_interval: typing.Optional[builtins.str] = None,
        secret_store_ref: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecSecretStoreRef", typing.Dict[builtins.str, typing.Any]]] = None,
        target: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecTarget", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''ExternalSecretSpec defines the desired state of ExternalSecret.

        :param data: Data defines the connection between the Kubernetes Secret keys and the Provider data.
        :param data_from: DataFrom is used to fetch all properties from a specific Provider data If multiple entries are specified, the Secret keys are merged in the specified order.
        :param refresh_interval: RefreshInterval is the amount of time before the values are read again from the SecretStore provider, specified as Golang Duration strings. Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h" Example values: "1h", "2h30m", "5d", "10s" May be set to zero to fetch and create it once. Defaults to 1h. Default: 1h.
        :param secret_store_ref: SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
        :param target: ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.

        :schema: ExternalSecretV1Beta1Spec
        '''
        if isinstance(secret_store_ref, dict):
            secret_store_ref = ExternalSecretV1Beta1SpecSecretStoreRef(**secret_store_ref)
        if isinstance(target, dict):
            target = ExternalSecretV1Beta1SpecTarget(**target)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__93f730c43130f4e637999febc8307761ffd7173d07e0fb0252beb9d33999daae)
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
            check_type(argname="argument data_from", value=data_from, expected_type=type_hints["data_from"])
            check_type(argname="argument refresh_interval", value=refresh_interval, expected_type=type_hints["refresh_interval"])
            check_type(argname="argument secret_store_ref", value=secret_store_ref, expected_type=type_hints["secret_store_ref"])
            check_type(argname="argument target", value=target, expected_type=type_hints["target"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if data is not None:
            self._values["data"] = data
        if data_from is not None:
            self._values["data_from"] = data_from
        if refresh_interval is not None:
            self._values["refresh_interval"] = refresh_interval
        if secret_store_ref is not None:
            self._values["secret_store_ref"] = secret_store_ref
        if target is not None:
            self._values["target"] = target

    @builtins.property
    def data(self) -> typing.Optional[typing.List["ExternalSecretV1Beta1SpecData"]]:
        '''Data defines the connection between the Kubernetes Secret keys and the Provider data.

        :schema: ExternalSecretV1Beta1Spec#data
        '''
        result = self._values.get("data")
        return typing.cast(typing.Optional[typing.List["ExternalSecretV1Beta1SpecData"]], result)

    @builtins.property
    def data_from(
        self,
    ) -> typing.Optional[typing.List["ExternalSecretV1Beta1SpecDataFrom"]]:
        '''DataFrom is used to fetch all properties from a specific Provider data If multiple entries are specified, the Secret keys are merged in the specified order.

        :schema: ExternalSecretV1Beta1Spec#dataFrom
        '''
        result = self._values.get("data_from")
        return typing.cast(typing.Optional[typing.List["ExternalSecretV1Beta1SpecDataFrom"]], result)

    @builtins.property
    def refresh_interval(self) -> typing.Optional[builtins.str]:
        '''RefreshInterval is the amount of time before the values are read again from the SecretStore provider, specified as Golang Duration strings.

        Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h"
        Example values: "1h", "2h30m", "5d", "10s"
        May be set to zero to fetch and create it once. Defaults to 1h.

        :default: 1h.

        :schema: ExternalSecretV1Beta1Spec#refreshInterval
        '''
        result = self._values.get("refresh_interval")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_store_ref(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecSecretStoreRef"]:
        '''SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :schema: ExternalSecretV1Beta1Spec#secretStoreRef
        '''
        result = self._values.get("secret_store_ref")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecSecretStoreRef"], result)

    @builtins.property
    def target(self) -> typing.Optional["ExternalSecretV1Beta1SpecTarget"]:
        '''ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.

        :schema: ExternalSecretV1Beta1Spec#target
        '''
        result = self._values.get("target")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecTarget"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1Spec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecData",
    jsii_struct_bases=[],
    name_mapping={
        "remote_ref": "remoteRef",
        "secret_key": "secretKey",
        "source_ref": "sourceRef",
    },
)
class ExternalSecretV1Beta1SpecData:
    def __init__(
        self,
        *,
        remote_ref: typing.Union["ExternalSecretV1Beta1SpecDataRemoteRef", typing.Dict[builtins.str, typing.Any]],
        secret_key: builtins.str,
        source_ref: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecDataSourceRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''ExternalSecretData defines the connection between the Kubernetes Secret key (spec.data.) and the Provider data.

        :param remote_ref: RemoteRef points to the remote secret and defines which secret (version/property/..) to fetch.
        :param secret_key: The key in the Kubernetes Secret to store the value.
        :param source_ref: SourceRef allows you to override the source from which the value will be pulled.

        :schema: ExternalSecretV1Beta1SpecData
        '''
        if isinstance(remote_ref, dict):
            remote_ref = ExternalSecretV1Beta1SpecDataRemoteRef(**remote_ref)
        if isinstance(source_ref, dict):
            source_ref = ExternalSecretV1Beta1SpecDataSourceRef(**source_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__57cac15896a1d924720292c54c0d0f922c9daf2aa81f875475449aef38e0e295)
            check_type(argname="argument remote_ref", value=remote_ref, expected_type=type_hints["remote_ref"])
            check_type(argname="argument secret_key", value=secret_key, expected_type=type_hints["secret_key"])
            check_type(argname="argument source_ref", value=source_ref, expected_type=type_hints["source_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "remote_ref": remote_ref,
            "secret_key": secret_key,
        }
        if source_ref is not None:
            self._values["source_ref"] = source_ref

    @builtins.property
    def remote_ref(self) -> "ExternalSecretV1Beta1SpecDataRemoteRef":
        '''RemoteRef points to the remote secret and defines which secret (version/property/..) to fetch.

        :schema: ExternalSecretV1Beta1SpecData#remoteRef
        '''
        result = self._values.get("remote_ref")
        assert result is not None, "Required property 'remote_ref' is missing"
        return typing.cast("ExternalSecretV1Beta1SpecDataRemoteRef", result)

    @builtins.property
    def secret_key(self) -> builtins.str:
        '''The key in the Kubernetes Secret to store the value.

        :schema: ExternalSecretV1Beta1SpecData#secretKey
        '''
        result = self._values.get("secret_key")
        assert result is not None, "Required property 'secret_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def source_ref(self) -> typing.Optional["ExternalSecretV1Beta1SpecDataSourceRef"]:
        '''SourceRef allows you to override the source from which the value will be pulled.

        :schema: ExternalSecretV1Beta1SpecData#sourceRef
        '''
        result = self._values.get("source_ref")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataSourceRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecData(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFrom",
    jsii_struct_bases=[],
    name_mapping={
        "extract": "extract",
        "find": "find",
        "rewrite": "rewrite",
        "source_ref": "sourceRef",
    },
)
class ExternalSecretV1Beta1SpecDataFrom:
    def __init__(
        self,
        *,
        extract: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecDataFromExtract", typing.Dict[builtins.str, typing.Any]]] = None,
        find: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecDataFromFind", typing.Dict[builtins.str, typing.Any]]] = None,
        rewrite: typing.Optional[typing.Sequence[typing.Union["ExternalSecretV1Beta1SpecDataFromRewrite", typing.Dict[builtins.str, typing.Any]]]] = None,
        source_ref: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecDataFromSourceRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param extract: Used to extract multiple key/value pairs from one secret Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.
        :param find: Used to find secrets based on tags or regular expressions Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.
        :param rewrite: Used to rewrite secret Keys after getting them from the secret Provider Multiple Rewrite operations can be provided. They are applied in a layered order (first to last)
        :param source_ref: SourceRef points to a store or generator which contains secret values ready to use. Use this in combination with Extract or Find pull values out of a specific SecretStore. When sourceRef points to a generator Extract or Find is not supported. The generator returns a static map of values

        :schema: ExternalSecretV1Beta1SpecDataFrom
        '''
        if isinstance(extract, dict):
            extract = ExternalSecretV1Beta1SpecDataFromExtract(**extract)
        if isinstance(find, dict):
            find = ExternalSecretV1Beta1SpecDataFromFind(**find)
        if isinstance(source_ref, dict):
            source_ref = ExternalSecretV1Beta1SpecDataFromSourceRef(**source_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a22f4fe792b72c3eaf030666d89e08718509ca8d74cccad99560062b6eeb559)
            check_type(argname="argument extract", value=extract, expected_type=type_hints["extract"])
            check_type(argname="argument find", value=find, expected_type=type_hints["find"])
            check_type(argname="argument rewrite", value=rewrite, expected_type=type_hints["rewrite"])
            check_type(argname="argument source_ref", value=source_ref, expected_type=type_hints["source_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if extract is not None:
            self._values["extract"] = extract
        if find is not None:
            self._values["find"] = find
        if rewrite is not None:
            self._values["rewrite"] = rewrite
        if source_ref is not None:
            self._values["source_ref"] = source_ref

    @builtins.property
    def extract(self) -> typing.Optional["ExternalSecretV1Beta1SpecDataFromExtract"]:
        '''Used to extract multiple key/value pairs from one secret Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.

        :schema: ExternalSecretV1Beta1SpecDataFrom#extract
        '''
        result = self._values.get("extract")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataFromExtract"], result)

    @builtins.property
    def find(self) -> typing.Optional["ExternalSecretV1Beta1SpecDataFromFind"]:
        '''Used to find secrets based on tags or regular expressions Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.

        :schema: ExternalSecretV1Beta1SpecDataFrom#find
        '''
        result = self._values.get("find")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataFromFind"], result)

    @builtins.property
    def rewrite(
        self,
    ) -> typing.Optional[typing.List["ExternalSecretV1Beta1SpecDataFromRewrite"]]:
        '''Used to rewrite secret Keys after getting them from the secret Provider Multiple Rewrite operations can be provided.

        They are applied in a layered order (first to last)

        :schema: ExternalSecretV1Beta1SpecDataFrom#rewrite
        '''
        result = self._values.get("rewrite")
        return typing.cast(typing.Optional[typing.List["ExternalSecretV1Beta1SpecDataFromRewrite"]], result)

    @builtins.property
    def source_ref(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecDataFromSourceRef"]:
        '''SourceRef points to a store or generator which contains secret values ready to use.

        Use this in combination with Extract or Find pull values out of
        a specific SecretStore.
        When sourceRef points to a generator Extract or Find is not supported.
        The generator returns a static map of values

        :schema: ExternalSecretV1Beta1SpecDataFrom#sourceRef
        '''
        result = self._values.get("source_ref")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataFromSourceRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromExtract",
    jsii_struct_bases=[],
    name_mapping={
        "key": "key",
        "conversion_strategy": "conversionStrategy",
        "decoding_strategy": "decodingStrategy",
        "metadata_policy": "metadataPolicy",
        "property": "property",
        "version": "version",
    },
)
class ExternalSecretV1Beta1SpecDataFromExtract:
    def __init__(
        self,
        *,
        key: builtins.str,
        conversion_strategy: typing.Optional["ExternalSecretV1Beta1SpecDataFromExtractConversionStrategy"] = None,
        decoding_strategy: typing.Optional["ExternalSecretV1Beta1SpecDataFromExtractDecodingStrategy"] = None,
        metadata_policy: typing.Optional["ExternalSecretV1Beta1SpecDataFromExtractMetadataPolicy"] = None,
        property: typing.Optional[builtins.str] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Used to extract multiple key/value pairs from one secret Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.

        :param key: Key is the key used in the Provider, mandatory.
        :param conversion_strategy: Used to define a conversion Strategy.
        :param decoding_strategy: Used to define a decoding Strategy.
        :param metadata_policy: Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None Default: None
        :param property: Used to select a specific property of the Provider value (if a map), if supported.
        :param version: Used to select a specific version of the Provider value, if supported.

        :schema: ExternalSecretV1Beta1SpecDataFromExtract
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4470abe995b704cbdcdf0492e1e91e23a97f5bd83a22269ccf3af13015136970)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument conversion_strategy", value=conversion_strategy, expected_type=type_hints["conversion_strategy"])
            check_type(argname="argument decoding_strategy", value=decoding_strategy, expected_type=type_hints["decoding_strategy"])
            check_type(argname="argument metadata_policy", value=metadata_policy, expected_type=type_hints["metadata_policy"])
            check_type(argname="argument property", value=property, expected_type=type_hints["property"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
        }
        if conversion_strategy is not None:
            self._values["conversion_strategy"] = conversion_strategy
        if decoding_strategy is not None:
            self._values["decoding_strategy"] = decoding_strategy
        if metadata_policy is not None:
            self._values["metadata_policy"] = metadata_policy
        if property is not None:
            self._values["property"] = property
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def key(self) -> builtins.str:
        '''Key is the key used in the Provider, mandatory.

        :schema: ExternalSecretV1Beta1SpecDataFromExtract#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def conversion_strategy(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecDataFromExtractConversionStrategy"]:
        '''Used to define a conversion Strategy.

        :schema: ExternalSecretV1Beta1SpecDataFromExtract#conversionStrategy
        '''
        result = self._values.get("conversion_strategy")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataFromExtractConversionStrategy"], result)

    @builtins.property
    def decoding_strategy(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecDataFromExtractDecodingStrategy"]:
        '''Used to define a decoding Strategy.

        :schema: ExternalSecretV1Beta1SpecDataFromExtract#decodingStrategy
        '''
        result = self._values.get("decoding_strategy")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataFromExtractDecodingStrategy"], result)

    @builtins.property
    def metadata_policy(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecDataFromExtractMetadataPolicy"]:
        '''Policy for fetching tags/labels from provider secrets, possible options are Fetch, None.

        Defaults to None

        :default: None

        :schema: ExternalSecretV1Beta1SpecDataFromExtract#metadataPolicy
        '''
        result = self._values.get("metadata_policy")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataFromExtractMetadataPolicy"], result)

    @builtins.property
    def property(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific property of the Provider value (if a map), if supported.

        :schema: ExternalSecretV1Beta1SpecDataFromExtract#property
        '''
        result = self._values.get("property")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific version of the Provider value, if supported.

        :schema: ExternalSecretV1Beta1SpecDataFromExtract#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataFromExtract(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromExtractConversionStrategy"
)
class ExternalSecretV1Beta1SpecDataFromExtractConversionStrategy(enum.Enum):
    '''Used to define a conversion Strategy.

    :schema: ExternalSecretV1Beta1SpecDataFromExtractConversionStrategy
    '''

    DEFAULT = "DEFAULT"
    '''Default.'''
    UNICODE = "UNICODE"
    '''Unicode.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromExtractDecodingStrategy"
)
class ExternalSecretV1Beta1SpecDataFromExtractDecodingStrategy(enum.Enum):
    '''Used to define a decoding Strategy.

    :schema: ExternalSecretV1Beta1SpecDataFromExtractDecodingStrategy
    '''

    AUTO = "AUTO"
    '''Auto.'''
    BASE64 = "BASE64"
    '''Base64.'''
    BASE64_URL = "BASE64_URL"
    '''Base64URL.'''
    NONE = "NONE"
    '''None.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromExtractMetadataPolicy"
)
class ExternalSecretV1Beta1SpecDataFromExtractMetadataPolicy(enum.Enum):
    '''Policy for fetching tags/labels from provider secrets, possible options are Fetch, None.

    Defaults to None

    :default: None

    :schema: ExternalSecretV1Beta1SpecDataFromExtractMetadataPolicy
    '''

    NONE = "NONE"
    '''None.'''
    FETCH = "FETCH"
    '''Fetch.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromFind",
    jsii_struct_bases=[],
    name_mapping={
        "conversion_strategy": "conversionStrategy",
        "decoding_strategy": "decodingStrategy",
        "name": "name",
        "path": "path",
        "tags": "tags",
    },
)
class ExternalSecretV1Beta1SpecDataFromFind:
    def __init__(
        self,
        *,
        conversion_strategy: typing.Optional["ExternalSecretV1Beta1SpecDataFromFindConversionStrategy"] = None,
        decoding_strategy: typing.Optional["ExternalSecretV1Beta1SpecDataFromFindDecodingStrategy"] = None,
        name: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecDataFromFindName", typing.Dict[builtins.str, typing.Any]]] = None,
        path: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Used to find secrets based on tags or regular expressions Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.

        :param conversion_strategy: Used to define a conversion Strategy.
        :param decoding_strategy: Used to define a decoding Strategy.
        :param name: Finds secrets based on the name.
        :param path: A root path to start the find operations.
        :param tags: Find secrets based on tags.

        :schema: ExternalSecretV1Beta1SpecDataFromFind
        '''
        if isinstance(name, dict):
            name = ExternalSecretV1Beta1SpecDataFromFindName(**name)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__22b4b957dbb9cd8460e4e930700a48d34f638298827b6fe53d68d1b82de6f401)
            check_type(argname="argument conversion_strategy", value=conversion_strategy, expected_type=type_hints["conversion_strategy"])
            check_type(argname="argument decoding_strategy", value=decoding_strategy, expected_type=type_hints["decoding_strategy"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if conversion_strategy is not None:
            self._values["conversion_strategy"] = conversion_strategy
        if decoding_strategy is not None:
            self._values["decoding_strategy"] = decoding_strategy
        if name is not None:
            self._values["name"] = name
        if path is not None:
            self._values["path"] = path
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def conversion_strategy(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecDataFromFindConversionStrategy"]:
        '''Used to define a conversion Strategy.

        :schema: ExternalSecretV1Beta1SpecDataFromFind#conversionStrategy
        '''
        result = self._values.get("conversion_strategy")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataFromFindConversionStrategy"], result)

    @builtins.property
    def decoding_strategy(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecDataFromFindDecodingStrategy"]:
        '''Used to define a decoding Strategy.

        :schema: ExternalSecretV1Beta1SpecDataFromFind#decodingStrategy
        '''
        result = self._values.get("decoding_strategy")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataFromFindDecodingStrategy"], result)

    @builtins.property
    def name(self) -> typing.Optional["ExternalSecretV1Beta1SpecDataFromFindName"]:
        '''Finds secrets based on the name.

        :schema: ExternalSecretV1Beta1SpecDataFromFind#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataFromFindName"], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''A root path to start the find operations.

        :schema: ExternalSecretV1Beta1SpecDataFromFind#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Find secrets based on tags.

        :schema: ExternalSecretV1Beta1SpecDataFromFind#tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataFromFind(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromFindConversionStrategy"
)
class ExternalSecretV1Beta1SpecDataFromFindConversionStrategy(enum.Enum):
    '''Used to define a conversion Strategy.

    :schema: ExternalSecretV1Beta1SpecDataFromFindConversionStrategy
    '''

    DEFAULT = "DEFAULT"
    '''Default.'''
    UNICODE = "UNICODE"
    '''Unicode.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromFindDecodingStrategy"
)
class ExternalSecretV1Beta1SpecDataFromFindDecodingStrategy(enum.Enum):
    '''Used to define a decoding Strategy.

    :schema: ExternalSecretV1Beta1SpecDataFromFindDecodingStrategy
    '''

    AUTO = "AUTO"
    '''Auto.'''
    BASE64 = "BASE64"
    '''Base64.'''
    BASE64_URL = "BASE64_URL"
    '''Base64URL.'''
    NONE = "NONE"
    '''None.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromFindName",
    jsii_struct_bases=[],
    name_mapping={"regexp": "regexp"},
)
class ExternalSecretV1Beta1SpecDataFromFindName:
    def __init__(self, *, regexp: typing.Optional[builtins.str] = None) -> None:
        '''Finds secrets based on the name.

        :param regexp: Finds secrets base.

        :schema: ExternalSecretV1Beta1SpecDataFromFindName
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f615a184713f5d364337da92283293111522fd42282ad325a8afbd2d1962916)
            check_type(argname="argument regexp", value=regexp, expected_type=type_hints["regexp"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if regexp is not None:
            self._values["regexp"] = regexp

    @builtins.property
    def regexp(self) -> typing.Optional[builtins.str]:
        '''Finds secrets base.

        :schema: ExternalSecretV1Beta1SpecDataFromFindName#regexp
        '''
        result = self._values.get("regexp")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataFromFindName(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromRewrite",
    jsii_struct_bases=[],
    name_mapping={"regexp": "regexp", "transform": "transform"},
)
class ExternalSecretV1Beta1SpecDataFromRewrite:
    def __init__(
        self,
        *,
        regexp: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecDataFromRewriteRegexp", typing.Dict[builtins.str, typing.Any]]] = None,
        transform: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecDataFromRewriteTransform", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param regexp: Used to rewrite with regular expressions. The resulting key will be the output of a regexp.ReplaceAll operation.
        :param transform: Used to apply string transformation on the secrets. The resulting key will be the output of the template applied by the operation.

        :schema: ExternalSecretV1Beta1SpecDataFromRewrite
        '''
        if isinstance(regexp, dict):
            regexp = ExternalSecretV1Beta1SpecDataFromRewriteRegexp(**regexp)
        if isinstance(transform, dict):
            transform = ExternalSecretV1Beta1SpecDataFromRewriteTransform(**transform)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__454681f1cc3a392e81ef5c92bfa786dde1e38e7aaa5f2a3ed665e0b4cb009c13)
            check_type(argname="argument regexp", value=regexp, expected_type=type_hints["regexp"])
            check_type(argname="argument transform", value=transform, expected_type=type_hints["transform"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if regexp is not None:
            self._values["regexp"] = regexp
        if transform is not None:
            self._values["transform"] = transform

    @builtins.property
    def regexp(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecDataFromRewriteRegexp"]:
        '''Used to rewrite with regular expressions.

        The resulting key will be the output of a regexp.ReplaceAll operation.

        :schema: ExternalSecretV1Beta1SpecDataFromRewrite#regexp
        '''
        result = self._values.get("regexp")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataFromRewriteRegexp"], result)

    @builtins.property
    def transform(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecDataFromRewriteTransform"]:
        '''Used to apply string transformation on the secrets.

        The resulting key will be the output of the template applied by the operation.

        :schema: ExternalSecretV1Beta1SpecDataFromRewrite#transform
        '''
        result = self._values.get("transform")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataFromRewriteTransform"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataFromRewrite(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromRewriteRegexp",
    jsii_struct_bases=[],
    name_mapping={"source": "source", "target": "target"},
)
class ExternalSecretV1Beta1SpecDataFromRewriteRegexp:
    def __init__(self, *, source: builtins.str, target: builtins.str) -> None:
        '''Used to rewrite with regular expressions.

        The resulting key will be the output of a regexp.ReplaceAll operation.

        :param source: Used to define the regular expression of a re.Compiler.
        :param target: Used to define the target pattern of a ReplaceAll operation.

        :schema: ExternalSecretV1Beta1SpecDataFromRewriteRegexp
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__22d63d6e820ab00e4df04c49344342bd4731978ef6611c06c5ac4b5332794e7c)
            check_type(argname="argument source", value=source, expected_type=type_hints["source"])
            check_type(argname="argument target", value=target, expected_type=type_hints["target"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "source": source,
            "target": target,
        }

    @builtins.property
    def source(self) -> builtins.str:
        '''Used to define the regular expression of a re.Compiler.

        :schema: ExternalSecretV1Beta1SpecDataFromRewriteRegexp#source
        '''
        result = self._values.get("source")
        assert result is not None, "Required property 'source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target(self) -> builtins.str:
        '''Used to define the target pattern of a ReplaceAll operation.

        :schema: ExternalSecretV1Beta1SpecDataFromRewriteRegexp#target
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataFromRewriteRegexp(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromRewriteTransform",
    jsii_struct_bases=[],
    name_mapping={"template": "template"},
)
class ExternalSecretV1Beta1SpecDataFromRewriteTransform:
    def __init__(self, *, template: builtins.str) -> None:
        '''Used to apply string transformation on the secrets.

        The resulting key will be the output of the template applied by the operation.

        :param template: Used to define the template to apply on the secret name. ``.value `` will specify the secret name in the template.

        :schema: ExternalSecretV1Beta1SpecDataFromRewriteTransform
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d47b0f8c8a5dc70763b8dc023f9180f55c381aaf0b4f19237eb10dcd1ac06128)
            check_type(argname="argument template", value=template, expected_type=type_hints["template"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "template": template,
        }

    @builtins.property
    def template(self) -> builtins.str:
        '''Used to define the template to apply on the secret name.

        ``.value `` will specify the secret name in the template.

        :schema: ExternalSecretV1Beta1SpecDataFromRewriteTransform#template
        '''
        result = self._values.get("template")
        assert result is not None, "Required property 'template' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataFromRewriteTransform(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromSourceRef",
    jsii_struct_bases=[],
    name_mapping={"generator_ref": "generatorRef", "store_ref": "storeRef"},
)
class ExternalSecretV1Beta1SpecDataFromSourceRef:
    def __init__(
        self,
        *,
        generator_ref: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef", typing.Dict[builtins.str, typing.Any]]] = None,
        store_ref: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''SourceRef points to a store or generator which contains secret values ready to use.

        Use this in combination with Extract or Find pull values out of
        a specific SecretStore.
        When sourceRef points to a generator Extract or Find is not supported.
        The generator returns a static map of values

        :param generator_ref: GeneratorRef points to a generator custom resource.
        :param store_ref: SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :schema: ExternalSecretV1Beta1SpecDataFromSourceRef
        '''
        if isinstance(generator_ref, dict):
            generator_ref = ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef(**generator_ref)
        if isinstance(store_ref, dict):
            store_ref = ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef(**store_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1e31764683713a9a8f8bf7cbe8fa64128cb17a25250a39a9dce43346a98e28ed)
            check_type(argname="argument generator_ref", value=generator_ref, expected_type=type_hints["generator_ref"])
            check_type(argname="argument store_ref", value=store_ref, expected_type=type_hints["store_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if generator_ref is not None:
            self._values["generator_ref"] = generator_ref
        if store_ref is not None:
            self._values["store_ref"] = store_ref

    @builtins.property
    def generator_ref(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef"]:
        '''GeneratorRef points to a generator custom resource.

        :schema: ExternalSecretV1Beta1SpecDataFromSourceRef#generatorRef
        '''
        result = self._values.get("generator_ref")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef"], result)

    @builtins.property
    def store_ref(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef"]:
        '''SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :schema: ExternalSecretV1Beta1SpecDataFromSourceRef#storeRef
        '''
        result = self._values.get("store_ref")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataFromSourceRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "name": "name", "api_version": "apiVersion"},
)
class ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef:
    def __init__(
        self,
        *,
        kind: "ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRefKind",
        name: builtins.str,
        api_version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''GeneratorRef points to a generator custom resource.

        :param kind: Specify the Kind of the generator resource.
        :param name: Specify the name of the generator resource.
        :param api_version: Specify the apiVersion of the generator resource.

        :schema: ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a25657d5911002a9ed43593a36ebeae2b366d18947f1a909c37401825186ff0e)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "kind": kind,
            "name": name,
        }
        if api_version is not None:
            self._values["api_version"] = api_version

    @builtins.property
    def kind(self) -> "ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRefKind":
        '''Specify the Kind of the generator resource.

        :schema: ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef#kind
        '''
        result = self._values.get("kind")
        assert result is not None, "Required property 'kind' is missing"
        return typing.cast("ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRefKind", result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Specify the name of the generator resource.

        :schema: ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Specify the apiVersion of the generator resource.

        :schema: ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef#apiVersion
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRefKind"
)
class ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRefKind(enum.Enum):
    '''Specify the Kind of the generator resource.

    :schema: ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRefKind
    '''

    ACR_ACCESS_TOKEN = "ACR_ACCESS_TOKEN"
    '''ACRAccessToken.'''
    CLUSTER_GENERATOR = "CLUSTER_GENERATOR"
    '''ClusterGenerator.'''
    ECR_AUTHORIZATION_TOKEN = "ECR_AUTHORIZATION_TOKEN"
    '''ECRAuthorizationToken.'''
    FAKE = "FAKE"
    '''Fake.'''
    GCR_ACCESS_TOKEN = "GCR_ACCESS_TOKEN"
    '''GCRAccessToken.'''
    GITHUB_ACCESS_TOKEN = "GITHUB_ACCESS_TOKEN"
    '''GithubAccessToken.'''
    PASSWORD = "PASSWORD"
    '''Password.'''
    STS_SESSION_TOKEN = "STS_SESSION_TOKEN"
    '''STSSessionToken.'''
    UUID = "UUID"
    '''UUID.'''
    VAULT_DYNAMIC_SECRET = "VAULT_DYNAMIC_SECRET"
    '''VaultDynamicSecret.'''
    WEBHOOK = "WEBHOOK"
    '''Webhook.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "name": "name"},
)
class ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef:
    def __init__(
        self,
        *,
        kind: typing.Optional["ExternalSecretV1Beta1SpecDataFromSourceRefStoreRefKind"] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :param kind: Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``. Default: SecretStore`
        :param name: Name of the SecretStore resource.

        :schema: ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__313a803335f1a3dcc9bd5c2b02ad7bab54c82cffdedec119f8d273c3ca941610)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if kind is not None:
            self._values["kind"] = kind
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def kind(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecDataFromSourceRefStoreRefKind"]:
        '''Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``.

        :default: SecretStore`

        :schema: ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataFromSourceRefStoreRefKind"], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the SecretStore resource.

        :schema: ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromSourceRefStoreRefKind"
)
class ExternalSecretV1Beta1SpecDataFromSourceRefStoreRefKind(enum.Enum):
    '''Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``.

    :default: SecretStore`

    :schema: ExternalSecretV1Beta1SpecDataFromSourceRefStoreRefKind
    '''

    SECRET_STORE = "SECRET_STORE"
    '''SecretStore.'''
    CLUSTER_SECRET_STORE = "CLUSTER_SECRET_STORE"
    '''ClusterSecretStore.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataRemoteRef",
    jsii_struct_bases=[],
    name_mapping={
        "key": "key",
        "conversion_strategy": "conversionStrategy",
        "decoding_strategy": "decodingStrategy",
        "metadata_policy": "metadataPolicy",
        "property": "property",
        "version": "version",
    },
)
class ExternalSecretV1Beta1SpecDataRemoteRef:
    def __init__(
        self,
        *,
        key: builtins.str,
        conversion_strategy: typing.Optional["ExternalSecretV1Beta1SpecDataRemoteRefConversionStrategy"] = None,
        decoding_strategy: typing.Optional["ExternalSecretV1Beta1SpecDataRemoteRefDecodingStrategy"] = None,
        metadata_policy: typing.Optional["ExternalSecretV1Beta1SpecDataRemoteRefMetadataPolicy"] = None,
        property: typing.Optional[builtins.str] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''RemoteRef points to the remote secret and defines which secret (version/property/..) to fetch.

        :param key: Key is the key used in the Provider, mandatory.
        :param conversion_strategy: Used to define a conversion Strategy.
        :param decoding_strategy: Used to define a decoding Strategy.
        :param metadata_policy: Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None Default: None
        :param property: Used to select a specific property of the Provider value (if a map), if supported.
        :param version: Used to select a specific version of the Provider value, if supported.

        :schema: ExternalSecretV1Beta1SpecDataRemoteRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__823faeef50b2c0df69c9ae99b8ab132511378b031b5042afba0c9fe24ba93dd4)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument conversion_strategy", value=conversion_strategy, expected_type=type_hints["conversion_strategy"])
            check_type(argname="argument decoding_strategy", value=decoding_strategy, expected_type=type_hints["decoding_strategy"])
            check_type(argname="argument metadata_policy", value=metadata_policy, expected_type=type_hints["metadata_policy"])
            check_type(argname="argument property", value=property, expected_type=type_hints["property"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
        }
        if conversion_strategy is not None:
            self._values["conversion_strategy"] = conversion_strategy
        if decoding_strategy is not None:
            self._values["decoding_strategy"] = decoding_strategy
        if metadata_policy is not None:
            self._values["metadata_policy"] = metadata_policy
        if property is not None:
            self._values["property"] = property
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def key(self) -> builtins.str:
        '''Key is the key used in the Provider, mandatory.

        :schema: ExternalSecretV1Beta1SpecDataRemoteRef#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def conversion_strategy(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecDataRemoteRefConversionStrategy"]:
        '''Used to define a conversion Strategy.

        :schema: ExternalSecretV1Beta1SpecDataRemoteRef#conversionStrategy
        '''
        result = self._values.get("conversion_strategy")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataRemoteRefConversionStrategy"], result)

    @builtins.property
    def decoding_strategy(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecDataRemoteRefDecodingStrategy"]:
        '''Used to define a decoding Strategy.

        :schema: ExternalSecretV1Beta1SpecDataRemoteRef#decodingStrategy
        '''
        result = self._values.get("decoding_strategy")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataRemoteRefDecodingStrategy"], result)

    @builtins.property
    def metadata_policy(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecDataRemoteRefMetadataPolicy"]:
        '''Policy for fetching tags/labels from provider secrets, possible options are Fetch, None.

        Defaults to None

        :default: None

        :schema: ExternalSecretV1Beta1SpecDataRemoteRef#metadataPolicy
        '''
        result = self._values.get("metadata_policy")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataRemoteRefMetadataPolicy"], result)

    @builtins.property
    def property(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific property of the Provider value (if a map), if supported.

        :schema: ExternalSecretV1Beta1SpecDataRemoteRef#property
        '''
        result = self._values.get("property")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific version of the Provider value, if supported.

        :schema: ExternalSecretV1Beta1SpecDataRemoteRef#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataRemoteRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataRemoteRefConversionStrategy"
)
class ExternalSecretV1Beta1SpecDataRemoteRefConversionStrategy(enum.Enum):
    '''Used to define a conversion Strategy.

    :schema: ExternalSecretV1Beta1SpecDataRemoteRefConversionStrategy
    '''

    DEFAULT = "DEFAULT"
    '''Default.'''
    UNICODE = "UNICODE"
    '''Unicode.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataRemoteRefDecodingStrategy"
)
class ExternalSecretV1Beta1SpecDataRemoteRefDecodingStrategy(enum.Enum):
    '''Used to define a decoding Strategy.

    :schema: ExternalSecretV1Beta1SpecDataRemoteRefDecodingStrategy
    '''

    AUTO = "AUTO"
    '''Auto.'''
    BASE64 = "BASE64"
    '''Base64.'''
    BASE64_URL = "BASE64_URL"
    '''Base64URL.'''
    NONE = "NONE"
    '''None.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataRemoteRefMetadataPolicy"
)
class ExternalSecretV1Beta1SpecDataRemoteRefMetadataPolicy(enum.Enum):
    '''Policy for fetching tags/labels from provider secrets, possible options are Fetch, None.

    Defaults to None

    :default: None

    :schema: ExternalSecretV1Beta1SpecDataRemoteRefMetadataPolicy
    '''

    NONE = "NONE"
    '''None.'''
    FETCH = "FETCH"
    '''Fetch.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataSourceRef",
    jsii_struct_bases=[],
    name_mapping={"generator_ref": "generatorRef", "store_ref": "storeRef"},
)
class ExternalSecretV1Beta1SpecDataSourceRef:
    def __init__(
        self,
        *,
        generator_ref: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef", typing.Dict[builtins.str, typing.Any]]] = None,
        store_ref: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecDataSourceRefStoreRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''SourceRef allows you to override the source from which the value will be pulled.

        :param generator_ref: GeneratorRef points to a generator custom resource. Deprecated: The generatorRef is not implemented in .data[]. this will be removed with v1.
        :param store_ref: SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :schema: ExternalSecretV1Beta1SpecDataSourceRef
        '''
        if isinstance(generator_ref, dict):
            generator_ref = ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef(**generator_ref)
        if isinstance(store_ref, dict):
            store_ref = ExternalSecretV1Beta1SpecDataSourceRefStoreRef(**store_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ddbbc6e6e35a17c0e134f27793083186c7768306a73ee6e63372b5181a919122)
            check_type(argname="argument generator_ref", value=generator_ref, expected_type=type_hints["generator_ref"])
            check_type(argname="argument store_ref", value=store_ref, expected_type=type_hints["store_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if generator_ref is not None:
            self._values["generator_ref"] = generator_ref
        if store_ref is not None:
            self._values["store_ref"] = store_ref

    @builtins.property
    def generator_ref(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef"]:
        '''GeneratorRef points to a generator custom resource.

        Deprecated: The generatorRef is not implemented in .data[].
        this will be removed with v1.

        :schema: ExternalSecretV1Beta1SpecDataSourceRef#generatorRef
        '''
        result = self._values.get("generator_ref")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef"], result)

    @builtins.property
    def store_ref(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecDataSourceRefStoreRef"]:
        '''SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :schema: ExternalSecretV1Beta1SpecDataSourceRef#storeRef
        '''
        result = self._values.get("store_ref")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataSourceRefStoreRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataSourceRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "name": "name", "api_version": "apiVersion"},
)
class ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef:
    def __init__(
        self,
        *,
        kind: "ExternalSecretV1Beta1SpecDataSourceRefGeneratorRefKind",
        name: builtins.str,
        api_version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''GeneratorRef points to a generator custom resource.

        Deprecated: The generatorRef is not implemented in .data[].
        this will be removed with v1.

        :param kind: Specify the Kind of the generator resource.
        :param name: Specify the name of the generator resource.
        :param api_version: Specify the apiVersion of the generator resource.

        :schema: ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__294137a19635c86246291dbae5ba6d655fd0cc9233328d9348f5622e2d5487eb)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "kind": kind,
            "name": name,
        }
        if api_version is not None:
            self._values["api_version"] = api_version

    @builtins.property
    def kind(self) -> "ExternalSecretV1Beta1SpecDataSourceRefGeneratorRefKind":
        '''Specify the Kind of the generator resource.

        :schema: ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef#kind
        '''
        result = self._values.get("kind")
        assert result is not None, "Required property 'kind' is missing"
        return typing.cast("ExternalSecretV1Beta1SpecDataSourceRefGeneratorRefKind", result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Specify the name of the generator resource.

        :schema: ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Specify the apiVersion of the generator resource.

        :schema: ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef#apiVersion
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataSourceRefGeneratorRefKind"
)
class ExternalSecretV1Beta1SpecDataSourceRefGeneratorRefKind(enum.Enum):
    '''Specify the Kind of the generator resource.

    :schema: ExternalSecretV1Beta1SpecDataSourceRefGeneratorRefKind
    '''

    ACR_ACCESS_TOKEN = "ACR_ACCESS_TOKEN"
    '''ACRAccessToken.'''
    CLUSTER_GENERATOR = "CLUSTER_GENERATOR"
    '''ClusterGenerator.'''
    ECR_AUTHORIZATION_TOKEN = "ECR_AUTHORIZATION_TOKEN"
    '''ECRAuthorizationToken.'''
    FAKE = "FAKE"
    '''Fake.'''
    GCR_ACCESS_TOKEN = "GCR_ACCESS_TOKEN"
    '''GCRAccessToken.'''
    GITHUB_ACCESS_TOKEN = "GITHUB_ACCESS_TOKEN"
    '''GithubAccessToken.'''
    PASSWORD = "PASSWORD"
    '''Password.'''
    STS_SESSION_TOKEN = "STS_SESSION_TOKEN"
    '''STSSessionToken.'''
    UUID = "UUID"
    '''UUID.'''
    VAULT_DYNAMIC_SECRET = "VAULT_DYNAMIC_SECRET"
    '''VaultDynamicSecret.'''
    WEBHOOK = "WEBHOOK"
    '''Webhook.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataSourceRefStoreRef",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "name": "name"},
)
class ExternalSecretV1Beta1SpecDataSourceRefStoreRef:
    def __init__(
        self,
        *,
        kind: typing.Optional["ExternalSecretV1Beta1SpecDataSourceRefStoreRefKind"] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :param kind: Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``. Default: SecretStore`
        :param name: Name of the SecretStore resource.

        :schema: ExternalSecretV1Beta1SpecDataSourceRefStoreRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ee05ae4a797f40081b7fc7ff7fbe24176ce4f18ec8da215e046951f11bebeca)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if kind is not None:
            self._values["kind"] = kind
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def kind(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecDataSourceRefStoreRefKind"]:
        '''Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``.

        :default: SecretStore`

        :schema: ExternalSecretV1Beta1SpecDataSourceRefStoreRef#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataSourceRefStoreRefKind"], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the SecretStore resource.

        :schema: ExternalSecretV1Beta1SpecDataSourceRefStoreRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataSourceRefStoreRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataSourceRefStoreRefKind"
)
class ExternalSecretV1Beta1SpecDataSourceRefStoreRefKind(enum.Enum):
    '''Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``.

    :default: SecretStore`

    :schema: ExternalSecretV1Beta1SpecDataSourceRefStoreRefKind
    '''

    SECRET_STORE = "SECRET_STORE"
    '''SecretStore.'''
    CLUSTER_SECRET_STORE = "CLUSTER_SECRET_STORE"
    '''ClusterSecretStore.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecSecretStoreRef",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "name": "name"},
)
class ExternalSecretV1Beta1SpecSecretStoreRef:
    def __init__(
        self,
        *,
        kind: typing.Optional["ExternalSecretV1Beta1SpecSecretStoreRefKind"] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :param kind: Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``. Default: SecretStore`
        :param name: Name of the SecretStore resource.

        :schema: ExternalSecretV1Beta1SpecSecretStoreRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f1f99a615b28ea8c79a67cd067ee214dfafc7d9ce344d5895cdcba82c5d4337)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if kind is not None:
            self._values["kind"] = kind
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def kind(self) -> typing.Optional["ExternalSecretV1Beta1SpecSecretStoreRefKind"]:
        '''Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``.

        :default: SecretStore`

        :schema: ExternalSecretV1Beta1SpecSecretStoreRef#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecSecretStoreRefKind"], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name of the SecretStore resource.

        :schema: ExternalSecretV1Beta1SpecSecretStoreRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecSecretStoreRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecSecretStoreRefKind")
class ExternalSecretV1Beta1SpecSecretStoreRefKind(enum.Enum):
    '''Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``.

    :default: SecretStore`

    :schema: ExternalSecretV1Beta1SpecSecretStoreRefKind
    '''

    SECRET_STORE = "SECRET_STORE"
    '''SecretStore.'''
    CLUSTER_SECRET_STORE = "CLUSTER_SECRET_STORE"
    '''ClusterSecretStore.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTarget",
    jsii_struct_bases=[],
    name_mapping={
        "creation_policy": "creationPolicy",
        "deletion_policy": "deletionPolicy",
        "immutable": "immutable",
        "name": "name",
        "template": "template",
    },
)
class ExternalSecretV1Beta1SpecTarget:
    def __init__(
        self,
        *,
        creation_policy: typing.Optional["ExternalSecretV1Beta1SpecTargetCreationPolicy"] = None,
        deletion_policy: typing.Optional["ExternalSecretV1Beta1SpecTargetDeletionPolicy"] = None,
        immutable: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
        template: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecTargetTemplate", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.

        :param creation_policy: CreationPolicy defines rules on how to create the resulting Secret. Defaults to "Owner" Default: Owner"
        :param deletion_policy: DeletionPolicy defines rules on how to delete the resulting Secret. Defaults to "Retain" Default: Retain"
        :param immutable: Immutable defines if the final secret will be immutable.
        :param name: The name of the Secret resource to be managed. Defaults to the .metadata.name of the ExternalSecret resource Default: the .metadata.name of the ExternalSecret resource
        :param template: Template defines a blueprint for the created Secret resource.

        :schema: ExternalSecretV1Beta1SpecTarget
        '''
        if isinstance(template, dict):
            template = ExternalSecretV1Beta1SpecTargetTemplate(**template)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__137058ee7bb8bbf207a1c6bea2d7edc847fcb8e66808b8a474d9e3f6cf606abd)
            check_type(argname="argument creation_policy", value=creation_policy, expected_type=type_hints["creation_policy"])
            check_type(argname="argument deletion_policy", value=deletion_policy, expected_type=type_hints["deletion_policy"])
            check_type(argname="argument immutable", value=immutable, expected_type=type_hints["immutable"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument template", value=template, expected_type=type_hints["template"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if creation_policy is not None:
            self._values["creation_policy"] = creation_policy
        if deletion_policy is not None:
            self._values["deletion_policy"] = deletion_policy
        if immutable is not None:
            self._values["immutable"] = immutable
        if name is not None:
            self._values["name"] = name
        if template is not None:
            self._values["template"] = template

    @builtins.property
    def creation_policy(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecTargetCreationPolicy"]:
        '''CreationPolicy defines rules on how to create the resulting Secret.

        Defaults to "Owner"

        :default: Owner"

        :schema: ExternalSecretV1Beta1SpecTarget#creationPolicy
        '''
        result = self._values.get("creation_policy")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecTargetCreationPolicy"], result)

    @builtins.property
    def deletion_policy(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecTargetDeletionPolicy"]:
        '''DeletionPolicy defines rules on how to delete the resulting Secret.

        Defaults to "Retain"

        :default: Retain"

        :schema: ExternalSecretV1Beta1SpecTarget#deletionPolicy
        '''
        result = self._values.get("deletion_policy")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecTargetDeletionPolicy"], result)

    @builtins.property
    def immutable(self) -> typing.Optional[builtins.bool]:
        '''Immutable defines if the final secret will be immutable.

        :schema: ExternalSecretV1Beta1SpecTarget#immutable
        '''
        result = self._values.get("immutable")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource to be managed.

        Defaults to the .metadata.name of the ExternalSecret resource

        :default: the .metadata.name of the ExternalSecret resource

        :schema: ExternalSecretV1Beta1SpecTarget#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def template(self) -> typing.Optional["ExternalSecretV1Beta1SpecTargetTemplate"]:
        '''Template defines a blueprint for the created Secret resource.

        :schema: ExternalSecretV1Beta1SpecTarget#template
        '''
        result = self._values.get("template")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecTargetTemplate"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecTarget(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetCreationPolicy"
)
class ExternalSecretV1Beta1SpecTargetCreationPolicy(enum.Enum):
    '''CreationPolicy defines rules on how to create the resulting Secret.

    Defaults to "Owner"

    :default: Owner"

    :schema: ExternalSecretV1Beta1SpecTargetCreationPolicy
    '''

    OWNER = "OWNER"
    '''Owner.'''
    ORPHAN = "ORPHAN"
    '''Orphan.'''
    MERGE = "MERGE"
    '''Merge.'''
    NONE = "NONE"
    '''None.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetDeletionPolicy"
)
class ExternalSecretV1Beta1SpecTargetDeletionPolicy(enum.Enum):
    '''DeletionPolicy defines rules on how to delete the resulting Secret.

    Defaults to "Retain"

    :default: Retain"

    :schema: ExternalSecretV1Beta1SpecTargetDeletionPolicy
    '''

    DELETE = "DELETE"
    '''Delete.'''
    MERGE = "MERGE"
    '''Merge.'''
    RETAIN = "RETAIN"
    '''Retain.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetTemplate",
    jsii_struct_bases=[],
    name_mapping={
        "data": "data",
        "engine_version": "engineVersion",
        "merge_policy": "mergePolicy",
        "metadata": "metadata",
        "template_from": "templateFrom",
        "type": "type",
    },
)
class ExternalSecretV1Beta1SpecTargetTemplate:
    def __init__(
        self,
        *,
        data: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        engine_version: typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateEngineVersion"] = None,
        merge_policy: typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateMergePolicy"] = None,
        metadata: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecTargetTemplateMetadata", typing.Dict[builtins.str, typing.Any]]] = None,
        template_from: typing.Optional[typing.Sequence[typing.Union["ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom", typing.Dict[builtins.str, typing.Any]]]] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Template defines a blueprint for the created Secret resource.

        :param data: 
        :param engine_version: EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].
        :param merge_policy: 
        :param metadata: ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
        :param template_from: 
        :param type: 

        :schema: ExternalSecretV1Beta1SpecTargetTemplate
        '''
        if isinstance(metadata, dict):
            metadata = ExternalSecretV1Beta1SpecTargetTemplateMetadata(**metadata)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0845c9cb8505c291793a6fac848aa5d4340d17ecc2e58386511e13ecba7b0d77)
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
            check_type(argname="argument engine_version", value=engine_version, expected_type=type_hints["engine_version"])
            check_type(argname="argument merge_policy", value=merge_policy, expected_type=type_hints["merge_policy"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument template_from", value=template_from, expected_type=type_hints["template_from"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if data is not None:
            self._values["data"] = data
        if engine_version is not None:
            self._values["engine_version"] = engine_version
        if merge_policy is not None:
            self._values["merge_policy"] = merge_policy
        if metadata is not None:
            self._values["metadata"] = metadata
        if template_from is not None:
            self._values["template_from"] = template_from
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def data(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplate#data
        '''
        result = self._values.get("data")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def engine_version(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateEngineVersion"]:
        '''EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].

        :schema: ExternalSecretV1Beta1SpecTargetTemplate#engineVersion
        '''
        result = self._values.get("engine_version")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateEngineVersion"], result)

    @builtins.property
    def merge_policy(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateMergePolicy"]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplate#mergePolicy
        '''
        result = self._values.get("merge_policy")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateMergePolicy"], result)

    @builtins.property
    def metadata(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateMetadata"]:
        '''ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.

        :schema: ExternalSecretV1Beta1SpecTargetTemplate#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateMetadata"], result)

    @builtins.property
    def template_from(
        self,
    ) -> typing.Optional[typing.List["ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom"]]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplate#templateFrom
        '''
        result = self._values.get("template_from")
        return typing.cast(typing.Optional[typing.List["ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom"]], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplate#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecTargetTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetTemplateEngineVersion"
)
class ExternalSecretV1Beta1SpecTargetTemplateEngineVersion(enum.Enum):
    '''EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].

    :schema: ExternalSecretV1Beta1SpecTargetTemplateEngineVersion
    '''

    V1 = "V1"
    '''v1.'''
    V2 = "V2"
    '''v2.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetTemplateMergePolicy"
)
class ExternalSecretV1Beta1SpecTargetTemplateMergePolicy(enum.Enum):
    '''
    :schema: ExternalSecretV1Beta1SpecTargetTemplateMergePolicy
    '''

    REPLACE = "REPLACE"
    '''Replace.'''
    MERGE = "MERGE"
    '''Merge.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetTemplateMetadata",
    jsii_struct_bases=[],
    name_mapping={"annotations": "annotations", "labels": "labels"},
)
class ExternalSecretV1Beta1SpecTargetTemplateMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.

        :param annotations: 
        :param labels: 

        :schema: ExternalSecretV1Beta1SpecTargetTemplateMetadata
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__018d8922bc23dbcc72288a6bb9df1ee13ec20a354c2863ebe6f5778d0547c2b9)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if labels is not None:
            self._values["labels"] = labels

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplateMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplateMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecTargetTemplateMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom",
    jsii_struct_bases=[],
    name_mapping={
        "config_map": "configMap",
        "literal": "literal",
        "secret": "secret",
        "target": "target",
    },
)
class ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom:
    def __init__(
        self,
        *,
        config_map: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap", typing.Dict[builtins.str, typing.Any]]] = None,
        literal: typing.Optional[builtins.str] = None,
        secret: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret", typing.Dict[builtins.str, typing.Any]]] = None,
        target: typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromTarget"] = None,
    ) -> None:
        '''
        :param config_map: 
        :param literal: 
        :param secret: 
        :param target: 

        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom
        '''
        if isinstance(config_map, dict):
            config_map = ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap(**config_map)
        if isinstance(secret, dict):
            secret = ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret(**secret)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf8068a43ca684f4a943d7d5e82ab5f65a31b37cd2681ead194fa54dd950d01d)
            check_type(argname="argument config_map", value=config_map, expected_type=type_hints["config_map"])
            check_type(argname="argument literal", value=literal, expected_type=type_hints["literal"])
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
            check_type(argname="argument target", value=target, expected_type=type_hints["target"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if config_map is not None:
            self._values["config_map"] = config_map
        if literal is not None:
            self._values["literal"] = literal
        if secret is not None:
            self._values["secret"] = secret
        if target is not None:
            self._values["target"] = target

    @builtins.property
    def config_map(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap"]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom#configMap
        '''
        result = self._values.get("config_map")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap"], result)

    @builtins.property
    def literal(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom#literal
        '''
        result = self._values.get("literal")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret"]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom#secret
        '''
        result = self._values.get("secret")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret"], result)

    @builtins.property
    def target(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromTarget"]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom#target
        '''
        result = self._values.get("target")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromTarget"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap",
    jsii_struct_bases=[],
    name_mapping={"items": "items", "name": "name"},
)
class ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap:
    def __init__(
        self,
        *,
        items: typing.Sequence[typing.Union["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems", typing.Dict[builtins.str, typing.Any]]],
        name: builtins.str,
    ) -> None:
        '''
        :param items: A list of keys in the ConfigMap/Secret to use as templates for Secret data.
        :param name: The name of the ConfigMap/Secret resource.

        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d4521141f13b4bd1ec1e9d03377bb4f8fb99f832992af18de111f17b9698448)
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "items": items,
            "name": name,
        }

    @builtins.property
    def items(
        self,
    ) -> typing.List["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems"]:
        '''A list of keys in the ConfigMap/Secret to use as templates for Secret data.

        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap#items
        '''
        result = self._values.get("items")
        assert result is not None, "Required property 'items' is missing"
        return typing.cast(typing.List["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems"], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ConfigMap/Secret resource.

        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "template_as": "templateAs"},
)
class ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems:
    def __init__(
        self,
        *,
        key: builtins.str,
        template_as: typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItemsTemplateAs"] = None,
    ) -> None:
        '''
        :param key: A key in the ConfigMap/Secret.
        :param template_as: 

        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__450b9bfafc5b457a75263d0420c05dfd89276947b601ed2cd9c63bca7bc8c6ed)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument template_as", value=template_as, expected_type=type_hints["template_as"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
        }
        if template_as is not None:
            self._values["template_as"] = template_as

    @builtins.property
    def key(self) -> builtins.str:
        '''A key in the ConfigMap/Secret.

        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def template_as(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItemsTemplateAs"]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems#templateAs
        '''
        result = self._values.get("template_as")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItemsTemplateAs"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItemsTemplateAs"
)
class ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItemsTemplateAs(
    enum.Enum,
):
    '''
    :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItemsTemplateAs
    '''

    VALUES = "VALUES"
    '''Values.'''
    KEYS_AND_VALUES = "KEYS_AND_VALUES"
    '''KeysAndValues.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret",
    jsii_struct_bases=[],
    name_mapping={"items": "items", "name": "name"},
)
class ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret:
    def __init__(
        self,
        *,
        items: typing.Sequence[typing.Union["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems", typing.Dict[builtins.str, typing.Any]]],
        name: builtins.str,
    ) -> None:
        '''
        :param items: A list of keys in the ConfigMap/Secret to use as templates for Secret data.
        :param name: The name of the ConfigMap/Secret resource.

        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a4a2e35d3be01cb8a634eeb73ba90e80dfeb0ffe5653a7d44637ac186ee815e7)
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "items": items,
            "name": name,
        }

    @builtins.property
    def items(
        self,
    ) -> typing.List["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems"]:
        '''A list of keys in the ConfigMap/Secret to use as templates for Secret data.

        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret#items
        '''
        result = self._values.get("items")
        assert result is not None, "Required property 'items' is missing"
        return typing.cast(typing.List["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems"], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ConfigMap/Secret resource.

        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "template_as": "templateAs"},
)
class ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems:
    def __init__(
        self,
        *,
        key: builtins.str,
        template_as: typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItemsTemplateAs"] = None,
    ) -> None:
        '''
        :param key: A key in the ConfigMap/Secret.
        :param template_as: 

        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2623eb672daf55d319267bd37583020eebefd412a2e3fa6a451b378cf22e9522)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument template_as", value=template_as, expected_type=type_hints["template_as"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
        }
        if template_as is not None:
            self._values["template_as"] = template_as

    @builtins.property
    def key(self) -> builtins.str:
        '''A key in the ConfigMap/Secret.

        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def template_as(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItemsTemplateAs"]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems#templateAs
        '''
        result = self._values.get("template_as")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItemsTemplateAs"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItemsTemplateAs"
)
class ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItemsTemplateAs(
    enum.Enum,
):
    '''
    :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItemsTemplateAs
    '''

    VALUES = "VALUES"
    '''Values.'''
    KEYS_AND_VALUES = "KEYS_AND_VALUES"
    '''KeysAndValues.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetTemplateTemplateFromTarget"
)
class ExternalSecretV1Beta1SpecTargetTemplateTemplateFromTarget(enum.Enum):
    '''
    :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromTarget
    '''

    DATA = "DATA"
    '''Data.'''
    ANNOTATIONS = "ANNOTATIONS"
    '''Annotations.'''
    LABELS = "LABELS"
    '''Labels.'''


class PushSecret(
    _cdk8s_d3d9af27.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="ioexternal-secrets.PushSecret",
):
    '''
    :schema: PushSecret
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["PushSecretSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a "PushSecret" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param metadata: 
        :param spec: PushSecretSpec configures the behavior of the PushSecret.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0475c36ad45a857daad5f71ebc1259c46fc794d0a66fbf4e2f6f16e2b36672cc)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = PushSecretProps(metadata=metadata, spec=spec)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest")
    @builtins.classmethod
    def manifest(
        cls,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["PushSecretSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> typing.Any:
        '''Renders a Kubernetes manifest for "PushSecret".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param metadata: 
        :param spec: PushSecretSpec configures the behavior of the PushSecret.
        '''
        props = PushSecretProps(metadata=metadata, spec=spec)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''Renders the object to Kubernetes JSON.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> _cdk8s_d3d9af27.GroupVersionKind:
        '''Returns the apiVersion and kind for "PushSecret".'''
        return typing.cast(_cdk8s_d3d9af27.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="ioexternal-secrets.PushSecretProps",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class PushSecretProps:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["PushSecretSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param metadata: 
        :param spec: PushSecretSpec configures the behavior of the PushSecret.

        :schema: PushSecret
        '''
        if isinstance(metadata, dict):
            metadata = _cdk8s_d3d9af27.ApiObjectMetadata(**metadata)
        if isinstance(spec, dict):
            spec = PushSecretSpec(**spec)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6298d58475c4a0eeeb4db1a4072c8490107e3409332c3f4e24092ab4f4bf0097)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(self) -> typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata]:
        '''
        :schema: PushSecret#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata], result)

    @builtins.property
    def spec(self) -> typing.Optional["PushSecretSpec"]:
        '''PushSecretSpec configures the behavior of the PushSecret.

        :schema: PushSecret#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["PushSecretSpec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PushSecretProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.PushSecretSpec",
    jsii_struct_bases=[],
    name_mapping={
        "secret_store_refs": "secretStoreRefs",
        "selector": "selector",
        "data": "data",
        "deletion_policy": "deletionPolicy",
        "refresh_interval": "refreshInterval",
        "template": "template",
        "update_policy": "updatePolicy",
    },
)
class PushSecretSpec:
    def __init__(
        self,
        *,
        secret_store_refs: typing.Sequence[typing.Union["PushSecretSpecSecretStoreRefs", typing.Dict[builtins.str, typing.Any]]],
        selector: typing.Union["PushSecretSpecSelector", typing.Dict[builtins.str, typing.Any]],
        data: typing.Optional[typing.Sequence[typing.Union["PushSecretSpecData", typing.Dict[builtins.str, typing.Any]]]] = None,
        deletion_policy: typing.Optional["PushSecretSpecDeletionPolicy"] = None,
        refresh_interval: typing.Optional[builtins.str] = None,
        template: typing.Optional[typing.Union["PushSecretSpecTemplate", typing.Dict[builtins.str, typing.Any]]] = None,
        update_policy: typing.Optional["PushSecretSpecUpdatePolicy"] = None,
    ) -> None:
        '''PushSecretSpec configures the behavior of the PushSecret.

        :param secret_store_refs: 
        :param selector: The Secret Selector (k8s source) for the Push Secret.
        :param data: Secret Data that should be pushed to providers.
        :param deletion_policy: Deletion Policy to handle Secrets in the provider.
        :param refresh_interval: The Interval to which External Secrets will try to push a secret definition.
        :param template: Template defines a blueprint for the created Secret resource.
        :param update_policy: UpdatePolicy to handle Secrets in the provider.

        :schema: PushSecretSpec
        '''
        if isinstance(selector, dict):
            selector = PushSecretSpecSelector(**selector)
        if isinstance(template, dict):
            template = PushSecretSpecTemplate(**template)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__01e12d461460e19379d69e28b07562f8ff407ec647ae133368d5aebd3e1bad6b)
            check_type(argname="argument secret_store_refs", value=secret_store_refs, expected_type=type_hints["secret_store_refs"])
            check_type(argname="argument selector", value=selector, expected_type=type_hints["selector"])
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
            check_type(argname="argument deletion_policy", value=deletion_policy, expected_type=type_hints["deletion_policy"])
            check_type(argname="argument refresh_interval", value=refresh_interval, expected_type=type_hints["refresh_interval"])
            check_type(argname="argument template", value=template, expected_type=type_hints["template"])
            check_type(argname="argument update_policy", value=update_policy, expected_type=type_hints["update_policy"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_store_refs": secret_store_refs,
            "selector": selector,
        }
        if data is not None:
            self._values["data"] = data
        if deletion_policy is not None:
            self._values["deletion_policy"] = deletion_policy
        if refresh_interval is not None:
            self._values["refresh_interval"] = refresh_interval
        if template is not None:
            self._values["template"] = template
        if update_policy is not None:
            self._values["update_policy"] = update_policy

    @builtins.property
    def secret_store_refs(self) -> typing.List["PushSecretSpecSecretStoreRefs"]:
        '''
        :schema: PushSecretSpec#secretStoreRefs
        '''
        result = self._values.get("secret_store_refs")
        assert result is not None, "Required property 'secret_store_refs' is missing"
        return typing.cast(typing.List["PushSecretSpecSecretStoreRefs"], result)

    @builtins.property
    def selector(self) -> "PushSecretSpecSelector":
        '''The Secret Selector (k8s source) for the Push Secret.

        :schema: PushSecretSpec#selector
        '''
        result = self._values.get("selector")
        assert result is not None, "Required property 'selector' is missing"
        return typing.cast("PushSecretSpecSelector", result)

    @builtins.property
    def data(self) -> typing.Optional[typing.List["PushSecretSpecData"]]:
        '''Secret Data that should be pushed to providers.

        :schema: PushSecretSpec#data
        '''
        result = self._values.get("data")
        return typing.cast(typing.Optional[typing.List["PushSecretSpecData"]], result)

    @builtins.property
    def deletion_policy(self) -> typing.Optional["PushSecretSpecDeletionPolicy"]:
        '''Deletion Policy to handle Secrets in the provider.

        :schema: PushSecretSpec#deletionPolicy
        '''
        result = self._values.get("deletion_policy")
        return typing.cast(typing.Optional["PushSecretSpecDeletionPolicy"], result)

    @builtins.property
    def refresh_interval(self) -> typing.Optional[builtins.str]:
        '''The Interval to which External Secrets will try to push a secret definition.

        :schema: PushSecretSpec#refreshInterval
        '''
        result = self._values.get("refresh_interval")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def template(self) -> typing.Optional["PushSecretSpecTemplate"]:
        '''Template defines a blueprint for the created Secret resource.

        :schema: PushSecretSpec#template
        '''
        result = self._values.get("template")
        return typing.cast(typing.Optional["PushSecretSpecTemplate"], result)

    @builtins.property
    def update_policy(self) -> typing.Optional["PushSecretSpecUpdatePolicy"]:
        '''UpdatePolicy to handle Secrets in the provider.

        :schema: PushSecretSpec#updatePolicy
        '''
        result = self._values.get("update_policy")
        return typing.cast(typing.Optional["PushSecretSpecUpdatePolicy"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PushSecretSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.PushSecretSpecData",
    jsii_struct_bases=[],
    name_mapping={
        "match": "match",
        "conversion_strategy": "conversionStrategy",
        "metadata": "metadata",
    },
)
class PushSecretSpecData:
    def __init__(
        self,
        *,
        match: typing.Union["PushSecretSpecDataMatch", typing.Dict[builtins.str, typing.Any]],
        conversion_strategy: typing.Optional["PushSecretSpecDataConversionStrategy"] = None,
        metadata: typing.Any = None,
    ) -> None:
        '''
        :param match: Match a given Secret Key to be pushed to the provider.
        :param conversion_strategy: Used to define a conversion Strategy for the secret keys.
        :param metadata: Metadata is metadata attached to the secret. The structure of metadata is provider specific, please look it up in the provider documentation.

        :schema: PushSecretSpecData
        '''
        if isinstance(match, dict):
            match = PushSecretSpecDataMatch(**match)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e69051c5188259a4dc4335438fe6e7bbda39d93381fe4f0033cda0f3f3bfcf8)
            check_type(argname="argument match", value=match, expected_type=type_hints["match"])
            check_type(argname="argument conversion_strategy", value=conversion_strategy, expected_type=type_hints["conversion_strategy"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "match": match,
        }
        if conversion_strategy is not None:
            self._values["conversion_strategy"] = conversion_strategy
        if metadata is not None:
            self._values["metadata"] = metadata

    @builtins.property
    def match(self) -> "PushSecretSpecDataMatch":
        '''Match a given Secret Key to be pushed to the provider.

        :schema: PushSecretSpecData#match
        '''
        result = self._values.get("match")
        assert result is not None, "Required property 'match' is missing"
        return typing.cast("PushSecretSpecDataMatch", result)

    @builtins.property
    def conversion_strategy(
        self,
    ) -> typing.Optional["PushSecretSpecDataConversionStrategy"]:
        '''Used to define a conversion Strategy for the secret keys.

        :schema: PushSecretSpecData#conversionStrategy
        '''
        result = self._values.get("conversion_strategy")
        return typing.cast(typing.Optional["PushSecretSpecDataConversionStrategy"], result)

    @builtins.property
    def metadata(self) -> typing.Any:
        '''Metadata is metadata attached to the secret.

        The structure of metadata is provider specific, please look it up in the provider documentation.

        :schema: PushSecretSpecData#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Any, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PushSecretSpecData(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.PushSecretSpecDataConversionStrategy")
class PushSecretSpecDataConversionStrategy(enum.Enum):
    '''Used to define a conversion Strategy for the secret keys.

    :schema: PushSecretSpecDataConversionStrategy
    '''

    NONE = "NONE"
    '''None.'''
    REVERSE_UNICODE = "REVERSE_UNICODE"
    '''ReverseUnicode.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.PushSecretSpecDataMatch",
    jsii_struct_bases=[],
    name_mapping={"remote_ref": "remoteRef", "secret_key": "secretKey"},
)
class PushSecretSpecDataMatch:
    def __init__(
        self,
        *,
        remote_ref: typing.Union["PushSecretSpecDataMatchRemoteRef", typing.Dict[builtins.str, typing.Any]],
        secret_key: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Match a given Secret Key to be pushed to the provider.

        :param remote_ref: Remote Refs to push to providers.
        :param secret_key: Secret Key to be pushed.

        :schema: PushSecretSpecDataMatch
        '''
        if isinstance(remote_ref, dict):
            remote_ref = PushSecretSpecDataMatchRemoteRef(**remote_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2ac875402ec72b0e6df3e3764db655ec5d29fa1a690e7cb0cec2838ae0d9e339)
            check_type(argname="argument remote_ref", value=remote_ref, expected_type=type_hints["remote_ref"])
            check_type(argname="argument secret_key", value=secret_key, expected_type=type_hints["secret_key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "remote_ref": remote_ref,
        }
        if secret_key is not None:
            self._values["secret_key"] = secret_key

    @builtins.property
    def remote_ref(self) -> "PushSecretSpecDataMatchRemoteRef":
        '''Remote Refs to push to providers.

        :schema: PushSecretSpecDataMatch#remoteRef
        '''
        result = self._values.get("remote_ref")
        assert result is not None, "Required property 'remote_ref' is missing"
        return typing.cast("PushSecretSpecDataMatchRemoteRef", result)

    @builtins.property
    def secret_key(self) -> typing.Optional[builtins.str]:
        '''Secret Key to be pushed.

        :schema: PushSecretSpecDataMatch#secretKey
        '''
        result = self._values.get("secret_key")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PushSecretSpecDataMatch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.PushSecretSpecDataMatchRemoteRef",
    jsii_struct_bases=[],
    name_mapping={"remote_key": "remoteKey", "property": "property"},
)
class PushSecretSpecDataMatchRemoteRef:
    def __init__(
        self,
        *,
        remote_key: builtins.str,
        property: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Remote Refs to push to providers.

        :param remote_key: Name of the resulting provider secret.
        :param property: Name of the property in the resulting secret.

        :schema: PushSecretSpecDataMatchRemoteRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e133030e524ef8e2d29add5377ec0a66cf7ab81602d9fd744ca787e2c66078a2)
            check_type(argname="argument remote_key", value=remote_key, expected_type=type_hints["remote_key"])
            check_type(argname="argument property", value=property, expected_type=type_hints["property"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "remote_key": remote_key,
        }
        if property is not None:
            self._values["property"] = property

    @builtins.property
    def remote_key(self) -> builtins.str:
        '''Name of the resulting provider secret.

        :schema: PushSecretSpecDataMatchRemoteRef#remoteKey
        '''
        result = self._values.get("remote_key")
        assert result is not None, "Required property 'remote_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def property(self) -> typing.Optional[builtins.str]:
        '''Name of the property in the resulting secret.

        :schema: PushSecretSpecDataMatchRemoteRef#property
        '''
        result = self._values.get("property")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PushSecretSpecDataMatchRemoteRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.PushSecretSpecDeletionPolicy")
class PushSecretSpecDeletionPolicy(enum.Enum):
    '''Deletion Policy to handle Secrets in the provider.

    :schema: PushSecretSpecDeletionPolicy
    '''

    DELETE = "DELETE"
    '''Delete.'''
    NONE = "NONE"
    '''None.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.PushSecretSpecSecretStoreRefs",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "label_selector": "labelSelector", "name": "name"},
)
class PushSecretSpecSecretStoreRefs:
    def __init__(
        self,
        *,
        kind: typing.Optional["PushSecretSpecSecretStoreRefsKind"] = None,
        label_selector: typing.Optional[typing.Union["PushSecretSpecSecretStoreRefsLabelSelector", typing.Dict[builtins.str, typing.Any]]] = None,
        name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param kind: Kind of the SecretStore resource (SecretStore or ClusterSecretStore).
        :param label_selector: Optionally, sync to secret stores with label selector.
        :param name: Optionally, sync to the SecretStore of the given name.

        :schema: PushSecretSpecSecretStoreRefs
        '''
        if isinstance(label_selector, dict):
            label_selector = PushSecretSpecSecretStoreRefsLabelSelector(**label_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df1c4f5b609f7859699b7e14f448e08967d0f3942b0f5ee5bbd5045392427b6a)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument label_selector", value=label_selector, expected_type=type_hints["label_selector"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if kind is not None:
            self._values["kind"] = kind
        if label_selector is not None:
            self._values["label_selector"] = label_selector
        if name is not None:
            self._values["name"] = name

    @builtins.property
    def kind(self) -> typing.Optional["PushSecretSpecSecretStoreRefsKind"]:
        '''Kind of the SecretStore resource (SecretStore or ClusterSecretStore).

        :schema: PushSecretSpecSecretStoreRefs#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional["PushSecretSpecSecretStoreRefsKind"], result)

    @builtins.property
    def label_selector(
        self,
    ) -> typing.Optional["PushSecretSpecSecretStoreRefsLabelSelector"]:
        '''Optionally, sync to secret stores with label selector.

        :schema: PushSecretSpecSecretStoreRefs#labelSelector
        '''
        result = self._values.get("label_selector")
        return typing.cast(typing.Optional["PushSecretSpecSecretStoreRefsLabelSelector"], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Optionally, sync to the SecretStore of the given name.

        :schema: PushSecretSpecSecretStoreRefs#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PushSecretSpecSecretStoreRefs(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.PushSecretSpecSecretStoreRefsKind")
class PushSecretSpecSecretStoreRefsKind(enum.Enum):
    '''Kind of the SecretStore resource (SecretStore or ClusterSecretStore).

    :schema: PushSecretSpecSecretStoreRefsKind
    '''

    SECRET_STORE = "SECRET_STORE"
    '''SecretStore.'''
    CLUSTER_SECRET_STORE = "CLUSTER_SECRET_STORE"
    '''ClusterSecretStore.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.PushSecretSpecSecretStoreRefsLabelSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class PushSecretSpecSecretStoreRefsLabelSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Optionally, sync to secret stores with label selector.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: PushSecretSpecSecretStoreRefsLabelSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__570699534ed6780f5603a7134b0003f72230f360397d88e8c85caed17f8d7592)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: PushSecretSpecSecretStoreRefsLabelSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: PushSecretSpecSecretStoreRefsLabelSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PushSecretSpecSecretStoreRefsLabelSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f0b7a6f1944a19aa57cbe54d5958b908824e4a80e11d401870c40abcd1fe19f)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.PushSecretSpecSelector",
    jsii_struct_bases=[],
    name_mapping={"generator_ref": "generatorRef", "secret": "secret"},
)
class PushSecretSpecSelector:
    def __init__(
        self,
        *,
        generator_ref: typing.Optional[typing.Union["PushSecretSpecSelectorGeneratorRef", typing.Dict[builtins.str, typing.Any]]] = None,
        secret: typing.Optional[typing.Union["PushSecretSpecSelectorSecret", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''The Secret Selector (k8s source) for the Push Secret.

        :param generator_ref: Point to a generator to create a Secret.
        :param secret: Select a Secret to Push.

        :schema: PushSecretSpecSelector
        '''
        if isinstance(generator_ref, dict):
            generator_ref = PushSecretSpecSelectorGeneratorRef(**generator_ref)
        if isinstance(secret, dict):
            secret = PushSecretSpecSelectorSecret(**secret)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d7a3f2adcf7de568e829e7d5eee2938ce2ab1a46b00124f458bd6972df2704b)
            check_type(argname="argument generator_ref", value=generator_ref, expected_type=type_hints["generator_ref"])
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if generator_ref is not None:
            self._values["generator_ref"] = generator_ref
        if secret is not None:
            self._values["secret"] = secret

    @builtins.property
    def generator_ref(self) -> typing.Optional["PushSecretSpecSelectorGeneratorRef"]:
        '''Point to a generator to create a Secret.

        :schema: PushSecretSpecSelector#generatorRef
        '''
        result = self._values.get("generator_ref")
        return typing.cast(typing.Optional["PushSecretSpecSelectorGeneratorRef"], result)

    @builtins.property
    def secret(self) -> typing.Optional["PushSecretSpecSelectorSecret"]:
        '''Select a Secret to Push.

        :schema: PushSecretSpecSelector#secret
        '''
        result = self._values.get("secret")
        return typing.cast(typing.Optional["PushSecretSpecSelectorSecret"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PushSecretSpecSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.PushSecretSpecSelectorGeneratorRef",
    jsii_struct_bases=[],
    name_mapping={"kind": "kind", "name": "name", "api_version": "apiVersion"},
)
class PushSecretSpecSelectorGeneratorRef:
    def __init__(
        self,
        *,
        kind: "PushSecretSpecSelectorGeneratorRefKind",
        name: builtins.str,
        api_version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Point to a generator to create a Secret.

        :param kind: Specify the Kind of the generator resource.
        :param name: Specify the name of the generator resource.
        :param api_version: Specify the apiVersion of the generator resource.

        :schema: PushSecretSpecSelectorGeneratorRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a43726c25cc295cb5613a0efacde6c953b6d66e651c10de9a43522604161262)
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument api_version", value=api_version, expected_type=type_hints["api_version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "kind": kind,
            "name": name,
        }
        if api_version is not None:
            self._values["api_version"] = api_version

    @builtins.property
    def kind(self) -> "PushSecretSpecSelectorGeneratorRefKind":
        '''Specify the Kind of the generator resource.

        :schema: PushSecretSpecSelectorGeneratorRef#kind
        '''
        result = self._values.get("kind")
        assert result is not None, "Required property 'kind' is missing"
        return typing.cast("PushSecretSpecSelectorGeneratorRefKind", result)

    @builtins.property
    def name(self) -> builtins.str:
        '''Specify the name of the generator resource.

        :schema: PushSecretSpecSelectorGeneratorRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_version(self) -> typing.Optional[builtins.str]:
        '''Specify the apiVersion of the generator resource.

        :schema: PushSecretSpecSelectorGeneratorRef#apiVersion
        '''
        result = self._values.get("api_version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PushSecretSpecSelectorGeneratorRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.PushSecretSpecSelectorGeneratorRefKind")
class PushSecretSpecSelectorGeneratorRefKind(enum.Enum):
    '''Specify the Kind of the generator resource.

    :schema: PushSecretSpecSelectorGeneratorRefKind
    '''

    ACR_ACCESS_TOKEN = "ACR_ACCESS_TOKEN"
    '''ACRAccessToken.'''
    CLUSTER_GENERATOR = "CLUSTER_GENERATOR"
    '''ClusterGenerator.'''
    ECR_AUTHORIZATION_TOKEN = "ECR_AUTHORIZATION_TOKEN"
    '''ECRAuthorizationToken.'''
    FAKE = "FAKE"
    '''Fake.'''
    GCR_ACCESS_TOKEN = "GCR_ACCESS_TOKEN"
    '''GCRAccessToken.'''
    GITHUB_ACCESS_TOKEN = "GITHUB_ACCESS_TOKEN"
    '''GithubAccessToken.'''
    PASSWORD = "PASSWORD"
    '''Password.'''
    STS_SESSION_TOKEN = "STS_SESSION_TOKEN"
    '''STSSessionToken.'''
    UUID = "UUID"
    '''UUID.'''
    VAULT_DYNAMIC_SECRET = "VAULT_DYNAMIC_SECRET"
    '''VaultDynamicSecret.'''
    WEBHOOK = "WEBHOOK"
    '''Webhook.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.PushSecretSpecSelectorSecret",
    jsii_struct_bases=[],
    name_mapping={"name": "name"},
)
class PushSecretSpecSelectorSecret:
    def __init__(self, *, name: builtins.str) -> None:
        '''Select a Secret to Push.

        :param name: Name of the Secret. The Secret must exist in the same namespace as the PushSecret manifest.

        :schema: PushSecretSpecSelectorSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f7b91364067418846d0a3b2395366778e11064c3f9e61a8308636472ad20c561)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the Secret.

        The Secret must exist in the same namespace as the PushSecret manifest.

        :schema: PushSecretSpecSelectorSecret#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PushSecretSpecSelectorSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.PushSecretSpecTemplate",
    jsii_struct_bases=[],
    name_mapping={
        "data": "data",
        "engine_version": "engineVersion",
        "merge_policy": "mergePolicy",
        "metadata": "metadata",
        "template_from": "templateFrom",
        "type": "type",
    },
)
class PushSecretSpecTemplate:
    def __init__(
        self,
        *,
        data: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        engine_version: typing.Optional["PushSecretSpecTemplateEngineVersion"] = None,
        merge_policy: typing.Optional["PushSecretSpecTemplateMergePolicy"] = None,
        metadata: typing.Optional[typing.Union["PushSecretSpecTemplateMetadata", typing.Dict[builtins.str, typing.Any]]] = None,
        template_from: typing.Optional[typing.Sequence[typing.Union["PushSecretSpecTemplateTemplateFrom", typing.Dict[builtins.str, typing.Any]]]] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Template defines a blueprint for the created Secret resource.

        :param data: 
        :param engine_version: EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].
        :param merge_policy: 
        :param metadata: ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
        :param template_from: 
        :param type: 

        :schema: PushSecretSpecTemplate
        '''
        if isinstance(metadata, dict):
            metadata = PushSecretSpecTemplateMetadata(**metadata)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__043efa311dbe27603a426dd211a811e5149303d0034c83846ba775fa2e9085f5)
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
            check_type(argname="argument engine_version", value=engine_version, expected_type=type_hints["engine_version"])
            check_type(argname="argument merge_policy", value=merge_policy, expected_type=type_hints["merge_policy"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument template_from", value=template_from, expected_type=type_hints["template_from"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if data is not None:
            self._values["data"] = data
        if engine_version is not None:
            self._values["engine_version"] = engine_version
        if merge_policy is not None:
            self._values["merge_policy"] = merge_policy
        if metadata is not None:
            self._values["metadata"] = metadata
        if template_from is not None:
            self._values["template_from"] = template_from
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def data(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: PushSecretSpecTemplate#data
        '''
        result = self._values.get("data")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def engine_version(self) -> typing.Optional["PushSecretSpecTemplateEngineVersion"]:
        '''EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].

        :schema: PushSecretSpecTemplate#engineVersion
        '''
        result = self._values.get("engine_version")
        return typing.cast(typing.Optional["PushSecretSpecTemplateEngineVersion"], result)

    @builtins.property
    def merge_policy(self) -> typing.Optional["PushSecretSpecTemplateMergePolicy"]:
        '''
        :schema: PushSecretSpecTemplate#mergePolicy
        '''
        result = self._values.get("merge_policy")
        return typing.cast(typing.Optional["PushSecretSpecTemplateMergePolicy"], result)

    @builtins.property
    def metadata(self) -> typing.Optional["PushSecretSpecTemplateMetadata"]:
        '''ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.

        :schema: PushSecretSpecTemplate#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["PushSecretSpecTemplateMetadata"], result)

    @builtins.property
    def template_from(
        self,
    ) -> typing.Optional[typing.List["PushSecretSpecTemplateTemplateFrom"]]:
        '''
        :schema: PushSecretSpecTemplate#templateFrom
        '''
        result = self._values.get("template_from")
        return typing.cast(typing.Optional[typing.List["PushSecretSpecTemplateTemplateFrom"]], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :schema: PushSecretSpecTemplate#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PushSecretSpecTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.PushSecretSpecTemplateEngineVersion")
class PushSecretSpecTemplateEngineVersion(enum.Enum):
    '''EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].

    :schema: PushSecretSpecTemplateEngineVersion
    '''

    V1 = "V1"
    '''v1.'''
    V2 = "V2"
    '''v2.'''


@jsii.enum(jsii_type="ioexternal-secrets.PushSecretSpecTemplateMergePolicy")
class PushSecretSpecTemplateMergePolicy(enum.Enum):
    '''
    :schema: PushSecretSpecTemplateMergePolicy
    '''

    REPLACE = "REPLACE"
    '''Replace.'''
    MERGE = "MERGE"
    '''Merge.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.PushSecretSpecTemplateMetadata",
    jsii_struct_bases=[],
    name_mapping={"annotations": "annotations", "labels": "labels"},
)
class PushSecretSpecTemplateMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.

        :param annotations: 
        :param labels: 

        :schema: PushSecretSpecTemplateMetadata
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d52589b70a620d8ac512086f76140bbf322ad60786b3dec8258b5b52f568600)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if labels is not None:
            self._values["labels"] = labels

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: PushSecretSpecTemplateMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: PushSecretSpecTemplateMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PushSecretSpecTemplateMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.PushSecretSpecTemplateTemplateFrom",
    jsii_struct_bases=[],
    name_mapping={
        "config_map": "configMap",
        "literal": "literal",
        "secret": "secret",
        "target": "target",
    },
)
class PushSecretSpecTemplateTemplateFrom:
    def __init__(
        self,
        *,
        config_map: typing.Optional[typing.Union["PushSecretSpecTemplateTemplateFromConfigMap", typing.Dict[builtins.str, typing.Any]]] = None,
        literal: typing.Optional[builtins.str] = None,
        secret: typing.Optional[typing.Union["PushSecretSpecTemplateTemplateFromSecret", typing.Dict[builtins.str, typing.Any]]] = None,
        target: typing.Optional["PushSecretSpecTemplateTemplateFromTarget"] = None,
    ) -> None:
        '''
        :param config_map: 
        :param literal: 
        :param secret: 
        :param target: 

        :schema: PushSecretSpecTemplateTemplateFrom
        '''
        if isinstance(config_map, dict):
            config_map = PushSecretSpecTemplateTemplateFromConfigMap(**config_map)
        if isinstance(secret, dict):
            secret = PushSecretSpecTemplateTemplateFromSecret(**secret)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f4a614224c0c7c641288cae1b707047dac305041493dfd9c87bbabace35f1620)
            check_type(argname="argument config_map", value=config_map, expected_type=type_hints["config_map"])
            check_type(argname="argument literal", value=literal, expected_type=type_hints["literal"])
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
            check_type(argname="argument target", value=target, expected_type=type_hints["target"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if config_map is not None:
            self._values["config_map"] = config_map
        if literal is not None:
            self._values["literal"] = literal
        if secret is not None:
            self._values["secret"] = secret
        if target is not None:
            self._values["target"] = target

    @builtins.property
    def config_map(
        self,
    ) -> typing.Optional["PushSecretSpecTemplateTemplateFromConfigMap"]:
        '''
        :schema: PushSecretSpecTemplateTemplateFrom#configMap
        '''
        result = self._values.get("config_map")
        return typing.cast(typing.Optional["PushSecretSpecTemplateTemplateFromConfigMap"], result)

    @builtins.property
    def literal(self) -> typing.Optional[builtins.str]:
        '''
        :schema: PushSecretSpecTemplateTemplateFrom#literal
        '''
        result = self._values.get("literal")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret(self) -> typing.Optional["PushSecretSpecTemplateTemplateFromSecret"]:
        '''
        :schema: PushSecretSpecTemplateTemplateFrom#secret
        '''
        result = self._values.get("secret")
        return typing.cast(typing.Optional["PushSecretSpecTemplateTemplateFromSecret"], result)

    @builtins.property
    def target(self) -> typing.Optional["PushSecretSpecTemplateTemplateFromTarget"]:
        '''
        :schema: PushSecretSpecTemplateTemplateFrom#target
        '''
        result = self._values.get("target")
        return typing.cast(typing.Optional["PushSecretSpecTemplateTemplateFromTarget"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PushSecretSpecTemplateTemplateFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.PushSecretSpecTemplateTemplateFromConfigMap",
    jsii_struct_bases=[],
    name_mapping={"items": "items", "name": "name"},
)
class PushSecretSpecTemplateTemplateFromConfigMap:
    def __init__(
        self,
        *,
        items: typing.Sequence[typing.Union["PushSecretSpecTemplateTemplateFromConfigMapItems", typing.Dict[builtins.str, typing.Any]]],
        name: builtins.str,
    ) -> None:
        '''
        :param items: A list of keys in the ConfigMap/Secret to use as templates for Secret data.
        :param name: The name of the ConfigMap/Secret resource.

        :schema: PushSecretSpecTemplateTemplateFromConfigMap
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab8fa0fe2413fb0ecd9497afcfe96a9033efa9c944df15e078cf2dbb321fdd8c)
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "items": items,
            "name": name,
        }

    @builtins.property
    def items(self) -> typing.List["PushSecretSpecTemplateTemplateFromConfigMapItems"]:
        '''A list of keys in the ConfigMap/Secret to use as templates for Secret data.

        :schema: PushSecretSpecTemplateTemplateFromConfigMap#items
        '''
        result = self._values.get("items")
        assert result is not None, "Required property 'items' is missing"
        return typing.cast(typing.List["PushSecretSpecTemplateTemplateFromConfigMapItems"], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ConfigMap/Secret resource.

        :schema: PushSecretSpecTemplateTemplateFromConfigMap#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PushSecretSpecTemplateTemplateFromConfigMap(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.PushSecretSpecTemplateTemplateFromConfigMapItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "template_as": "templateAs"},
)
class PushSecretSpecTemplateTemplateFromConfigMapItems:
    def __init__(
        self,
        *,
        key: builtins.str,
        template_as: typing.Optional["PushSecretSpecTemplateTemplateFromConfigMapItemsTemplateAs"] = None,
    ) -> None:
        '''
        :param key: A key in the ConfigMap/Secret.
        :param template_as: 

        :schema: PushSecretSpecTemplateTemplateFromConfigMapItems
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e6db7a84c42a39b4216b7fad6296c30fafe517dddacb69bc4a4cec9f07552b2a)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument template_as", value=template_as, expected_type=type_hints["template_as"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
        }
        if template_as is not None:
            self._values["template_as"] = template_as

    @builtins.property
    def key(self) -> builtins.str:
        '''A key in the ConfigMap/Secret.

        :schema: PushSecretSpecTemplateTemplateFromConfigMapItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def template_as(
        self,
    ) -> typing.Optional["PushSecretSpecTemplateTemplateFromConfigMapItemsTemplateAs"]:
        '''
        :schema: PushSecretSpecTemplateTemplateFromConfigMapItems#templateAs
        '''
        result = self._values.get("template_as")
        return typing.cast(typing.Optional["PushSecretSpecTemplateTemplateFromConfigMapItemsTemplateAs"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PushSecretSpecTemplateTemplateFromConfigMapItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.PushSecretSpecTemplateTemplateFromConfigMapItemsTemplateAs"
)
class PushSecretSpecTemplateTemplateFromConfigMapItemsTemplateAs(enum.Enum):
    '''
    :schema: PushSecretSpecTemplateTemplateFromConfigMapItemsTemplateAs
    '''

    VALUES = "VALUES"
    '''Values.'''
    KEYS_AND_VALUES = "KEYS_AND_VALUES"
    '''KeysAndValues.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.PushSecretSpecTemplateTemplateFromSecret",
    jsii_struct_bases=[],
    name_mapping={"items": "items", "name": "name"},
)
class PushSecretSpecTemplateTemplateFromSecret:
    def __init__(
        self,
        *,
        items: typing.Sequence[typing.Union["PushSecretSpecTemplateTemplateFromSecretItems", typing.Dict[builtins.str, typing.Any]]],
        name: builtins.str,
    ) -> None:
        '''
        :param items: A list of keys in the ConfigMap/Secret to use as templates for Secret data.
        :param name: The name of the ConfigMap/Secret resource.

        :schema: PushSecretSpecTemplateTemplateFromSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cc8257e94fa508bc1d240a1c74aee6b95681f4425961467f7052144b089177af)
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "items": items,
            "name": name,
        }

    @builtins.property
    def items(self) -> typing.List["PushSecretSpecTemplateTemplateFromSecretItems"]:
        '''A list of keys in the ConfigMap/Secret to use as templates for Secret data.

        :schema: PushSecretSpecTemplateTemplateFromSecret#items
        '''
        result = self._values.get("items")
        assert result is not None, "Required property 'items' is missing"
        return typing.cast(typing.List["PushSecretSpecTemplateTemplateFromSecretItems"], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ConfigMap/Secret resource.

        :schema: PushSecretSpecTemplateTemplateFromSecret#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PushSecretSpecTemplateTemplateFromSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.PushSecretSpecTemplateTemplateFromSecretItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "template_as": "templateAs"},
)
class PushSecretSpecTemplateTemplateFromSecretItems:
    def __init__(
        self,
        *,
        key: builtins.str,
        template_as: typing.Optional["PushSecretSpecTemplateTemplateFromSecretItemsTemplateAs"] = None,
    ) -> None:
        '''
        :param key: A key in the ConfigMap/Secret.
        :param template_as: 

        :schema: PushSecretSpecTemplateTemplateFromSecretItems
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9339fc9558b78011b1c6592c9f29be59728aad524684c223264d0508baaf19cd)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument template_as", value=template_as, expected_type=type_hints["template_as"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
        }
        if template_as is not None:
            self._values["template_as"] = template_as

    @builtins.property
    def key(self) -> builtins.str:
        '''A key in the ConfigMap/Secret.

        :schema: PushSecretSpecTemplateTemplateFromSecretItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def template_as(
        self,
    ) -> typing.Optional["PushSecretSpecTemplateTemplateFromSecretItemsTemplateAs"]:
        '''
        :schema: PushSecretSpecTemplateTemplateFromSecretItems#templateAs
        '''
        result = self._values.get("template_as")
        return typing.cast(typing.Optional["PushSecretSpecTemplateTemplateFromSecretItemsTemplateAs"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PushSecretSpecTemplateTemplateFromSecretItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.PushSecretSpecTemplateTemplateFromSecretItemsTemplateAs"
)
class PushSecretSpecTemplateTemplateFromSecretItemsTemplateAs(enum.Enum):
    '''
    :schema: PushSecretSpecTemplateTemplateFromSecretItemsTemplateAs
    '''

    VALUES = "VALUES"
    '''Values.'''
    KEYS_AND_VALUES = "KEYS_AND_VALUES"
    '''KeysAndValues.'''


@jsii.enum(jsii_type="ioexternal-secrets.PushSecretSpecTemplateTemplateFromTarget")
class PushSecretSpecTemplateTemplateFromTarget(enum.Enum):
    '''
    :schema: PushSecretSpecTemplateTemplateFromTarget
    '''

    DATA = "DATA"
    '''Data.'''
    ANNOTATIONS = "ANNOTATIONS"
    '''Annotations.'''
    LABELS = "LABELS"
    '''Labels.'''


@jsii.enum(jsii_type="ioexternal-secrets.PushSecretSpecUpdatePolicy")
class PushSecretSpecUpdatePolicy(enum.Enum):
    '''UpdatePolicy to handle Secrets in the provider.

    :schema: PushSecretSpecUpdatePolicy
    '''

    REPLACE = "REPLACE"
    '''Replace.'''
    IF_NOT_EXISTS = "IF_NOT_EXISTS"
    '''IfNotExists.'''


class SecretStore(
    _cdk8s_d3d9af27.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="ioexternal-secrets.SecretStore",
):
    '''SecretStore represents a secure external location for storing secrets, which can be referenced as part of ``storeRef`` fields.

    :schema: SecretStore
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["SecretStoreSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a "SecretStore" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__180aec373b8c9c56e68a264b2b4b4d292b94771886f0aa691cf5bb6dbec97d6b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SecretStoreProps(metadata=metadata, spec=spec)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest")
    @builtins.classmethod
    def manifest(
        cls,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["SecretStoreSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> typing.Any:
        '''Renders a Kubernetes manifest for "SecretStore".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.
        '''
        props = SecretStoreProps(metadata=metadata, spec=spec)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''Renders the object to Kubernetes JSON.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> _cdk8s_d3d9af27.GroupVersionKind:
        '''Returns the apiVersion and kind for "SecretStore".'''
        return typing.cast(_cdk8s_d3d9af27.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreProps",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class SecretStoreProps:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["SecretStoreSpec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''SecretStore represents a secure external location for storing secrets, which can be referenced as part of ``storeRef`` fields.

        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.

        :schema: SecretStore
        '''
        if isinstance(metadata, dict):
            metadata = _cdk8s_d3d9af27.ApiObjectMetadata(**metadata)
        if isinstance(spec, dict):
            spec = SecretStoreSpec(**spec)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d1dab5bf5499b6000b83acce303ccadfb92208c478648fa8e4071edb8459ed03)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(self) -> typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata]:
        '''
        :schema: SecretStore#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata], result)

    @builtins.property
    def spec(self) -> typing.Optional["SecretStoreSpec"]:
        '''SecretStoreSpec defines the desired state of SecretStore.

        :schema: SecretStore#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["SecretStoreSpec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpec",
    jsii_struct_bases=[],
    name_mapping={
        "provider": "provider",
        "controller": "controller",
        "retry_settings": "retrySettings",
    },
)
class SecretStoreSpec:
    def __init__(
        self,
        *,
        provider: typing.Union["SecretStoreSpecProvider", typing.Dict[builtins.str, typing.Any]],
        controller: typing.Optional[builtins.str] = None,
        retry_settings: typing.Optional[typing.Union["SecretStoreSpecRetrySettings", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''SecretStoreSpec defines the desired state of SecretStore.

        :param provider: Used to configure the provider. Only one provider may be set
        :param controller: Used to select the correct ESO controller (think: ingress.ingressClassName) The ESO controller is instantiated with a specific controller name and filters ES based on this property.
        :param retry_settings: Used to configure http retries if failed.

        :schema: SecretStoreSpec
        '''
        if isinstance(provider, dict):
            provider = SecretStoreSpecProvider(**provider)
        if isinstance(retry_settings, dict):
            retry_settings = SecretStoreSpecRetrySettings(**retry_settings)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba085ab3c8441d364a5007e3094da84533695a382d5308b8e6f1b321858ef625)
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument controller", value=controller, expected_type=type_hints["controller"])
            check_type(argname="argument retry_settings", value=retry_settings, expected_type=type_hints["retry_settings"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "provider": provider,
        }
        if controller is not None:
            self._values["controller"] = controller
        if retry_settings is not None:
            self._values["retry_settings"] = retry_settings

    @builtins.property
    def provider(self) -> "SecretStoreSpecProvider":
        '''Used to configure the provider.

        Only one provider may be set

        :schema: SecretStoreSpec#provider
        '''
        result = self._values.get("provider")
        assert result is not None, "Required property 'provider' is missing"
        return typing.cast("SecretStoreSpecProvider", result)

    @builtins.property
    def controller(self) -> typing.Optional[builtins.str]:
        '''Used to select the correct ESO controller (think: ingress.ingressClassName) The ESO controller is instantiated with a specific controller name and filters ES based on this property.

        :schema: SecretStoreSpec#controller
        '''
        result = self._values.get("controller")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def retry_settings(self) -> typing.Optional["SecretStoreSpecRetrySettings"]:
        '''Used to configure http retries if failed.

        :schema: SecretStoreSpec#retrySettings
        '''
        result = self._values.get("retry_settings")
        return typing.cast(typing.Optional["SecretStoreSpecRetrySettings"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProvider",
    jsii_struct_bases=[],
    name_mapping={
        "akeyless": "akeyless",
        "alibaba": "alibaba",
        "aws": "aws",
        "azurekv": "azurekv",
        "fake": "fake",
        "gcpsm": "gcpsm",
        "gitlab": "gitlab",
        "ibm": "ibm",
        "kubernetes": "kubernetes",
        "oracle": "oracle",
        "passworddepot": "passworddepot",
        "vault": "vault",
        "webhook": "webhook",
        "yandexlockbox": "yandexlockbox",
    },
)
class SecretStoreSpecProvider:
    def __init__(
        self,
        *,
        akeyless: typing.Optional[typing.Union["SecretStoreSpecProviderAkeyless", typing.Dict[builtins.str, typing.Any]]] = None,
        alibaba: typing.Optional[typing.Union["SecretStoreSpecProviderAlibaba", typing.Dict[builtins.str, typing.Any]]] = None,
        aws: typing.Optional[typing.Union["SecretStoreSpecProviderAws", typing.Dict[builtins.str, typing.Any]]] = None,
        azurekv: typing.Optional[typing.Union["SecretStoreSpecProviderAzurekv", typing.Dict[builtins.str, typing.Any]]] = None,
        fake: typing.Optional[typing.Union["SecretStoreSpecProviderFake", typing.Dict[builtins.str, typing.Any]]] = None,
        gcpsm: typing.Optional[typing.Union["SecretStoreSpecProviderGcpsm", typing.Dict[builtins.str, typing.Any]]] = None,
        gitlab: typing.Optional[typing.Union["SecretStoreSpecProviderGitlab", typing.Dict[builtins.str, typing.Any]]] = None,
        ibm: typing.Optional[typing.Union["SecretStoreSpecProviderIbm", typing.Dict[builtins.str, typing.Any]]] = None,
        kubernetes: typing.Optional[typing.Union["SecretStoreSpecProviderKubernetes", typing.Dict[builtins.str, typing.Any]]] = None,
        oracle: typing.Optional[typing.Union["SecretStoreSpecProviderOracle", typing.Dict[builtins.str, typing.Any]]] = None,
        passworddepot: typing.Optional[typing.Union["SecretStoreSpecProviderPassworddepot", typing.Dict[builtins.str, typing.Any]]] = None,
        vault: typing.Optional[typing.Union["SecretStoreSpecProviderVault", typing.Dict[builtins.str, typing.Any]]] = None,
        webhook: typing.Optional[typing.Union["SecretStoreSpecProviderWebhook", typing.Dict[builtins.str, typing.Any]]] = None,
        yandexlockbox: typing.Optional[typing.Union["SecretStoreSpecProviderYandexlockbox", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Used to configure the provider.

        Only one provider may be set

        :param akeyless: Akeyless configures this store to sync secrets using Akeyless Vault provider.
        :param alibaba: Alibaba configures this store to sync secrets using Alibaba Cloud provider.
        :param aws: AWS configures this store to sync secrets using AWS Secret Manager provider.
        :param azurekv: AzureKV configures this store to sync secrets using Azure Key Vault provider.
        :param fake: Fake configures a store with static key/value pairs.
        :param gcpsm: GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.
        :param gitlab: GitLab configures this store to sync secrets using GitLab Variables provider.
        :param ibm: IBM configures this store to sync secrets using IBM Cloud provider.
        :param kubernetes: Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.
        :param oracle: Oracle configures this store to sync secrets using Oracle Vault provider.
        :param passworddepot: Configures a store to sync secrets with a Password Depot instance.
        :param vault: Vault configures this store to sync secrets using Hashi provider.
        :param webhook: Webhook configures this store to sync secrets using a generic templated webhook.
        :param yandexlockbox: YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :schema: SecretStoreSpecProvider
        '''
        if isinstance(akeyless, dict):
            akeyless = SecretStoreSpecProviderAkeyless(**akeyless)
        if isinstance(alibaba, dict):
            alibaba = SecretStoreSpecProviderAlibaba(**alibaba)
        if isinstance(aws, dict):
            aws = SecretStoreSpecProviderAws(**aws)
        if isinstance(azurekv, dict):
            azurekv = SecretStoreSpecProviderAzurekv(**azurekv)
        if isinstance(fake, dict):
            fake = SecretStoreSpecProviderFake(**fake)
        if isinstance(gcpsm, dict):
            gcpsm = SecretStoreSpecProviderGcpsm(**gcpsm)
        if isinstance(gitlab, dict):
            gitlab = SecretStoreSpecProviderGitlab(**gitlab)
        if isinstance(ibm, dict):
            ibm = SecretStoreSpecProviderIbm(**ibm)
        if isinstance(kubernetes, dict):
            kubernetes = SecretStoreSpecProviderKubernetes(**kubernetes)
        if isinstance(oracle, dict):
            oracle = SecretStoreSpecProviderOracle(**oracle)
        if isinstance(passworddepot, dict):
            passworddepot = SecretStoreSpecProviderPassworddepot(**passworddepot)
        if isinstance(vault, dict):
            vault = SecretStoreSpecProviderVault(**vault)
        if isinstance(webhook, dict):
            webhook = SecretStoreSpecProviderWebhook(**webhook)
        if isinstance(yandexlockbox, dict):
            yandexlockbox = SecretStoreSpecProviderYandexlockbox(**yandexlockbox)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c530965dc9a8ce9c6b19c8fa2f1a1209e5d3f087076176d43c9a82a73ad3e971)
            check_type(argname="argument akeyless", value=akeyless, expected_type=type_hints["akeyless"])
            check_type(argname="argument alibaba", value=alibaba, expected_type=type_hints["alibaba"])
            check_type(argname="argument aws", value=aws, expected_type=type_hints["aws"])
            check_type(argname="argument azurekv", value=azurekv, expected_type=type_hints["azurekv"])
            check_type(argname="argument fake", value=fake, expected_type=type_hints["fake"])
            check_type(argname="argument gcpsm", value=gcpsm, expected_type=type_hints["gcpsm"])
            check_type(argname="argument gitlab", value=gitlab, expected_type=type_hints["gitlab"])
            check_type(argname="argument ibm", value=ibm, expected_type=type_hints["ibm"])
            check_type(argname="argument kubernetes", value=kubernetes, expected_type=type_hints["kubernetes"])
            check_type(argname="argument oracle", value=oracle, expected_type=type_hints["oracle"])
            check_type(argname="argument passworddepot", value=passworddepot, expected_type=type_hints["passworddepot"])
            check_type(argname="argument vault", value=vault, expected_type=type_hints["vault"])
            check_type(argname="argument webhook", value=webhook, expected_type=type_hints["webhook"])
            check_type(argname="argument yandexlockbox", value=yandexlockbox, expected_type=type_hints["yandexlockbox"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if akeyless is not None:
            self._values["akeyless"] = akeyless
        if alibaba is not None:
            self._values["alibaba"] = alibaba
        if aws is not None:
            self._values["aws"] = aws
        if azurekv is not None:
            self._values["azurekv"] = azurekv
        if fake is not None:
            self._values["fake"] = fake
        if gcpsm is not None:
            self._values["gcpsm"] = gcpsm
        if gitlab is not None:
            self._values["gitlab"] = gitlab
        if ibm is not None:
            self._values["ibm"] = ibm
        if kubernetes is not None:
            self._values["kubernetes"] = kubernetes
        if oracle is not None:
            self._values["oracle"] = oracle
        if passworddepot is not None:
            self._values["passworddepot"] = passworddepot
        if vault is not None:
            self._values["vault"] = vault
        if webhook is not None:
            self._values["webhook"] = webhook
        if yandexlockbox is not None:
            self._values["yandexlockbox"] = yandexlockbox

    @builtins.property
    def akeyless(self) -> typing.Optional["SecretStoreSpecProviderAkeyless"]:
        '''Akeyless configures this store to sync secrets using Akeyless Vault provider.

        :schema: SecretStoreSpecProvider#akeyless
        '''
        result = self._values.get("akeyless")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAkeyless"], result)

    @builtins.property
    def alibaba(self) -> typing.Optional["SecretStoreSpecProviderAlibaba"]:
        '''Alibaba configures this store to sync secrets using Alibaba Cloud provider.

        :schema: SecretStoreSpecProvider#alibaba
        '''
        result = self._values.get("alibaba")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAlibaba"], result)

    @builtins.property
    def aws(self) -> typing.Optional["SecretStoreSpecProviderAws"]:
        '''AWS configures this store to sync secrets using AWS Secret Manager provider.

        :schema: SecretStoreSpecProvider#aws
        '''
        result = self._values.get("aws")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAws"], result)

    @builtins.property
    def azurekv(self) -> typing.Optional["SecretStoreSpecProviderAzurekv"]:
        '''AzureKV configures this store to sync secrets using Azure Key Vault provider.

        :schema: SecretStoreSpecProvider#azurekv
        '''
        result = self._values.get("azurekv")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAzurekv"], result)

    @builtins.property
    def fake(self) -> typing.Optional["SecretStoreSpecProviderFake"]:
        '''Fake configures a store with static key/value pairs.

        :schema: SecretStoreSpecProvider#fake
        '''
        result = self._values.get("fake")
        return typing.cast(typing.Optional["SecretStoreSpecProviderFake"], result)

    @builtins.property
    def gcpsm(self) -> typing.Optional["SecretStoreSpecProviderGcpsm"]:
        '''GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.

        :schema: SecretStoreSpecProvider#gcpsm
        '''
        result = self._values.get("gcpsm")
        return typing.cast(typing.Optional["SecretStoreSpecProviderGcpsm"], result)

    @builtins.property
    def gitlab(self) -> typing.Optional["SecretStoreSpecProviderGitlab"]:
        '''GitLab configures this store to sync secrets using GitLab Variables provider.

        :schema: SecretStoreSpecProvider#gitlab
        '''
        result = self._values.get("gitlab")
        return typing.cast(typing.Optional["SecretStoreSpecProviderGitlab"], result)

    @builtins.property
    def ibm(self) -> typing.Optional["SecretStoreSpecProviderIbm"]:
        '''IBM configures this store to sync secrets using IBM Cloud provider.

        :schema: SecretStoreSpecProvider#ibm
        '''
        result = self._values.get("ibm")
        return typing.cast(typing.Optional["SecretStoreSpecProviderIbm"], result)

    @builtins.property
    def kubernetes(self) -> typing.Optional["SecretStoreSpecProviderKubernetes"]:
        '''Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.

        :schema: SecretStoreSpecProvider#kubernetes
        '''
        result = self._values.get("kubernetes")
        return typing.cast(typing.Optional["SecretStoreSpecProviderKubernetes"], result)

    @builtins.property
    def oracle(self) -> typing.Optional["SecretStoreSpecProviderOracle"]:
        '''Oracle configures this store to sync secrets using Oracle Vault provider.

        :schema: SecretStoreSpecProvider#oracle
        '''
        result = self._values.get("oracle")
        return typing.cast(typing.Optional["SecretStoreSpecProviderOracle"], result)

    @builtins.property
    def passworddepot(self) -> typing.Optional["SecretStoreSpecProviderPassworddepot"]:
        '''Configures a store to sync secrets with a Password Depot instance.

        :schema: SecretStoreSpecProvider#passworddepot
        '''
        result = self._values.get("passworddepot")
        return typing.cast(typing.Optional["SecretStoreSpecProviderPassworddepot"], result)

    @builtins.property
    def vault(self) -> typing.Optional["SecretStoreSpecProviderVault"]:
        '''Vault configures this store to sync secrets using Hashi provider.

        :schema: SecretStoreSpecProvider#vault
        '''
        result = self._values.get("vault")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVault"], result)

    @builtins.property
    def webhook(self) -> typing.Optional["SecretStoreSpecProviderWebhook"]:
        '''Webhook configures this store to sync secrets using a generic templated webhook.

        :schema: SecretStoreSpecProvider#webhook
        '''
        result = self._values.get("webhook")
        return typing.cast(typing.Optional["SecretStoreSpecProviderWebhook"], result)

    @builtins.property
    def yandexlockbox(self) -> typing.Optional["SecretStoreSpecProviderYandexlockbox"]:
        '''YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :schema: SecretStoreSpecProvider#yandexlockbox
        '''
        result = self._values.get("yandexlockbox")
        return typing.cast(typing.Optional["SecretStoreSpecProviderYandexlockbox"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAkeyless",
    jsii_struct_bases=[],
    name_mapping={
        "akeyless_gw_api_url": "akeylessGwApiUrl",
        "auth_secret_ref": "authSecretRef",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
    },
)
class SecretStoreSpecProviderAkeyless:
    def __init__(
        self,
        *,
        akeyless_gw_api_url: builtins.str,
        auth_secret_ref: typing.Union["SecretStoreSpecProviderAkeylessAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreSpecProviderAkeylessCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Akeyless configures this store to sync secrets using Akeyless Vault provider.

        :param akeyless_gw_api_url: Akeyless GW API Url from which the secrets to be fetched from.
        :param auth_secret_ref: Auth configures how the operator authenticates with Akeyless.
        :param ca_bundle: PEM/base64 encoded CA bundle used to validate Akeyless Gateway certificate. Only used if the AkeylessGWApiURL URL is using HTTPS protocol. If not set the system root certificates are used to validate the TLS connection.
        :param ca_provider: The provider for the CA bundle to use to validate Akeyless Gateway certificate.

        :schema: SecretStoreSpecProviderAkeyless
        '''
        if isinstance(auth_secret_ref, dict):
            auth_secret_ref = SecretStoreSpecProviderAkeylessAuthSecretRef(**auth_secret_ref)
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreSpecProviderAkeylessCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f597bf285afb5c633e38c431ce82655d4616622b525a2d703b9381af3a1804f2)
            check_type(argname="argument akeyless_gw_api_url", value=akeyless_gw_api_url, expected_type=type_hints["akeyless_gw_api_url"])
            check_type(argname="argument auth_secret_ref", value=auth_secret_ref, expected_type=type_hints["auth_secret_ref"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "akeyless_gw_api_url": akeyless_gw_api_url,
            "auth_secret_ref": auth_secret_ref,
        }
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider

    @builtins.property
    def akeyless_gw_api_url(self) -> builtins.str:
        '''Akeyless GW API Url from which the secrets to be fetched from.

        :schema: SecretStoreSpecProviderAkeyless#akeylessGWApiURL
        '''
        result = self._values.get("akeyless_gw_api_url")
        assert result is not None, "Required property 'akeyless_gw_api_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth_secret_ref(self) -> "SecretStoreSpecProviderAkeylessAuthSecretRef":
        '''Auth configures how the operator authenticates with Akeyless.

        :schema: SecretStoreSpecProviderAkeyless#authSecretRef
        '''
        result = self._values.get("auth_secret_ref")
        assert result is not None, "Required property 'auth_secret_ref' is missing"
        return typing.cast("SecretStoreSpecProviderAkeylessAuthSecretRef", result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''PEM/base64 encoded CA bundle used to validate Akeyless Gateway certificate.

        Only used
        if the AkeylessGWApiURL URL is using HTTPS protocol. If not set the system root certificates
        are used to validate the TLS connection.

        :schema: SecretStoreSpecProviderAkeyless#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAkeylessCaProvider"]:
        '''The provider for the CA bundle to use to validate Akeyless Gateway certificate.

        :schema: SecretStoreSpecProviderAkeyless#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAkeylessCaProvider"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAkeyless(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAkeylessAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"kubernetes_auth": "kubernetesAuth", "secret_ref": "secretRef"},
)
class SecretStoreSpecProviderAkeylessAuthSecretRef:
    def __init__(
        self,
        *,
        kubernetes_auth: typing.Optional[typing.Union["SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how the operator authenticates with Akeyless.

        :param kubernetes_auth: Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
        :param secret_ref: Reference to a Secret that contains the details to authenticate with Akeyless.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRef
        '''
        if isinstance(kubernetes_auth, dict):
            kubernetes_auth = SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth(**kubernetes_auth)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cda0f12fb61f2949b2c77d5bb0d1e8a9b9b4301454fc1cffb9952a3b1658e2cc)
            check_type(argname="argument kubernetes_auth", value=kubernetes_auth, expected_type=type_hints["kubernetes_auth"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if kubernetes_auth is not None:
            self._values["kubernetes_auth"] = kubernetes_auth
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def kubernetes_auth(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth"]:
        '''Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRef#kubernetesAuth
        '''
        result = self._values.get("kubernetes_auth")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef"]:
        '''Reference to a Secret that contains the details to authenticate with Akeyless.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRef#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAkeylessAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth",
    jsii_struct_bases=[],
    name_mapping={
        "access_id": "accessId",
        "k8_s_conf_name": "k8SConfName",
        "secret_ref": "secretRef",
        "service_account_ref": "serviceAccountRef",
    },
)
class SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth:
    def __init__(
        self,
        *,
        access_id: builtins.str,
        k8_s_conf_name: builtins.str,
        secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account_ref: typing.Optional[typing.Union["SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.

        :param access_id: the Akeyless Kubernetes auth-method access-id.
        :param k8_s_conf_name: Kubernetes-auth configuration name in Akeyless-Gateway.
        :param secret_ref: Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.
        :param service_account_ref: Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(**secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae1d5d2c1b8d1b1723c903970ab7cdf664c090a69850bbe33bba4d43dc332342)
            check_type(argname="argument access_id", value=access_id, expected_type=type_hints["access_id"])
            check_type(argname="argument k8_s_conf_name", value=k8_s_conf_name, expected_type=type_hints["k8_s_conf_name"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "access_id": access_id,
            "k8_s_conf_name": k8_s_conf_name,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def access_id(self) -> builtins.str:
        '''the Akeyless Kubernetes auth-method access-id.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#accessID
        '''
        result = self._values.get("access_id")
        assert result is not None, "Required property 'access_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def k8_s_conf_name(self) -> builtins.str:
        '''Kubernetes-auth configuration name in Akeyless-Gateway.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#k8sConfName
        '''
        result = self._values.get("k8_s_conf_name")
        assert result is not None, "Required property 'k8_s_conf_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef"]:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless.

        If a name is specified without a key,
        ``token`` is the default. If one is not specified, the one bound to
        the controller will be used.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef"]:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used
        for authenticating with Akeyless. If the service account selector is not supplied,
        the secretRef will be used instead.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless.

        If a name is specified without a key,
        ``token`` is the default. If one is not specified, the one bound to
        the controller will be used.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e370d9d39bba6f7ee010e33d276f110d5075548ecb7b73f373d703f886030b6c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used
        for authenticating with Akeyless. If the service account selector is not supplied,
        the secretRef will be used instead.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__35cb94b11cba70c093368a79eb257455da6fabf4fac8ef68d4d39b90bf654dee)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_id": "accessId",
        "access_type": "accessType",
        "access_type_param": "accessTypeParam",
    },
)
class SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef:
    def __init__(
        self,
        *,
        access_id: typing.Optional[typing.Union["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId", typing.Dict[builtins.str, typing.Any]]] = None,
        access_type: typing.Optional[typing.Union["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType", typing.Dict[builtins.str, typing.Any]]] = None,
        access_type_param: typing.Optional[typing.Union["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Reference to a Secret that contains the details to authenticate with Akeyless.

        :param access_id: The SecretAccessID is used for authentication.
        :param access_type: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param access_type_param: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef
        '''
        if isinstance(access_id, dict):
            access_id = SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId(**access_id)
        if isinstance(access_type, dict):
            access_type = SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType(**access_type)
        if isinstance(access_type_param, dict):
            access_type_param = SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(**access_type_param)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f212895f3238ae558cc70d86c5e96033e438ae08bbac34bb207c998d69db8b4a)
            check_type(argname="argument access_id", value=access_id, expected_type=type_hints["access_id"])
            check_type(argname="argument access_type", value=access_type, expected_type=type_hints["access_type"])
            check_type(argname="argument access_type_param", value=access_type_param, expected_type=type_hints["access_type_param"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if access_id is not None:
            self._values["access_id"] = access_id
        if access_type is not None:
            self._values["access_type"] = access_type
        if access_type_param is not None:
            self._values["access_type_param"] = access_type_param

    @builtins.property
    def access_id(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId"]:
        '''The SecretAccessID is used for authentication.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessID
        '''
        result = self._values.get("access_id")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId"], result)

    @builtins.property
    def access_type(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessType
        '''
        result = self._values.get("access_type")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType"], result)

    @builtins.property
    def access_type_param(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessTypeParam
        '''
        result = self._values.get("access_type_param")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessID is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e9bc19061bf794b228ae3c85bd2c8a539641c474838c3d24b0534ac2df4a3000)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64d37657fe77dbb1beb16d7928cf21adb979d050e6ff461f18aed915d564ebd6)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a8a8e97d38f881fa234c143b578f9406cde35bb5cb65d61338b15321de80fc9e)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAkeylessCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class SecretStoreSpecProviderAkeylessCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "SecretStoreSpecProviderAkeylessCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Akeyless Gateway certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in.

        :schema: SecretStoreSpecProviderAkeylessCaProvider
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f9c3b2ffab421d502bfac8a63fe44a7a580876ac897a20ca7ef6da1d7ac1475)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: SecretStoreSpecProviderAkeylessCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "SecretStoreSpecProviderAkeylessCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: SecretStoreSpecProviderAkeylessCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("SecretStoreSpecProviderAkeylessCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: SecretStoreSpecProviderAkeylessCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        :schema: SecretStoreSpecProviderAkeylessCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAkeylessCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAkeylessCaProviderType"
)
class SecretStoreSpecProviderAkeylessCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: SecretStoreSpecProviderAkeylessCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAlibaba",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "region_id": "regionId"},
)
class SecretStoreSpecProviderAlibaba:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreSpecProviderAlibabaAuth", typing.Dict[builtins.str, typing.Any]],
        region_id: builtins.str,
    ) -> None:
        '''Alibaba configures this store to sync secrets using Alibaba Cloud provider.

        :param auth: AlibabaAuth contains a secretRef for credentials.
        :param region_id: Alibaba Region to be used for the provider.

        :schema: SecretStoreSpecProviderAlibaba
        '''
        if isinstance(auth, dict):
            auth = SecretStoreSpecProviderAlibabaAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__160555d984538fdfb12b506e87bb6765d149005405f5ae079b3691db6a1d770f)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument region_id", value=region_id, expected_type=type_hints["region_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "region_id": region_id,
        }

    @builtins.property
    def auth(self) -> "SecretStoreSpecProviderAlibabaAuth":
        '''AlibabaAuth contains a secretRef for credentials.

        :schema: SecretStoreSpecProviderAlibaba#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreSpecProviderAlibabaAuth", result)

    @builtins.property
    def region_id(self) -> builtins.str:
        '''Alibaba Region to be used for the provider.

        :schema: SecretStoreSpecProviderAlibaba#regionID
        '''
        result = self._values.get("region_id")
        assert result is not None, "Required property 'region_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAlibaba(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAlibabaAuth",
    jsii_struct_bases=[],
    name_mapping={"rrsa": "rrsa", "secret_ref": "secretRef"},
)
class SecretStoreSpecProviderAlibabaAuth:
    def __init__(
        self,
        *,
        rrsa: typing.Optional[typing.Union["SecretStoreSpecProviderAlibabaAuthRrsa", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderAlibabaAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''AlibabaAuth contains a secretRef for credentials.

        :param rrsa: Authenticate against Alibaba using RRSA.
        :param secret_ref: AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :schema: SecretStoreSpecProviderAlibabaAuth
        '''
        if isinstance(rrsa, dict):
            rrsa = SecretStoreSpecProviderAlibabaAuthRrsa(**rrsa)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderAlibabaAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d8b50e50e137fe4e3f84cfad896da01555d6ac69b57ae5d2e585611bb05e278)
            check_type(argname="argument rrsa", value=rrsa, expected_type=type_hints["rrsa"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if rrsa is not None:
            self._values["rrsa"] = rrsa
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def rrsa(self) -> typing.Optional["SecretStoreSpecProviderAlibabaAuthRrsa"]:
        '''Authenticate against Alibaba using RRSA.

        :schema: SecretStoreSpecProviderAlibabaAuth#rrsa
        '''
        result = self._values.get("rrsa")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAlibabaAuthRrsa"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAlibabaAuthSecretRef"]:
        '''AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :schema: SecretStoreSpecProviderAlibabaAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAlibabaAuthSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAlibabaAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAlibabaAuthRrsa",
    jsii_struct_bases=[],
    name_mapping={
        "oidc_provider_arn": "oidcProviderArn",
        "oidc_token_file_path": "oidcTokenFilePath",
        "role_arn": "roleArn",
        "session_name": "sessionName",
    },
)
class SecretStoreSpecProviderAlibabaAuthRrsa:
    def __init__(
        self,
        *,
        oidc_provider_arn: builtins.str,
        oidc_token_file_path: builtins.str,
        role_arn: builtins.str,
        session_name: builtins.str,
    ) -> None:
        '''Authenticate against Alibaba using RRSA.

        :param oidc_provider_arn: 
        :param oidc_token_file_path: 
        :param role_arn: 
        :param session_name: 

        :schema: SecretStoreSpecProviderAlibabaAuthRrsa
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__22fd549ae04f8c34cf4357cee9af0ba1a090b8e6889bbb1347558106e5e66c4f)
            check_type(argname="argument oidc_provider_arn", value=oidc_provider_arn, expected_type=type_hints["oidc_provider_arn"])
            check_type(argname="argument oidc_token_file_path", value=oidc_token_file_path, expected_type=type_hints["oidc_token_file_path"])
            check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            check_type(argname="argument session_name", value=session_name, expected_type=type_hints["session_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "oidc_provider_arn": oidc_provider_arn,
            "oidc_token_file_path": oidc_token_file_path,
            "role_arn": role_arn,
            "session_name": session_name,
        }

    @builtins.property
    def oidc_provider_arn(self) -> builtins.str:
        '''
        :schema: SecretStoreSpecProviderAlibabaAuthRrsa#oidcProviderArn
        '''
        result = self._values.get("oidc_provider_arn")
        assert result is not None, "Required property 'oidc_provider_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def oidc_token_file_path(self) -> builtins.str:
        '''
        :schema: SecretStoreSpecProviderAlibabaAuthRrsa#oidcTokenFilePath
        '''
        result = self._values.get("oidc_token_file_path")
        assert result is not None, "Required property 'oidc_token_file_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role_arn(self) -> builtins.str:
        '''
        :schema: SecretStoreSpecProviderAlibabaAuthRrsa#roleArn
        '''
        result = self._values.get("role_arn")
        assert result is not None, "Required property 'role_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def session_name(self) -> builtins.str:
        '''
        :schema: SecretStoreSpecProviderAlibabaAuthRrsa#sessionName
        '''
        result = self._values.get("session_name")
        assert result is not None, "Required property 'session_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAlibabaAuthRrsa(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAlibabaAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_key_id_secret_ref": "accessKeyIdSecretRef",
        "access_key_secret_secret_ref": "accessKeySecretSecretRef",
    },
)
class SecretStoreSpecProviderAlibabaAuthSecretRef:
    def __init__(
        self,
        *,
        access_key_id_secret_ref: typing.Union["SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef", typing.Dict[builtins.str, typing.Any]],
        access_key_secret_secret_ref: typing.Union["SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :param access_key_id_secret_ref: The AccessKeyID is used for authentication.
        :param access_key_secret_secret_ref: The AccessKeySecret is used for authentication.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRef
        '''
        if isinstance(access_key_id_secret_ref, dict):
            access_key_id_secret_ref = SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(**access_key_id_secret_ref)
        if isinstance(access_key_secret_secret_ref, dict):
            access_key_secret_secret_ref = SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(**access_key_secret_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__83b732209a24571a7a96042e186e91398c6b74cf7cb865114ea675a90ddfc6e2)
            check_type(argname="argument access_key_id_secret_ref", value=access_key_id_secret_ref, expected_type=type_hints["access_key_id_secret_ref"])
            check_type(argname="argument access_key_secret_secret_ref", value=access_key_secret_secret_ref, expected_type=type_hints["access_key_secret_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "access_key_id_secret_ref": access_key_id_secret_ref,
            "access_key_secret_secret_ref": access_key_secret_secret_ref,
        }

    @builtins.property
    def access_key_id_secret_ref(
        self,
    ) -> "SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef":
        '''The AccessKeyID is used for authentication.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRef#accessKeyIDSecretRef
        '''
        result = self._values.get("access_key_id_secret_ref")
        assert result is not None, "Required property 'access_key_id_secret_ref' is missing"
        return typing.cast("SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef", result)

    @builtins.property
    def access_key_secret_secret_ref(
        self,
    ) -> "SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef":
        '''The AccessKeySecret is used for authentication.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRef#accessKeySecretSecretRef
        '''
        result = self._values.get("access_key_secret_secret_ref")
        assert result is not None, "Required property 'access_key_secret_secret_ref' is missing"
        return typing.cast("SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAlibabaAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeyID is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c21bb376b2e3a0198bfcc4ef9da1f454aec69fed4187ddac868a437f5508e1de)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeySecret is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__26d4e7fa82cee06a66db9f84afb99426b45555f9719c95d7984dc5ae97cec7b4)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAws",
    jsii_struct_bases=[],
    name_mapping={
        "region": "region",
        "service": "service",
        "auth": "auth",
        "role": "role",
    },
)
class SecretStoreSpecProviderAws:
    def __init__(
        self,
        *,
        region: builtins.str,
        service: "SecretStoreSpecProviderAwsService",
        auth: typing.Optional[typing.Union["SecretStoreSpecProviderAwsAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        role: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AWS configures this store to sync secrets using AWS Secret Manager provider.

        :param region: AWS Region to be used for the provider.
        :param service: Service defines which service should be used to fetch the secrets.
        :param auth: Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.
        :param role: Role is a Role ARN which the SecretManager provider will assume.

        :schema: SecretStoreSpecProviderAws
        '''
        if isinstance(auth, dict):
            auth = SecretStoreSpecProviderAwsAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b934c6cb3d89ed6210132277f1834ba27f8d6f93e4b788d15911d29aeb2a073b)
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "region": region,
            "service": service,
        }
        if auth is not None:
            self._values["auth"] = auth
        if role is not None:
            self._values["role"] = role

    @builtins.property
    def region(self) -> builtins.str:
        '''AWS Region to be used for the provider.

        :schema: SecretStoreSpecProviderAws#region
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service(self) -> "SecretStoreSpecProviderAwsService":
        '''Service defines which service should be used to fetch the secrets.

        :schema: SecretStoreSpecProviderAws#service
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast("SecretStoreSpecProviderAwsService", result)

    @builtins.property
    def auth(self) -> typing.Optional["SecretStoreSpecProviderAwsAuth"]:
        '''Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.

        :schema: SecretStoreSpecProviderAws#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAwsAuth"], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a Role ARN which the SecretManager provider will assume.

        :schema: SecretStoreSpecProviderAws#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAws(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAwsAuth",
    jsii_struct_bases=[],
    name_mapping={"jwt": "jwt", "secret_ref": "secretRef"},
)
class SecretStoreSpecProviderAwsAuth:
    def __init__(
        self,
        *,
        jwt: typing.Optional[typing.Union["SecretStoreSpecProviderAwsAuthJwt", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderAwsAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.

        :param jwt: Authenticate against AWS using service account tokens.
        :param secret_ref: AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :schema: SecretStoreSpecProviderAwsAuth
        '''
        if isinstance(jwt, dict):
            jwt = SecretStoreSpecProviderAwsAuthJwt(**jwt)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderAwsAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__95a0f277ee0cad3e87fc8f88b3beed52a176e997459eb96b21bfc2cd7e6867ce)
            check_type(argname="argument jwt", value=jwt, expected_type=type_hints["jwt"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if jwt is not None:
            self._values["jwt"] = jwt
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def jwt(self) -> typing.Optional["SecretStoreSpecProviderAwsAuthJwt"]:
        '''Authenticate against AWS using service account tokens.

        :schema: SecretStoreSpecProviderAwsAuth#jwt
        '''
        result = self._values.get("jwt")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAwsAuthJwt"], result)

    @builtins.property
    def secret_ref(self) -> typing.Optional["SecretStoreSpecProviderAwsAuthSecretRef"]:
        '''AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :schema: SecretStoreSpecProviderAwsAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAwsAuthSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAwsAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAwsAuthJwt",
    jsii_struct_bases=[],
    name_mapping={"service_account_ref": "serviceAccountRef"},
)
class SecretStoreSpecProviderAwsAuthJwt:
    def __init__(
        self,
        *,
        service_account_ref: typing.Optional[typing.Union["SecretStoreSpecProviderAwsAuthJwtServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Authenticate against AWS using service account tokens.

        :param service_account_ref: A reference to a ServiceAccount resource.

        :schema: SecretStoreSpecProviderAwsAuthJwt
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreSpecProviderAwsAuthJwtServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a2de8e353bd8a9c6b2b307f5edcfd83259dd689ddb1c7bcd7cba6aebd896d14)
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAwsAuthJwtServiceAccountRef"]:
        '''A reference to a ServiceAccount resource.

        :schema: SecretStoreSpecProviderAwsAuthJwt#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAwsAuthJwtServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAwsAuthJwt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAwsAuthJwtServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreSpecProviderAwsAuthJwtServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAwsAuthJwtServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee83739484981a1313ee3e396d008fd0daa33cea2f3bd4c940e1bdf71a18c74a)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreSpecProviderAwsAuthJwtServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreSpecProviderAwsAuthJwtServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAwsAuthJwtServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAwsAuthJwtServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAwsAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_key_id_secret_ref": "accessKeyIdSecretRef",
        "secret_access_key_secret_ref": "secretAccessKeySecretRef",
    },
)
class SecretStoreSpecProviderAwsAuthSecretRef:
    def __init__(
        self,
        *,
        access_key_id_secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_access_key_secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :param access_key_id_secret_ref: The AccessKeyID is used for authentication.
        :param secret_access_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: SecretStoreSpecProviderAwsAuthSecretRef
        '''
        if isinstance(access_key_id_secret_ref, dict):
            access_key_id_secret_ref = SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(**access_key_id_secret_ref)
        if isinstance(secret_access_key_secret_ref, dict):
            secret_access_key_secret_ref = SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(**secret_access_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70319a335a332153f12e762b41f5b67aee107bc3136ea70ae53f2a2c716a612a)
            check_type(argname="argument access_key_id_secret_ref", value=access_key_id_secret_ref, expected_type=type_hints["access_key_id_secret_ref"])
            check_type(argname="argument secret_access_key_secret_ref", value=secret_access_key_secret_ref, expected_type=type_hints["secret_access_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if access_key_id_secret_ref is not None:
            self._values["access_key_id_secret_ref"] = access_key_id_secret_ref
        if secret_access_key_secret_ref is not None:
            self._values["secret_access_key_secret_ref"] = secret_access_key_secret_ref

    @builtins.property
    def access_key_id_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef"]:
        '''The AccessKeyID is used for authentication.

        :schema: SecretStoreSpecProviderAwsAuthSecretRef#accessKeyIDSecretRef
        '''
        result = self._values.get("access_key_id_secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef"], result)

    @builtins.property
    def secret_access_key_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: SecretStoreSpecProviderAwsAuthSecretRef#secretAccessKeySecretRef
        '''
        result = self._values.get("secret_access_key_secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAwsAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeyID is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6cd067b142a207713dbe0c26baf3421dbaec7cf34b10e08c3a3958201b4d09fb)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0cbfd65dc9abbf06dee97c10e01c18ce7e875a3784134a02e09c54fe3a7fa425)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.SecretStoreSpecProviderAwsService")
class SecretStoreSpecProviderAwsService(enum.Enum):
    '''Service defines which service should be used to fetch the secrets.

    :schema: SecretStoreSpecProviderAwsService
    '''

    SECRETS_MANAGER = "SECRETS_MANAGER"
    '''SecretsManager.'''
    PARAMETER_STORE = "PARAMETER_STORE"
    '''ParameterStore.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAzurekv",
    jsii_struct_bases=[],
    name_mapping={
        "vault_url": "vaultUrl",
        "auth_secret_ref": "authSecretRef",
        "auth_type": "authType",
        "identity_id": "identityId",
        "service_account_ref": "serviceAccountRef",
        "tenant_id": "tenantId",
    },
)
class SecretStoreSpecProviderAzurekv:
    def __init__(
        self,
        *,
        vault_url: builtins.str,
        auth_secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderAzurekvAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        auth_type: typing.Optional["SecretStoreSpecProviderAzurekvAuthType"] = None,
        identity_id: typing.Optional[builtins.str] = None,
        service_account_ref: typing.Optional[typing.Union["SecretStoreSpecProviderAzurekvServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
        tenant_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AzureKV configures this store to sync secrets using Azure Key Vault provider.

        :param vault_url: Vault Url from which the secrets to be fetched from.
        :param auth_secret_ref: Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type.
        :param auth_type: Auth type defines how to authenticate to the keyvault service. Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
        :param identity_id: If multiple Managed Identity is assigned to the pod, you can select the one to be used.
        :param service_account_ref: ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
        :param tenant_id: TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type.

        :schema: SecretStoreSpecProviderAzurekv
        '''
        if isinstance(auth_secret_ref, dict):
            auth_secret_ref = SecretStoreSpecProviderAzurekvAuthSecretRef(**auth_secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreSpecProviderAzurekvServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3fff1dbb3fb26f345ccf9d164d11d27cdf0bf449ee80995bab7f58ed4e6cb4bf)
            check_type(argname="argument vault_url", value=vault_url, expected_type=type_hints["vault_url"])
            check_type(argname="argument auth_secret_ref", value=auth_secret_ref, expected_type=type_hints["auth_secret_ref"])
            check_type(argname="argument auth_type", value=auth_type, expected_type=type_hints["auth_type"])
            check_type(argname="argument identity_id", value=identity_id, expected_type=type_hints["identity_id"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument tenant_id", value=tenant_id, expected_type=type_hints["tenant_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vault_url": vault_url,
        }
        if auth_secret_ref is not None:
            self._values["auth_secret_ref"] = auth_secret_ref
        if auth_type is not None:
            self._values["auth_type"] = auth_type
        if identity_id is not None:
            self._values["identity_id"] = identity_id
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref
        if tenant_id is not None:
            self._values["tenant_id"] = tenant_id

    @builtins.property
    def vault_url(self) -> builtins.str:
        '''Vault Url from which the secrets to be fetched from.

        :schema: SecretStoreSpecProviderAzurekv#vaultUrl
        '''
        result = self._values.get("vault_url")
        assert result is not None, "Required property 'vault_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAzurekvAuthSecretRef"]:
        '''Auth configures how the operator authenticates with Azure.

        Required for ServicePrincipal auth type.

        :schema: SecretStoreSpecProviderAzurekv#authSecretRef
        '''
        result = self._values.get("auth_secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAzurekvAuthSecretRef"], result)

    @builtins.property
    def auth_type(self) -> typing.Optional["SecretStoreSpecProviderAzurekvAuthType"]:
        '''Auth type defines how to authenticate to the keyvault service.

        Valid values are:

        - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret)
        - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)

        :schema: SecretStoreSpecProviderAzurekv#authType
        '''
        result = self._values.get("auth_type")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAzurekvAuthType"], result)

    @builtins.property
    def identity_id(self) -> typing.Optional[builtins.str]:
        '''If multiple Managed Identity is assigned to the pod, you can select the one to be used.

        :schema: SecretStoreSpecProviderAzurekv#identityId
        '''
        result = self._values.get("identity_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAzurekvServiceAccountRef"]:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :schema: SecretStoreSpecProviderAzurekv#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAzurekvServiceAccountRef"], result)

    @builtins.property
    def tenant_id(self) -> typing.Optional[builtins.str]:
        '''TenantID configures the Azure Tenant to send requests to.

        Required for ServicePrincipal auth type.

        :schema: SecretStoreSpecProviderAzurekv#tenantId
        '''
        result = self._values.get("tenant_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAzurekv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAzurekvAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"client_id": "clientId", "client_secret": "clientSecret"},
)
class SecretStoreSpecProviderAzurekvAuthSecretRef:
    def __init__(
        self,
        *,
        client_id: typing.Optional[typing.Union["SecretStoreSpecProviderAzurekvAuthSecretRefClientId", typing.Dict[builtins.str, typing.Any]]] = None,
        client_secret: typing.Optional[typing.Union["SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how the operator authenticates with Azure.

        Required for ServicePrincipal auth type.

        :param client_id: The Azure clientId of the service principle used for authentication.
        :param client_secret: The Azure ClientSecret of the service principle used for authentication.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRef
        '''
        if isinstance(client_id, dict):
            client_id = SecretStoreSpecProviderAzurekvAuthSecretRefClientId(**client_id)
        if isinstance(client_secret, dict):
            client_secret = SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret(**client_secret)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__218003f6825cc8cc0f958bebabc2f3bdbc7a157e9b92d6f96a4ff08a85a92c40)
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret", value=client_secret, expected_type=type_hints["client_secret"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if client_id is not None:
            self._values["client_id"] = client_id
        if client_secret is not None:
            self._values["client_secret"] = client_secret

    @builtins.property
    def client_id(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAzurekvAuthSecretRefClientId"]:
        '''The Azure clientId of the service principle used for authentication.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRef#clientId
        '''
        result = self._values.get("client_id")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAzurekvAuthSecretRefClientId"], result)

    @builtins.property
    def client_secret(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret"]:
        '''The Azure ClientSecret of the service principle used for authentication.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRef#clientSecret
        '''
        result = self._values.get("client_secret")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAzurekvAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAzurekvAuthSecretRefClientId",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderAzurekvAuthSecretRefClientId:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Azure clientId of the service principle used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRefClientId
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e73937a53a8dc05dc2cb3c6f7e3d8c47478e39bae10ddb5f9395a603af3ed23b)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRefClientId#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRefClientId#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRefClientId#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAzurekvAuthSecretRefClientId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Azure ClientSecret of the service principle used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__94e37ecd5e686fb55810fc919ea1112f411c31d0570fa8910d7e09c861c65366)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.SecretStoreSpecProviderAzurekvAuthType")
class SecretStoreSpecProviderAzurekvAuthType(enum.Enum):
    '''Auth type defines how to authenticate to the keyvault service.

    Valid values are:

    - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret)
    - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)

    :schema: SecretStoreSpecProviderAzurekvAuthType
    '''

    SERVICE_PRINCIPAL = "SERVICE_PRINCIPAL"
    '''ServicePrincipal.'''
    MANAGED_IDENTITY = "MANAGED_IDENTITY"
    '''ManagedIdentity.'''
    WORKLOAD_IDENTITY = "WORKLOAD_IDENTITY"
    '''WorkloadIdentity.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAzurekvServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreSpecProviderAzurekvServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAzurekvServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6270c5495b069a85f3a72915c6c9d3b066899e220bc6fe5e733e75e8528cd46c)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreSpecProviderAzurekvServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreSpecProviderAzurekvServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAzurekvServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAzurekvServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderFake",
    jsii_struct_bases=[],
    name_mapping={"data": "data"},
)
class SecretStoreSpecProviderFake:
    def __init__(
        self,
        *,
        data: typing.Sequence[typing.Union["SecretStoreSpecProviderFakeData", typing.Dict[builtins.str, typing.Any]]],
    ) -> None:
        '''Fake configures a store with static key/value pairs.

        :param data: 

        :schema: SecretStoreSpecProviderFake
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee8ed03db2e828edd909617b817e612179bd4710b9592d45bedc827e7382a817)
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "data": data,
        }

    @builtins.property
    def data(self) -> typing.List["SecretStoreSpecProviderFakeData"]:
        '''
        :schema: SecretStoreSpecProviderFake#data
        '''
        result = self._values.get("data")
        assert result is not None, "Required property 'data' is missing"
        return typing.cast(typing.List["SecretStoreSpecProviderFakeData"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderFake(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderFakeData",
    jsii_struct_bases=[],
    name_mapping={
        "key": "key",
        "value": "value",
        "value_map": "valueMap",
        "version": "version",
    },
)
class SecretStoreSpecProviderFakeData:
    def __init__(
        self,
        *,
        key: builtins.str,
        value: typing.Optional[builtins.str] = None,
        value_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param key: 
        :param value: 
        :param value_map: 
        :param version: 

        :schema: SecretStoreSpecProviderFakeData
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9ee3f4b0c98c7c6c6914d11356c215cf3cf27d54394699eb8536a18709255bde)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            check_type(argname="argument value_map", value=value_map, expected_type=type_hints["value_map"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
        }
        if value is not None:
            self._values["value"] = value
        if value_map is not None:
            self._values["value_map"] = value_map
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :schema: SecretStoreSpecProviderFakeData#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreSpecProviderFakeData#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value_map(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: SecretStoreSpecProviderFakeData#valueMap
        '''
        result = self._values.get("value_map")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreSpecProviderFakeData#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderFakeData(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderGcpsm",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "project_id": "projectId"},
)
class SecretStoreSpecProviderGcpsm:
    def __init__(
        self,
        *,
        auth: typing.Optional[typing.Union["SecretStoreSpecProviderGcpsmAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        project_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.

        :param auth: Auth defines the information necessary to authenticate against GCP.
        :param project_id: ProjectID project where secret is located.

        :schema: SecretStoreSpecProviderGcpsm
        '''
        if isinstance(auth, dict):
            auth = SecretStoreSpecProviderGcpsmAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__433356edd23ff339815e78dd403eb845c5557e0e984de228fc0019869438b798)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if auth is not None:
            self._values["auth"] = auth
        if project_id is not None:
            self._values["project_id"] = project_id

    @builtins.property
    def auth(self) -> typing.Optional["SecretStoreSpecProviderGcpsmAuth"]:
        '''Auth defines the information necessary to authenticate against GCP.

        :schema: SecretStoreSpecProviderGcpsm#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["SecretStoreSpecProviderGcpsmAuth"], result)

    @builtins.property
    def project_id(self) -> typing.Optional[builtins.str]:
        '''ProjectID project where secret is located.

        :schema: SecretStoreSpecProviderGcpsm#projectID
        '''
        result = self._values.get("project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderGcpsm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderGcpsmAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "workload_identity": "workloadIdentity"},
)
class SecretStoreSpecProviderGcpsmAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderGcpsmAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        workload_identity: typing.Optional[typing.Union["SecretStoreSpecProviderGcpsmAuthWorkloadIdentity", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against GCP.

        :param secret_ref: 
        :param workload_identity: 

        :schema: SecretStoreSpecProviderGcpsmAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderGcpsmAuthSecretRef(**secret_ref)
        if isinstance(workload_identity, dict):
            workload_identity = SecretStoreSpecProviderGcpsmAuthWorkloadIdentity(**workload_identity)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c3dac985af09163062ee0f100a6f27f060ab84a70f92e464b0e33f194f9d2144)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument workload_identity", value=workload_identity, expected_type=type_hints["workload_identity"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if workload_identity is not None:
            self._values["workload_identity"] = workload_identity

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderGcpsmAuthSecretRef"]:
        '''
        :schema: SecretStoreSpecProviderGcpsmAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderGcpsmAuthSecretRef"], result)

    @builtins.property
    def workload_identity(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderGcpsmAuthWorkloadIdentity"]:
        '''
        :schema: SecretStoreSpecProviderGcpsmAuth#workloadIdentity
        '''
        result = self._values.get("workload_identity")
        return typing.cast(typing.Optional["SecretStoreSpecProviderGcpsmAuthWorkloadIdentity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderGcpsmAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderGcpsmAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"secret_access_key_secret_ref": "secretAccessKeySecretRef"},
)
class SecretStoreSpecProviderGcpsmAuthSecretRef:
    def __init__(
        self,
        *,
        secret_access_key_secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param secret_access_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: SecretStoreSpecProviderGcpsmAuthSecretRef
        '''
        if isinstance(secret_access_key_secret_ref, dict):
            secret_access_key_secret_ref = SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(**secret_access_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3ca5c2e53d8308a5605105725f2c5e7bdd938b3d8ecb9bea29c97128ee49603c)
            check_type(argname="argument secret_access_key_secret_ref", value=secret_access_key_secret_ref, expected_type=type_hints["secret_access_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_access_key_secret_ref is not None:
            self._values["secret_access_key_secret_ref"] = secret_access_key_secret_ref

    @builtins.property
    def secret_access_key_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: SecretStoreSpecProviderGcpsmAuthSecretRef#secretAccessKeySecretRef
        '''
        result = self._values.get("secret_access_key_secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderGcpsmAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d6e8ae2d693f0cb3bb2f015f58e3bdbb1cf79d29d3c7d7a1da2a8f171c0b9b0d)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderGcpsmAuthWorkloadIdentity",
    jsii_struct_bases=[],
    name_mapping={
        "cluster_location": "clusterLocation",
        "cluster_name": "clusterName",
        "service_account_ref": "serviceAccountRef",
        "cluster_project_id": "clusterProjectId",
    },
)
class SecretStoreSpecProviderGcpsmAuthWorkloadIdentity:
    def __init__(
        self,
        *,
        cluster_location: builtins.str,
        cluster_name: builtins.str,
        service_account_ref: typing.Union["SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef", typing.Dict[builtins.str, typing.Any]],
        cluster_project_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param cluster_location: 
        :param cluster_name: 
        :param service_account_ref: A reference to a ServiceAccount resource.
        :param cluster_project_id: 

        :schema: SecretStoreSpecProviderGcpsmAuthWorkloadIdentity
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__545f2582e9eda3209742adff37223ac38c989705d97ddaaaf2d68951ec464e1b)
            check_type(argname="argument cluster_location", value=cluster_location, expected_type=type_hints["cluster_location"])
            check_type(argname="argument cluster_name", value=cluster_name, expected_type=type_hints["cluster_name"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument cluster_project_id", value=cluster_project_id, expected_type=type_hints["cluster_project_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cluster_location": cluster_location,
            "cluster_name": cluster_name,
            "service_account_ref": service_account_ref,
        }
        if cluster_project_id is not None:
            self._values["cluster_project_id"] = cluster_project_id

    @builtins.property
    def cluster_location(self) -> builtins.str:
        '''
        :schema: SecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterLocation
        '''
        result = self._values.get("cluster_location")
        assert result is not None, "Required property 'cluster_location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cluster_name(self) -> builtins.str:
        '''
        :schema: SecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterName
        '''
        result = self._values.get("cluster_name")
        assert result is not None, "Required property 'cluster_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> "SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef":
        '''A reference to a ServiceAccount resource.

        :schema: SecretStoreSpecProviderGcpsmAuthWorkloadIdentity#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        assert result is not None, "Required property 'service_account_ref' is missing"
        return typing.cast("SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef", result)

    @builtins.property
    def cluster_project_id(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterProjectID
        '''
        result = self._values.get("cluster_project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderGcpsmAuthWorkloadIdentity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__00880ada914c2988e4f81a2bbf81f548e12d991c753f3632924ed040061739f9)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderGitlab",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "project_id": "projectId", "url": "url"},
)
class SecretStoreSpecProviderGitlab:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreSpecProviderGitlabAuth", typing.Dict[builtins.str, typing.Any]],
        project_id: typing.Optional[builtins.str] = None,
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''GitLab configures this store to sync secrets using GitLab Variables provider.

        :param auth: Auth configures how secret-manager authenticates with a GitLab instance.
        :param project_id: ProjectID specifies a project where secrets are located.
        :param url: URL configures the GitLab instance URL. Defaults to https://gitlab.com/. Default: https://gitlab.com/.

        :schema: SecretStoreSpecProviderGitlab
        '''
        if isinstance(auth, dict):
            auth = SecretStoreSpecProviderGitlabAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__74a9704961b5ebc67a85b13e3ea0b0eecabb2dbda2aee0064fc2ce88d60d1a03)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
        }
        if project_id is not None:
            self._values["project_id"] = project_id
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def auth(self) -> "SecretStoreSpecProviderGitlabAuth":
        '''Auth configures how secret-manager authenticates with a GitLab instance.

        :schema: SecretStoreSpecProviderGitlab#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreSpecProviderGitlabAuth", result)

    @builtins.property
    def project_id(self) -> typing.Optional[builtins.str]:
        '''ProjectID specifies a project where secrets are located.

        :schema: SecretStoreSpecProviderGitlab#projectID
        '''
        result = self._values.get("project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''URL configures the GitLab instance URL.

        Defaults to https://gitlab.com/.

        :default: https://gitlab.com/.

        :schema: SecretStoreSpecProviderGitlab#url
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderGitlab(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderGitlabAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class SecretStoreSpecProviderGitlabAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreSpecProviderGitlabAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth configures how secret-manager authenticates with a GitLab instance.

        :param secret_ref: 

        :schema: SecretStoreSpecProviderGitlabAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderGitlabAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__46cdf91513510c8d21322132a5945d246a0875325bc127c14fdce554439269e1)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "SecretStoreSpecProviderGitlabAuthSecretRef":
        '''
        :schema: SecretStoreSpecProviderGitlabAuth#SecretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreSpecProviderGitlabAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderGitlabAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderGitlabAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"access_token": "accessToken"},
)
class SecretStoreSpecProviderGitlabAuthSecretRef:
    def __init__(
        self,
        *,
        access_token: typing.Optional[typing.Union["SecretStoreSpecProviderGitlabAuthSecretRefAccessToken", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param access_token: AccessToken is used for authentication.

        :schema: SecretStoreSpecProviderGitlabAuthSecretRef
        '''
        if isinstance(access_token, dict):
            access_token = SecretStoreSpecProviderGitlabAuthSecretRefAccessToken(**access_token)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d22720edc8e41b53bce4c708816fbc06868a093474e54079ed99d225ce461ee)
            check_type(argname="argument access_token", value=access_token, expected_type=type_hints["access_token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if access_token is not None:
            self._values["access_token"] = access_token

    @builtins.property
    def access_token(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderGitlabAuthSecretRefAccessToken"]:
        '''AccessToken is used for authentication.

        :schema: SecretStoreSpecProviderGitlabAuthSecretRef#accessToken
        '''
        result = self._values.get("access_token")
        return typing.cast(typing.Optional["SecretStoreSpecProviderGitlabAuthSecretRefAccessToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderGitlabAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderGitlabAuthSecretRefAccessToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderGitlabAuthSecretRefAccessToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AccessToken is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderGitlabAuthSecretRefAccessToken
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__09362b98cec758e02e93e69b896f7fb16827ce7a4e50ce19232e7d22f62986e3)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderGitlabAuthSecretRefAccessToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderGitlabAuthSecretRefAccessToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderGitlabAuthSecretRefAccessToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderGitlabAuthSecretRefAccessToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderIbm",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "service_url": "serviceUrl"},
)
class SecretStoreSpecProviderIbm:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreSpecProviderIbmAuth", typing.Dict[builtins.str, typing.Any]],
        service_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''IBM configures this store to sync secrets using IBM Cloud provider.

        :param auth: Auth configures how secret-manager authenticates with the IBM secrets manager.
        :param service_url: ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance.

        :schema: SecretStoreSpecProviderIbm
        '''
        if isinstance(auth, dict):
            auth = SecretStoreSpecProviderIbmAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__087ffef410337619c50c121e7ef3359e554a57b9a10ce1edf8770b3d81e0ed8e)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument service_url", value=service_url, expected_type=type_hints["service_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
        }
        if service_url is not None:
            self._values["service_url"] = service_url

    @builtins.property
    def auth(self) -> "SecretStoreSpecProviderIbmAuth":
        '''Auth configures how secret-manager authenticates with the IBM secrets manager.

        :schema: SecretStoreSpecProviderIbm#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreSpecProviderIbmAuth", result)

    @builtins.property
    def service_url(self) -> typing.Optional[builtins.str]:
        '''ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance.

        :schema: SecretStoreSpecProviderIbm#serviceUrl
        '''
        result = self._values.get("service_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderIbm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderIbmAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class SecretStoreSpecProviderIbmAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreSpecProviderIbmAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth configures how secret-manager authenticates with the IBM secrets manager.

        :param secret_ref: 

        :schema: SecretStoreSpecProviderIbmAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderIbmAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f61c15804c1ea14aba8f3312c92149924d5fc9171c095620ebd5ce368db03750)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "SecretStoreSpecProviderIbmAuthSecretRef":
        '''
        :schema: SecretStoreSpecProviderIbmAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreSpecProviderIbmAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderIbmAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderIbmAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"secret_api_key_secret_ref": "secretApiKeySecretRef"},
)
class SecretStoreSpecProviderIbmAuthSecretRef:
    def __init__(
        self,
        *,
        secret_api_key_secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param secret_api_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: SecretStoreSpecProviderIbmAuthSecretRef
        '''
        if isinstance(secret_api_key_secret_ref, dict):
            secret_api_key_secret_ref = SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef(**secret_api_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__07e5284d9a003aeaf572246b0e4192e0b1555336a7526ede354d24b2bfa9117d)
            check_type(argname="argument secret_api_key_secret_ref", value=secret_api_key_secret_ref, expected_type=type_hints["secret_api_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_api_key_secret_ref is not None:
            self._values["secret_api_key_secret_ref"] = secret_api_key_secret_ref

    @builtins.property
    def secret_api_key_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: SecretStoreSpecProviderIbmAuthSecretRef#secretApiKeySecretRef
        '''
        result = self._values.get("secret_api_key_secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderIbmAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af92c8b92be448c0919d7ddf59d73c1f0547837b33364f979a4c39d387ae914d)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetes",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "remote_namespace": "remoteNamespace",
        "server": "server",
    },
)
class SecretStoreSpecProviderKubernetes:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreSpecProviderKubernetesAuth", typing.Dict[builtins.str, typing.Any]],
        remote_namespace: typing.Optional[builtins.str] = None,
        server: typing.Optional[typing.Union["SecretStoreSpecProviderKubernetesServer", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.

        :param auth: Auth configures how secret-manager authenticates with a Kubernetes instance.
        :param remote_namespace: Remote namespace to fetch the secrets from.
        :param server: configures the Kubernetes server Address.

        :schema: SecretStoreSpecProviderKubernetes
        '''
        if isinstance(auth, dict):
            auth = SecretStoreSpecProviderKubernetesAuth(**auth)
        if isinstance(server, dict):
            server = SecretStoreSpecProviderKubernetesServer(**server)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__904b128b7718fcd2bf2de42ebd0e146d997e1d49742e3ca3719f98eb5ebb46c7)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument remote_namespace", value=remote_namespace, expected_type=type_hints["remote_namespace"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
        }
        if remote_namespace is not None:
            self._values["remote_namespace"] = remote_namespace
        if server is not None:
            self._values["server"] = server

    @builtins.property
    def auth(self) -> "SecretStoreSpecProviderKubernetesAuth":
        '''Auth configures how secret-manager authenticates with a Kubernetes instance.

        :schema: SecretStoreSpecProviderKubernetes#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreSpecProviderKubernetesAuth", result)

    @builtins.property
    def remote_namespace(self) -> typing.Optional[builtins.str]:
        '''Remote namespace to fetch the secrets from.

        :schema: SecretStoreSpecProviderKubernetes#remoteNamespace
        '''
        result = self._values.get("remote_namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def server(self) -> typing.Optional["SecretStoreSpecProviderKubernetesServer"]:
        '''configures the Kubernetes server Address.

        :schema: SecretStoreSpecProviderKubernetes#server
        '''
        result = self._values.get("server")
        return typing.cast(typing.Optional["SecretStoreSpecProviderKubernetesServer"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesAuth",
    jsii_struct_bases=[],
    name_mapping={
        "cert": "cert",
        "service_account": "serviceAccount",
        "token": "token",
    },
)
class SecretStoreSpecProviderKubernetesAuth:
    def __init__(
        self,
        *,
        cert: typing.Optional[typing.Union["SecretStoreSpecProviderKubernetesAuthCert", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account: typing.Optional[typing.Union["SecretStoreSpecProviderKubernetesAuthServiceAccount", typing.Dict[builtins.str, typing.Any]]] = None,
        token: typing.Optional[typing.Union["SecretStoreSpecProviderKubernetesAuthToken", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how secret-manager authenticates with a Kubernetes instance.

        :param cert: has both clientCert and clientKey as secretKeySelector.
        :param service_account: points to a service account that should be used for authentication.
        :param token: use static token to authenticate with.

        :schema: SecretStoreSpecProviderKubernetesAuth
        '''
        if isinstance(cert, dict):
            cert = SecretStoreSpecProviderKubernetesAuthCert(**cert)
        if isinstance(service_account, dict):
            service_account = SecretStoreSpecProviderKubernetesAuthServiceAccount(**service_account)
        if isinstance(token, dict):
            token = SecretStoreSpecProviderKubernetesAuthToken(**token)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__151388d9b4c0b03790206cc929e9596ecfff49de852b599072600264a970c257)
            check_type(argname="argument cert", value=cert, expected_type=type_hints["cert"])
            check_type(argname="argument service_account", value=service_account, expected_type=type_hints["service_account"])
            check_type(argname="argument token", value=token, expected_type=type_hints["token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cert is not None:
            self._values["cert"] = cert
        if service_account is not None:
            self._values["service_account"] = service_account
        if token is not None:
            self._values["token"] = token

    @builtins.property
    def cert(self) -> typing.Optional["SecretStoreSpecProviderKubernetesAuthCert"]:
        '''has both clientCert and clientKey as secretKeySelector.

        :schema: SecretStoreSpecProviderKubernetesAuth#cert
        '''
        result = self._values.get("cert")
        return typing.cast(typing.Optional["SecretStoreSpecProviderKubernetesAuthCert"], result)

    @builtins.property
    def service_account(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderKubernetesAuthServiceAccount"]:
        '''points to a service account that should be used for authentication.

        :schema: SecretStoreSpecProviderKubernetesAuth#serviceAccount
        '''
        result = self._values.get("service_account")
        return typing.cast(typing.Optional["SecretStoreSpecProviderKubernetesAuthServiceAccount"], result)

    @builtins.property
    def token(self) -> typing.Optional["SecretStoreSpecProviderKubernetesAuthToken"]:
        '''use static token to authenticate with.

        :schema: SecretStoreSpecProviderKubernetesAuth#token
        '''
        result = self._values.get("token")
        return typing.cast(typing.Optional["SecretStoreSpecProviderKubernetesAuthToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetesAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesAuthCert",
    jsii_struct_bases=[],
    name_mapping={"client_cert": "clientCert", "client_key": "clientKey"},
)
class SecretStoreSpecProviderKubernetesAuthCert:
    def __init__(
        self,
        *,
        client_cert: typing.Optional[typing.Union["SecretStoreSpecProviderKubernetesAuthCertClientCert", typing.Dict[builtins.str, typing.Any]]] = None,
        client_key: typing.Optional[typing.Union["SecretStoreSpecProviderKubernetesAuthCertClientKey", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''has both clientCert and clientKey as secretKeySelector.

        :param client_cert: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param client_key: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: SecretStoreSpecProviderKubernetesAuthCert
        '''
        if isinstance(client_cert, dict):
            client_cert = SecretStoreSpecProviderKubernetesAuthCertClientCert(**client_cert)
        if isinstance(client_key, dict):
            client_key = SecretStoreSpecProviderKubernetesAuthCertClientKey(**client_key)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a96c6e462ac166552fd43d6e853ebe6677ad7313751774413548c4dc9d9cbd6d)
            check_type(argname="argument client_cert", value=client_cert, expected_type=type_hints["client_cert"])
            check_type(argname="argument client_key", value=client_key, expected_type=type_hints["client_key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if client_cert is not None:
            self._values["client_cert"] = client_cert
        if client_key is not None:
            self._values["client_key"] = client_key

    @builtins.property
    def client_cert(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderKubernetesAuthCertClientCert"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreSpecProviderKubernetesAuthCert#clientCert
        '''
        result = self._values.get("client_cert")
        return typing.cast(typing.Optional["SecretStoreSpecProviderKubernetesAuthCertClientCert"], result)

    @builtins.property
    def client_key(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderKubernetesAuthCertClientKey"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreSpecProviderKubernetesAuthCert#clientKey
        '''
        result = self._values.get("client_key")
        return typing.cast(typing.Optional["SecretStoreSpecProviderKubernetesAuthCertClientKey"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetesAuthCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesAuthCertClientCert",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderKubernetesAuthCertClientCert:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderKubernetesAuthCertClientCert
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f622c6fa4b3f98c8c90256538cfe1195389eea246105b866e4f8226a3e11a92)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderKubernetesAuthCertClientCert#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderKubernetesAuthCertClientCert#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderKubernetesAuthCertClientCert#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetesAuthCertClientCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesAuthCertClientKey",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderKubernetesAuthCertClientKey:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderKubernetesAuthCertClientKey
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ee6e0f3141539f98753d7f8c7f84109da05ee28cbb2496c62158aa37893c4e1f)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderKubernetesAuthCertClientKey#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderKubernetesAuthCertClientKey#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderKubernetesAuthCertClientKey#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetesAuthCertClientKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesAuthServiceAccount",
    jsii_struct_bases=[],
    name_mapping={"service_account": "serviceAccount"},
)
class SecretStoreSpecProviderKubernetesAuthServiceAccount:
    def __init__(
        self,
        *,
        service_account: typing.Optional[typing.Union["SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''points to a service account that should be used for authentication.

        :param service_account: A reference to a ServiceAccount resource.

        :schema: SecretStoreSpecProviderKubernetesAuthServiceAccount
        '''
        if isinstance(service_account, dict):
            service_account = SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount(**service_account)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4a38f6830f593f71ee328bf0bb7a2d5348dbd4c5a2a2c8ccab3acbabf77e63fc)
            check_type(argname="argument service_account", value=service_account, expected_type=type_hints["service_account"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if service_account is not None:
            self._values["service_account"] = service_account

    @builtins.property
    def service_account(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount"]:
        '''A reference to a ServiceAccount resource.

        :schema: SecretStoreSpecProviderKubernetesAuthServiceAccount#serviceAccount
        '''
        result = self._values.get("service_account")
        return typing.cast(typing.Optional["SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetesAuthServiceAccount(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__586cee09f8cca7480473d65c3cc68fe9848fa4209f08b883dea677a950b66013)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesAuthToken",
    jsii_struct_bases=[],
    name_mapping={"bearer_token": "bearerToken"},
)
class SecretStoreSpecProviderKubernetesAuthToken:
    def __init__(
        self,
        *,
        bearer_token: typing.Optional[typing.Union["SecretStoreSpecProviderKubernetesAuthTokenBearerToken", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''use static token to authenticate with.

        :param bearer_token: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: SecretStoreSpecProviderKubernetesAuthToken
        '''
        if isinstance(bearer_token, dict):
            bearer_token = SecretStoreSpecProviderKubernetesAuthTokenBearerToken(**bearer_token)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1581d621227fc42b2bc6fab0466a744ec14017ab25b27c4f605a3d67acfbe832)
            check_type(argname="argument bearer_token", value=bearer_token, expected_type=type_hints["bearer_token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if bearer_token is not None:
            self._values["bearer_token"] = bearer_token

    @builtins.property
    def bearer_token(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderKubernetesAuthTokenBearerToken"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreSpecProviderKubernetesAuthToken#bearerToken
        '''
        result = self._values.get("bearer_token")
        return typing.cast(typing.Optional["SecretStoreSpecProviderKubernetesAuthTokenBearerToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetesAuthToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesAuthTokenBearerToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderKubernetesAuthTokenBearerToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderKubernetesAuthTokenBearerToken
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__341d7ee7c9f1813146f595b6ac86827f52e296fbd90e305fbe30e75e6d1d7f0c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderKubernetesAuthTokenBearerToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderKubernetesAuthTokenBearerToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderKubernetesAuthTokenBearerToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetesAuthTokenBearerToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesServer",
    jsii_struct_bases=[],
    name_mapping={"ca_bundle": "caBundle", "ca_provider": "caProvider", "url": "url"},
)
class SecretStoreSpecProviderKubernetesServer:
    def __init__(
        self,
        *,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreSpecProviderKubernetesServerCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''configures the Kubernetes server Address.

        :param ca_bundle: CABundle is a base64-encoded CA certificate.
        :param ca_provider: see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.
        :param url: configures the Kubernetes server Address.

        :schema: SecretStoreSpecProviderKubernetesServer
        '''
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreSpecProviderKubernetesServerCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__49350e64932573067989f27f2c978c32a0b68db7780223b97496498ba0769b76)
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''CABundle is a base64-encoded CA certificate.

        :schema: SecretStoreSpecProviderKubernetesServer#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderKubernetesServerCaProvider"]:
        '''see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.

        :schema: SecretStoreSpecProviderKubernetesServer#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreSpecProviderKubernetesServerCaProvider"], result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''configures the Kubernetes server Address.

        :schema: SecretStoreSpecProviderKubernetesServer#url
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetesServer(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesServerCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class SecretStoreSpecProviderKubernetesServerCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "SecretStoreSpecProviderKubernetesServerCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in.

        :schema: SecretStoreSpecProviderKubernetesServerCaProvider
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__363e9db3b763eedad22dc94f5b2adaec3fea7bb6f5e0ffec6fb69f3806f91fe2)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: SecretStoreSpecProviderKubernetesServerCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "SecretStoreSpecProviderKubernetesServerCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: SecretStoreSpecProviderKubernetesServerCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("SecretStoreSpecProviderKubernetesServerCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: SecretStoreSpecProviderKubernetesServerCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        :schema: SecretStoreSpecProviderKubernetesServerCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetesServerCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesServerCaProviderType"
)
class SecretStoreSpecProviderKubernetesServerCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: SecretStoreSpecProviderKubernetesServerCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderOracle",
    jsii_struct_bases=[],
    name_mapping={
        "region": "region",
        "vault": "vault",
        "auth": "auth",
        "compartment": "compartment",
        "encryption_key": "encryptionKey",
        "principal_type": "principalType",
        "service_account_ref": "serviceAccountRef",
    },
)
class SecretStoreSpecProviderOracle:
    def __init__(
        self,
        *,
        region: builtins.str,
        vault: builtins.str,
        auth: typing.Optional[typing.Union["SecretStoreSpecProviderOracleAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        compartment: typing.Optional[builtins.str] = None,
        encryption_key: typing.Optional[builtins.str] = None,
        principal_type: typing.Optional["SecretStoreSpecProviderOraclePrincipalType"] = None,
        service_account_ref: typing.Optional[typing.Union["SecretStoreSpecProviderOracleServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Oracle configures this store to sync secrets using Oracle Vault provider.

        :param region: Region is the region where vault is located.
        :param vault: Vault is the vault's OCID of the specific vault where secret is located.
        :param auth: Auth configures how secret-manager authenticates with the Oracle Vault. If empty, instance principal is used. Optionally, the authenticating principal type and/or user data may be supplied for the use of workload identity and user principal.
        :param compartment: Compartment is the vault compartment OCID. Required for PushSecret
        :param encryption_key: EncryptionKey is the OCID of the encryption key within the vault. Required for PushSecret
        :param principal_type: The type of principal to use for authentication. If left blank, the Auth struct will determine the principal type. This optional field must be specified if using workload identity.
        :param service_account_ref: ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :schema: SecretStoreSpecProviderOracle
        '''
        if isinstance(auth, dict):
            auth = SecretStoreSpecProviderOracleAuth(**auth)
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreSpecProviderOracleServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c20124e1b995d76a5c23860f9ecff1ebac42889eac56116daf01652dc9c1605)
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument vault", value=vault, expected_type=type_hints["vault"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument compartment", value=compartment, expected_type=type_hints["compartment"])
            check_type(argname="argument encryption_key", value=encryption_key, expected_type=type_hints["encryption_key"])
            check_type(argname="argument principal_type", value=principal_type, expected_type=type_hints["principal_type"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "region": region,
            "vault": vault,
        }
        if auth is not None:
            self._values["auth"] = auth
        if compartment is not None:
            self._values["compartment"] = compartment
        if encryption_key is not None:
            self._values["encryption_key"] = encryption_key
        if principal_type is not None:
            self._values["principal_type"] = principal_type
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def region(self) -> builtins.str:
        '''Region is the region where vault is located.

        :schema: SecretStoreSpecProviderOracle#region
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vault(self) -> builtins.str:
        '''Vault is the vault's OCID of the specific vault where secret is located.

        :schema: SecretStoreSpecProviderOracle#vault
        '''
        result = self._values.get("vault")
        assert result is not None, "Required property 'vault' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth(self) -> typing.Optional["SecretStoreSpecProviderOracleAuth"]:
        '''Auth configures how secret-manager authenticates with the Oracle Vault.

        If empty, instance principal is used. Optionally, the authenticating principal type
        and/or user data may be supplied for the use of workload identity and user principal.

        :schema: SecretStoreSpecProviderOracle#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["SecretStoreSpecProviderOracleAuth"], result)

    @builtins.property
    def compartment(self) -> typing.Optional[builtins.str]:
        '''Compartment is the vault compartment OCID.

        Required for PushSecret

        :schema: SecretStoreSpecProviderOracle#compartment
        '''
        result = self._values.get("compartment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def encryption_key(self) -> typing.Optional[builtins.str]:
        '''EncryptionKey is the OCID of the encryption key within the vault.

        Required for PushSecret

        :schema: SecretStoreSpecProviderOracle#encryptionKey
        '''
        result = self._values.get("encryption_key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def principal_type(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderOraclePrincipalType"]:
        '''The type of principal to use for authentication.

        If left blank, the Auth struct will
        determine the principal type. This optional field must be specified if using
        workload identity.

        :schema: SecretStoreSpecProviderOracle#principalType
        '''
        result = self._values.get("principal_type")
        return typing.cast(typing.Optional["SecretStoreSpecProviderOraclePrincipalType"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderOracleServiceAccountRef"]:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :schema: SecretStoreSpecProviderOracle#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderOracleServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderOracle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderOracleAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "tenancy": "tenancy", "user": "user"},
)
class SecretStoreSpecProviderOracleAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreSpecProviderOracleAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
        tenancy: builtins.str,
        user: builtins.str,
    ) -> None:
        '''Auth configures how secret-manager authenticates with the Oracle Vault.

        If empty, instance principal is used. Optionally, the authenticating principal type
        and/or user data may be supplied for the use of workload identity and user principal.

        :param secret_ref: SecretRef to pass through sensitive information.
        :param tenancy: Tenancy is the tenancy OCID where user is located.
        :param user: User is an access OCID specific to the account.

        :schema: SecretStoreSpecProviderOracleAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderOracleAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8b0d6d1c44297738b31436d4946a4a8ce29246ad70f9d793df2188ecdc9b9017)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument tenancy", value=tenancy, expected_type=type_hints["tenancy"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
            "tenancy": tenancy,
            "user": user,
        }

    @builtins.property
    def secret_ref(self) -> "SecretStoreSpecProviderOracleAuthSecretRef":
        '''SecretRef to pass through sensitive information.

        :schema: SecretStoreSpecProviderOracleAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreSpecProviderOracleAuthSecretRef", result)

    @builtins.property
    def tenancy(self) -> builtins.str:
        '''Tenancy is the tenancy OCID where user is located.

        :schema: SecretStoreSpecProviderOracleAuth#tenancy
        '''
        result = self._values.get("tenancy")
        assert result is not None, "Required property 'tenancy' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def user(self) -> builtins.str:
        '''User is an access OCID specific to the account.

        :schema: SecretStoreSpecProviderOracleAuth#user
        '''
        result = self._values.get("user")
        assert result is not None, "Required property 'user' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderOracleAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderOracleAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"fingerprint": "fingerprint", "privatekey": "privatekey"},
)
class SecretStoreSpecProviderOracleAuthSecretRef:
    def __init__(
        self,
        *,
        fingerprint: typing.Union["SecretStoreSpecProviderOracleAuthSecretRefFingerprint", typing.Dict[builtins.str, typing.Any]],
        privatekey: typing.Union["SecretStoreSpecProviderOracleAuthSecretRefPrivatekey", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''SecretRef to pass through sensitive information.

        :param fingerprint: Fingerprint is the fingerprint of the API private key.
        :param privatekey: PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :schema: SecretStoreSpecProviderOracleAuthSecretRef
        '''
        if isinstance(fingerprint, dict):
            fingerprint = SecretStoreSpecProviderOracleAuthSecretRefFingerprint(**fingerprint)
        if isinstance(privatekey, dict):
            privatekey = SecretStoreSpecProviderOracleAuthSecretRefPrivatekey(**privatekey)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb3832cb9223d922c95e110bd9960a050b0d42eb510f564caa0903e89a57f31e)
            check_type(argname="argument fingerprint", value=fingerprint, expected_type=type_hints["fingerprint"])
            check_type(argname="argument privatekey", value=privatekey, expected_type=type_hints["privatekey"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "fingerprint": fingerprint,
            "privatekey": privatekey,
        }

    @builtins.property
    def fingerprint(self) -> "SecretStoreSpecProviderOracleAuthSecretRefFingerprint":
        '''Fingerprint is the fingerprint of the API private key.

        :schema: SecretStoreSpecProviderOracleAuthSecretRef#fingerprint
        '''
        result = self._values.get("fingerprint")
        assert result is not None, "Required property 'fingerprint' is missing"
        return typing.cast("SecretStoreSpecProviderOracleAuthSecretRefFingerprint", result)

    @builtins.property
    def privatekey(self) -> "SecretStoreSpecProviderOracleAuthSecretRefPrivatekey":
        '''PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :schema: SecretStoreSpecProviderOracleAuthSecretRef#privatekey
        '''
        result = self._values.get("privatekey")
        assert result is not None, "Required property 'privatekey' is missing"
        return typing.cast("SecretStoreSpecProviderOracleAuthSecretRefPrivatekey", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderOracleAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderOracleAuthSecretRefFingerprint",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderOracleAuthSecretRefFingerprint:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Fingerprint is the fingerprint of the API private key.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderOracleAuthSecretRefFingerprint
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a8123501f8e589da765eda43eddefc179135d62dafdff666b2dc162230854b9)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderOracleAuthSecretRefFingerprint#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderOracleAuthSecretRefFingerprint#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderOracleAuthSecretRefFingerprint#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderOracleAuthSecretRefFingerprint(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderOracleAuthSecretRefPrivatekey",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderOracleAuthSecretRefPrivatekey:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderOracleAuthSecretRefPrivatekey
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a26c7af5eb3d372a1a790a6143a7ae00bd502b4516c33828cd4f888eff60809f)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderOracleAuthSecretRefPrivatekey#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderOracleAuthSecretRefPrivatekey#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderOracleAuthSecretRefPrivatekey#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderOracleAuthSecretRefPrivatekey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.SecretStoreSpecProviderOraclePrincipalType")
class SecretStoreSpecProviderOraclePrincipalType(enum.Enum):
    '''The type of principal to use for authentication.

    If left blank, the Auth struct will
    determine the principal type. This optional field must be specified if using
    workload identity.

    :schema: SecretStoreSpecProviderOraclePrincipalType
    '''

    USER_PRINCIPAL = "USER_PRINCIPAL"
    '''UserPrincipal.'''
    INSTANCE_PRINCIPAL = "INSTANCE_PRINCIPAL"
    '''InstancePrincipal.'''
    WORKLOAD = "WORKLOAD"
    '''Workload.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderOracleServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreSpecProviderOracleServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderOracleServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__97202d07f8a20c377da4a4404da5930f6c1182c8d25b0837a4ffd53826a2bd5c)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreSpecProviderOracleServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreSpecProviderOracleServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderOracleServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderOracleServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderPassworddepot",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "database": "database", "host": "host"},
)
class SecretStoreSpecProviderPassworddepot:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreSpecProviderPassworddepotAuth", typing.Dict[builtins.str, typing.Any]],
        database: builtins.str,
        host: builtins.str,
    ) -> None:
        '''Configures a store to sync secrets with a Password Depot instance.

        :param auth: Auth configures how secret-manager authenticates with a Password Depot instance.
        :param database: Database to use as source.
        :param host: URL configures the Password Depot instance URL.

        :schema: SecretStoreSpecProviderPassworddepot
        '''
        if isinstance(auth, dict):
            auth = SecretStoreSpecProviderPassworddepotAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9210cc06755b6f79ef88436221883e23a6bc7877dd0f395c4cd16ac6a07cf1b7)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument database", value=database, expected_type=type_hints["database"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "database": database,
            "host": host,
        }

    @builtins.property
    def auth(self) -> "SecretStoreSpecProviderPassworddepotAuth":
        '''Auth configures how secret-manager authenticates with a Password Depot instance.

        :schema: SecretStoreSpecProviderPassworddepot#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreSpecProviderPassworddepotAuth", result)

    @builtins.property
    def database(self) -> builtins.str:
        '''Database to use as source.

        :schema: SecretStoreSpecProviderPassworddepot#database
        '''
        result = self._values.get("database")
        assert result is not None, "Required property 'database' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def host(self) -> builtins.str:
        '''URL configures the Password Depot instance URL.

        :schema: SecretStoreSpecProviderPassworddepot#host
        '''
        result = self._values.get("host")
        assert result is not None, "Required property 'host' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderPassworddepot(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderPassworddepotAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class SecretStoreSpecProviderPassworddepotAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreSpecProviderPassworddepotAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth configures how secret-manager authenticates with a Password Depot instance.

        :param secret_ref: 

        :schema: SecretStoreSpecProviderPassworddepotAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderPassworddepotAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__feb83c7479202ef875edec190269329957bcb4a5f12a7ddb3764ed63f3198eae)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "SecretStoreSpecProviderPassworddepotAuthSecretRef":
        '''
        :schema: SecretStoreSpecProviderPassworddepotAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreSpecProviderPassworddepotAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderPassworddepotAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderPassworddepotAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"credentials": "credentials"},
)
class SecretStoreSpecProviderPassworddepotAuthSecretRef:
    def __init__(
        self,
        *,
        credentials: typing.Optional[typing.Union["SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param credentials: Username / Password is used for authentication.

        :schema: SecretStoreSpecProviderPassworddepotAuthSecretRef
        '''
        if isinstance(credentials, dict):
            credentials = SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials(**credentials)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__385e5404d7188efbe5c105cd17b7472fdbe052f3dbb8ac60cc6cffbd88bd05a0)
            check_type(argname="argument credentials", value=credentials, expected_type=type_hints["credentials"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if credentials is not None:
            self._values["credentials"] = credentials

    @builtins.property
    def credentials(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials"]:
        '''Username / Password is used for authentication.

        :schema: SecretStoreSpecProviderPassworddepotAuthSecretRef#credentials
        '''
        result = self._values.get("credentials")
        return typing.cast(typing.Optional["SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderPassworddepotAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Username / Password is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__959a3bfa5af19658f93dc84d289d96c810eeb3219467e12a36491d3bcf6bc0d1)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVault",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "server": "server",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
        "forward_inconsistent": "forwardInconsistent",
        "namespace": "namespace",
        "path": "path",
        "read_your_writes": "readYourWrites",
        "version": "version",
    },
)
class SecretStoreSpecProviderVault:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreSpecProviderVaultAuth", typing.Dict[builtins.str, typing.Any]],
        server: builtins.str,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreSpecProviderVaultCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
        forward_inconsistent: typing.Optional[builtins.bool] = None,
        namespace: typing.Optional[builtins.str] = None,
        path: typing.Optional[builtins.str] = None,
        read_your_writes: typing.Optional[builtins.bool] = None,
        version: typing.Optional["SecretStoreSpecProviderVaultVersion"] = None,
    ) -> None:
        '''Vault configures this store to sync secrets using Hashi provider.

        :param auth: Auth configures how secret-manager authenticates with the Vault server.
        :param server: Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
        :param ca_bundle: PEM encoded CA bundle used to validate Vault server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
        :param ca_provider: The provider for the CA bundle to use to validate Vault server certificate.
        :param forward_inconsistent: ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop. This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
        :param namespace: Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
        :param path: Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.
        :param read_your_writes: ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request. More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency
        :param version: Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".

        :schema: SecretStoreSpecProviderVault
        '''
        if isinstance(auth, dict):
            auth = SecretStoreSpecProviderVaultAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreSpecProviderVaultCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4ae354c0bc0f63e88460e1b51ccf0b056861e4af5089834a48e7ffbaa7318995)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument forward_inconsistent", value=forward_inconsistent, expected_type=type_hints["forward_inconsistent"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument read_your_writes", value=read_your_writes, expected_type=type_hints["read_your_writes"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "server": server,
        }
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if forward_inconsistent is not None:
            self._values["forward_inconsistent"] = forward_inconsistent
        if namespace is not None:
            self._values["namespace"] = namespace
        if path is not None:
            self._values["path"] = path
        if read_your_writes is not None:
            self._values["read_your_writes"] = read_your_writes
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def auth(self) -> "SecretStoreSpecProviderVaultAuth":
        '''Auth configures how secret-manager authenticates with the Vault server.

        :schema: SecretStoreSpecProviderVault#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreSpecProviderVaultAuth", result)

    @builtins.property
    def server(self) -> builtins.str:
        '''Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".

        :schema: SecretStoreSpecProviderVault#server
        '''
        result = self._values.get("server")
        assert result is not None, "Required property 'server' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''PEM encoded CA bundle used to validate Vault server certificate.

        Only used
        if the Server URL is using HTTPS protocol. This parameter is ignored for
        plain HTTP protocol connection. If not set the system root certificates
        are used to validate the TLS connection.

        :schema: SecretStoreSpecProviderVault#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(self) -> typing.Optional["SecretStoreSpecProviderVaultCaProvider"]:
        '''The provider for the CA bundle to use to validate Vault server certificate.

        :schema: SecretStoreSpecProviderVault#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultCaProvider"], result)

    @builtins.property
    def forward_inconsistent(self) -> typing.Optional[builtins.bool]:
        '''ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop.

        This can increase performance if
        the option is enabled serverside.
        https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header

        :schema: SecretStoreSpecProviderVault#forwardInconsistent
        '''
        result = self._values.get("forward_inconsistent")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Name of the vault namespace.

        Namespaces is a set of features within Vault Enterprise that allows
        Vault environments to support Secure Multi-tenancy. e.g: "ns1".
        More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces

        :schema: SecretStoreSpecProviderVault#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.

        :schema: SecretStoreSpecProviderVault#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_your_writes(self) -> typing.Optional[builtins.bool]:
        '''ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request.

        More information about eventual consistency in Vault can be found here
        https://www.vaultproject.io/docs/enterprise/consistency

        :schema: SecretStoreSpecProviderVault#readYourWrites
        '''
        result = self._values.get("read_your_writes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def version(self) -> typing.Optional["SecretStoreSpecProviderVaultVersion"]:
        '''Version is the Vault KV secret engine version.

        This can be either "v1" or
        "v2". Version defaults to "v2".

        :schema: SecretStoreSpecProviderVault#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultVersion"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVault(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuth",
    jsii_struct_bases=[],
    name_mapping={
        "app_role": "appRole",
        "cert": "cert",
        "jwt": "jwt",
        "kubernetes": "kubernetes",
        "ldap": "ldap",
        "token_secret_ref": "tokenSecretRef",
    },
)
class SecretStoreSpecProviderVaultAuth:
    def __init__(
        self,
        *,
        app_role: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthAppRole", typing.Dict[builtins.str, typing.Any]]] = None,
        cert: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthCert", typing.Dict[builtins.str, typing.Any]]] = None,
        jwt: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthJwt", typing.Dict[builtins.str, typing.Any]]] = None,
        kubernetes: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthKubernetes", typing.Dict[builtins.str, typing.Any]]] = None,
        ldap: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthLdap", typing.Dict[builtins.str, typing.Any]]] = None,
        token_secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthTokenSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how secret-manager authenticates with the Vault server.

        :param app_role: AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
        :param cert: Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.
        :param jwt: Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.
        :param kubernetes: Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
        :param ldap: Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.
        :param token_secret_ref: TokenSecretRef authenticates with Vault by presenting a token.

        :schema: SecretStoreSpecProviderVaultAuth
        '''
        if isinstance(app_role, dict):
            app_role = SecretStoreSpecProviderVaultAuthAppRole(**app_role)
        if isinstance(cert, dict):
            cert = SecretStoreSpecProviderVaultAuthCert(**cert)
        if isinstance(jwt, dict):
            jwt = SecretStoreSpecProviderVaultAuthJwt(**jwt)
        if isinstance(kubernetes, dict):
            kubernetes = SecretStoreSpecProviderVaultAuthKubernetes(**kubernetes)
        if isinstance(ldap, dict):
            ldap = SecretStoreSpecProviderVaultAuthLdap(**ldap)
        if isinstance(token_secret_ref, dict):
            token_secret_ref = SecretStoreSpecProviderVaultAuthTokenSecretRef(**token_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a906da5a2a53f521d3aa7cb2ceff2f87f28a7ec0f7ac71cdcd6107bccdff2daa)
            check_type(argname="argument app_role", value=app_role, expected_type=type_hints["app_role"])
            check_type(argname="argument cert", value=cert, expected_type=type_hints["cert"])
            check_type(argname="argument jwt", value=jwt, expected_type=type_hints["jwt"])
            check_type(argname="argument kubernetes", value=kubernetes, expected_type=type_hints["kubernetes"])
            check_type(argname="argument ldap", value=ldap, expected_type=type_hints["ldap"])
            check_type(argname="argument token_secret_ref", value=token_secret_ref, expected_type=type_hints["token_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if app_role is not None:
            self._values["app_role"] = app_role
        if cert is not None:
            self._values["cert"] = cert
        if jwt is not None:
            self._values["jwt"] = jwt
        if kubernetes is not None:
            self._values["kubernetes"] = kubernetes
        if ldap is not None:
            self._values["ldap"] = ldap
        if token_secret_ref is not None:
            self._values["token_secret_ref"] = token_secret_ref

    @builtins.property
    def app_role(self) -> typing.Optional["SecretStoreSpecProviderVaultAuthAppRole"]:
        '''AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.

        :schema: SecretStoreSpecProviderVaultAuth#appRole
        '''
        result = self._values.get("app_role")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthAppRole"], result)

    @builtins.property
    def cert(self) -> typing.Optional["SecretStoreSpecProviderVaultAuthCert"]:
        '''Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.

        :schema: SecretStoreSpecProviderVaultAuth#cert
        '''
        result = self._values.get("cert")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthCert"], result)

    @builtins.property
    def jwt(self) -> typing.Optional["SecretStoreSpecProviderVaultAuthJwt"]:
        '''Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.

        :schema: SecretStoreSpecProviderVaultAuth#jwt
        '''
        result = self._values.get("jwt")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthJwt"], result)

    @builtins.property
    def kubernetes(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderVaultAuthKubernetes"]:
        '''Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.

        :schema: SecretStoreSpecProviderVaultAuth#kubernetes
        '''
        result = self._values.get("kubernetes")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthKubernetes"], result)

    @builtins.property
    def ldap(self) -> typing.Optional["SecretStoreSpecProviderVaultAuthLdap"]:
        '''Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.

        :schema: SecretStoreSpecProviderVaultAuth#ldap
        '''
        result = self._values.get("ldap")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthLdap"], result)

    @builtins.property
    def token_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderVaultAuthTokenSecretRef"]:
        '''TokenSecretRef authenticates with Vault by presenting a token.

        :schema: SecretStoreSpecProviderVaultAuth#tokenSecretRef
        '''
        result = self._values.get("token_secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthTokenSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthAppRole",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "role_id": "roleId", "secret_ref": "secretRef"},
)
class SecretStoreSpecProviderVaultAuthAppRole:
    def __init__(
        self,
        *,
        path: builtins.str,
        role_id: builtins.str,
        secret_ref: typing.Union["SecretStoreSpecProviderVaultAuthAppRoleSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.

        :param path: Path where the App Role authentication backend is mounted in Vault, e.g: "approle".
        :param role_id: RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.
        :param secret_ref: Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The ``key`` field must be specified and denotes which entry within the Secret resource is used as the app role secret.

        :schema: SecretStoreSpecProviderVaultAuthAppRole
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderVaultAuthAppRoleSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__91ec9daf30d4aa20417e9735e38cf1e7dc0f2bba40719ebfe97b72e5371bbd5b)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument role_id", value=role_id, expected_type=type_hints["role_id"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
            "role_id": role_id,
            "secret_ref": secret_ref,
        }

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the App Role authentication backend is mounted in Vault, e.g: "approle".

        :schema: SecretStoreSpecProviderVaultAuthAppRole#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role_id(self) -> builtins.str:
        '''RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.

        :schema: SecretStoreSpecProviderVaultAuthAppRole#roleId
        '''
        result = self._values.get("role_id")
        assert result is not None, "Required property 'role_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(self) -> "SecretStoreSpecProviderVaultAuthAppRoleSecretRef":
        '''Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret
        resource is used as the app role secret.

        :schema: SecretStoreSpecProviderVaultAuthAppRole#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreSpecProviderVaultAuthAppRoleSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthAppRole(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthAppRoleSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderVaultAuthAppRoleSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret
        resource is used as the app role secret.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthAppRoleSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3c921248240c9e8f809f8693886a7967a63ac9e70ce931585f66f97fd47efbc4)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderVaultAuthAppRoleSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderVaultAuthAppRoleSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthAppRoleSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthAppRoleSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthCert",
    jsii_struct_bases=[],
    name_mapping={"client_cert": "clientCert", "secret_ref": "secretRef"},
)
class SecretStoreSpecProviderVaultAuthCert:
    def __init__(
        self,
        *,
        client_cert: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthCertClientCert", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthCertSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.

        :param client_cert: ClientCert is a certificate to authenticate using the Cert Vault authentication method.
        :param secret_ref: SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :schema: SecretStoreSpecProviderVaultAuthCert
        '''
        if isinstance(client_cert, dict):
            client_cert = SecretStoreSpecProviderVaultAuthCertClientCert(**client_cert)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderVaultAuthCertSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__926989828203f27389b7a872e486f9f7c761453b969101d248844147a4d6af7e)
            check_type(argname="argument client_cert", value=client_cert, expected_type=type_hints["client_cert"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if client_cert is not None:
            self._values["client_cert"] = client_cert
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def client_cert(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderVaultAuthCertClientCert"]:
        '''ClientCert is a certificate to authenticate using the Cert Vault authentication method.

        :schema: SecretStoreSpecProviderVaultAuthCert#clientCert
        '''
        result = self._values.get("client_cert")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthCertClientCert"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderVaultAuthCertSecretRef"]:
        '''SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :schema: SecretStoreSpecProviderVaultAuthCert#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthCertSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthCertClientCert",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderVaultAuthCertClientCert:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ClientCert is a certificate to authenticate using the Cert Vault authentication method.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthCertClientCert
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de593eb1b62d872aa65a4baa74a37a4975d8e4386948886c952b85872f5397de)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderVaultAuthCertClientCert#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderVaultAuthCertClientCert#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthCertClientCert#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthCertClientCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderVaultAuthCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthCertSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8f69eeab4ca0ffa1bd204d31e5ed09f8168d70e5803d92d9f822a900f1b42155)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderVaultAuthCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderVaultAuthCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthJwt",
    jsii_struct_bases=[],
    name_mapping={
        "path": "path",
        "kubernetes_service_account_token": "kubernetesServiceAccountToken",
        "role": "role",
        "secret_ref": "secretRef",
    },
)
class SecretStoreSpecProviderVaultAuthJwt:
    def __init__(
        self,
        *,
        path: builtins.str,
        kubernetes_service_account_token: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken", typing.Dict[builtins.str, typing.Any]]] = None,
        role: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthJwtSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.

        :param path: Path where the JWT authentication backend is mounted in Vault, e.g: "jwt".
        :param kubernetes_service_account_token: Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.
        :param role: Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method.
        :param secret_ref: Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :schema: SecretStoreSpecProviderVaultAuthJwt
        '''
        if isinstance(kubernetes_service_account_token, dict):
            kubernetes_service_account_token = SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken(**kubernetes_service_account_token)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderVaultAuthJwtSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2641227e47ad754e8439010181c6cc78330135cee499741a0a3871027938bf40)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument kubernetes_service_account_token", value=kubernetes_service_account_token, expected_type=type_hints["kubernetes_service_account_token"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
        }
        if kubernetes_service_account_token is not None:
            self._values["kubernetes_service_account_token"] = kubernetes_service_account_token
        if role is not None:
            self._values["role"] = role
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the JWT authentication backend is mounted in Vault, e.g: "jwt".

        :schema: SecretStoreSpecProviderVaultAuthJwt#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def kubernetes_service_account_token(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken"]:
        '''Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :schema: SecretStoreSpecProviderVaultAuthJwt#kubernetesServiceAccountToken
        '''
        result = self._values.get("kubernetes_service_account_token")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken"], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method.

        :schema: SecretStoreSpecProviderVaultAuthJwt#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderVaultAuthJwtSecretRef"]:
        '''Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :schema: SecretStoreSpecProviderVaultAuthJwt#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthJwtSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthJwt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken",
    jsii_struct_bases=[],
    name_mapping={
        "service_account_ref": "serviceAccountRef",
        "audiences": "audiences",
        "expiration_seconds": "expirationSeconds",
    },
)
class SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken:
    def __init__(
        self,
        *,
        service_account_ref: typing.Union["SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef", typing.Dict[builtins.str, typing.Any]],
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        expiration_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :param service_account_ref: Service account field containing the name of a kubernetes ServiceAccount.
        :param audiences: Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``. Defaults to a single audience ``vault`` it not specified. Default: a single audience ``vault`` it not specified.
        :param expiration_seconds: Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``. Defaults to 10 minutes. Default: 10 minutes.

        :schema: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__746f956d1234f789608405b291bad7714e1859d2bf8667f7c8135f4799fd156b)
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument expiration_seconds", value=expiration_seconds, expected_type=type_hints["expiration_seconds"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "service_account_ref": service_account_ref,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if expiration_seconds is not None:
            self._values["expiration_seconds"] = expiration_seconds

    @builtins.property
    def service_account_ref(
        self,
    ) -> "SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef":
        '''Service account field containing the name of a kubernetes ServiceAccount.

        :schema: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        assert result is not None, "Required property 'service_account_ref' is missing"
        return typing.cast("SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef", result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``.

        Defaults to a single audience ``vault`` it not specified.

        :default: a single audience ``vault`` it not specified.

        :schema: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def expiration_seconds(self) -> typing.Optional[jsii.Number]:
        '''Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``.

        Defaults to 10 minutes.

        :default: 10 minutes.

        :schema: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#expirationSeconds
        '''
        result = self._values.get("expiration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Service account field containing the name of a kubernetes ServiceAccount.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe5149b96feef31ec30a430a00c72547d518e3e2b7d981a8647dc81c003207bd)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthJwtSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderVaultAuthJwtSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthJwtSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d4bd1e46d55696da0dd1d35870cc436c6ed2e3062fd0765d4f20fe3651d10c5)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderVaultAuthJwtSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderVaultAuthJwtSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthJwtSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthJwtSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthKubernetes",
    jsii_struct_bases=[],
    name_mapping={
        "mount_path": "mountPath",
        "role": "role",
        "secret_ref": "secretRef",
        "service_account_ref": "serviceAccountRef",
    },
)
class SecretStoreSpecProviderVaultAuthKubernetes:
    def __init__(
        self,
        *,
        mount_path: builtins.str,
        role: builtins.str,
        secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthKubernetesSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account_ref: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.

        :param mount_path: Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes".
        :param role: A required field containing the Vault Role to assume. A Role binds a Kubernetes ServiceAccount with a set of Vault policies.
        :param secret_ref: Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.
        :param service_account_ref: Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: SecretStoreSpecProviderVaultAuthKubernetes
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderVaultAuthKubernetesSecretRef(**secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ca939cc68749570d2ef4889f201ab3b3fd38c8f6dcd83bf12fe08aaab436b8fb)
            check_type(argname="argument mount_path", value=mount_path, expected_type=type_hints["mount_path"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "mount_path": mount_path,
            "role": role,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def mount_path(self) -> builtins.str:
        '''Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes".

        :schema: SecretStoreSpecProviderVaultAuthKubernetes#mountPath
        '''
        result = self._values.get("mount_path")
        assert result is not None, "Required property 'mount_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role(self) -> builtins.str:
        '''A required field containing the Vault Role to assume.

        A Role binds a
        Kubernetes ServiceAccount with a set of Vault policies.

        :schema: SecretStoreSpecProviderVaultAuthKubernetes#role
        '''
        result = self._values.get("role")
        assert result is not None, "Required property 'role' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderVaultAuthKubernetesSecretRef"]:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault.

        If a name is specified without a key,
        ``token`` is the default. If one is not specified, the one bound to
        the controller will be used.

        :schema: SecretStoreSpecProviderVaultAuthKubernetes#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthKubernetesSecretRef"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef"]:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used
        for authenticating with Vault. If the service account selector is not supplied,
        the secretRef will be used instead.

        :schema: SecretStoreSpecProviderVaultAuthKubernetes#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthKubernetes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthKubernetesSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderVaultAuthKubernetesSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault.

        If a name is specified without a key,
        ``token`` is the default. If one is not specified, the one bound to
        the controller will be used.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthKubernetesSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5576d3db2bcf7331d72c3646834111e13f1a9b0768bd6843887a4bfb2a37c2b7)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderVaultAuthKubernetesSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderVaultAuthKubernetesSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthKubernetesSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthKubernetesSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used
        for authenticating with Vault. If the service account selector is not supplied,
        the secretRef will be used instead.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1902bb9d0d46785a88bbf171a4e8d3512c9b72ff2e89a4e8d8cdaf67c675514c)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthLdap",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "username": "username", "secret_ref": "secretRef"},
)
class SecretStoreSpecProviderVaultAuthLdap:
    def __init__(
        self,
        *,
        path: builtins.str,
        username: builtins.str,
        secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthLdapSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.

        :param path: Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap".
        :param username: Username is a LDAP user name used to authenticate using the LDAP Vault authentication method.
        :param secret_ref: SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :schema: SecretStoreSpecProviderVaultAuthLdap
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderVaultAuthLdapSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__54daf7044cfb5a8fba7a5cc3a68df9e10b72c56cc5b8c6bb1588d528e2890dc1)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
            "username": username,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap".

        :schema: SecretStoreSpecProviderVaultAuthLdap#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def username(self) -> builtins.str:
        '''Username is a LDAP user name used to authenticate using the LDAP Vault authentication method.

        :schema: SecretStoreSpecProviderVaultAuthLdap#username
        '''
        result = self._values.get("username")
        assert result is not None, "Required property 'username' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderVaultAuthLdapSecretRef"]:
        '''SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :schema: SecretStoreSpecProviderVaultAuthLdap#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthLdapSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthLdap(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthLdapSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderVaultAuthLdapSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthLdapSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3781d82032a4838e8854e5d94439e01ad2c1ec8dbaf02e83334a9a1204deb736)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderVaultAuthLdapSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderVaultAuthLdapSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthLdapSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthLdapSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderVaultAuthTokenSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''TokenSecretRef authenticates with Vault by presenting a token.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7e96f47c442da148ae8f99573a79d554a4379a383748a113ceb3bd9974830296)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderVaultAuthTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderVaultAuthTokenSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthTokenSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class SecretStoreSpecProviderVaultCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "SecretStoreSpecProviderVaultCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Vault server certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in.

        :schema: SecretStoreSpecProviderVaultCaProvider
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a7694f04b7ccf70eddb5e62a956b1c20f67af5fdd544be8ab6f057460eaf8e64)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: SecretStoreSpecProviderVaultCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "SecretStoreSpecProviderVaultCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: SecretStoreSpecProviderVaultCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("SecretStoreSpecProviderVaultCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: SecretStoreSpecProviderVaultCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        :schema: SecretStoreSpecProviderVaultCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultCaProviderType")
class SecretStoreSpecProviderVaultCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: SecretStoreSpecProviderVaultCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.enum(jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultVersion")
class SecretStoreSpecProviderVaultVersion(enum.Enum):
    '''Version is the Vault KV secret engine version.

    This can be either "v1" or
    "v2". Version defaults to "v2".

    :schema: SecretStoreSpecProviderVaultVersion
    '''

    V1 = "V1"
    '''v1.'''
    V2 = "V2"
    '''v2.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderWebhook",
    jsii_struct_bases=[],
    name_mapping={
        "result": "result",
        "url": "url",
        "body": "body",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
        "headers": "headers",
        "method": "method",
        "secrets": "secrets",
        "timeout": "timeout",
    },
)
class SecretStoreSpecProviderWebhook:
    def __init__(
        self,
        *,
        result: typing.Union["SecretStoreSpecProviderWebhookResult", typing.Dict[builtins.str, typing.Any]],
        url: builtins.str,
        body: typing.Optional[builtins.str] = None,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreSpecProviderWebhookCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
        headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        method: typing.Optional[builtins.str] = None,
        secrets: typing.Optional[typing.Sequence[typing.Union["SecretStoreSpecProviderWebhookSecrets", typing.Dict[builtins.str, typing.Any]]]] = None,
        timeout: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Webhook configures this store to sync secrets using a generic templated webhook.

        :param result: Result formatting.
        :param url: Webhook url to call.
        :param body: Body.
        :param ca_bundle: PEM encoded CA bundle used to validate webhook server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
        :param ca_provider: The provider for the CA bundle to use to validate webhook server certificate.
        :param headers: Headers.
        :param method: Webhook Method.
        :param secrets: Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name.
        :param timeout: Timeout.

        :schema: SecretStoreSpecProviderWebhook
        '''
        if isinstance(result, dict):
            result = SecretStoreSpecProviderWebhookResult(**result)
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreSpecProviderWebhookCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d1fafecaff262b0c905232c30dcb29512b172ba2eadfc2e0fbd39779df81871c)
            check_type(argname="argument result", value=result, expected_type=type_hints["result"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
            check_type(argname="argument body", value=body, expected_type=type_hints["body"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument headers", value=headers, expected_type=type_hints["headers"])
            check_type(argname="argument method", value=method, expected_type=type_hints["method"])
            check_type(argname="argument secrets", value=secrets, expected_type=type_hints["secrets"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "result": result,
            "url": url,
        }
        if body is not None:
            self._values["body"] = body
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if headers is not None:
            self._values["headers"] = headers
        if method is not None:
            self._values["method"] = method
        if secrets is not None:
            self._values["secrets"] = secrets
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def result(self) -> "SecretStoreSpecProviderWebhookResult":
        '''Result formatting.

        :schema: SecretStoreSpecProviderWebhook#result
        '''
        result = self._values.get("result")
        assert result is not None, "Required property 'result' is missing"
        return typing.cast("SecretStoreSpecProviderWebhookResult", result)

    @builtins.property
    def url(self) -> builtins.str:
        '''Webhook url to call.

        :schema: SecretStoreSpecProviderWebhook#url
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def body(self) -> typing.Optional[builtins.str]:
        '''Body.

        :schema: SecretStoreSpecProviderWebhook#body
        '''
        result = self._values.get("body")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''PEM encoded CA bundle used to validate webhook server certificate.

        Only used
        if the Server URL is using HTTPS protocol. This parameter is ignored for
        plain HTTP protocol connection. If not set the system root certificates
        are used to validate the TLS connection.

        :schema: SecretStoreSpecProviderWebhook#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderWebhookCaProvider"]:
        '''The provider for the CA bundle to use to validate webhook server certificate.

        :schema: SecretStoreSpecProviderWebhook#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreSpecProviderWebhookCaProvider"], result)

    @builtins.property
    def headers(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Headers.

        :schema: SecretStoreSpecProviderWebhook#headers
        '''
        result = self._values.get("headers")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def method(self) -> typing.Optional[builtins.str]:
        '''Webhook Method.

        :schema: SecretStoreSpecProviderWebhook#method
        '''
        result = self._values.get("method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secrets(
        self,
    ) -> typing.Optional[typing.List["SecretStoreSpecProviderWebhookSecrets"]]:
        '''Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name.

        :schema: SecretStoreSpecProviderWebhook#secrets
        '''
        result = self._values.get("secrets")
        return typing.cast(typing.Optional[typing.List["SecretStoreSpecProviderWebhookSecrets"]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[builtins.str]:
        '''Timeout.

        :schema: SecretStoreSpecProviderWebhook#timeout
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderWebhook(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderWebhookCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class SecretStoreSpecProviderWebhookCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "SecretStoreSpecProviderWebhookCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate webhook server certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in.

        :schema: SecretStoreSpecProviderWebhookCaProvider
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f39587f1eb17b18ee2e637058f85bf78cfe6380cb981390c8095b0f017c4e18e)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: SecretStoreSpecProviderWebhookCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "SecretStoreSpecProviderWebhookCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: SecretStoreSpecProviderWebhookCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("SecretStoreSpecProviderWebhookCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: SecretStoreSpecProviderWebhookCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        :schema: SecretStoreSpecProviderWebhookCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderWebhookCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.SecretStoreSpecProviderWebhookCaProviderType")
class SecretStoreSpecProviderWebhookCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: SecretStoreSpecProviderWebhookCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderWebhookResult",
    jsii_struct_bases=[],
    name_mapping={"json_path": "jsonPath"},
)
class SecretStoreSpecProviderWebhookResult:
    def __init__(self, *, json_path: typing.Optional[builtins.str] = None) -> None:
        '''Result formatting.

        :param json_path: Json path of return value.

        :schema: SecretStoreSpecProviderWebhookResult
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cafbe3e08c7de16cc8da33377789a932dd134a8b6b6e0f97dd20f9ad9855b525)
            check_type(argname="argument json_path", value=json_path, expected_type=type_hints["json_path"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if json_path is not None:
            self._values["json_path"] = json_path

    @builtins.property
    def json_path(self) -> typing.Optional[builtins.str]:
        '''Json path of return value.

        :schema: SecretStoreSpecProviderWebhookResult#jsonPath
        '''
        result = self._values.get("json_path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderWebhookResult(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderWebhookSecrets",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "secret_ref": "secretRef"},
)
class SecretStoreSpecProviderWebhookSecrets:
    def __init__(
        self,
        *,
        name: builtins.str,
        secret_ref: typing.Union["SecretStoreSpecProviderWebhookSecretsSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param name: Name of this secret in templates.
        :param secret_ref: Secret ref to fill in credentials.

        :schema: SecretStoreSpecProviderWebhookSecrets
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderWebhookSecretsSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e93ce843f65bae96c79261461e439cfe309d889743e564fb465715ac0c23a02)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "secret_ref": secret_ref,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of this secret in templates.

        :schema: SecretStoreSpecProviderWebhookSecrets#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(self) -> "SecretStoreSpecProviderWebhookSecretsSecretRef":
        '''Secret ref to fill in credentials.

        :schema: SecretStoreSpecProviderWebhookSecrets#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreSpecProviderWebhookSecretsSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderWebhookSecrets(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderWebhookSecretsSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderWebhookSecretsSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Secret ref to fill in credentials.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderWebhookSecretsSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea63366696c859af5d2a5362752db30665aea1a23df692b606dd25c3c877c26f)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderWebhookSecretsSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderWebhookSecretsSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderWebhookSecretsSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderWebhookSecretsSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderYandexlockbox",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "api_endpoint": "apiEndpoint",
        "ca_provider": "caProvider",
    },
)
class SecretStoreSpecProviderYandexlockbox:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreSpecProviderYandexlockboxAuth", typing.Dict[builtins.str, typing.Any]],
        api_endpoint: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreSpecProviderYandexlockboxCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :param auth: Auth defines the information necessary to authenticate against Yandex Lockbox.
        :param api_endpoint: Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').
        :param ca_provider: The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: SecretStoreSpecProviderYandexlockbox
        '''
        if isinstance(auth, dict):
            auth = SecretStoreSpecProviderYandexlockboxAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreSpecProviderYandexlockboxCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__96053fb82850a86b14c63904db9ada416f60bfc3669c2d8475be1a94daf8b13d)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument api_endpoint", value=api_endpoint, expected_type=type_hints["api_endpoint"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
        }
        if api_endpoint is not None:
            self._values["api_endpoint"] = api_endpoint
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider

    @builtins.property
    def auth(self) -> "SecretStoreSpecProviderYandexlockboxAuth":
        '''Auth defines the information necessary to authenticate against Yandex Lockbox.

        :schema: SecretStoreSpecProviderYandexlockbox#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreSpecProviderYandexlockboxAuth", result)

    @builtins.property
    def api_endpoint(self) -> typing.Optional[builtins.str]:
        '''Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').

        :schema: SecretStoreSpecProviderYandexlockbox#apiEndpoint
        '''
        result = self._values.get("api_endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderYandexlockboxCaProvider"]:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: SecretStoreSpecProviderYandexlockbox#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreSpecProviderYandexlockboxCaProvider"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderYandexlockbox(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderYandexlockboxAuth",
    jsii_struct_bases=[],
    name_mapping={"authorized_key_secret_ref": "authorizedKeySecretRef"},
)
class SecretStoreSpecProviderYandexlockboxAuth:
    def __init__(
        self,
        *,
        authorized_key_secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against Yandex Lockbox.

        :param authorized_key_secret_ref: The authorized key used for authentication.

        :schema: SecretStoreSpecProviderYandexlockboxAuth
        '''
        if isinstance(authorized_key_secret_ref, dict):
            authorized_key_secret_ref = SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef(**authorized_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__63938f9991ccca07eaa1b529f96cc1fd913594543c10333f42261d9982731728)
            check_type(argname="argument authorized_key_secret_ref", value=authorized_key_secret_ref, expected_type=type_hints["authorized_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if authorized_key_secret_ref is not None:
            self._values["authorized_key_secret_ref"] = authorized_key_secret_ref

    @builtins.property
    def authorized_key_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef"]:
        '''The authorized key used for authentication.

        :schema: SecretStoreSpecProviderYandexlockboxAuth#authorizedKeySecretRef
        '''
        result = self._values.get("authorized_key_secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderYandexlockboxAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The authorized key used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a751dc60535eb863895eb7c23eb9dcea4fb168088a67affab4456e33bfde401c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderYandexlockboxCaProvider",
    jsii_struct_bases=[],
    name_mapping={"cert_secret_ref": "certSecretRef"},
)
class SecretStoreSpecProviderYandexlockboxCaProvider:
    def __init__(
        self,
        *,
        cert_secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :param cert_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: SecretStoreSpecProviderYandexlockboxCaProvider
        '''
        if isinstance(cert_secret_ref, dict):
            cert_secret_ref = SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef(**cert_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d9055787165578835dde87a2c4abe39336ef0799f4ac41721d94cbc23f3325e)
            check_type(argname="argument cert_secret_ref", value=cert_secret_ref, expected_type=type_hints["cert_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cert_secret_ref is not None:
            self._values["cert_secret_ref"] = cert_secret_ref

    @builtins.property
    def cert_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreSpecProviderYandexlockboxCaProvider#certSecretRef
        '''
        result = self._values.get("cert_secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderYandexlockboxCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__27b77f15061632174e6c2312f622d30ab57aa2a455aca37f308b86a7d9850d4e)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecRetrySettings",
    jsii_struct_bases=[],
    name_mapping={"max_retries": "maxRetries", "retry_interval": "retryInterval"},
)
class SecretStoreSpecRetrySettings:
    def __init__(
        self,
        *,
        max_retries: typing.Optional[jsii.Number] = None,
        retry_interval: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Used to configure http retries if failed.

        :param max_retries: 
        :param retry_interval: 

        :schema: SecretStoreSpecRetrySettings
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab1b2959f3a84685392b7376862f54f9c2af1a3c8607a0325c24aa2e5739ede8)
            check_type(argname="argument max_retries", value=max_retries, expected_type=type_hints["max_retries"])
            check_type(argname="argument retry_interval", value=retry_interval, expected_type=type_hints["retry_interval"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if max_retries is not None:
            self._values["max_retries"] = max_retries
        if retry_interval is not None:
            self._values["retry_interval"] = retry_interval

    @builtins.property
    def max_retries(self) -> typing.Optional[jsii.Number]:
        '''
        :schema: SecretStoreSpecRetrySettings#maxRetries
        '''
        result = self._values.get("max_retries")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def retry_interval(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreSpecRetrySettings#retryInterval
        '''
        result = self._values.get("retry_interval")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecRetrySettings(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SecretStoreV1Beta1(
    _cdk8s_d3d9af27.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1",
):
    '''SecretStore represents a secure external location for storing secrets, which can be referenced as part of ``storeRef`` fields.

    :schema: SecretStoreV1Beta1
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["SecretStoreV1Beta1Spec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Defines a "SecretStoreV1Beta1" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7f3552b2035d2dc266ffbe6203fea53942c8094aacfba3f6974b214efef55f98)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SecretStoreV1Beta1Props(metadata=metadata, spec=spec)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest")
    @builtins.classmethod
    def manifest(
        cls,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["SecretStoreV1Beta1Spec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> typing.Any:
        '''Renders a Kubernetes manifest for "SecretStoreV1Beta1".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.
        '''
        props = SecretStoreV1Beta1Props(metadata=metadata, spec=spec)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''Renders the object to Kubernetes JSON.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> _cdk8s_d3d9af27.GroupVersionKind:
        '''Returns the apiVersion and kind for "SecretStoreV1Beta1".'''
        return typing.cast(_cdk8s_d3d9af27.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1Props",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class SecretStoreV1Beta1Props:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["SecretStoreV1Beta1Spec", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''SecretStore represents a secure external location for storing secrets, which can be referenced as part of ``storeRef`` fields.

        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.

        :schema: SecretStoreV1Beta1
        '''
        if isinstance(metadata, dict):
            metadata = _cdk8s_d3d9af27.ApiObjectMetadata(**metadata)
        if isinstance(spec, dict):
            spec = SecretStoreV1Beta1Spec(**spec)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dfa8dbd2d0c2a721eab5f6a87539e2f56289de2b823686d13df4bbaf39467296)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(self) -> typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata]:
        '''
        :schema: SecretStoreV1Beta1#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[_cdk8s_d3d9af27.ApiObjectMetadata], result)

    @builtins.property
    def spec(self) -> typing.Optional["SecretStoreV1Beta1Spec"]:
        '''SecretStoreSpec defines the desired state of SecretStore.

        :schema: SecretStoreV1Beta1#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["SecretStoreV1Beta1Spec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1Props(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1Spec",
    jsii_struct_bases=[],
    name_mapping={
        "provider": "provider",
        "conditions": "conditions",
        "controller": "controller",
        "refresh_interval": "refreshInterval",
        "retry_settings": "retrySettings",
    },
)
class SecretStoreV1Beta1Spec:
    def __init__(
        self,
        *,
        provider: typing.Union["SecretStoreV1Beta1SpecProvider", typing.Dict[builtins.str, typing.Any]],
        conditions: typing.Optional[typing.Sequence[typing.Union["SecretStoreV1Beta1SpecConditions", typing.Dict[builtins.str, typing.Any]]]] = None,
        controller: typing.Optional[builtins.str] = None,
        refresh_interval: typing.Optional[jsii.Number] = None,
        retry_settings: typing.Optional[typing.Union["SecretStoreV1Beta1SpecRetrySettings", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''SecretStoreSpec defines the desired state of SecretStore.

        :param provider: Used to configure the provider. Only one provider may be set
        :param conditions: Used to constraint a ClusterSecretStore to specific namespaces. Relevant only to ClusterSecretStore
        :param controller: Used to select the correct ESO controller (think: ingress.ingressClassName) The ESO controller is instantiated with a specific controller name and filters ES based on this property.
        :param refresh_interval: Used to configure store refresh interval in seconds. Empty or 0 will default to the controller config.
        :param retry_settings: Used to configure http retries if failed.

        :schema: SecretStoreV1Beta1Spec
        '''
        if isinstance(provider, dict):
            provider = SecretStoreV1Beta1SpecProvider(**provider)
        if isinstance(retry_settings, dict):
            retry_settings = SecretStoreV1Beta1SpecRetrySettings(**retry_settings)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e887ced4c6bd3b61a242644b3eeab6a61e1a3f1981cea3e885f9d1548225d729)
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument conditions", value=conditions, expected_type=type_hints["conditions"])
            check_type(argname="argument controller", value=controller, expected_type=type_hints["controller"])
            check_type(argname="argument refresh_interval", value=refresh_interval, expected_type=type_hints["refresh_interval"])
            check_type(argname="argument retry_settings", value=retry_settings, expected_type=type_hints["retry_settings"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "provider": provider,
        }
        if conditions is not None:
            self._values["conditions"] = conditions
        if controller is not None:
            self._values["controller"] = controller
        if refresh_interval is not None:
            self._values["refresh_interval"] = refresh_interval
        if retry_settings is not None:
            self._values["retry_settings"] = retry_settings

    @builtins.property
    def provider(self) -> "SecretStoreV1Beta1SpecProvider":
        '''Used to configure the provider.

        Only one provider may be set

        :schema: SecretStoreV1Beta1Spec#provider
        '''
        result = self._values.get("provider")
        assert result is not None, "Required property 'provider' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProvider", result)

    @builtins.property
    def conditions(
        self,
    ) -> typing.Optional[typing.List["SecretStoreV1Beta1SpecConditions"]]:
        '''Used to constraint a ClusterSecretStore to specific namespaces.

        Relevant only to ClusterSecretStore

        :schema: SecretStoreV1Beta1Spec#conditions
        '''
        result = self._values.get("conditions")
        return typing.cast(typing.Optional[typing.List["SecretStoreV1Beta1SpecConditions"]], result)

    @builtins.property
    def controller(self) -> typing.Optional[builtins.str]:
        '''Used to select the correct ESO controller (think: ingress.ingressClassName) The ESO controller is instantiated with a specific controller name and filters ES based on this property.

        :schema: SecretStoreV1Beta1Spec#controller
        '''
        result = self._values.get("controller")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def refresh_interval(self) -> typing.Optional[jsii.Number]:
        '''Used to configure store refresh interval in seconds.

        Empty or 0 will default to the controller config.

        :schema: SecretStoreV1Beta1Spec#refreshInterval
        '''
        result = self._values.get("refresh_interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def retry_settings(self) -> typing.Optional["SecretStoreV1Beta1SpecRetrySettings"]:
        '''Used to configure http retries if failed.

        :schema: SecretStoreV1Beta1Spec#retrySettings
        '''
        result = self._values.get("retry_settings")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecRetrySettings"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1Spec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecConditions",
    jsii_struct_bases=[],
    name_mapping={
        "namespace_regexes": "namespaceRegexes",
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
    },
)
class SecretStoreV1Beta1SpecConditions:
    def __init__(
        self,
        *,
        namespace_regexes: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["SecretStoreV1Beta1SpecConditionsNamespaceSelector", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''ClusterSecretStoreCondition describes a condition by which to choose namespaces to process ExternalSecrets in for a ClusterSecretStore instance.

        :param namespace_regexes: Choose namespaces by using regex matching.
        :param namespaces: Choose namespaces by name.
        :param namespace_selector: Choose namespace using a labelSelector.

        :schema: SecretStoreV1Beta1SpecConditions
        '''
        if isinstance(namespace_selector, dict):
            namespace_selector = SecretStoreV1Beta1SpecConditionsNamespaceSelector(**namespace_selector)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__781f0a3fce525ee313d188cf41c0cb440a85aa5de7791f933d055b4023d7ff2e)
            check_type(argname="argument namespace_regexes", value=namespace_regexes, expected_type=type_hints["namespace_regexes"])
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if namespace_regexes is not None:
            self._values["namespace_regexes"] = namespace_regexes
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector

    @builtins.property
    def namespace_regexes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Choose namespaces by using regex matching.

        :schema: SecretStoreV1Beta1SpecConditions#namespaceRegexes
        '''
        result = self._values.get("namespace_regexes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Choose namespaces by name.

        :schema: SecretStoreV1Beta1SpecConditions#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecConditionsNamespaceSelector"]:
        '''Choose namespace using a labelSelector.

        :schema: SecretStoreV1Beta1SpecConditions#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecConditionsNamespaceSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecConditions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecConditionsNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class SecretStoreV1Beta1SpecConditionsNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions", typing.Dict[builtins.str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Choose namespace using a labelSelector.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: SecretStoreV1Beta1SpecConditionsNamespaceSelector
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2044c5fddb5d84a07100f5e6505b6d7c7423848a6be1069e04b243a1af9d8134)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: SecretStoreV1Beta1SpecConditionsNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels
        map is equivalent to an element of matchExpressions, whose key field is "key", the
        operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: SecretStoreV1Beta1SpecConditionsNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecConditionsNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__39b5ca4819b9b954dfdfd05453fcef64f9e52a3792efaa16ae3fa7fb24d8740a)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn,
        the values array must be non-empty. If the operator is Exists or DoesNotExist,
        the values array must be empty. This array is replaced during a strategic
        merge patch.

        :schema: SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProvider",
    jsii_struct_bases=[],
    name_mapping={
        "akeyless": "akeyless",
        "alibaba": "alibaba",
        "aws": "aws",
        "azurekv": "azurekv",
        "beyondtrust": "beyondtrust",
        "bitwardensecretsmanager": "bitwardensecretsmanager",
        "chef": "chef",
        "conjur": "conjur",
        "delinea": "delinea",
        "device42": "device42",
        "doppler": "doppler",
        "fake": "fake",
        "fortanix": "fortanix",
        "gcpsm": "gcpsm",
        "gitlab": "gitlab",
        "ibm": "ibm",
        "infisical": "infisical",
        "keepersecurity": "keepersecurity",
        "kubernetes": "kubernetes",
        "onboardbase": "onboardbase",
        "onepassword": "onepassword",
        "oracle": "oracle",
        "passbolt": "passbolt",
        "passworddepot": "passworddepot",
        "previder": "previder",
        "pulumi": "pulumi",
        "scaleway": "scaleway",
        "secretserver": "secretserver",
        "senhasegura": "senhasegura",
        "vault": "vault",
        "webhook": "webhook",
        "yandexcertificatemanager": "yandexcertificatemanager",
        "yandexlockbox": "yandexlockbox",
    },
)
class SecretStoreV1Beta1SpecProvider:
    def __init__(
        self,
        *,
        akeyless: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAkeyless", typing.Dict[builtins.str, typing.Any]]] = None,
        alibaba: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAlibaba", typing.Dict[builtins.str, typing.Any]]] = None,
        aws: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAws", typing.Dict[builtins.str, typing.Any]]] = None,
        azurekv: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAzurekv", typing.Dict[builtins.str, typing.Any]]] = None,
        beyondtrust: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderBeyondtrust", typing.Dict[builtins.str, typing.Any]]] = None,
        bitwardensecretsmanager: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderBitwardensecretsmanager", typing.Dict[builtins.str, typing.Any]]] = None,
        chef: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderChef", typing.Dict[builtins.str, typing.Any]]] = None,
        conjur: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderConjur", typing.Dict[builtins.str, typing.Any]]] = None,
        delinea: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderDelinea", typing.Dict[builtins.str, typing.Any]]] = None,
        device42: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderDevice42", typing.Dict[builtins.str, typing.Any]]] = None,
        doppler: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderDoppler", typing.Dict[builtins.str, typing.Any]]] = None,
        fake: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderFake", typing.Dict[builtins.str, typing.Any]]] = None,
        fortanix: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderFortanix", typing.Dict[builtins.str, typing.Any]]] = None,
        gcpsm: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderGcpsm", typing.Dict[builtins.str, typing.Any]]] = None,
        gitlab: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderGitlab", typing.Dict[builtins.str, typing.Any]]] = None,
        ibm: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderIbm", typing.Dict[builtins.str, typing.Any]]] = None,
        infisical: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderInfisical", typing.Dict[builtins.str, typing.Any]]] = None,
        keepersecurity: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKeepersecurity", typing.Dict[builtins.str, typing.Any]]] = None,
        kubernetes: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKubernetes", typing.Dict[builtins.str, typing.Any]]] = None,
        onboardbase: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderOnboardbase", typing.Dict[builtins.str, typing.Any]]] = None,
        onepassword: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderOnepassword", typing.Dict[builtins.str, typing.Any]]] = None,
        oracle: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderOracle", typing.Dict[builtins.str, typing.Any]]] = None,
        passbolt: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderPassbolt", typing.Dict[builtins.str, typing.Any]]] = None,
        passworddepot: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderPassworddepot", typing.Dict[builtins.str, typing.Any]]] = None,
        previder: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderPrevider", typing.Dict[builtins.str, typing.Any]]] = None,
        pulumi: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderPulumi", typing.Dict[builtins.str, typing.Any]]] = None,
        scaleway: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderScaleway", typing.Dict[builtins.str, typing.Any]]] = None,
        secretserver: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderSecretserver", typing.Dict[builtins.str, typing.Any]]] = None,
        senhasegura: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderSenhasegura", typing.Dict[builtins.str, typing.Any]]] = None,
        vault: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVault", typing.Dict[builtins.str, typing.Any]]] = None,
        webhook: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderWebhook", typing.Dict[builtins.str, typing.Any]]] = None,
        yandexcertificatemanager: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderYandexcertificatemanager", typing.Dict[builtins.str, typing.Any]]] = None,
        yandexlockbox: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderYandexlockbox", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Used to configure the provider.

        Only one provider may be set

        :param akeyless: Akeyless configures this store to sync secrets using Akeyless Vault provider.
        :param alibaba: Alibaba configures this store to sync secrets using Alibaba Cloud provider.
        :param aws: AWS configures this store to sync secrets using AWS Secret Manager provider.
        :param azurekv: AzureKV configures this store to sync secrets using Azure Key Vault provider.
        :param beyondtrust: Beyondtrust configures this store to sync secrets using Password Safe provider.
        :param bitwardensecretsmanager: BitwardenSecretsManager configures this store to sync secrets using BitwardenSecretsManager provider.
        :param chef: Chef configures this store to sync secrets with chef server.
        :param conjur: Conjur configures this store to sync secrets using conjur provider.
        :param delinea: Delinea DevOps Secrets Vault https://docs.delinea.com/online-help/products/devops-secrets-vault/current.
        :param device42: Device42 configures this store to sync secrets using the Device42 provider.
        :param doppler: Doppler configures this store to sync secrets using the Doppler provider.
        :param fake: Fake configures a store with static key/value pairs.
        :param fortanix: Fortanix configures this store to sync secrets using the Fortanix provider.
        :param gcpsm: GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.
        :param gitlab: GitLab configures this store to sync secrets using GitLab Variables provider.
        :param ibm: IBM configures this store to sync secrets using IBM Cloud provider.
        :param infisical: Infisical configures this store to sync secrets using the Infisical provider.
        :param keepersecurity: KeeperSecurity configures this store to sync secrets using the KeeperSecurity provider.
        :param kubernetes: Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.
        :param onboardbase: Onboardbase configures this store to sync secrets using the Onboardbase provider.
        :param onepassword: OnePassword configures this store to sync secrets using the 1Password Cloud provider.
        :param oracle: Oracle configures this store to sync secrets using Oracle Vault provider.
        :param passbolt: 
        :param passworddepot: Configures a store to sync secrets with a Password Depot instance.
        :param previder: Previder configures this store to sync secrets using the Previder provider.
        :param pulumi: Pulumi configures this store to sync secrets using the Pulumi provider.
        :param scaleway: Scaleway.
        :param secretserver: SecretServer configures this store to sync secrets using SecretServer provider https://docs.delinea.com/online-help/secret-server/start.htm.
        :param senhasegura: Senhasegura configures this store to sync secrets using senhasegura provider.
        :param vault: Vault configures this store to sync secrets using Hashi provider.
        :param webhook: Webhook configures this store to sync secrets using a generic templated webhook.
        :param yandexcertificatemanager: YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider.
        :param yandexlockbox: YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :schema: SecretStoreV1Beta1SpecProvider
        '''
        if isinstance(akeyless, dict):
            akeyless = SecretStoreV1Beta1SpecProviderAkeyless(**akeyless)
        if isinstance(alibaba, dict):
            alibaba = SecretStoreV1Beta1SpecProviderAlibaba(**alibaba)
        if isinstance(aws, dict):
            aws = SecretStoreV1Beta1SpecProviderAws(**aws)
        if isinstance(azurekv, dict):
            azurekv = SecretStoreV1Beta1SpecProviderAzurekv(**azurekv)
        if isinstance(beyondtrust, dict):
            beyondtrust = SecretStoreV1Beta1SpecProviderBeyondtrust(**beyondtrust)
        if isinstance(bitwardensecretsmanager, dict):
            bitwardensecretsmanager = SecretStoreV1Beta1SpecProviderBitwardensecretsmanager(**bitwardensecretsmanager)
        if isinstance(chef, dict):
            chef = SecretStoreV1Beta1SpecProviderChef(**chef)
        if isinstance(conjur, dict):
            conjur = SecretStoreV1Beta1SpecProviderConjur(**conjur)
        if isinstance(delinea, dict):
            delinea = SecretStoreV1Beta1SpecProviderDelinea(**delinea)
        if isinstance(device42, dict):
            device42 = SecretStoreV1Beta1SpecProviderDevice42(**device42)
        if isinstance(doppler, dict):
            doppler = SecretStoreV1Beta1SpecProviderDoppler(**doppler)
        if isinstance(fake, dict):
            fake = SecretStoreV1Beta1SpecProviderFake(**fake)
        if isinstance(fortanix, dict):
            fortanix = SecretStoreV1Beta1SpecProviderFortanix(**fortanix)
        if isinstance(gcpsm, dict):
            gcpsm = SecretStoreV1Beta1SpecProviderGcpsm(**gcpsm)
        if isinstance(gitlab, dict):
            gitlab = SecretStoreV1Beta1SpecProviderGitlab(**gitlab)
        if isinstance(ibm, dict):
            ibm = SecretStoreV1Beta1SpecProviderIbm(**ibm)
        if isinstance(infisical, dict):
            infisical = SecretStoreV1Beta1SpecProviderInfisical(**infisical)
        if isinstance(keepersecurity, dict):
            keepersecurity = SecretStoreV1Beta1SpecProviderKeepersecurity(**keepersecurity)
        if isinstance(kubernetes, dict):
            kubernetes = SecretStoreV1Beta1SpecProviderKubernetes(**kubernetes)
        if isinstance(onboardbase, dict):
            onboardbase = SecretStoreV1Beta1SpecProviderOnboardbase(**onboardbase)
        if isinstance(onepassword, dict):
            onepassword = SecretStoreV1Beta1SpecProviderOnepassword(**onepassword)
        if isinstance(oracle, dict):
            oracle = SecretStoreV1Beta1SpecProviderOracle(**oracle)
        if isinstance(passbolt, dict):
            passbolt = SecretStoreV1Beta1SpecProviderPassbolt(**passbolt)
        if isinstance(passworddepot, dict):
            passworddepot = SecretStoreV1Beta1SpecProviderPassworddepot(**passworddepot)
        if isinstance(previder, dict):
            previder = SecretStoreV1Beta1SpecProviderPrevider(**previder)
        if isinstance(pulumi, dict):
            pulumi = SecretStoreV1Beta1SpecProviderPulumi(**pulumi)
        if isinstance(scaleway, dict):
            scaleway = SecretStoreV1Beta1SpecProviderScaleway(**scaleway)
        if isinstance(secretserver, dict):
            secretserver = SecretStoreV1Beta1SpecProviderSecretserver(**secretserver)
        if isinstance(senhasegura, dict):
            senhasegura = SecretStoreV1Beta1SpecProviderSenhasegura(**senhasegura)
        if isinstance(vault, dict):
            vault = SecretStoreV1Beta1SpecProviderVault(**vault)
        if isinstance(webhook, dict):
            webhook = SecretStoreV1Beta1SpecProviderWebhook(**webhook)
        if isinstance(yandexcertificatemanager, dict):
            yandexcertificatemanager = SecretStoreV1Beta1SpecProviderYandexcertificatemanager(**yandexcertificatemanager)
        if isinstance(yandexlockbox, dict):
            yandexlockbox = SecretStoreV1Beta1SpecProviderYandexlockbox(**yandexlockbox)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea7dd9e387afcb814f7b73b94bda5cdd7dfdba58759fb42c1d35129125adb364)
            check_type(argname="argument akeyless", value=akeyless, expected_type=type_hints["akeyless"])
            check_type(argname="argument alibaba", value=alibaba, expected_type=type_hints["alibaba"])
            check_type(argname="argument aws", value=aws, expected_type=type_hints["aws"])
            check_type(argname="argument azurekv", value=azurekv, expected_type=type_hints["azurekv"])
            check_type(argname="argument beyondtrust", value=beyondtrust, expected_type=type_hints["beyondtrust"])
            check_type(argname="argument bitwardensecretsmanager", value=bitwardensecretsmanager, expected_type=type_hints["bitwardensecretsmanager"])
            check_type(argname="argument chef", value=chef, expected_type=type_hints["chef"])
            check_type(argname="argument conjur", value=conjur, expected_type=type_hints["conjur"])
            check_type(argname="argument delinea", value=delinea, expected_type=type_hints["delinea"])
            check_type(argname="argument device42", value=device42, expected_type=type_hints["device42"])
            check_type(argname="argument doppler", value=doppler, expected_type=type_hints["doppler"])
            check_type(argname="argument fake", value=fake, expected_type=type_hints["fake"])
            check_type(argname="argument fortanix", value=fortanix, expected_type=type_hints["fortanix"])
            check_type(argname="argument gcpsm", value=gcpsm, expected_type=type_hints["gcpsm"])
            check_type(argname="argument gitlab", value=gitlab, expected_type=type_hints["gitlab"])
            check_type(argname="argument ibm", value=ibm, expected_type=type_hints["ibm"])
            check_type(argname="argument infisical", value=infisical, expected_type=type_hints["infisical"])
            check_type(argname="argument keepersecurity", value=keepersecurity, expected_type=type_hints["keepersecurity"])
            check_type(argname="argument kubernetes", value=kubernetes, expected_type=type_hints["kubernetes"])
            check_type(argname="argument onboardbase", value=onboardbase, expected_type=type_hints["onboardbase"])
            check_type(argname="argument onepassword", value=onepassword, expected_type=type_hints["onepassword"])
            check_type(argname="argument oracle", value=oracle, expected_type=type_hints["oracle"])
            check_type(argname="argument passbolt", value=passbolt, expected_type=type_hints["passbolt"])
            check_type(argname="argument passworddepot", value=passworddepot, expected_type=type_hints["passworddepot"])
            check_type(argname="argument previder", value=previder, expected_type=type_hints["previder"])
            check_type(argname="argument pulumi", value=pulumi, expected_type=type_hints["pulumi"])
            check_type(argname="argument scaleway", value=scaleway, expected_type=type_hints["scaleway"])
            check_type(argname="argument secretserver", value=secretserver, expected_type=type_hints["secretserver"])
            check_type(argname="argument senhasegura", value=senhasegura, expected_type=type_hints["senhasegura"])
            check_type(argname="argument vault", value=vault, expected_type=type_hints["vault"])
            check_type(argname="argument webhook", value=webhook, expected_type=type_hints["webhook"])
            check_type(argname="argument yandexcertificatemanager", value=yandexcertificatemanager, expected_type=type_hints["yandexcertificatemanager"])
            check_type(argname="argument yandexlockbox", value=yandexlockbox, expected_type=type_hints["yandexlockbox"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if akeyless is not None:
            self._values["akeyless"] = akeyless
        if alibaba is not None:
            self._values["alibaba"] = alibaba
        if aws is not None:
            self._values["aws"] = aws
        if azurekv is not None:
            self._values["azurekv"] = azurekv
        if beyondtrust is not None:
            self._values["beyondtrust"] = beyondtrust
        if bitwardensecretsmanager is not None:
            self._values["bitwardensecretsmanager"] = bitwardensecretsmanager
        if chef is not None:
            self._values["chef"] = chef
        if conjur is not None:
            self._values["conjur"] = conjur
        if delinea is not None:
            self._values["delinea"] = delinea
        if device42 is not None:
            self._values["device42"] = device42
        if doppler is not None:
            self._values["doppler"] = doppler
        if fake is not None:
            self._values["fake"] = fake
        if fortanix is not None:
            self._values["fortanix"] = fortanix
        if gcpsm is not None:
            self._values["gcpsm"] = gcpsm
        if gitlab is not None:
            self._values["gitlab"] = gitlab
        if ibm is not None:
            self._values["ibm"] = ibm
        if infisical is not None:
            self._values["infisical"] = infisical
        if keepersecurity is not None:
            self._values["keepersecurity"] = keepersecurity
        if kubernetes is not None:
            self._values["kubernetes"] = kubernetes
        if onboardbase is not None:
            self._values["onboardbase"] = onboardbase
        if onepassword is not None:
            self._values["onepassword"] = onepassword
        if oracle is not None:
            self._values["oracle"] = oracle
        if passbolt is not None:
            self._values["passbolt"] = passbolt
        if passworddepot is not None:
            self._values["passworddepot"] = passworddepot
        if previder is not None:
            self._values["previder"] = previder
        if pulumi is not None:
            self._values["pulumi"] = pulumi
        if scaleway is not None:
            self._values["scaleway"] = scaleway
        if secretserver is not None:
            self._values["secretserver"] = secretserver
        if senhasegura is not None:
            self._values["senhasegura"] = senhasegura
        if vault is not None:
            self._values["vault"] = vault
        if webhook is not None:
            self._values["webhook"] = webhook
        if yandexcertificatemanager is not None:
            self._values["yandexcertificatemanager"] = yandexcertificatemanager
        if yandexlockbox is not None:
            self._values["yandexlockbox"] = yandexlockbox

    @builtins.property
    def akeyless(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderAkeyless"]:
        '''Akeyless configures this store to sync secrets using Akeyless Vault provider.

        :schema: SecretStoreV1Beta1SpecProvider#akeyless
        '''
        result = self._values.get("akeyless")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAkeyless"], result)

    @builtins.property
    def alibaba(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderAlibaba"]:
        '''Alibaba configures this store to sync secrets using Alibaba Cloud provider.

        :schema: SecretStoreV1Beta1SpecProvider#alibaba
        '''
        result = self._values.get("alibaba")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAlibaba"], result)

    @builtins.property
    def aws(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderAws"]:
        '''AWS configures this store to sync secrets using AWS Secret Manager provider.

        :schema: SecretStoreV1Beta1SpecProvider#aws
        '''
        result = self._values.get("aws")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAws"], result)

    @builtins.property
    def azurekv(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderAzurekv"]:
        '''AzureKV configures this store to sync secrets using Azure Key Vault provider.

        :schema: SecretStoreV1Beta1SpecProvider#azurekv
        '''
        result = self._values.get("azurekv")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAzurekv"], result)

    @builtins.property
    def beyondtrust(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrust"]:
        '''Beyondtrust configures this store to sync secrets using Password Safe provider.

        :schema: SecretStoreV1Beta1SpecProvider#beyondtrust
        '''
        result = self._values.get("beyondtrust")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrust"], result)

    @builtins.property
    def bitwardensecretsmanager(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderBitwardensecretsmanager"]:
        '''BitwardenSecretsManager configures this store to sync secrets using BitwardenSecretsManager provider.

        :schema: SecretStoreV1Beta1SpecProvider#bitwardensecretsmanager
        '''
        result = self._values.get("bitwardensecretsmanager")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderBitwardensecretsmanager"], result)

    @builtins.property
    def chef(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderChef"]:
        '''Chef configures this store to sync secrets with chef server.

        :schema: SecretStoreV1Beta1SpecProvider#chef
        '''
        result = self._values.get("chef")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderChef"], result)

    @builtins.property
    def conjur(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderConjur"]:
        '''Conjur configures this store to sync secrets using conjur provider.

        :schema: SecretStoreV1Beta1SpecProvider#conjur
        '''
        result = self._values.get("conjur")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderConjur"], result)

    @builtins.property
    def delinea(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderDelinea"]:
        '''Delinea DevOps Secrets Vault https://docs.delinea.com/online-help/products/devops-secrets-vault/current.

        :schema: SecretStoreV1Beta1SpecProvider#delinea
        '''
        result = self._values.get("delinea")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderDelinea"], result)

    @builtins.property
    def device42(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderDevice42"]:
        '''Device42 configures this store to sync secrets using the Device42 provider.

        :schema: SecretStoreV1Beta1SpecProvider#device42
        '''
        result = self._values.get("device42")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderDevice42"], result)

    @builtins.property
    def doppler(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderDoppler"]:
        '''Doppler configures this store to sync secrets using the Doppler provider.

        :schema: SecretStoreV1Beta1SpecProvider#doppler
        '''
        result = self._values.get("doppler")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderDoppler"], result)

    @builtins.property
    def fake(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderFake"]:
        '''Fake configures a store with static key/value pairs.

        :schema: SecretStoreV1Beta1SpecProvider#fake
        '''
        result = self._values.get("fake")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderFake"], result)

    @builtins.property
    def fortanix(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderFortanix"]:
        '''Fortanix configures this store to sync secrets using the Fortanix provider.

        :schema: SecretStoreV1Beta1SpecProvider#fortanix
        '''
        result = self._values.get("fortanix")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderFortanix"], result)

    @builtins.property
    def gcpsm(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderGcpsm"]:
        '''GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.

        :schema: SecretStoreV1Beta1SpecProvider#gcpsm
        '''
        result = self._values.get("gcpsm")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderGcpsm"], result)

    @builtins.property
    def gitlab(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderGitlab"]:
        '''GitLab configures this store to sync secrets using GitLab Variables provider.

        :schema: SecretStoreV1Beta1SpecProvider#gitlab
        '''
        result = self._values.get("gitlab")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderGitlab"], result)

    @builtins.property
    def ibm(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderIbm"]:
        '''IBM configures this store to sync secrets using IBM Cloud provider.

        :schema: SecretStoreV1Beta1SpecProvider#ibm
        '''
        result = self._values.get("ibm")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderIbm"], result)

    @builtins.property
    def infisical(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderInfisical"]:
        '''Infisical configures this store to sync secrets using the Infisical provider.

        :schema: SecretStoreV1Beta1SpecProvider#infisical
        '''
        result = self._values.get("infisical")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderInfisical"], result)

    @builtins.property
    def keepersecurity(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderKeepersecurity"]:
        '''KeeperSecurity configures this store to sync secrets using the KeeperSecurity provider.

        :schema: SecretStoreV1Beta1SpecProvider#keepersecurity
        '''
        result = self._values.get("keepersecurity")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKeepersecurity"], result)

    @builtins.property
    def kubernetes(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderKubernetes"]:
        '''Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.

        :schema: SecretStoreV1Beta1SpecProvider#kubernetes
        '''
        result = self._values.get("kubernetes")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKubernetes"], result)

    @builtins.property
    def onboardbase(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderOnboardbase"]:
        '''Onboardbase configures this store to sync secrets using the Onboardbase provider.

        :schema: SecretStoreV1Beta1SpecProvider#onboardbase
        '''
        result = self._values.get("onboardbase")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderOnboardbase"], result)

    @builtins.property
    def onepassword(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderOnepassword"]:
        '''OnePassword configures this store to sync secrets using the 1Password Cloud provider.

        :schema: SecretStoreV1Beta1SpecProvider#onepassword
        '''
        result = self._values.get("onepassword")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderOnepassword"], result)

    @builtins.property
    def oracle(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderOracle"]:
        '''Oracle configures this store to sync secrets using Oracle Vault provider.

        :schema: SecretStoreV1Beta1SpecProvider#oracle
        '''
        result = self._values.get("oracle")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderOracle"], result)

    @builtins.property
    def passbolt(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderPassbolt"]:
        '''
        :schema: SecretStoreV1Beta1SpecProvider#passbolt
        '''
        result = self._values.get("passbolt")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderPassbolt"], result)

    @builtins.property
    def passworddepot(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderPassworddepot"]:
        '''Configures a store to sync secrets with a Password Depot instance.

        :schema: SecretStoreV1Beta1SpecProvider#passworddepot
        '''
        result = self._values.get("passworddepot")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderPassworddepot"], result)

    @builtins.property
    def previder(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderPrevider"]:
        '''Previder configures this store to sync secrets using the Previder provider.

        :schema: SecretStoreV1Beta1SpecProvider#previder
        '''
        result = self._values.get("previder")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderPrevider"], result)

    @builtins.property
    def pulumi(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderPulumi"]:
        '''Pulumi configures this store to sync secrets using the Pulumi provider.

        :schema: SecretStoreV1Beta1SpecProvider#pulumi
        '''
        result = self._values.get("pulumi")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderPulumi"], result)

    @builtins.property
    def scaleway(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderScaleway"]:
        '''Scaleway.

        :schema: SecretStoreV1Beta1SpecProvider#scaleway
        '''
        result = self._values.get("scaleway")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderScaleway"], result)

    @builtins.property
    def secretserver(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderSecretserver"]:
        '''SecretServer configures this store to sync secrets using SecretServer provider https://docs.delinea.com/online-help/secret-server/start.htm.

        :schema: SecretStoreV1Beta1SpecProvider#secretserver
        '''
        result = self._values.get("secretserver")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderSecretserver"], result)

    @builtins.property
    def senhasegura(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderSenhasegura"]:
        '''Senhasegura configures this store to sync secrets using senhasegura provider.

        :schema: SecretStoreV1Beta1SpecProvider#senhasegura
        '''
        result = self._values.get("senhasegura")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderSenhasegura"], result)

    @builtins.property
    def vault(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderVault"]:
        '''Vault configures this store to sync secrets using Hashi provider.

        :schema: SecretStoreV1Beta1SpecProvider#vault
        '''
        result = self._values.get("vault")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVault"], result)

    @builtins.property
    def webhook(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderWebhook"]:
        '''Webhook configures this store to sync secrets using a generic templated webhook.

        :schema: SecretStoreV1Beta1SpecProvider#webhook
        '''
        result = self._values.get("webhook")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderWebhook"], result)

    @builtins.property
    def yandexcertificatemanager(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderYandexcertificatemanager"]:
        '''YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider.

        :schema: SecretStoreV1Beta1SpecProvider#yandexcertificatemanager
        '''
        result = self._values.get("yandexcertificatemanager")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderYandexcertificatemanager"], result)

    @builtins.property
    def yandexlockbox(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderYandexlockbox"]:
        '''YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :schema: SecretStoreV1Beta1SpecProvider#yandexlockbox
        '''
        result = self._values.get("yandexlockbox")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderYandexlockbox"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAkeyless",
    jsii_struct_bases=[],
    name_mapping={
        "akeyless_gw_api_url": "akeylessGwApiUrl",
        "auth_secret_ref": "authSecretRef",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
    },
)
class SecretStoreV1Beta1SpecProviderAkeyless:
    def __init__(
        self,
        *,
        akeyless_gw_api_url: builtins.str,
        auth_secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAkeylessCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Akeyless configures this store to sync secrets using Akeyless Vault provider.

        :param akeyless_gw_api_url: Akeyless GW API Url from which the secrets to be fetched from.
        :param auth_secret_ref: Auth configures how the operator authenticates with Akeyless.
        :param ca_bundle: PEM/base64 encoded CA bundle used to validate Akeyless Gateway certificate. Only used if the AkeylessGWApiURL URL is using HTTPS protocol. If not set the system root certificates are used to validate the TLS connection.
        :param ca_provider: The provider for the CA bundle to use to validate Akeyless Gateway certificate.

        :schema: SecretStoreV1Beta1SpecProviderAkeyless
        '''
        if isinstance(auth_secret_ref, dict):
            auth_secret_ref = SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef(**auth_secret_ref)
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreV1Beta1SpecProviderAkeylessCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bed89082ee43718091d9f91d5d7aa30aeb89d80fd22689743ea9be9a5910bf5b)
            check_type(argname="argument akeyless_gw_api_url", value=akeyless_gw_api_url, expected_type=type_hints["akeyless_gw_api_url"])
            check_type(argname="argument auth_secret_ref", value=auth_secret_ref, expected_type=type_hints["auth_secret_ref"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "akeyless_gw_api_url": akeyless_gw_api_url,
            "auth_secret_ref": auth_secret_ref,
        }
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider

    @builtins.property
    def akeyless_gw_api_url(self) -> builtins.str:
        '''Akeyless GW API Url from which the secrets to be fetched from.

        :schema: SecretStoreV1Beta1SpecProviderAkeyless#akeylessGWApiURL
        '''
        result = self._values.get("akeyless_gw_api_url")
        assert result is not None, "Required property 'akeyless_gw_api_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth_secret_ref(self) -> "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef":
        '''Auth configures how the operator authenticates with Akeyless.

        :schema: SecretStoreV1Beta1SpecProviderAkeyless#authSecretRef
        '''
        result = self._values.get("auth_secret_ref")
        assert result is not None, "Required property 'auth_secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef", result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''PEM/base64 encoded CA bundle used to validate Akeyless Gateway certificate.

        Only used
        if the AkeylessGWApiURL URL is using HTTPS protocol. If not set the system root certificates
        are used to validate the TLS connection.

        :schema: SecretStoreV1Beta1SpecProviderAkeyless#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessCaProvider"]:
        '''The provider for the CA bundle to use to validate Akeyless Gateway certificate.

        :schema: SecretStoreV1Beta1SpecProviderAkeyless#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessCaProvider"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAkeyless(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"kubernetes_auth": "kubernetesAuth", "secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef:
    def __init__(
        self,
        *,
        kubernetes_auth: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how the operator authenticates with Akeyless.

        :param kubernetes_auth: Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
        :param secret_ref: Reference to a Secret that contains the details to authenticate with Akeyless.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef
        '''
        if isinstance(kubernetes_auth, dict):
            kubernetes_auth = SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth(**kubernetes_auth)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__74121be233be822179e1fffc40d7f70e1bf5baac40b64c026d41ae76c44bbc9e)
            check_type(argname="argument kubernetes_auth", value=kubernetes_auth, expected_type=type_hints["kubernetes_auth"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if kubernetes_auth is not None:
            self._values["kubernetes_auth"] = kubernetes_auth
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def kubernetes_auth(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth"]:
        '''Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef#kubernetesAuth
        '''
        result = self._values.get("kubernetes_auth")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef"]:
        '''Reference to a Secret that contains the details to authenticate with Akeyless.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth",
    jsii_struct_bases=[],
    name_mapping={
        "access_id": "accessId",
        "k8_s_conf_name": "k8SConfName",
        "secret_ref": "secretRef",
        "service_account_ref": "serviceAccountRef",
    },
)
class SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth:
    def __init__(
        self,
        *,
        access_id: builtins.str,
        k8_s_conf_name: builtins.str,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.

        :param access_id: the Akeyless Kubernetes auth-method access-id.
        :param k8_s_conf_name: Kubernetes-auth configuration name in Akeyless-Gateway.
        :param secret_ref: Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.
        :param service_account_ref: Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(**secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__44b30cb7361730d5728dbfc7861be5dacffb630732bbecffb28ad09986b1158d)
            check_type(argname="argument access_id", value=access_id, expected_type=type_hints["access_id"])
            check_type(argname="argument k8_s_conf_name", value=k8_s_conf_name, expected_type=type_hints["k8_s_conf_name"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "access_id": access_id,
            "k8_s_conf_name": k8_s_conf_name,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def access_id(self) -> builtins.str:
        '''the Akeyless Kubernetes auth-method access-id.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#accessID
        '''
        result = self._values.get("access_id")
        assert result is not None, "Required property 'access_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def k8_s_conf_name(self) -> builtins.str:
        '''Kubernetes-auth configuration name in Akeyless-Gateway.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#k8sConfName
        '''
        result = self._values.get("k8_s_conf_name")
        assert result is not None, "Required property 'k8_s_conf_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef"]:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless.

        If a name is specified without a key,
        ``token`` is the default. If one is not specified, the one bound to
        the controller will be used.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef"]:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used
        for authenticating with Akeyless. If the service account selector is not supplied,
        the secretRef will be used instead.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless.

        If a name is specified without a key,
        ``token`` is the default. If one is not specified, the one bound to
        the controller will be used.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2a4c510b386734e858a3a16c1320574f58f9264bdd1977dead494c9ff909e85c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used
        for authenticating with Akeyless. If the service account selector is not supplied,
        the secretRef will be used instead.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a2972b9bdc93422fb8750e2e18bacb0b5b9bcf80476ae1c9bee4a833c9e5ab9a)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_id": "accessId",
        "access_type": "accessType",
        "access_type_param": "accessTypeParam",
    },
)
class SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef:
    def __init__(
        self,
        *,
        access_id: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId", typing.Dict[builtins.str, typing.Any]]] = None,
        access_type: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType", typing.Dict[builtins.str, typing.Any]]] = None,
        access_type_param: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Reference to a Secret that contains the details to authenticate with Akeyless.

        :param access_id: The SecretAccessID is used for authentication.
        :param access_type: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param access_type_param: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef
        '''
        if isinstance(access_id, dict):
            access_id = SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId(**access_id)
        if isinstance(access_type, dict):
            access_type = SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType(**access_type)
        if isinstance(access_type_param, dict):
            access_type_param = SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(**access_type_param)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d95ece84921a933e967386c74f586317717bf443bedaecf37737f310f3e2270d)
            check_type(argname="argument access_id", value=access_id, expected_type=type_hints["access_id"])
            check_type(argname="argument access_type", value=access_type, expected_type=type_hints["access_type"])
            check_type(argname="argument access_type_param", value=access_type_param, expected_type=type_hints["access_type_param"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if access_id is not None:
            self._values["access_id"] = access_id
        if access_type is not None:
            self._values["access_type"] = access_type
        if access_type_param is not None:
            self._values["access_type_param"] = access_type_param

    @builtins.property
    def access_id(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId"]:
        '''The SecretAccessID is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessID
        '''
        result = self._values.get("access_id")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId"], result)

    @builtins.property
    def access_type(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessType
        '''
        result = self._values.get("access_type")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType"], result)

    @builtins.property
    def access_type_param(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessTypeParam
        '''
        result = self._values.get("access_type_param")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessID is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f495e81081fb2ba9d62c740c6018c154847feb6578b054444bda7cf8c2e72e8)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__613c40b00b05241cf57899cf71d7762d8469acdd57708faaf8c9301e21d587ad)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__58018932fd4ec7fd73bc3ed194e6908b462e22712506f25eca23a0d659847886)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAkeylessCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class SecretStoreV1Beta1SpecProviderAkeylessCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "SecretStoreV1Beta1SpecProviderAkeylessCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Akeyless Gateway certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessCaProvider
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b51d00c03b1bba53f1af93434b0eecfd678db38e463beab710d17132b62f9ef8)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "SecretStoreV1Beta1SpecProviderAkeylessCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: SecretStoreV1Beta1SpecProviderAkeylessCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderAkeylessCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        Can only be defined when used in a ClusterSecretStore.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAkeylessCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAkeylessCaProviderType"
)
class SecretStoreV1Beta1SpecProviderAkeylessCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: SecretStoreV1Beta1SpecProviderAkeylessCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAlibaba",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "region_id": "regionId"},
)
class SecretStoreV1Beta1SpecProviderAlibaba:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderAlibabaAuth", typing.Dict[builtins.str, typing.Any]],
        region_id: builtins.str,
    ) -> None:
        '''Alibaba configures this store to sync secrets using Alibaba Cloud provider.

        :param auth: AlibabaAuth contains a secretRef for credentials.
        :param region_id: Alibaba Region to be used for the provider.

        :schema: SecretStoreV1Beta1SpecProviderAlibaba
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderAlibabaAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f96a153d300ff01c20e7fb7ab637a3c4d57d1fd8e61d2e8bb6d65f9f38d1896e)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument region_id", value=region_id, expected_type=type_hints["region_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "region_id": region_id,
        }

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderAlibabaAuth":
        '''AlibabaAuth contains a secretRef for credentials.

        :schema: SecretStoreV1Beta1SpecProviderAlibaba#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderAlibabaAuth", result)

    @builtins.property
    def region_id(self) -> builtins.str:
        '''Alibaba Region to be used for the provider.

        :schema: SecretStoreV1Beta1SpecProviderAlibaba#regionID
        '''
        result = self._values.get("region_id")
        assert result is not None, "Required property 'region_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAlibaba(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAlibabaAuth",
    jsii_struct_bases=[],
    name_mapping={"rrsa": "rrsa", "secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderAlibabaAuth:
    def __init__(
        self,
        *,
        rrsa: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''AlibabaAuth contains a secretRef for credentials.

        :param rrsa: Authenticate against Alibaba using RRSA.
        :param secret_ref: AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuth
        '''
        if isinstance(rrsa, dict):
            rrsa = SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa(**rrsa)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2271b3fcb686cc99d754c4b2b01c0ce3516bdcbb9b0f6136412860adeae20e97)
            check_type(argname="argument rrsa", value=rrsa, expected_type=type_hints["rrsa"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if rrsa is not None:
            self._values["rrsa"] = rrsa
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def rrsa(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa"]:
        '''Authenticate against Alibaba using RRSA.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuth#rrsa
        '''
        result = self._values.get("rrsa")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef"]:
        '''AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAlibabaAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa",
    jsii_struct_bases=[],
    name_mapping={
        "oidc_provider_arn": "oidcProviderArn",
        "oidc_token_file_path": "oidcTokenFilePath",
        "role_arn": "roleArn",
        "session_name": "sessionName",
    },
)
class SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa:
    def __init__(
        self,
        *,
        oidc_provider_arn: builtins.str,
        oidc_token_file_path: builtins.str,
        role_arn: builtins.str,
        session_name: builtins.str,
    ) -> None:
        '''Authenticate against Alibaba using RRSA.

        :param oidc_provider_arn: 
        :param oidc_token_file_path: 
        :param role_arn: 
        :param session_name: 

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e984beed549840ae3cafd984c234e6d2130919e34269fd21cecd0403e2d05419)
            check_type(argname="argument oidc_provider_arn", value=oidc_provider_arn, expected_type=type_hints["oidc_provider_arn"])
            check_type(argname="argument oidc_token_file_path", value=oidc_token_file_path, expected_type=type_hints["oidc_token_file_path"])
            check_type(argname="argument role_arn", value=role_arn, expected_type=type_hints["role_arn"])
            check_type(argname="argument session_name", value=session_name, expected_type=type_hints["session_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "oidc_provider_arn": oidc_provider_arn,
            "oidc_token_file_path": oidc_token_file_path,
            "role_arn": role_arn,
            "session_name": session_name,
        }

    @builtins.property
    def oidc_provider_arn(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#oidcProviderArn
        '''
        result = self._values.get("oidc_provider_arn")
        assert result is not None, "Required property 'oidc_provider_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def oidc_token_file_path(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#oidcTokenFilePath
        '''
        result = self._values.get("oidc_token_file_path")
        assert result is not None, "Required property 'oidc_token_file_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role_arn(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#roleArn
        '''
        result = self._values.get("role_arn")
        assert result is not None, "Required property 'role_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def session_name(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#sessionName
        '''
        result = self._values.get("session_name")
        assert result is not None, "Required property 'session_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_key_id_secret_ref": "accessKeyIdSecretRef",
        "access_key_secret_secret_ref": "accessKeySecretSecretRef",
    },
)
class SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef:
    def __init__(
        self,
        *,
        access_key_id_secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef", typing.Dict[builtins.str, typing.Any]],
        access_key_secret_secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :param access_key_id_secret_ref: The AccessKeyID is used for authentication.
        :param access_key_secret_secret_ref: The AccessKeySecret is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef
        '''
        if isinstance(access_key_id_secret_ref, dict):
            access_key_id_secret_ref = SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(**access_key_id_secret_ref)
        if isinstance(access_key_secret_secret_ref, dict):
            access_key_secret_secret_ref = SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(**access_key_secret_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0187fad4e721a6222f70c1884497a2f1eddd6e74a1337f9aaaa4c5f758a1ac58)
            check_type(argname="argument access_key_id_secret_ref", value=access_key_id_secret_ref, expected_type=type_hints["access_key_id_secret_ref"])
            check_type(argname="argument access_key_secret_secret_ref", value=access_key_secret_secret_ref, expected_type=type_hints["access_key_secret_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "access_key_id_secret_ref": access_key_id_secret_ref,
            "access_key_secret_secret_ref": access_key_secret_secret_ref,
        }

    @builtins.property
    def access_key_id_secret_ref(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef":
        '''The AccessKeyID is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef#accessKeyIDSecretRef
        '''
        result = self._values.get("access_key_id_secret_ref")
        assert result is not None, "Required property 'access_key_id_secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef", result)

    @builtins.property
    def access_key_secret_secret_ref(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef":
        '''The AccessKeySecret is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef#accessKeySecretSecretRef
        '''
        result = self._values.get("access_key_secret_secret_ref")
        assert result is not None, "Required property 'access_key_secret_secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeyID is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6fa998fa7196a6f87d3e357648846c1a7d7b95b2e6022399c6040182086165b1)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeySecret is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e42973e9b7595404724b2fe7f3f242219216c842943642924d043a0da2113ce3)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAws",
    jsii_struct_bases=[],
    name_mapping={
        "region": "region",
        "service": "service",
        "additional_roles": "additionalRoles",
        "auth": "auth",
        "external_id": "externalId",
        "prefix": "prefix",
        "role": "role",
        "secrets_manager": "secretsManager",
        "session_tags": "sessionTags",
        "transitive_tag_keys": "transitiveTagKeys",
    },
)
class SecretStoreV1Beta1SpecProviderAws:
    def __init__(
        self,
        *,
        region: builtins.str,
        service: "SecretStoreV1Beta1SpecProviderAwsService",
        additional_roles: typing.Optional[typing.Sequence[builtins.str]] = None,
        auth: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAwsAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        external_id: typing.Optional[builtins.str] = None,
        prefix: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        secrets_manager: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAwsSecretsManager", typing.Dict[builtins.str, typing.Any]]] = None,
        session_tags: typing.Optional[typing.Sequence[typing.Union["SecretStoreV1Beta1SpecProviderAwsSessionTags", typing.Dict[builtins.str, typing.Any]]]] = None,
        transitive_tag_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''AWS configures this store to sync secrets using AWS Secret Manager provider.

        :param region: AWS Region to be used for the provider.
        :param service: Service defines which service should be used to fetch the secrets.
        :param additional_roles: AdditionalRoles is a chained list of Role ARNs which the provider will sequentially assume before assuming the Role.
        :param auth: Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.
        :param external_id: AWS External ID set on assumed IAM roles.
        :param prefix: Prefix adds a prefix to all retrieved values.
        :param role: Role is a Role ARN which the provider will assume.
        :param secrets_manager: SecretsManager defines how the provider behaves when interacting with AWS SecretsManager.
        :param session_tags: AWS STS assume role session tags.
        :param transitive_tag_keys: AWS STS assume role transitive session tags. Required when multiple rules are used with the provider

        :schema: SecretStoreV1Beta1SpecProviderAws
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderAwsAuth(**auth)
        if isinstance(secrets_manager, dict):
            secrets_manager = SecretStoreV1Beta1SpecProviderAwsSecretsManager(**secrets_manager)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__62290ee01214cf301e7987fdab68bcb3b685aa43bf724e7dc735e5ac63111a0a)
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument additional_roles", value=additional_roles, expected_type=type_hints["additional_roles"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument external_id", value=external_id, expected_type=type_hints["external_id"])
            check_type(argname="argument prefix", value=prefix, expected_type=type_hints["prefix"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secrets_manager", value=secrets_manager, expected_type=type_hints["secrets_manager"])
            check_type(argname="argument session_tags", value=session_tags, expected_type=type_hints["session_tags"])
            check_type(argname="argument transitive_tag_keys", value=transitive_tag_keys, expected_type=type_hints["transitive_tag_keys"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "region": region,
            "service": service,
        }
        if additional_roles is not None:
            self._values["additional_roles"] = additional_roles
        if auth is not None:
            self._values["auth"] = auth
        if external_id is not None:
            self._values["external_id"] = external_id
        if prefix is not None:
            self._values["prefix"] = prefix
        if role is not None:
            self._values["role"] = role
        if secrets_manager is not None:
            self._values["secrets_manager"] = secrets_manager
        if session_tags is not None:
            self._values["session_tags"] = session_tags
        if transitive_tag_keys is not None:
            self._values["transitive_tag_keys"] = transitive_tag_keys

    @builtins.property
    def region(self) -> builtins.str:
        '''AWS Region to be used for the provider.

        :schema: SecretStoreV1Beta1SpecProviderAws#region
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service(self) -> "SecretStoreV1Beta1SpecProviderAwsService":
        '''Service defines which service should be used to fetch the secrets.

        :schema: SecretStoreV1Beta1SpecProviderAws#service
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderAwsService", result)

    @builtins.property
    def additional_roles(self) -> typing.Optional[typing.List[builtins.str]]:
        '''AdditionalRoles is a chained list of Role ARNs which the provider will sequentially assume before assuming the Role.

        :schema: SecretStoreV1Beta1SpecProviderAws#additionalRoles
        '''
        result = self._values.get("additional_roles")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def auth(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuth"]:
        '''Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.

        :schema: SecretStoreV1Beta1SpecProviderAws#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuth"], result)

    @builtins.property
    def external_id(self) -> typing.Optional[builtins.str]:
        '''AWS External ID set on assumed IAM roles.

        :schema: SecretStoreV1Beta1SpecProviderAws#externalID
        '''
        result = self._values.get("external_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def prefix(self) -> typing.Optional[builtins.str]:
        '''Prefix adds a prefix to all retrieved values.

        :schema: SecretStoreV1Beta1SpecProviderAws#prefix
        '''
        result = self._values.get("prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a Role ARN which the provider will assume.

        :schema: SecretStoreV1Beta1SpecProviderAws#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secrets_manager(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAwsSecretsManager"]:
        '''SecretsManager defines how the provider behaves when interacting with AWS SecretsManager.

        :schema: SecretStoreV1Beta1SpecProviderAws#secretsManager
        '''
        result = self._values.get("secrets_manager")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAwsSecretsManager"], result)

    @builtins.property
    def session_tags(
        self,
    ) -> typing.Optional[typing.List["SecretStoreV1Beta1SpecProviderAwsSessionTags"]]:
        '''AWS STS assume role session tags.

        :schema: SecretStoreV1Beta1SpecProviderAws#sessionTags
        '''
        result = self._values.get("session_tags")
        return typing.cast(typing.Optional[typing.List["SecretStoreV1Beta1SpecProviderAwsSessionTags"]], result)

    @builtins.property
    def transitive_tag_keys(self) -> typing.Optional[typing.List[builtins.str]]:
        '''AWS STS assume role transitive session tags.

        Required when multiple rules are used with the provider

        :schema: SecretStoreV1Beta1SpecProviderAws#transitiveTagKeys
        '''
        result = self._values.get("transitive_tag_keys")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAws(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAwsAuth",
    jsii_struct_bases=[],
    name_mapping={"jwt": "jwt", "secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderAwsAuth:
    def __init__(
        self,
        *,
        jwt: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAwsAuthJwt", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAwsAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.

        :param jwt: Authenticate against AWS using service account tokens.
        :param secret_ref: AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuth
        '''
        if isinstance(jwt, dict):
            jwt = SecretStoreV1Beta1SpecProviderAwsAuthJwt(**jwt)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderAwsAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__00dddb0c8e37de3d9e897dfc11a386c82ccfcf7edf6a64799db1526ec6a85166)
            check_type(argname="argument jwt", value=jwt, expected_type=type_hints["jwt"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if jwt is not None:
            self._values["jwt"] = jwt
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def jwt(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthJwt"]:
        '''Authenticate against AWS using service account tokens.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuth#jwt
        '''
        result = self._values.get("jwt")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthJwt"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthSecretRef"]:
        '''AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAwsAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAwsAuthJwt",
    jsii_struct_bases=[],
    name_mapping={"service_account_ref": "serviceAccountRef"},
)
class SecretStoreV1Beta1SpecProviderAwsAuthJwt:
    def __init__(
        self,
        *,
        service_account_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Authenticate against AWS using service account tokens.

        :param service_account_ref: A reference to a ServiceAccount resource.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthJwt
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c8774a4feb5c9e404a52e2e99d1f871029c8430064a6fb0c7ca04e1c1c826f84)
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef"]:
        '''A reference to a ServiceAccount resource.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthJwt#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAwsAuthJwt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2394d475836b18dbaa6f40ecb6933020b781a95f1720db6e096a3cc03be94805)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAwsAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_key_id_secret_ref": "accessKeyIdSecretRef",
        "secret_access_key_secret_ref": "secretAccessKeySecretRef",
        "session_token_secret_ref": "sessionTokenSecretRef",
    },
)
class SecretStoreV1Beta1SpecProviderAwsAuthSecretRef:
    def __init__(
        self,
        *,
        access_key_id_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_access_key_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        session_token_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :param access_key_id_secret_ref: The AccessKeyID is used for authentication.
        :param secret_access_key_secret_ref: The SecretAccessKey is used for authentication.
        :param session_token_secret_ref: The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRef
        '''
        if isinstance(access_key_id_secret_ref, dict):
            access_key_id_secret_ref = SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(**access_key_id_secret_ref)
        if isinstance(secret_access_key_secret_ref, dict):
            secret_access_key_secret_ref = SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(**secret_access_key_secret_ref)
        if isinstance(session_token_secret_ref, dict):
            session_token_secret_ref = SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef(**session_token_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b57dc85c1f30d4578476b7d7451b50a139cc6f25cb7fca4b2c86fa4f34d3b8e)
            check_type(argname="argument access_key_id_secret_ref", value=access_key_id_secret_ref, expected_type=type_hints["access_key_id_secret_ref"])
            check_type(argname="argument secret_access_key_secret_ref", value=secret_access_key_secret_ref, expected_type=type_hints["secret_access_key_secret_ref"])
            check_type(argname="argument session_token_secret_ref", value=session_token_secret_ref, expected_type=type_hints["session_token_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if access_key_id_secret_ref is not None:
            self._values["access_key_id_secret_ref"] = access_key_id_secret_ref
        if secret_access_key_secret_ref is not None:
            self._values["secret_access_key_secret_ref"] = secret_access_key_secret_ref
        if session_token_secret_ref is not None:
            self._values["session_token_secret_ref"] = session_token_secret_ref

    @builtins.property
    def access_key_id_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef"]:
        '''The AccessKeyID is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRef#accessKeyIDSecretRef
        '''
        result = self._values.get("access_key_id_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef"], result)

    @builtins.property
    def secret_access_key_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRef#secretAccessKeySecretRef
        '''
        result = self._values.get("secret_access_key_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef"], result)

    @builtins.property
    def session_token_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef"]:
        '''The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRef#sessionTokenSecretRef
        '''
        result = self._values.get("session_token_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAwsAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeyID is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c1d3d92125450f26fe4347f50a5577043aaca83943223aa5b36e49c2ba807b9)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb31e0cbd82e41937767722aae600636c68f79c57d03b3180dfc1c5e96f96b09)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de5db4fa3573a19186756285ed3f23e894d62d5239c363795d0970988983b329)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAwsSecretsManager",
    jsii_struct_bases=[],
    name_mapping={
        "force_delete_without_recovery": "forceDeleteWithoutRecovery",
        "recovery_window_in_days": "recoveryWindowInDays",
    },
)
class SecretStoreV1Beta1SpecProviderAwsSecretsManager:
    def __init__(
        self,
        *,
        force_delete_without_recovery: typing.Optional[builtins.bool] = None,
        recovery_window_in_days: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''SecretsManager defines how the provider behaves when interacting with AWS SecretsManager.

        :param force_delete_without_recovery: Specifies whether to delete the secret without any recovery window. You can't use both this parameter and RecoveryWindowInDays in the same call. If you don't use either, then by default Secrets Manager uses a 30 day recovery window. see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-ForceDeleteWithoutRecovery
        :param recovery_window_in_days: The number of days from 7 to 30 that Secrets Manager waits before permanently deleting the secret. You can't use both this parameter and ForceDeleteWithoutRecovery in the same call. If you don't use either, then by default Secrets Manager uses a 30 day recovery window. see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-RecoveryWindowInDays

        :schema: SecretStoreV1Beta1SpecProviderAwsSecretsManager
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fcf0c03abb9abce00a1111221163bdab1cb870b96e6e63cbaef6d4817a797366)
            check_type(argname="argument force_delete_without_recovery", value=force_delete_without_recovery, expected_type=type_hints["force_delete_without_recovery"])
            check_type(argname="argument recovery_window_in_days", value=recovery_window_in_days, expected_type=type_hints["recovery_window_in_days"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if force_delete_without_recovery is not None:
            self._values["force_delete_without_recovery"] = force_delete_without_recovery
        if recovery_window_in_days is not None:
            self._values["recovery_window_in_days"] = recovery_window_in_days

    @builtins.property
    def force_delete_without_recovery(self) -> typing.Optional[builtins.bool]:
        '''Specifies whether to delete the secret without any recovery window.

        You
        can't use both this parameter and RecoveryWindowInDays in the same call.
        If you don't use either, then by default Secrets Manager uses a 30 day
        recovery window.
        see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-ForceDeleteWithoutRecovery

        :schema: SecretStoreV1Beta1SpecProviderAwsSecretsManager#forceDeleteWithoutRecovery
        '''
        result = self._values.get("force_delete_without_recovery")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def recovery_window_in_days(self) -> typing.Optional[jsii.Number]:
        '''The number of days from 7 to 30 that Secrets Manager waits before permanently deleting the secret.

        You can't use both this parameter and
        ForceDeleteWithoutRecovery in the same call. If you don't use either,
        then by default Secrets Manager uses a 30 day recovery window.
        see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-RecoveryWindowInDays

        :schema: SecretStoreV1Beta1SpecProviderAwsSecretsManager#recoveryWindowInDays
        '''
        result = self._values.get("recovery_window_in_days")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAwsSecretsManager(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAwsService")
class SecretStoreV1Beta1SpecProviderAwsService(enum.Enum):
    '''Service defines which service should be used to fetch the secrets.

    :schema: SecretStoreV1Beta1SpecProviderAwsService
    '''

    SECRETS_MANAGER = "SECRETS_MANAGER"
    '''SecretsManager.'''
    PARAMETER_STORE = "PARAMETER_STORE"
    '''ParameterStore.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAwsSessionTags",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "value": "value"},
)
class SecretStoreV1Beta1SpecProviderAwsSessionTags:
    def __init__(self, *, key: builtins.str, value: builtins.str) -> None:
        '''
        :param key: 
        :param value: 

        :schema: SecretStoreV1Beta1SpecProviderAwsSessionTags
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bec003d532442fc01806938cd60e826bbe59eaf5f2736326a27ddea7d79b6d19)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
            "value": value,
        }

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderAwsSessionTags#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderAwsSessionTags#value
        '''
        result = self._values.get("value")
        assert result is not None, "Required property 'value' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAwsSessionTags(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAzurekv",
    jsii_struct_bases=[],
    name_mapping={
        "vault_url": "vaultUrl",
        "auth_secret_ref": "authSecretRef",
        "auth_type": "authType",
        "environment_type": "environmentType",
        "identity_id": "identityId",
        "service_account_ref": "serviceAccountRef",
        "tenant_id": "tenantId",
    },
)
class SecretStoreV1Beta1SpecProviderAzurekv:
    def __init__(
        self,
        *,
        vault_url: builtins.str,
        auth_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        auth_type: typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthType"] = None,
        environment_type: typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType"] = None,
        identity_id: typing.Optional[builtins.str] = None,
        service_account_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
        tenant_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AzureKV configures this store to sync secrets using Azure Key Vault provider.

        :param vault_url: Vault Url from which the secrets to be fetched from.
        :param auth_secret_ref: Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type. Optional for WorkloadIdentity.
        :param auth_type: Auth type defines how to authenticate to the keyvault service. Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
        :param environment_type: EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint. The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152 PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
        :param identity_id: If multiple Managed Identity is assigned to the pod, you can select the one to be used.
        :param service_account_ref: ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
        :param tenant_id: TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type. Optional for WorkloadIdentity.

        :schema: SecretStoreV1Beta1SpecProviderAzurekv
        '''
        if isinstance(auth_secret_ref, dict):
            auth_secret_ref = SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef(**auth_secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1102c98a03f32b51f230ee6adf278c19d54673b52c8312fe8182f941b2335ddc)
            check_type(argname="argument vault_url", value=vault_url, expected_type=type_hints["vault_url"])
            check_type(argname="argument auth_secret_ref", value=auth_secret_ref, expected_type=type_hints["auth_secret_ref"])
            check_type(argname="argument auth_type", value=auth_type, expected_type=type_hints["auth_type"])
            check_type(argname="argument environment_type", value=environment_type, expected_type=type_hints["environment_type"])
            check_type(argname="argument identity_id", value=identity_id, expected_type=type_hints["identity_id"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument tenant_id", value=tenant_id, expected_type=type_hints["tenant_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vault_url": vault_url,
        }
        if auth_secret_ref is not None:
            self._values["auth_secret_ref"] = auth_secret_ref
        if auth_type is not None:
            self._values["auth_type"] = auth_type
        if environment_type is not None:
            self._values["environment_type"] = environment_type
        if identity_id is not None:
            self._values["identity_id"] = identity_id
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref
        if tenant_id is not None:
            self._values["tenant_id"] = tenant_id

    @builtins.property
    def vault_url(self) -> builtins.str:
        '''Vault Url from which the secrets to be fetched from.

        :schema: SecretStoreV1Beta1SpecProviderAzurekv#vaultUrl
        '''
        result = self._values.get("vault_url")
        assert result is not None, "Required property 'vault_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef"]:
        '''Auth configures how the operator authenticates with Azure.

        Required for ServicePrincipal auth type. Optional for WorkloadIdentity.

        :schema: SecretStoreV1Beta1SpecProviderAzurekv#authSecretRef
        '''
        result = self._values.get("auth_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef"], result)

    @builtins.property
    def auth_type(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthType"]:
        '''Auth type defines how to authenticate to the keyvault service.

        Valid values are:

        - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret)
        - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)

        :schema: SecretStoreV1Beta1SpecProviderAzurekv#authType
        '''
        result = self._values.get("auth_type")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthType"], result)

    @builtins.property
    def environment_type(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType"]:
        '''EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure.

        By default it points to the public cloud AAD endpoint.
        The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152
        PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud

        :schema: SecretStoreV1Beta1SpecProviderAzurekv#environmentType
        '''
        result = self._values.get("environment_type")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType"], result)

    @builtins.property
    def identity_id(self) -> typing.Optional[builtins.str]:
        '''If multiple Managed Identity is assigned to the pod, you can select the one to be used.

        :schema: SecretStoreV1Beta1SpecProviderAzurekv#identityId
        '''
        result = self._values.get("identity_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef"]:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :schema: SecretStoreV1Beta1SpecProviderAzurekv#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef"], result)

    @builtins.property
    def tenant_id(self) -> typing.Optional[builtins.str]:
        '''TenantID configures the Azure Tenant to send requests to.

        Required for ServicePrincipal auth type. Optional for WorkloadIdentity.

        :schema: SecretStoreV1Beta1SpecProviderAzurekv#tenantId
        '''
        result = self._values.get("tenant_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAzurekv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "client_certificate": "clientCertificate",
        "client_id": "clientId",
        "client_secret": "clientSecret",
        "tenant_id": "tenantId",
    },
)
class SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef:
    def __init__(
        self,
        *,
        client_certificate: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate", typing.Dict[builtins.str, typing.Any]]] = None,
        client_id: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId", typing.Dict[builtins.str, typing.Any]]] = None,
        client_secret: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret", typing.Dict[builtins.str, typing.Any]]] = None,
        tenant_id: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how the operator authenticates with Azure.

        Required for ServicePrincipal auth type. Optional for WorkloadIdentity.

        :param client_certificate: The Azure ClientCertificate of the service principle used for authentication.
        :param client_id: The Azure clientId of the service principle or managed identity used for authentication.
        :param client_secret: The Azure ClientSecret of the service principle used for authentication.
        :param tenant_id: The Azure tenantId of the managed identity used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef
        '''
        if isinstance(client_certificate, dict):
            client_certificate = SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate(**client_certificate)
        if isinstance(client_id, dict):
            client_id = SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId(**client_id)
        if isinstance(client_secret, dict):
            client_secret = SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret(**client_secret)
        if isinstance(tenant_id, dict):
            tenant_id = SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId(**tenant_id)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a4938b5255f3aa984783f676bc89cdd2bd990505a85f0fd72b37dbaa5f7b4ef)
            check_type(argname="argument client_certificate", value=client_certificate, expected_type=type_hints["client_certificate"])
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret", value=client_secret, expected_type=type_hints["client_secret"])
            check_type(argname="argument tenant_id", value=tenant_id, expected_type=type_hints["tenant_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if client_certificate is not None:
            self._values["client_certificate"] = client_certificate
        if client_id is not None:
            self._values["client_id"] = client_id
        if client_secret is not None:
            self._values["client_secret"] = client_secret
        if tenant_id is not None:
            self._values["tenant_id"] = tenant_id

    @builtins.property
    def client_certificate(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate"]:
        '''The Azure ClientCertificate of the service principle used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientCertificate
        '''
        result = self._values.get("client_certificate")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate"], result)

    @builtins.property
    def client_id(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId"]:
        '''The Azure clientId of the service principle or managed identity used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientId
        '''
        result = self._values.get("client_id")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId"], result)

    @builtins.property
    def client_secret(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret"]:
        '''The Azure ClientSecret of the service principle used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientSecret
        '''
        result = self._values.get("client_secret")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret"], result)

    @builtins.property
    def tenant_id(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId"]:
        '''The Azure tenantId of the managed identity used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#tenantId
        '''
        result = self._values.get("tenant_id")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Azure ClientCertificate of the service principle used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__831c428d32e1809fa8755d7275384249478a2b1b2977461d205882f576150ee7)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Azure clientId of the service principle or managed identity used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1ed9139f1201d752d0544dffe465265042c7b8a6bad36a96c27ac55fb5b4efad)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Azure ClientSecret of the service principle used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b5781b1e7d687e6973d4e5221625c7edbeae341526205210eb53c47810c7b1c3)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Azure tenantId of the managed identity used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1681d1ac099829c7e3d7ddc9d8d2171f0c00eac05620d619ba73a164a4ac8b46)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAzurekvAuthType"
)
class SecretStoreV1Beta1SpecProviderAzurekvAuthType(enum.Enum):
    '''Auth type defines how to authenticate to the keyvault service.

    Valid values are:

    - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret)
    - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)

    :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthType
    '''

    SERVICE_PRINCIPAL = "SERVICE_PRINCIPAL"
    '''ServicePrincipal.'''
    MANAGED_IDENTITY = "MANAGED_IDENTITY"
    '''ManagedIdentity.'''
    WORKLOAD_IDENTITY = "WORKLOAD_IDENTITY"
    '''WorkloadIdentity.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType"
)
class SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType(enum.Enum):
    '''EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure.

    By default it points to the public cloud AAD endpoint.
    The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152
    PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud

    :schema: SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType
    '''

    PUBLIC_CLOUD = "PUBLIC_CLOUD"
    '''PublicCloud.'''
    US_GOVERNMENT_CLOUD = "US_GOVERNMENT_CLOUD"
    '''USGovernmentCloud.'''
    CHINA_CLOUD = "CHINA_CLOUD"
    '''ChinaCloud.'''
    GERMAN_CLOUD = "GERMAN_CLOUD"
    '''GermanCloud.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c3701d52a6b4ef32f42230c1c20ac928c8800856543ae008bb3eff3348b988ed)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderBeyondtrust",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "server": "server"},
)
class SecretStoreV1Beta1SpecProviderBeyondtrust:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderBeyondtrustAuth", typing.Dict[builtins.str, typing.Any]],
        server: typing.Union["SecretStoreV1Beta1SpecProviderBeyondtrustServer", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Beyondtrust configures this store to sync secrets using Password Safe provider.

        :param auth: Auth configures how the operator authenticates with Beyondtrust.
        :param server: Auth configures how API server works.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrust
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderBeyondtrustAuth(**auth)
        if isinstance(server, dict):
            server = SecretStoreV1Beta1SpecProviderBeyondtrustServer(**server)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__720e80a24c1c4b06f96e3eceecdbda8f48e6b69d7995af64a1607377b610b318)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "server": server,
        }

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderBeyondtrustAuth":
        '''Auth configures how the operator authenticates with Beyondtrust.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrust#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderBeyondtrustAuth", result)

    @builtins.property
    def server(self) -> "SecretStoreV1Beta1SpecProviderBeyondtrustServer":
        '''Auth configures how API server works.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrust#server
        '''
        result = self._values.get("server")
        assert result is not None, "Required property 'server' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderBeyondtrustServer", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderBeyondtrust(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderBeyondtrustAuth",
    jsii_struct_bases=[],
    name_mapping={
        "api_key": "apiKey",
        "certificate": "certificate",
        "certificate_key": "certificateKey",
        "client_id": "clientId",
        "client_secret": "clientSecret",
    },
)
class SecretStoreV1Beta1SpecProviderBeyondtrustAuth:
    def __init__(
        self,
        *,
        api_key: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey", typing.Dict[builtins.str, typing.Any]]] = None,
        certificate: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate", typing.Dict[builtins.str, typing.Any]]] = None,
        certificate_key: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey", typing.Dict[builtins.str, typing.Any]]] = None,
        client_id: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId", typing.Dict[builtins.str, typing.Any]]] = None,
        client_secret: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how the operator authenticates with Beyondtrust.

        :param api_key: APIKey If not provided then ClientID/ClientSecret become required.
        :param certificate: Certificate (cert.pem) for use when authenticating with an OAuth client Id using a Client Certificate.
        :param certificate_key: Certificate private key (key.pem). For use when authenticating with an OAuth client Id.
        :param client_id: ClientID is the API OAuth Client ID.
        :param client_secret: ClientSecret is the API OAuth Client Secret.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuth
        '''
        if isinstance(api_key, dict):
            api_key = SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey(**api_key)
        if isinstance(certificate, dict):
            certificate = SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate(**certificate)
        if isinstance(certificate_key, dict):
            certificate_key = SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey(**certificate_key)
        if isinstance(client_id, dict):
            client_id = SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId(**client_id)
        if isinstance(client_secret, dict):
            client_secret = SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret(**client_secret)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__54972e5e94f17e926be68cda60347f539d02cd6bfafd29d3f2b9919cd7ebc646)
            check_type(argname="argument api_key", value=api_key, expected_type=type_hints["api_key"])
            check_type(argname="argument certificate", value=certificate, expected_type=type_hints["certificate"])
            check_type(argname="argument certificate_key", value=certificate_key, expected_type=type_hints["certificate_key"])
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret", value=client_secret, expected_type=type_hints["client_secret"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if api_key is not None:
            self._values["api_key"] = api_key
        if certificate is not None:
            self._values["certificate"] = certificate
        if certificate_key is not None:
            self._values["certificate_key"] = certificate_key
        if client_id is not None:
            self._values["client_id"] = client_id
        if client_secret is not None:
            self._values["client_secret"] = client_secret

    @builtins.property
    def api_key(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey"]:
        '''APIKey If not provided then ClientID/ClientSecret become required.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuth#apiKey
        '''
        result = self._values.get("api_key")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey"], result)

    @builtins.property
    def certificate(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate"]:
        '''Certificate (cert.pem) for use when authenticating with an OAuth client Id using a Client Certificate.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuth#certificate
        '''
        result = self._values.get("certificate")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate"], result)

    @builtins.property
    def certificate_key(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey"]:
        '''Certificate private key (key.pem). For use when authenticating with an OAuth client Id.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuth#certificateKey
        '''
        result = self._values.get("certificate_key")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey"], result)

    @builtins.property
    def client_id(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId"]:
        '''ClientID is the API OAuth Client ID.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuth#clientId
        '''
        result = self._values.get("client_id")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId"], result)

    @builtins.property
    def client_secret(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret"]:
        '''ClientSecret is the API OAuth Client Secret.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuth#clientSecret
        '''
        result = self._values.get("client_secret")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderBeyondtrustAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''APIKey If not provided then ClientID/ClientSecret become required.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__892b420a6108fe141d09afb8dc5eda04f14e16e0601e0be9a36e6e7dac8b71a9)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bc626c3c9611371e85ee1efb691d06ee3c414f83f927db995073dd4b2f02e95c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Certificate (cert.pem) for use when authenticating with an OAuth client Id using a Client Certificate.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da89ad96825b8c076b6ca55337238e7d2f2b5f4496f168b3b2b9d9231065598b)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Certificate private key (key.pem). For use when authenticating with an OAuth client Id.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e926aea2da7e03a7073e04a82eacc1a75a84ffc3253b7372188ee5057b1e82b)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c787a514860695abc85dae452bb94e1bddd190542f15ae82b8e90d352ce913c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a3f8310fb041f02baaaf7051f4890ac89513a7a899d2affb277092e38a70d96a)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ClientID is the API OAuth Client ID.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73df30abc817c56768cbeca733152919a63e432b1e1cf53632439202c3a036e1)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a30c87e91749081367319be2b68ed2d5a9ec0cbe5b725f91272c01b9d8adaa3)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ClientSecret is the API OAuth Client Secret.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__56c6fef00a69fbe92be8a6b4e831ce232fe37bdeebf76635ac8fe5a3019544a6)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1d3abe33c96e528155c4d190f7df9607bc55d3cf7f3ac193d91249fdcdea7160)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderBeyondtrustServer",
    jsii_struct_bases=[],
    name_mapping={
        "api_url": "apiUrl",
        "verify_ca": "verifyCa",
        "client_time_out_seconds": "clientTimeOutSeconds",
        "retrieval_type": "retrievalType",
        "separator": "separator",
    },
)
class SecretStoreV1Beta1SpecProviderBeyondtrustServer:
    def __init__(
        self,
        *,
        api_url: builtins.str,
        verify_ca: builtins.bool,
        client_time_out_seconds: typing.Optional[jsii.Number] = None,
        retrieval_type: typing.Optional[builtins.str] = None,
        separator: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Auth configures how API server works.

        :param api_url: 
        :param verify_ca: 
        :param client_time_out_seconds: Timeout specifies a time limit for requests made by this Client. The timeout includes connection time, any redirects, and reading the response body. Defaults to 45 seconds. Default: 45 seconds.
        :param retrieval_type: The secret retrieval type. SECRET = Secrets Safe (credential, text, file). MANAGED_ACCOUNT = Password Safe account associated with a system.
        :param separator: A character that separates the folder names.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustServer
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e3a45e59ccaf8d835902daa56d4287a9108ffbc3c080277441ed37dbf953131a)
            check_type(argname="argument api_url", value=api_url, expected_type=type_hints["api_url"])
            check_type(argname="argument verify_ca", value=verify_ca, expected_type=type_hints["verify_ca"])
            check_type(argname="argument client_time_out_seconds", value=client_time_out_seconds, expected_type=type_hints["client_time_out_seconds"])
            check_type(argname="argument retrieval_type", value=retrieval_type, expected_type=type_hints["retrieval_type"])
            check_type(argname="argument separator", value=separator, expected_type=type_hints["separator"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api_url": api_url,
            "verify_ca": verify_ca,
        }
        if client_time_out_seconds is not None:
            self._values["client_time_out_seconds"] = client_time_out_seconds
        if retrieval_type is not None:
            self._values["retrieval_type"] = retrieval_type
        if separator is not None:
            self._values["separator"] = separator

    @builtins.property
    def api_url(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustServer#apiUrl
        '''
        result = self._values.get("api_url")
        assert result is not None, "Required property 'api_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def verify_ca(self) -> builtins.bool:
        '''
        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustServer#verifyCA
        '''
        result = self._values.get("verify_ca")
        assert result is not None, "Required property 'verify_ca' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def client_time_out_seconds(self) -> typing.Optional[jsii.Number]:
        '''Timeout specifies a time limit for requests made by this Client.

        The timeout includes connection time, any redirects, and reading the response body. Defaults to 45 seconds.

        :default: 45 seconds.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustServer#clientTimeOutSeconds
        '''
        result = self._values.get("client_time_out_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def retrieval_type(self) -> typing.Optional[builtins.str]:
        '''The secret retrieval type.

        SECRET = Secrets Safe (credential, text, file). MANAGED_ACCOUNT = Password Safe account associated with a system.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustServer#retrievalType
        '''
        result = self._values.get("retrieval_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def separator(self) -> typing.Optional[builtins.str]:
        '''A character that separates the folder names.

        :schema: SecretStoreV1Beta1SpecProviderBeyondtrustServer#separator
        '''
        result = self._values.get("separator")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderBeyondtrustServer(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderBitwardensecretsmanager",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "organization_id": "organizationId",
        "project_id": "projectId",
        "api_url": "apiUrl",
        "bitwarden_server_sdkurl": "bitwardenServerSdkurl",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
        "identity_url": "identityUrl",
    },
)
class SecretStoreV1Beta1SpecProviderBitwardensecretsmanager:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth", typing.Dict[builtins.str, typing.Any]],
        organization_id: builtins.str,
        project_id: builtins.str,
        api_url: typing.Optional[builtins.str] = None,
        bitwarden_server_sdkurl: typing.Optional[builtins.str] = None,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
        identity_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''BitwardenSecretsManager configures this store to sync secrets using BitwardenSecretsManager provider.

        :param auth: Auth configures how secret-manager authenticates with a bitwarden machine account instance. Make sure that the token being used has permissions on the given secret.
        :param organization_id: OrganizationID determines which organization this secret store manages.
        :param project_id: ProjectID determines which project this secret store manages.
        :param api_url: 
        :param bitwarden_server_sdkurl: 
        :param ca_bundle: Base64 encoded certificate for the bitwarden server sdk. The sdk MUST run with HTTPS to make sure no MITM attack can be performed.
        :param ca_provider: see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider.
        :param identity_url: 

        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanager
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__55277eb66e9fbfb21f66e7e9d1697a8d5fa1ee87e8b38cd3da7b0b2c50cacff1)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument organization_id", value=organization_id, expected_type=type_hints["organization_id"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
            check_type(argname="argument api_url", value=api_url, expected_type=type_hints["api_url"])
            check_type(argname="argument bitwarden_server_sdkurl", value=bitwarden_server_sdkurl, expected_type=type_hints["bitwarden_server_sdkurl"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument identity_url", value=identity_url, expected_type=type_hints["identity_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "organization_id": organization_id,
            "project_id": project_id,
        }
        if api_url is not None:
            self._values["api_url"] = api_url
        if bitwarden_server_sdkurl is not None:
            self._values["bitwarden_server_sdkurl"] = bitwarden_server_sdkurl
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if identity_url is not None:
            self._values["identity_url"] = identity_url

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth":
        '''Auth configures how secret-manager authenticates with a bitwarden machine account instance.

        Make sure that the token being used has permissions on the given secret.

        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanager#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth", result)

    @builtins.property
    def organization_id(self) -> builtins.str:
        '''OrganizationID determines which organization this secret store manages.

        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanager#organizationID
        '''
        result = self._values.get("organization_id")
        assert result is not None, "Required property 'organization_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def project_id(self) -> builtins.str:
        '''ProjectID determines which project this secret store manages.

        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanager#projectID
        '''
        result = self._values.get("project_id")
        assert result is not None, "Required property 'project_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_url(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanager#apiURL
        '''
        result = self._values.get("api_url")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def bitwarden_server_sdkurl(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanager#bitwardenServerSDKURL
        '''
        result = self._values.get("bitwarden_server_sdkurl")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''Base64 encoded certificate for the bitwarden server sdk.

        The sdk MUST run with HTTPS to make sure no MITM attack
        can be performed.

        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanager#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider"]:
        '''see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider.

        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanager#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider"], result)

    @builtins.property
    def identity_url(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanager#identityURL
        '''
        result = self._values.get("identity_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderBitwardensecretsmanager(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth configures how secret-manager authenticates with a bitwarden machine account instance.

        Make sure that the token being used has permissions on the given secret.

        :param secret_ref: BitwardenSecretsManagerSecretRef contains the credential ref to the bitwarden instance.

        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5d367e7ff8ce82dd30e23386d9a4032977fef60e4cf836b6ece1f98cde8e7ecc)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef":
        '''BitwardenSecretsManagerSecretRef contains the credential ref to the bitwarden instance.

        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"credentials": "credentials"},
)
class SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef:
    def __init__(
        self,
        *,
        credentials: typing.Union["SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''BitwardenSecretsManagerSecretRef contains the credential ref to the bitwarden instance.

        :param credentials: AccessToken used for the bitwarden instance.

        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef
        '''
        if isinstance(credentials, dict):
            credentials = SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials(**credentials)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9dbb7d348c57c4813bcf9e08f0dc03c486ea20f5c307999e5c0b505865bdfc07)
            check_type(argname="argument credentials", value=credentials, expected_type=type_hints["credentials"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "credentials": credentials,
        }

    @builtins.property
    def credentials(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials":
        '''AccessToken used for the bitwarden instance.

        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef#credentials
        '''
        result = self._values.get("credentials")
        assert result is not None, "Required property 'credentials' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AccessToken used for the bitwarden instance.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8d34905d4d9793676dd4352f32573dd004d72f7f3f4a4af70ce5a5447f5dba74)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.

        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__69bf9b74cef9d53246a6914325039799a3c204d804c76ce54770642198971103)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        Can only be defined when used in a ClusterSecretStore.

        :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType"
)
class SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderChef",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "server_url": "serverUrl", "username": "username"},
)
class SecretStoreV1Beta1SpecProviderChef:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderChefAuth", typing.Dict[builtins.str, typing.Any]],
        server_url: builtins.str,
        username: builtins.str,
    ) -> None:
        '''Chef configures this store to sync secrets with chef server.

        :param auth: Auth defines the information necessary to authenticate against chef Server.
        :param server_url: ServerURL is the chef server URL used to connect to. If using orgs you should include your org in the url and terminate the url with a "/"
        :param username: UserName should be the user ID on the chef server.

        :schema: SecretStoreV1Beta1SpecProviderChef
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderChefAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f64e0832ce2e5bdcc4b76418c1c8f6b250a9915dfc564831df334ef7324e7409)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument server_url", value=server_url, expected_type=type_hints["server_url"])
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "server_url": server_url,
            "username": username,
        }

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderChefAuth":
        '''Auth defines the information necessary to authenticate against chef Server.

        :schema: SecretStoreV1Beta1SpecProviderChef#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderChefAuth", result)

    @builtins.property
    def server_url(self) -> builtins.str:
        '''ServerURL is the chef server URL used to connect to.

        If using orgs you should include your org in the url and terminate the url with a "/"

        :schema: SecretStoreV1Beta1SpecProviderChef#serverUrl
        '''
        result = self._values.get("server_url")
        assert result is not None, "Required property 'server_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def username(self) -> builtins.str:
        '''UserName should be the user ID on the chef server.

        :schema: SecretStoreV1Beta1SpecProviderChef#username
        '''
        result = self._values.get("username")
        assert result is not None, "Required property 'username' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderChef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderChefAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderChefAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderChefAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth defines the information necessary to authenticate against chef Server.

        :param secret_ref: ChefAuthSecretRef holds secret references for chef server login credentials.

        :schema: SecretStoreV1Beta1SpecProviderChefAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderChefAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__841e246e57cfb6bedacfdb7742ddc5fb831a8819df60d0fa000de5a0226dd6af)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "SecretStoreV1Beta1SpecProviderChefAuthSecretRef":
        '''ChefAuthSecretRef holds secret references for chef server login credentials.

        :schema: SecretStoreV1Beta1SpecProviderChefAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderChefAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderChefAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderChefAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"private_key_secret_ref": "privateKeySecretRef"},
)
class SecretStoreV1Beta1SpecProviderChefAuthSecretRef:
    def __init__(
        self,
        *,
        private_key_secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''ChefAuthSecretRef holds secret references for chef server login credentials.

        :param private_key_secret_ref: SecretKey is the Signing Key in PEM format, used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderChefAuthSecretRef
        '''
        if isinstance(private_key_secret_ref, dict):
            private_key_secret_ref = SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef(**private_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ccec2280a7834691b1b1a1e3a425d5af5af629d5c5443ff97529003d2afb968e)
            check_type(argname="argument private_key_secret_ref", value=private_key_secret_ref, expected_type=type_hints["private_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "private_key_secret_ref": private_key_secret_ref,
        }

    @builtins.property
    def private_key_secret_ref(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef":
        '''SecretKey is the Signing Key in PEM format, used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderChefAuthSecretRef#privateKeySecretRef
        '''
        result = self._values.get("private_key_secret_ref")
        assert result is not None, "Required property 'private_key_secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderChefAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretKey is the Signing Key in PEM format, used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb2b4c047fa2fef18f7acb531b269edb3f14b2cadd6b0e431ebd04ac42fdc47e)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderConjur",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "url": "url",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
    },
)
class SecretStoreV1Beta1SpecProviderConjur:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderConjurAuth", typing.Dict[builtins.str, typing.Any]],
        url: builtins.str,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderConjurCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Conjur configures this store to sync secrets using conjur provider.

        :param auth: 
        :param url: 
        :param ca_bundle: 
        :param ca_provider: Used to provide custom certificate authority (CA) certificates for a secret store. The CAProvider points to a Secret or ConfigMap resource that contains a PEM-encoded certificate.

        :schema: SecretStoreV1Beta1SpecProviderConjur
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderConjurAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreV1Beta1SpecProviderConjurCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a6f1ef64695568dabb0aa434d8e5124f9a6fabf324198091c3800f51bf04ab96)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "url": url,
        }
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderConjurAuth":
        '''
        :schema: SecretStoreV1Beta1SpecProviderConjur#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderConjurAuth", result)

    @builtins.property
    def url(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderConjur#url
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderConjur#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderConjurCaProvider"]:
        '''Used to provide custom certificate authority (CA) certificates for a secret store.

        The CAProvider points to a Secret or ConfigMap resource
        that contains a PEM-encoded certificate.

        :schema: SecretStoreV1Beta1SpecProviderConjur#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderConjurCaProvider"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderConjur(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderConjurAuth",
    jsii_struct_bases=[],
    name_mapping={"apikey": "apikey", "jwt": "jwt"},
)
class SecretStoreV1Beta1SpecProviderConjurAuth:
    def __init__(
        self,
        *,
        apikey: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderConjurAuthApikey", typing.Dict[builtins.str, typing.Any]]] = None,
        jwt: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderConjurAuthJwt", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param apikey: 
        :param jwt: 

        :schema: SecretStoreV1Beta1SpecProviderConjurAuth
        '''
        if isinstance(apikey, dict):
            apikey = SecretStoreV1Beta1SpecProviderConjurAuthApikey(**apikey)
        if isinstance(jwt, dict):
            jwt = SecretStoreV1Beta1SpecProviderConjurAuthJwt(**jwt)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1daccbc5c2a79286a9b9e0864bdccf07ed80e3907c3261763ab402ab42a84d3a)
            check_type(argname="argument apikey", value=apikey, expected_type=type_hints["apikey"])
            check_type(argname="argument jwt", value=jwt, expected_type=type_hints["jwt"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if apikey is not None:
            self._values["apikey"] = apikey
        if jwt is not None:
            self._values["jwt"] = jwt

    @builtins.property
    def apikey(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderConjurAuthApikey"]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderConjurAuth#apikey
        '''
        result = self._values.get("apikey")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderConjurAuthApikey"], result)

    @builtins.property
    def jwt(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderConjurAuthJwt"]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderConjurAuth#jwt
        '''
        result = self._values.get("jwt")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderConjurAuthJwt"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderConjurAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderConjurAuthApikey",
    jsii_struct_bases=[],
    name_mapping={
        "account": "account",
        "api_key_ref": "apiKeyRef",
        "user_ref": "userRef",
    },
)
class SecretStoreV1Beta1SpecProviderConjurAuthApikey:
    def __init__(
        self,
        *,
        account: builtins.str,
        api_key_ref: typing.Union["SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef", typing.Dict[builtins.str, typing.Any]],
        user_ref: typing.Union["SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param account: 
        :param api_key_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param user_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthApikey
        '''
        if isinstance(api_key_ref, dict):
            api_key_ref = SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef(**api_key_ref)
        if isinstance(user_ref, dict):
            user_ref = SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef(**user_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ed432fad15be4faae5317037009e654643e8972dfd7b6a08ff91c1caa5eae286)
            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
            check_type(argname="argument api_key_ref", value=api_key_ref, expected_type=type_hints["api_key_ref"])
            check_type(argname="argument user_ref", value=user_ref, expected_type=type_hints["user_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "account": account,
            "api_key_ref": api_key_ref,
            "user_ref": user_ref,
        }

    @builtins.property
    def account(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderConjurAuthApikey#account
        '''
        result = self._values.get("account")
        assert result is not None, "Required property 'account' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_key_ref(self) -> "SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthApikey#apiKeyRef
        '''
        result = self._values.get("api_key_ref")
        assert result is not None, "Required property 'api_key_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef", result)

    @builtins.property
    def user_ref(self) -> "SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthApikey#userRef
        '''
        result = self._values.get("user_ref")
        assert result is not None, "Required property 'user_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderConjurAuthApikey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8346134db38193c187441717727361b3370751b8ab05b5053122a1829a038380)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__81b4efd14e2dff860aa5f6097b35553e68b70a5eaf21be9f22fe6a7b09757c8d)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderConjurAuthJwt",
    jsii_struct_bases=[],
    name_mapping={
        "account": "account",
        "service_id": "serviceId",
        "host_id": "hostId",
        "secret_ref": "secretRef",
        "service_account_ref": "serviceAccountRef",
    },
)
class SecretStoreV1Beta1SpecProviderConjurAuthJwt:
    def __init__(
        self,
        *,
        account: builtins.str,
        service_id: builtins.str,
        host_id: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param account: 
        :param service_id: The conjur authn jwt webservice id.
        :param host_id: Optional HostID for JWT authentication. This may be used depending on how the Conjur JWT authenticator policy is configured.
        :param secret_ref: Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Conjur using the JWT authentication method.
        :param service_account_ref: Optional ServiceAccountRef specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthJwt
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef(**secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a867ef73ed6ba39fbba7a7f6d600f26748884d8042ede3b1085d3dd5f8eb0de3)
            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
            check_type(argname="argument service_id", value=service_id, expected_type=type_hints["service_id"])
            check_type(argname="argument host_id", value=host_id, expected_type=type_hints["host_id"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "account": account,
            "service_id": service_id,
        }
        if host_id is not None:
            self._values["host_id"] = host_id
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def account(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderConjurAuthJwt#account
        '''
        result = self._values.get("account")
        assert result is not None, "Required property 'account' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service_id(self) -> builtins.str:
        '''The conjur authn jwt webservice id.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthJwt#serviceID
        '''
        result = self._values.get("service_id")
        assert result is not None, "Required property 'service_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def host_id(self) -> typing.Optional[builtins.str]:
        '''Optional HostID for JWT authentication.

        This may be used depending
        on how the Conjur JWT authenticator policy is configured.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthJwt#hostId
        '''
        result = self._values.get("host_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef"]:
        '''Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Conjur using the JWT authentication method.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthJwt#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef"]:
        '''Optional ServiceAccountRef specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthJwt#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderConjurAuthJwt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Conjur using the JWT authentication method.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ca4251b9478b27f6c74ac35dcd506c5a62a10be258bda857e096dc3e88fabef3)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional ServiceAccountRef specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d8a90af3fcfda6befe66e319ac7847d46dd60c6a7b559554710a2639a361a52b)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderConjurCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class SecretStoreV1Beta1SpecProviderConjurCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "SecretStoreV1Beta1SpecProviderConjurCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Used to provide custom certificate authority (CA) certificates for a secret store.

        The CAProvider points to a Secret or ConfigMap resource
        that contains a PEM-encoded certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.

        :schema: SecretStoreV1Beta1SpecProviderConjurCaProvider
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__35f27de5668b24c62a9ca0d2d74309a50e26ee7a353e45ab9098d8a0984d75b4)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: SecretStoreV1Beta1SpecProviderConjurCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "SecretStoreV1Beta1SpecProviderConjurCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: SecretStoreV1Beta1SpecProviderConjurCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderConjurCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: SecretStoreV1Beta1SpecProviderConjurCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        Can only be defined when used in a ClusterSecretStore.

        :schema: SecretStoreV1Beta1SpecProviderConjurCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderConjurCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderConjurCaProviderType"
)
class SecretStoreV1Beta1SpecProviderConjurCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: SecretStoreV1Beta1SpecProviderConjurCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDelinea",
    jsii_struct_bases=[],
    name_mapping={
        "client_id": "clientId",
        "client_secret": "clientSecret",
        "tenant": "tenant",
        "tld": "tld",
        "url_template": "urlTemplate",
    },
)
class SecretStoreV1Beta1SpecProviderDelinea:
    def __init__(
        self,
        *,
        client_id: typing.Union["SecretStoreV1Beta1SpecProviderDelineaClientId", typing.Dict[builtins.str, typing.Any]],
        client_secret: typing.Union["SecretStoreV1Beta1SpecProviderDelineaClientSecret", typing.Dict[builtins.str, typing.Any]],
        tenant: builtins.str,
        tld: typing.Optional[builtins.str] = None,
        url_template: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Delinea DevOps Secrets Vault https://docs.delinea.com/online-help/products/devops-secrets-vault/current.

        :param client_id: ClientID is the non-secret part of the credential.
        :param client_secret: ClientSecret is the secret part of the credential.
        :param tenant: Tenant is the chosen hostname / site name.
        :param tld: TLD is based on the server location that was chosen during provisioning. If unset, defaults to "com".
        :param url_template: URLTemplate If unset, defaults to "https://%s.secretsvaultcloud.%s/v1/%s%s".

        :schema: SecretStoreV1Beta1SpecProviderDelinea
        '''
        if isinstance(client_id, dict):
            client_id = SecretStoreV1Beta1SpecProviderDelineaClientId(**client_id)
        if isinstance(client_secret, dict):
            client_secret = SecretStoreV1Beta1SpecProviderDelineaClientSecret(**client_secret)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__601761258fb268462c478cfa85b6e67a4cf9bf930641b4e2e00d2d7a3f2cb9f8)
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret", value=client_secret, expected_type=type_hints["client_secret"])
            check_type(argname="argument tenant", value=tenant, expected_type=type_hints["tenant"])
            check_type(argname="argument tld", value=tld, expected_type=type_hints["tld"])
            check_type(argname="argument url_template", value=url_template, expected_type=type_hints["url_template"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "client_id": client_id,
            "client_secret": client_secret,
            "tenant": tenant,
        }
        if tld is not None:
            self._values["tld"] = tld
        if url_template is not None:
            self._values["url_template"] = url_template

    @builtins.property
    def client_id(self) -> "SecretStoreV1Beta1SpecProviderDelineaClientId":
        '''ClientID is the non-secret part of the credential.

        :schema: SecretStoreV1Beta1SpecProviderDelinea#clientId
        '''
        result = self._values.get("client_id")
        assert result is not None, "Required property 'client_id' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderDelineaClientId", result)

    @builtins.property
    def client_secret(self) -> "SecretStoreV1Beta1SpecProviderDelineaClientSecret":
        '''ClientSecret is the secret part of the credential.

        :schema: SecretStoreV1Beta1SpecProviderDelinea#clientSecret
        '''
        result = self._values.get("client_secret")
        assert result is not None, "Required property 'client_secret' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderDelineaClientSecret", result)

    @builtins.property
    def tenant(self) -> builtins.str:
        '''Tenant is the chosen hostname / site name.

        :schema: SecretStoreV1Beta1SpecProviderDelinea#tenant
        '''
        result = self._values.get("tenant")
        assert result is not None, "Required property 'tenant' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tld(self) -> typing.Optional[builtins.str]:
        '''TLD is based on the server location that was chosen during provisioning.

        If unset, defaults to "com".

        :schema: SecretStoreV1Beta1SpecProviderDelinea#tld
        '''
        result = self._values.get("tld")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def url_template(self) -> typing.Optional[builtins.str]:
        '''URLTemplate If unset, defaults to "https://%s.secretsvaultcloud.%s/v1/%s%s".

        :schema: SecretStoreV1Beta1SpecProviderDelinea#urlTemplate
        '''
        result = self._values.get("url_template")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderDelinea(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDelineaClientId",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class SecretStoreV1Beta1SpecProviderDelineaClientId:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ClientID is the non-secret part of the credential.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderDelineaClientId
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__336dbd3d291848be34ee043e586fa144b2f34f8adaf0e9feca36ceedea1ac75c)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: SecretStoreV1Beta1SpecProviderDelineaClientId#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderDelineaClientId#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderDelineaClientId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5b3cace1d6453ec18e7ecca7917c2a25e5bc6e37590877b17ee084dd5e2dec18)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDelineaClientSecret",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class SecretStoreV1Beta1SpecProviderDelineaClientSecret:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ClientSecret is the secret part of the credential.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderDelineaClientSecret
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9739998751454289fb648dedbf7d2915a9e1f7b24989f27a0cb8ab6c46fca6a5)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: SecretStoreV1Beta1SpecProviderDelineaClientSecret#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderDelineaClientSecret#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderDelineaClientSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b125fc1f8cb496333ab667c850ba2db5a064f7da877a2e734be47bb04171b269)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDevice42",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "host": "host"},
)
class SecretStoreV1Beta1SpecProviderDevice42:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderDevice42Auth", typing.Dict[builtins.str, typing.Any]],
        host: builtins.str,
    ) -> None:
        '''Device42 configures this store to sync secrets using the Device42 provider.

        :param auth: Auth configures how secret-manager authenticates with a Device42 instance.
        :param host: URL configures the Device42 instance URL.

        :schema: SecretStoreV1Beta1SpecProviderDevice42
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderDevice42Auth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bec892a00075ae279bbfe350e8f210e622147988c9d51fc3e4ffaeb67c0371d9)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "host": host,
        }

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderDevice42Auth":
        '''Auth configures how secret-manager authenticates with a Device42 instance.

        :schema: SecretStoreV1Beta1SpecProviderDevice42#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderDevice42Auth", result)

    @builtins.property
    def host(self) -> builtins.str:
        '''URL configures the Device42 instance URL.

        :schema: SecretStoreV1Beta1SpecProviderDevice42#host
        '''
        result = self._values.get("host")
        assert result is not None, "Required property 'host' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderDevice42(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDevice42Auth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderDevice42Auth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderDevice42AuthSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth configures how secret-manager authenticates with a Device42 instance.

        :param secret_ref: 

        :schema: SecretStoreV1Beta1SpecProviderDevice42Auth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderDevice42AuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8ae510a8d74c46acc4bb83849b8c49eff4c5c023fc270e6bf3beb8ddc415041b)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "SecretStoreV1Beta1SpecProviderDevice42AuthSecretRef":
        '''
        :schema: SecretStoreV1Beta1SpecProviderDevice42Auth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderDevice42AuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderDevice42Auth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDevice42AuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"credentials": "credentials"},
)
class SecretStoreV1Beta1SpecProviderDevice42AuthSecretRef:
    def __init__(
        self,
        *,
        credentials: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param credentials: Username / Password is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderDevice42AuthSecretRef
        '''
        if isinstance(credentials, dict):
            credentials = SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials(**credentials)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b0789db669755cbf7c67d3705bf8a107cd61abd3fbc811fcda64ad452cff514)
            check_type(argname="argument credentials", value=credentials, expected_type=type_hints["credentials"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if credentials is not None:
            self._values["credentials"] = credentials

    @builtins.property
    def credentials(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials"]:
        '''Username / Password is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderDevice42AuthSecretRef#credentials
        '''
        result = self._values.get("credentials")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderDevice42AuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Username / Password is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c7d3bf3758c964979e101dcaba1bb98cc90cc0d7665254fd9b3945de7447536c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDoppler",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "config": "config",
        "format": "format",
        "name_transformer": "nameTransformer",
        "project": "project",
    },
)
class SecretStoreV1Beta1SpecProviderDoppler:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderDopplerAuth", typing.Dict[builtins.str, typing.Any]],
        config: typing.Optional[builtins.str] = None,
        format: typing.Optional["SecretStoreV1Beta1SpecProviderDopplerFormat"] = None,
        name_transformer: typing.Optional["SecretStoreV1Beta1SpecProviderDopplerNameTransformer"] = None,
        project: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Doppler configures this store to sync secrets using the Doppler provider.

        :param auth: Auth configures how the Operator authenticates with the Doppler API.
        :param config: Doppler config (required if not using a Service Token).
        :param format: Format enables the downloading of secrets as a file (string).
        :param name_transformer: Environment variable compatible name transforms that change secret names to a different format.
        :param project: Doppler project (required if not using a Service Token).

        :schema: SecretStoreV1Beta1SpecProviderDoppler
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderDopplerAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b0a6de8fe3255ce5836d963fc77fd83dc33e4967030d8a35f633edcc4974573)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument config", value=config, expected_type=type_hints["config"])
            check_type(argname="argument format", value=format, expected_type=type_hints["format"])
            check_type(argname="argument name_transformer", value=name_transformer, expected_type=type_hints["name_transformer"])
            check_type(argname="argument project", value=project, expected_type=type_hints["project"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
        }
        if config is not None:
            self._values["config"] = config
        if format is not None:
            self._values["format"] = format
        if name_transformer is not None:
            self._values["name_transformer"] = name_transformer
        if project is not None:
            self._values["project"] = project

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderDopplerAuth":
        '''Auth configures how the Operator authenticates with the Doppler API.

        :schema: SecretStoreV1Beta1SpecProviderDoppler#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderDopplerAuth", result)

    @builtins.property
    def config(self) -> typing.Optional[builtins.str]:
        '''Doppler config (required if not using a Service Token).

        :schema: SecretStoreV1Beta1SpecProviderDoppler#config
        '''
        result = self._values.get("config")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def format(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderDopplerFormat"]:
        '''Format enables the downloading of secrets as a file (string).

        :schema: SecretStoreV1Beta1SpecProviderDoppler#format
        '''
        result = self._values.get("format")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderDopplerFormat"], result)

    @builtins.property
    def name_transformer(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderDopplerNameTransformer"]:
        '''Environment variable compatible name transforms that change secret names to a different format.

        :schema: SecretStoreV1Beta1SpecProviderDoppler#nameTransformer
        '''
        result = self._values.get("name_transformer")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderDopplerNameTransformer"], result)

    @builtins.property
    def project(self) -> typing.Optional[builtins.str]:
        '''Doppler project (required if not using a Service Token).

        :schema: SecretStoreV1Beta1SpecProviderDoppler#project
        '''
        result = self._values.get("project")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderDoppler(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDopplerAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderDopplerAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth configures how the Operator authenticates with the Doppler API.

        :param secret_ref: 

        :schema: SecretStoreV1Beta1SpecProviderDopplerAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e8841d8359ddc01188720737ada5a706c1619c22e7425a5d663b94eea33309b7)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef":
        '''
        :schema: SecretStoreV1Beta1SpecProviderDopplerAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderDopplerAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"doppler_token": "dopplerToken"},
)
class SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef:
    def __init__(
        self,
        *,
        doppler_token: typing.Union["SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param doppler_token: The DopplerToken is used for authentication. See https://docs.doppler.com/reference/api#authentication for auth token types. The Key attribute defaults to dopplerToken if not specified.

        :schema: SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef
        '''
        if isinstance(doppler_token, dict):
            doppler_token = SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken(**doppler_token)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4731b7ff6b5f7e1c67462193a0401491586b1d1d2101fea57353fb824e4ced21)
            check_type(argname="argument doppler_token", value=doppler_token, expected_type=type_hints["doppler_token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "doppler_token": doppler_token,
        }

    @builtins.property
    def doppler_token(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken":
        '''The DopplerToken is used for authentication.

        See https://docs.doppler.com/reference/api#authentication for auth token types.
        The Key attribute defaults to dopplerToken if not specified.

        :schema: SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef#dopplerToken
        '''
        result = self._values.get("doppler_token")
        assert result is not None, "Required property 'doppler_token' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The DopplerToken is used for authentication.

        See https://docs.doppler.com/reference/api#authentication for auth token types.
        The Key attribute defaults to dopplerToken if not specified.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a1fea7caeb42148ebb3eb2e91a01eb769cb2308b62b93143a35ea56f351310c4)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDopplerFormat")
class SecretStoreV1Beta1SpecProviderDopplerFormat(enum.Enum):
    '''Format enables the downloading of secrets as a file (string).

    :schema: SecretStoreV1Beta1SpecProviderDopplerFormat
    '''

    JSON = "JSON"
    '''json.'''
    DOTNET_HYPHEN_JSON = "DOTNET_HYPHEN_JSON"
    '''dotnet-json.'''
    ENV = "ENV"
    '''env.'''
    YAML = "YAML"
    '''yaml.'''
    DOCKER = "DOCKER"
    '''docker.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDopplerNameTransformer"
)
class SecretStoreV1Beta1SpecProviderDopplerNameTransformer(enum.Enum):
    '''Environment variable compatible name transforms that change secret names to a different format.

    :schema: SecretStoreV1Beta1SpecProviderDopplerNameTransformer
    '''

    UPPER_HYPHEN_CAMEL = "UPPER_HYPHEN_CAMEL"
    '''upper-camel.'''
    CAMEL = "CAMEL"
    '''camel.'''
    LOWER_HYPHEN_SNAKE = "LOWER_HYPHEN_SNAKE"
    '''lower-snake.'''
    TF_HYPHEN_VAR = "TF_HYPHEN_VAR"
    '''tf-var.'''
    DOTNET_HYPHEN_ENV = "DOTNET_HYPHEN_ENV"
    '''dotnet-env.'''
    LOWER_HYPHEN_KEBAB = "LOWER_HYPHEN_KEBAB"
    '''lower-kebab.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderFake",
    jsii_struct_bases=[],
    name_mapping={"data": "data"},
)
class SecretStoreV1Beta1SpecProviderFake:
    def __init__(
        self,
        *,
        data: typing.Sequence[typing.Union["SecretStoreV1Beta1SpecProviderFakeData", typing.Dict[builtins.str, typing.Any]]],
    ) -> None:
        '''Fake configures a store with static key/value pairs.

        :param data: 

        :schema: SecretStoreV1Beta1SpecProviderFake
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d93a6c92c9c0b83f9c3884e6f384592e50aa4a8ce8673c5eb495ba612323373b)
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "data": data,
        }

    @builtins.property
    def data(self) -> typing.List["SecretStoreV1Beta1SpecProviderFakeData"]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderFake#data
        '''
        result = self._values.get("data")
        assert result is not None, "Required property 'data' is missing"
        return typing.cast(typing.List["SecretStoreV1Beta1SpecProviderFakeData"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderFake(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderFakeData",
    jsii_struct_bases=[],
    name_mapping={
        "key": "key",
        "value": "value",
        "value_map": "valueMap",
        "version": "version",
    },
)
class SecretStoreV1Beta1SpecProviderFakeData:
    def __init__(
        self,
        *,
        key: builtins.str,
        value: typing.Optional[builtins.str] = None,
        value_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param key: 
        :param value: 
        :param value_map: Deprecated: ValueMap is deprecated and is intended to be removed in the future, use the ``value`` field instead.
        :param version: 

        :schema: SecretStoreV1Beta1SpecProviderFakeData
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29a0c184f90e7b31b38a333f23beda06732b2fd6367a56e1d22e214b8eebaeac)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            check_type(argname="argument value_map", value=value_map, expected_type=type_hints["value_map"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "key": key,
        }
        if value is not None:
            self._values["value"] = value
        if value_map is not None:
            self._values["value_map"] = value_map
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderFakeData#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderFakeData#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value_map(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Deprecated: ValueMap is deprecated and is intended to be removed in the future, use the ``value`` field instead.

        :schema: SecretStoreV1Beta1SpecProviderFakeData#valueMap
        '''
        result = self._values.get("value_map")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderFakeData#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderFakeData(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderFortanix",
    jsii_struct_bases=[],
    name_mapping={"api_key": "apiKey", "api_url": "apiUrl"},
)
class SecretStoreV1Beta1SpecProviderFortanix:
    def __init__(
        self,
        *,
        api_key: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderFortanixApiKey", typing.Dict[builtins.str, typing.Any]]] = None,
        api_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Fortanix configures this store to sync secrets using the Fortanix provider.

        :param api_key: APIKey is the API token to access SDKMS Applications.
        :param api_url: APIURL is the URL of SDKMS API. Defaults to ``sdkms.fortanix.com``. Default: sdkms.fortanix.com`.

        :schema: SecretStoreV1Beta1SpecProviderFortanix
        '''
        if isinstance(api_key, dict):
            api_key = SecretStoreV1Beta1SpecProviderFortanixApiKey(**api_key)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06565003520ed3b4b182cebc0df0782c7397bedc4434807ad14ffd5aec404b33)
            check_type(argname="argument api_key", value=api_key, expected_type=type_hints["api_key"])
            check_type(argname="argument api_url", value=api_url, expected_type=type_hints["api_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if api_key is not None:
            self._values["api_key"] = api_key
        if api_url is not None:
            self._values["api_url"] = api_url

    @builtins.property
    def api_key(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderFortanixApiKey"]:
        '''APIKey is the API token to access SDKMS Applications.

        :schema: SecretStoreV1Beta1SpecProviderFortanix#apiKey
        '''
        result = self._values.get("api_key")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderFortanixApiKey"], result)

    @builtins.property
    def api_url(self) -> typing.Optional[builtins.str]:
        '''APIURL is the URL of SDKMS API.

        Defaults to ``sdkms.fortanix.com``.

        :default: sdkms.fortanix.com`.

        :schema: SecretStoreV1Beta1SpecProviderFortanix#apiUrl
        '''
        result = self._values.get("api_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderFortanix(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderFortanixApiKey",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderFortanixApiKey:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''APIKey is the API token to access SDKMS Applications.

        :param secret_ref: SecretRef is a reference to a secret containing the SDKMS API Key.

        :schema: SecretStoreV1Beta1SpecProviderFortanixApiKey
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cd5c80b0001695a1fb0fcff73f4aeb88106fef86a38f6efecd70f8518b4c0535)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef"]:
        '''SecretRef is a reference to a secret containing the SDKMS API Key.

        :schema: SecretStoreV1Beta1SpecProviderFortanixApiKey#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderFortanixApiKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef is a reference to a secret containing the SDKMS API Key.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e8e0fb3b561b24e961f7cc53b7d7f52995c9a1587f2622d98c62cbd10481f550)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderGcpsm",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "location": "location", "project_id": "projectId"},
)
class SecretStoreV1Beta1SpecProviderGcpsm:
    def __init__(
        self,
        *,
        auth: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderGcpsmAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        location: typing.Optional[builtins.str] = None,
        project_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.

        :param auth: Auth defines the information necessary to authenticate against GCP.
        :param location: Location optionally defines a location for a secret.
        :param project_id: ProjectID project where secret is located.

        :schema: SecretStoreV1Beta1SpecProviderGcpsm
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderGcpsmAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c3ecb75384dd8f76bb3e29feed63aaf82819c4952cd30b31a059d987820d165a)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument location", value=location, expected_type=type_hints["location"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if auth is not None:
            self._values["auth"] = auth
        if location is not None:
            self._values["location"] = location
        if project_id is not None:
            self._values["project_id"] = project_id

    @builtins.property
    def auth(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderGcpsmAuth"]:
        '''Auth defines the information necessary to authenticate against GCP.

        :schema: SecretStoreV1Beta1SpecProviderGcpsm#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderGcpsmAuth"], result)

    @builtins.property
    def location(self) -> typing.Optional[builtins.str]:
        '''Location optionally defines a location for a secret.

        :schema: SecretStoreV1Beta1SpecProviderGcpsm#location
        '''
        result = self._values.get("location")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def project_id(self) -> typing.Optional[builtins.str]:
        '''ProjectID project where secret is located.

        :schema: SecretStoreV1Beta1SpecProviderGcpsm#projectID
        '''
        result = self._values.get("project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderGcpsm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderGcpsmAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "workload_identity": "workloadIdentity"},
)
class SecretStoreV1Beta1SpecProviderGcpsmAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        workload_identity: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against GCP.

        :param secret_ref: 
        :param workload_identity: 

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef(**secret_ref)
        if isinstance(workload_identity, dict):
            workload_identity = SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity(**workload_identity)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ece6b6ecf5d7444ab38286c886b12f5ae237b3e61e0410bf7a06e137cc5ddcbf)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument workload_identity", value=workload_identity, expected_type=type_hints["workload_identity"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if workload_identity is not None:
            self._values["workload_identity"] = workload_identity

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef"]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef"], result)

    @builtins.property
    def workload_identity(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity"]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuth#workloadIdentity
        '''
        result = self._values.get("workload_identity")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderGcpsmAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"secret_access_key_secret_ref": "secretAccessKeySecretRef"},
)
class SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef:
    def __init__(
        self,
        *,
        secret_access_key_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param secret_access_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef
        '''
        if isinstance(secret_access_key_secret_ref, dict):
            secret_access_key_secret_ref = SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(**secret_access_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c1368bb18127d39725cce7022c44341150fd77fd75a76890278cb64f891d90cc)
            check_type(argname="argument secret_access_key_secret_ref", value=secret_access_key_secret_ref, expected_type=type_hints["secret_access_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_access_key_secret_ref is not None:
            self._values["secret_access_key_secret_ref"] = secret_access_key_secret_ref

    @builtins.property
    def secret_access_key_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef#secretAccessKeySecretRef
        '''
        result = self._values.get("secret_access_key_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__364aa3a256ffb1db5e8aad80987b84984403cd06f707862457451651798f5d95)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity",
    jsii_struct_bases=[],
    name_mapping={
        "cluster_location": "clusterLocation",
        "cluster_name": "clusterName",
        "service_account_ref": "serviceAccountRef",
        "cluster_project_id": "clusterProjectId",
    },
)
class SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity:
    def __init__(
        self,
        *,
        cluster_location: builtins.str,
        cluster_name: builtins.str,
        service_account_ref: typing.Union["SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef", typing.Dict[builtins.str, typing.Any]],
        cluster_project_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param cluster_location: 
        :param cluster_name: 
        :param service_account_ref: A reference to a ServiceAccount resource.
        :param cluster_project_id: 

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b5ffa9b3599a682d44be37badcece2843f9e11c0c3af162dcd58dd5faa12281)
            check_type(argname="argument cluster_location", value=cluster_location, expected_type=type_hints["cluster_location"])
            check_type(argname="argument cluster_name", value=cluster_name, expected_type=type_hints["cluster_name"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument cluster_project_id", value=cluster_project_id, expected_type=type_hints["cluster_project_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cluster_location": cluster_location,
            "cluster_name": cluster_name,
            "service_account_ref": service_account_ref,
        }
        if cluster_project_id is not None:
            self._values["cluster_project_id"] = cluster_project_id

    @builtins.property
    def cluster_location(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterLocation
        '''
        result = self._values.get("cluster_location")
        assert result is not None, "Required property 'cluster_location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cluster_name(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterName
        '''
        result = self._values.get("cluster_name")
        assert result is not None, "Required property 'cluster_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef":
        '''A reference to a ServiceAccount resource.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        assert result is not None, "Required property 'service_account_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef", result)

    @builtins.property
    def cluster_project_id(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterProjectID
        '''
        result = self._values.get("cluster_project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c85d822f9260d7b2e71fd3554e55b1fb5aafb3791ffbc13548a56267364e098e)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderGitlab",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "environment": "environment",
        "group_i_ds": "groupIDs",
        "inherit_from_groups": "inheritFromGroups",
        "project_id": "projectId",
        "url": "url",
    },
)
class SecretStoreV1Beta1SpecProviderGitlab:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderGitlabAuth", typing.Dict[builtins.str, typing.Any]],
        environment: typing.Optional[builtins.str] = None,
        group_i_ds: typing.Optional[typing.Sequence[builtins.str]] = None,
        inherit_from_groups: typing.Optional[builtins.bool] = None,
        project_id: typing.Optional[builtins.str] = None,
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''GitLab configures this store to sync secrets using GitLab Variables provider.

        :param auth: Auth configures how secret-manager authenticates with a GitLab instance.
        :param environment: Environment environment_scope of gitlab CI/CD variables (Please see https://docs.gitlab.com/ee/ci/environments/#create-a-static-environment on how to create environments).
        :param group_i_ds: GroupIDs specify, which gitlab groups to pull secrets from. Group secrets are read from left to right followed by the project variables.
        :param inherit_from_groups: InheritFromGroups specifies whether parent groups should be discovered and checked for secrets.
        :param project_id: ProjectID specifies a project where secrets are located.
        :param url: URL configures the GitLab instance URL. Defaults to https://gitlab.com/. Default: https://gitlab.com/.

        :schema: SecretStoreV1Beta1SpecProviderGitlab
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderGitlabAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b398588d0e2703fe1f91c36ee1116bd611797b0d35e42ae69ec6f3a660a899aa)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
            check_type(argname="argument group_i_ds", value=group_i_ds, expected_type=type_hints["group_i_ds"])
            check_type(argname="argument inherit_from_groups", value=inherit_from_groups, expected_type=type_hints["inherit_from_groups"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
        }
        if environment is not None:
            self._values["environment"] = environment
        if group_i_ds is not None:
            self._values["group_i_ds"] = group_i_ds
        if inherit_from_groups is not None:
            self._values["inherit_from_groups"] = inherit_from_groups
        if project_id is not None:
            self._values["project_id"] = project_id
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderGitlabAuth":
        '''Auth configures how secret-manager authenticates with a GitLab instance.

        :schema: SecretStoreV1Beta1SpecProviderGitlab#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderGitlabAuth", result)

    @builtins.property
    def environment(self) -> typing.Optional[builtins.str]:
        '''Environment environment_scope of gitlab CI/CD variables (Please see https://docs.gitlab.com/ee/ci/environments/#create-a-static-environment on how to create environments).

        :schema: SecretStoreV1Beta1SpecProviderGitlab#environment
        '''
        result = self._values.get("environment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def group_i_ds(self) -> typing.Optional[typing.List[builtins.str]]:
        '''GroupIDs specify, which gitlab groups to pull secrets from.

        Group secrets are read from left to right followed by the project variables.

        :schema: SecretStoreV1Beta1SpecProviderGitlab#groupIDs
        '''
        result = self._values.get("group_i_ds")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def inherit_from_groups(self) -> typing.Optional[builtins.bool]:
        '''InheritFromGroups specifies whether parent groups should be discovered and checked for secrets.

        :schema: SecretStoreV1Beta1SpecProviderGitlab#inheritFromGroups
        '''
        result = self._values.get("inherit_from_groups")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def project_id(self) -> typing.Optional[builtins.str]:
        '''ProjectID specifies a project where secrets are located.

        :schema: SecretStoreV1Beta1SpecProviderGitlab#projectID
        '''
        result = self._values.get("project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''URL configures the GitLab instance URL.

        Defaults to https://gitlab.com/.

        :default: https://gitlab.com/.

        :schema: SecretStoreV1Beta1SpecProviderGitlab#url
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderGitlab(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderGitlabAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderGitlabAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth configures how secret-manager authenticates with a GitLab instance.

        :param secret_ref: 

        :schema: SecretStoreV1Beta1SpecProviderGitlabAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__20deece46bd316fa7ee77d2cd3ef1138ae550b6a6852687ee249f45373fb65bb)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef":
        '''
        :schema: SecretStoreV1Beta1SpecProviderGitlabAuth#SecretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderGitlabAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"access_token": "accessToken"},
)
class SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef:
    def __init__(
        self,
        *,
        access_token: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param access_token: AccessToken is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef
        '''
        if isinstance(access_token, dict):
            access_token = SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken(**access_token)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9cc2000edfcefc04ea18587adbfe7cc7cccc9ee68e326e76edb3ac39b2d4e766)
            check_type(argname="argument access_token", value=access_token, expected_type=type_hints["access_token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if access_token is not None:
            self._values["access_token"] = access_token

    @builtins.property
    def access_token(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken"]:
        '''AccessToken is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef#accessToken
        '''
        result = self._values.get("access_token")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AccessToken is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d5024106fecce7059ce27d090bc0293130bbb172a7cd76a1e71a78bb7c515931)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderIbm",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "service_url": "serviceUrl"},
)
class SecretStoreV1Beta1SpecProviderIbm:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderIbmAuth", typing.Dict[builtins.str, typing.Any]],
        service_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''IBM configures this store to sync secrets using IBM Cloud provider.

        :param auth: Auth configures how secret-manager authenticates with the IBM secrets manager.
        :param service_url: ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance.

        :schema: SecretStoreV1Beta1SpecProviderIbm
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderIbmAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d0267097db94e6dd73fdfcea08ec320aa5df8c05909723119660daa4697d4e89)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument service_url", value=service_url, expected_type=type_hints["service_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
        }
        if service_url is not None:
            self._values["service_url"] = service_url

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderIbmAuth":
        '''Auth configures how secret-manager authenticates with the IBM secrets manager.

        :schema: SecretStoreV1Beta1SpecProviderIbm#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderIbmAuth", result)

    @builtins.property
    def service_url(self) -> typing.Optional[builtins.str]:
        '''ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance.

        :schema: SecretStoreV1Beta1SpecProviderIbm#serviceUrl
        '''
        result = self._values.get("service_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderIbm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderIbmAuth",
    jsii_struct_bases=[],
    name_mapping={"container_auth": "containerAuth", "secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderIbmAuth:
    def __init__(
        self,
        *,
        container_auth: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderIbmAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how secret-manager authenticates with the IBM secrets manager.

        :param container_auth: IBM Container-based auth with IAM Trusted Profile.
        :param secret_ref: 

        :schema: SecretStoreV1Beta1SpecProviderIbmAuth
        '''
        if isinstance(container_auth, dict):
            container_auth = SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth(**container_auth)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderIbmAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7442a2e4e22992bf0d9ad03fd141ee4789ea32cf7e9bf2c281bf6c2de12799ff)
            check_type(argname="argument container_auth", value=container_auth, expected_type=type_hints["container_auth"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if container_auth is not None:
            self._values["container_auth"] = container_auth
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def container_auth(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth"]:
        '''IBM Container-based auth with IAM Trusted Profile.

        :schema: SecretStoreV1Beta1SpecProviderIbmAuth#containerAuth
        '''
        result = self._values.get("container_auth")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderIbmAuthSecretRef"]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderIbmAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderIbmAuthSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderIbmAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth",
    jsii_struct_bases=[],
    name_mapping={
        "profile": "profile",
        "iam_endpoint": "iamEndpoint",
        "token_location": "tokenLocation",
    },
)
class SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth:
    def __init__(
        self,
        *,
        profile: builtins.str,
        iam_endpoint: typing.Optional[builtins.str] = None,
        token_location: typing.Optional[builtins.str] = None,
    ) -> None:
        '''IBM Container-based auth with IAM Trusted Profile.

        :param profile: the IBM Trusted Profile.
        :param iam_endpoint: 
        :param token_location: Location the token is mounted on the pod.

        :schema: SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8eb8570d22a9232e49428aadfeff673e7c1bb95db459a128da09d18dd9a877f4)
            check_type(argname="argument profile", value=profile, expected_type=type_hints["profile"])
            check_type(argname="argument iam_endpoint", value=iam_endpoint, expected_type=type_hints["iam_endpoint"])
            check_type(argname="argument token_location", value=token_location, expected_type=type_hints["token_location"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "profile": profile,
        }
        if iam_endpoint is not None:
            self._values["iam_endpoint"] = iam_endpoint
        if token_location is not None:
            self._values["token_location"] = token_location

    @builtins.property
    def profile(self) -> builtins.str:
        '''the IBM Trusted Profile.

        :schema: SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#profile
        '''
        result = self._values.get("profile")
        assert result is not None, "Required property 'profile' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def iam_endpoint(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#iamEndpoint
        '''
        result = self._values.get("iam_endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def token_location(self) -> typing.Optional[builtins.str]:
        '''Location the token is mounted on the pod.

        :schema: SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#tokenLocation
        '''
        result = self._values.get("token_location")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderIbmAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"secret_api_key_secret_ref": "secretApiKeySecretRef"},
)
class SecretStoreV1Beta1SpecProviderIbmAuthSecretRef:
    def __init__(
        self,
        *,
        secret_api_key_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param secret_api_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderIbmAuthSecretRef
        '''
        if isinstance(secret_api_key_secret_ref, dict):
            secret_api_key_secret_ref = SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef(**secret_api_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f9228a280e6a7ce80f5fcf86b911b502c8f53a339a0ca0037fc7b01e92346ab2)
            check_type(argname="argument secret_api_key_secret_ref", value=secret_api_key_secret_ref, expected_type=type_hints["secret_api_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_api_key_secret_ref is not None:
            self._values["secret_api_key_secret_ref"] = secret_api_key_secret_ref

    @builtins.property
    def secret_api_key_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderIbmAuthSecretRef#secretApiKeySecretRef
        '''
        result = self._values.get("secret_api_key_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderIbmAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b80417f3083dcb5866dfa1ab42fde962e8a28bdfaebc05ed9c45e28155f05db3)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderInfisical",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "secrets_scope": "secretsScope",
        "host_api": "hostApi",
    },
)
class SecretStoreV1Beta1SpecProviderInfisical:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderInfisicalAuth", typing.Dict[builtins.str, typing.Any]],
        secrets_scope: typing.Union["SecretStoreV1Beta1SpecProviderInfisicalSecretsScope", typing.Dict[builtins.str, typing.Any]],
        host_api: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Infisical configures this store to sync secrets using the Infisical provider.

        :param auth: Auth configures how the Operator authenticates with the Infisical API.
        :param secrets_scope: 
        :param host_api: 

        :schema: SecretStoreV1Beta1SpecProviderInfisical
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderInfisicalAuth(**auth)
        if isinstance(secrets_scope, dict):
            secrets_scope = SecretStoreV1Beta1SpecProviderInfisicalSecretsScope(**secrets_scope)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5696fe83de35c838526a48deb02994a29a952de6385b449b25917008ffd77663)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument secrets_scope", value=secrets_scope, expected_type=type_hints["secrets_scope"])
            check_type(argname="argument host_api", value=host_api, expected_type=type_hints["host_api"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "secrets_scope": secrets_scope,
        }
        if host_api is not None:
            self._values["host_api"] = host_api

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderInfisicalAuth":
        '''Auth configures how the Operator authenticates with the Infisical API.

        :schema: SecretStoreV1Beta1SpecProviderInfisical#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderInfisicalAuth", result)

    @builtins.property
    def secrets_scope(self) -> "SecretStoreV1Beta1SpecProviderInfisicalSecretsScope":
        '''
        :schema: SecretStoreV1Beta1SpecProviderInfisical#secretsScope
        '''
        result = self._values.get("secrets_scope")
        assert result is not None, "Required property 'secrets_scope' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderInfisicalSecretsScope", result)

    @builtins.property
    def host_api(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderInfisical#hostAPI
        '''
        result = self._values.get("host_api")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderInfisical(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderInfisicalAuth",
    jsii_struct_bases=[],
    name_mapping={"universal_auth_credentials": "universalAuthCredentials"},
)
class SecretStoreV1Beta1SpecProviderInfisicalAuth:
    def __init__(
        self,
        *,
        universal_auth_credentials: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how the Operator authenticates with the Infisical API.

        :param universal_auth_credentials: 

        :schema: SecretStoreV1Beta1SpecProviderInfisicalAuth
        '''
        if isinstance(universal_auth_credentials, dict):
            universal_auth_credentials = SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials(**universal_auth_credentials)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__868ceb988e2e935a9fa34a03db92f4ab714652d3311b8aba10406461aa1046bf)
            check_type(argname="argument universal_auth_credentials", value=universal_auth_credentials, expected_type=type_hints["universal_auth_credentials"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if universal_auth_credentials is not None:
            self._values["universal_auth_credentials"] = universal_auth_credentials

    @builtins.property
    def universal_auth_credentials(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials"]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderInfisicalAuth#universalAuthCredentials
        '''
        result = self._values.get("universal_auth_credentials")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderInfisicalAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials",
    jsii_struct_bases=[],
    name_mapping={"client_id": "clientId", "client_secret": "clientSecret"},
)
class SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials:
    def __init__(
        self,
        *,
        client_id: typing.Union["SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId", typing.Dict[builtins.str, typing.Any]],
        client_secret: typing.Union["SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param client_id: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param client_secret: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials
        '''
        if isinstance(client_id, dict):
            client_id = SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId(**client_id)
        if isinstance(client_secret, dict):
            client_secret = SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret(**client_secret)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2cf2a05ff999605fe493a7341d0a3844820d163b6009e97b4f72c25265b480cc)
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret", value=client_secret, expected_type=type_hints["client_secret"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "client_id": client_id,
            "client_secret": client_secret,
        }

    @builtins.property
    def client_id(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials#clientId
        '''
        result = self._values.get("client_id")
        assert result is not None, "Required property 'client_id' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId", result)

    @builtins.property
    def client_secret(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials#clientSecret
        '''
        result = self._values.get("client_secret")
        assert result is not None, "Required property 'client_secret' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cafb1b4ef446e23929708e926c3c8fa1b4e9ac2aefec43ec17f969b7821f5c6a)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ed964da6cd2e6f440e3adc9259840a6c0e3abd7880e1cd086947e3afe6ca563e)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderInfisicalSecretsScope",
    jsii_struct_bases=[],
    name_mapping={
        "environment_slug": "environmentSlug",
        "project_slug": "projectSlug",
        "recursive": "recursive",
        "secrets_path": "secretsPath",
    },
)
class SecretStoreV1Beta1SpecProviderInfisicalSecretsScope:
    def __init__(
        self,
        *,
        environment_slug: builtins.str,
        project_slug: builtins.str,
        recursive: typing.Optional[builtins.bool] = None,
        secrets_path: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param environment_slug: 
        :param project_slug: 
        :param recursive: 
        :param secrets_path: 

        :schema: SecretStoreV1Beta1SpecProviderInfisicalSecretsScope
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__761099bf5f2bb3b5a6bd0a405b68fbdba0412fe5522d7ebddc1daaed13b2874c)
            check_type(argname="argument environment_slug", value=environment_slug, expected_type=type_hints["environment_slug"])
            check_type(argname="argument project_slug", value=project_slug, expected_type=type_hints["project_slug"])
            check_type(argname="argument recursive", value=recursive, expected_type=type_hints["recursive"])
            check_type(argname="argument secrets_path", value=secrets_path, expected_type=type_hints["secrets_path"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "environment_slug": environment_slug,
            "project_slug": project_slug,
        }
        if recursive is not None:
            self._values["recursive"] = recursive
        if secrets_path is not None:
            self._values["secrets_path"] = secrets_path

    @builtins.property
    def environment_slug(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderInfisicalSecretsScope#environmentSlug
        '''
        result = self._values.get("environment_slug")
        assert result is not None, "Required property 'environment_slug' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def project_slug(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderInfisicalSecretsScope#projectSlug
        '''
        result = self._values.get("project_slug")
        assert result is not None, "Required property 'project_slug' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def recursive(self) -> typing.Optional[builtins.bool]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderInfisicalSecretsScope#recursive
        '''
        result = self._values.get("recursive")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def secrets_path(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderInfisicalSecretsScope#secretsPath
        '''
        result = self._values.get("secrets_path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderInfisicalSecretsScope(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKeepersecurity",
    jsii_struct_bases=[],
    name_mapping={"auth_ref": "authRef", "folder_id": "folderId"},
)
class SecretStoreV1Beta1SpecProviderKeepersecurity:
    def __init__(
        self,
        *,
        auth_ref: typing.Union["SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef", typing.Dict[builtins.str, typing.Any]],
        folder_id: builtins.str,
    ) -> None:
        '''KeeperSecurity configures this store to sync secrets using the KeeperSecurity provider.

        :param auth_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param folder_id: 

        :schema: SecretStoreV1Beta1SpecProviderKeepersecurity
        '''
        if isinstance(auth_ref, dict):
            auth_ref = SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef(**auth_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__efc55607e2e04fd40e28fde54ad8ce8275d7b1108f41fce4ccd79d1815a9bef8)
            check_type(argname="argument auth_ref", value=auth_ref, expected_type=type_hints["auth_ref"])
            check_type(argname="argument folder_id", value=folder_id, expected_type=type_hints["folder_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth_ref": auth_ref,
            "folder_id": folder_id,
        }

    @builtins.property
    def auth_ref(self) -> "SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderKeepersecurity#authRef
        '''
        result = self._values.get("auth_ref")
        assert result is not None, "Required property 'auth_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef", result)

    @builtins.property
    def folder_id(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderKeepersecurity#folderID
        '''
        result = self._values.get("folder_id")
        assert result is not None, "Required property 'folder_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKeepersecurity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8bcdaa1ea712d368e5211f754c07a2a5b0ea64ab766fa4ec6d4b63c9269a5540)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetes",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "auth_ref": "authRef",
        "remote_namespace": "remoteNamespace",
        "server": "server",
    },
)
class SecretStoreV1Beta1SpecProviderKubernetes:
    def __init__(
        self,
        *,
        auth: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKubernetesAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        auth_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKubernetesAuthRef", typing.Dict[builtins.str, typing.Any]]] = None,
        remote_namespace: typing.Optional[builtins.str] = None,
        server: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKubernetesServer", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.

        :param auth: Auth configures how secret-manager authenticates with a Kubernetes instance.
        :param auth_ref: A reference to a secret that contains the auth information.
        :param remote_namespace: Remote namespace to fetch the secrets from.
        :param server: configures the Kubernetes server Address.

        :schema: SecretStoreV1Beta1SpecProviderKubernetes
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderKubernetesAuth(**auth)
        if isinstance(auth_ref, dict):
            auth_ref = SecretStoreV1Beta1SpecProviderKubernetesAuthRef(**auth_ref)
        if isinstance(server, dict):
            server = SecretStoreV1Beta1SpecProviderKubernetesServer(**server)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0eb51a2fef268ed31500d17e2a6bb9611a7ee40a9b4d213ac395b958c064a2f0)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument auth_ref", value=auth_ref, expected_type=type_hints["auth_ref"])
            check_type(argname="argument remote_namespace", value=remote_namespace, expected_type=type_hints["remote_namespace"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if auth is not None:
            self._values["auth"] = auth
        if auth_ref is not None:
            self._values["auth_ref"] = auth_ref
        if remote_namespace is not None:
            self._values["remote_namespace"] = remote_namespace
        if server is not None:
            self._values["server"] = server

    @builtins.property
    def auth(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuth"]:
        '''Auth configures how secret-manager authenticates with a Kubernetes instance.

        :schema: SecretStoreV1Beta1SpecProviderKubernetes#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuth"], result)

    @builtins.property
    def auth_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthRef"]:
        '''A reference to a secret that contains the auth information.

        :schema: SecretStoreV1Beta1SpecProviderKubernetes#authRef
        '''
        result = self._values.get("auth_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthRef"], result)

    @builtins.property
    def remote_namespace(self) -> typing.Optional[builtins.str]:
        '''Remote namespace to fetch the secrets from.

        :schema: SecretStoreV1Beta1SpecProviderKubernetes#remoteNamespace
        '''
        result = self._values.get("remote_namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def server(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesServer"]:
        '''configures the Kubernetes server Address.

        :schema: SecretStoreV1Beta1SpecProviderKubernetes#server
        '''
        result = self._values.get("server")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesServer"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesAuth",
    jsii_struct_bases=[],
    name_mapping={
        "cert": "cert",
        "service_account": "serviceAccount",
        "token": "token",
    },
)
class SecretStoreV1Beta1SpecProviderKubernetesAuth:
    def __init__(
        self,
        *,
        cert: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKubernetesAuthCert", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount", typing.Dict[builtins.str, typing.Any]]] = None,
        token: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKubernetesAuthToken", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how secret-manager authenticates with a Kubernetes instance.

        :param cert: has both clientCert and clientKey as secretKeySelector.
        :param service_account: points to a service account that should be used for authentication.
        :param token: use static token to authenticate with.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuth
        '''
        if isinstance(cert, dict):
            cert = SecretStoreV1Beta1SpecProviderKubernetesAuthCert(**cert)
        if isinstance(service_account, dict):
            service_account = SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount(**service_account)
        if isinstance(token, dict):
            token = SecretStoreV1Beta1SpecProviderKubernetesAuthToken(**token)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4febf2b0eb0fdcdfa0b17099ffe8a84a5a1941668925d672dbf362202f1660e3)
            check_type(argname="argument cert", value=cert, expected_type=type_hints["cert"])
            check_type(argname="argument service_account", value=service_account, expected_type=type_hints["service_account"])
            check_type(argname="argument token", value=token, expected_type=type_hints["token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cert is not None:
            self._values["cert"] = cert
        if service_account is not None:
            self._values["service_account"] = service_account
        if token is not None:
            self._values["token"] = token

    @builtins.property
    def cert(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthCert"]:
        '''has both clientCert and clientKey as secretKeySelector.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuth#cert
        '''
        result = self._values.get("cert")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthCert"], result)

    @builtins.property
    def service_account(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount"]:
        '''points to a service account that should be used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuth#serviceAccount
        '''
        result = self._values.get("service_account")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount"], result)

    @builtins.property
    def token(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthToken"]:
        '''use static token to authenticate with.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuth#token
        '''
        result = self._values.get("token")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetesAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesAuthCert",
    jsii_struct_bases=[],
    name_mapping={"client_cert": "clientCert", "client_key": "clientKey"},
)
class SecretStoreV1Beta1SpecProviderKubernetesAuthCert:
    def __init__(
        self,
        *,
        client_cert: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert", typing.Dict[builtins.str, typing.Any]]] = None,
        client_key: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''has both clientCert and clientKey as secretKeySelector.

        :param client_cert: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param client_key: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCert
        '''
        if isinstance(client_cert, dict):
            client_cert = SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert(**client_cert)
        if isinstance(client_key, dict):
            client_key = SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey(**client_key)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__18a4079b17dfbbd744c6cdfc7ae7b0d97805f749bb4c0b3e9619dea0f53e5c7a)
            check_type(argname="argument client_cert", value=client_cert, expected_type=type_hints["client_cert"])
            check_type(argname="argument client_key", value=client_key, expected_type=type_hints["client_key"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if client_cert is not None:
            self._values["client_cert"] = client_cert
        if client_key is not None:
            self._values["client_key"] = client_key

    @builtins.property
    def client_cert(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCert#clientCert
        '''
        result = self._values.get("client_cert")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert"], result)

    @builtins.property
    def client_key(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCert#clientKey
        '''
        result = self._values.get("client_key")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetesAuthCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d9b3f78cc3bb7658dd3c35554318220b15eb7c942accae3ec4b352f516ebd14c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__42f24331268dcb0d9cdbf6ec4b18b536c5d9105df0ca060410bcb16e7844262d)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesAuthRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderKubernetesAuthRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a secret that contains the auth information.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__51599d235d54542b854c563140b4ee7e3a290daada6b217791ae49f0e2f48a9c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetesAuthRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''points to a service account that should be used for authentication.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eacf4713dc2dbb9bc810892d116a1fcbcb9d0e0841869a5d07ada3bc56701208)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesAuthToken",
    jsii_struct_bases=[],
    name_mapping={"bearer_token": "bearerToken"},
)
class SecretStoreV1Beta1SpecProviderKubernetesAuthToken:
    def __init__(
        self,
        *,
        bearer_token: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''use static token to authenticate with.

        :param bearer_token: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthToken
        '''
        if isinstance(bearer_token, dict):
            bearer_token = SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken(**bearer_token)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bec138ba036b38e5ba6a971a6c04acb29aa345aaef6e195f213ad1536637c5a0)
            check_type(argname="argument bearer_token", value=bearer_token, expected_type=type_hints["bearer_token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if bearer_token is not None:
            self._values["bearer_token"] = bearer_token

    @builtins.property
    def bearer_token(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthToken#bearerToken
        '''
        result = self._values.get("bearer_token")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetesAuthToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eb2c93bb0eef9af5c6b7d58045d71fc562b13e87a832f12bc87da48410851e8e)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesServer",
    jsii_struct_bases=[],
    name_mapping={"ca_bundle": "caBundle", "ca_provider": "caProvider", "url": "url"},
)
class SecretStoreV1Beta1SpecProviderKubernetesServer:
    def __init__(
        self,
        *,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''configures the Kubernetes server Address.

        :param ca_bundle: CABundle is a base64-encoded CA certificate.
        :param ca_provider: see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.
        :param url: configures the Kubernetes server Address.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesServer
        '''
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d679aa7557793ca3a8fd37725eb27302305e012ef0651a9008e422fc4c78bc81)
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''CABundle is a base64-encoded CA certificate.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesServer#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider"]:
        '''see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesServer#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider"], result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''configures the Kubernetes server Address.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesServer#url
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetesServer(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f682dc01ab3544124912213346c39e299a227713b49003eb2742c133629f431)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        Can only be defined when used in a ClusterSecretStore.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType"
)
class SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOnboardbase",
    jsii_struct_bases=[],
    name_mapping={
        "api_host": "apiHost",
        "auth": "auth",
        "environment": "environment",
        "project": "project",
    },
)
class SecretStoreV1Beta1SpecProviderOnboardbase:
    def __init__(
        self,
        *,
        api_host: builtins.str,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderOnboardbaseAuth", typing.Dict[builtins.str, typing.Any]],
        environment: builtins.str,
        project: builtins.str,
    ) -> None:
        '''Onboardbase configures this store to sync secrets using the Onboardbase provider.

        :param api_host: APIHost use this to configure the host url for the API for selfhosted installation, default is https://public.onboardbase.com/api/v1/.
        :param auth: Auth configures how the Operator authenticates with the Onboardbase API.
        :param environment: Environment is the name of an environmnent within a project to pull the secrets from.
        :param project: Project is an onboardbase project that the secrets should be pulled from.

        :schema: SecretStoreV1Beta1SpecProviderOnboardbase
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderOnboardbaseAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a5297836f61be88e9ba167fa61d792f192e7ee54541be7598800f46cdf85c06f)
            check_type(argname="argument api_host", value=api_host, expected_type=type_hints["api_host"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
            check_type(argname="argument project", value=project, expected_type=type_hints["project"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api_host": api_host,
            "auth": auth,
            "environment": environment,
            "project": project,
        }

    @builtins.property
    def api_host(self) -> builtins.str:
        '''APIHost use this to configure the host url for the API for selfhosted installation, default is https://public.onboardbase.com/api/v1/.

        :schema: SecretStoreV1Beta1SpecProviderOnboardbase#apiHost
        '''
        result = self._values.get("api_host")
        assert result is not None, "Required property 'api_host' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderOnboardbaseAuth":
        '''Auth configures how the Operator authenticates with the Onboardbase API.

        :schema: SecretStoreV1Beta1SpecProviderOnboardbase#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderOnboardbaseAuth", result)

    @builtins.property
    def environment(self) -> builtins.str:
        '''Environment is the name of an environmnent within a project to pull the secrets from.

        :schema: SecretStoreV1Beta1SpecProviderOnboardbase#environment
        '''
        result = self._values.get("environment")
        assert result is not None, "Required property 'environment' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def project(self) -> builtins.str:
        '''Project is an onboardbase project that the secrets should be pulled from.

        :schema: SecretStoreV1Beta1SpecProviderOnboardbase#project
        '''
        result = self._values.get("project")
        assert result is not None, "Required property 'project' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOnboardbase(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOnboardbaseAuth",
    jsii_struct_bases=[],
    name_mapping={"api_key_ref": "apiKeyRef", "passcode_ref": "passcodeRef"},
)
class SecretStoreV1Beta1SpecProviderOnboardbaseAuth:
    def __init__(
        self,
        *,
        api_key_ref: typing.Union["SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef", typing.Dict[builtins.str, typing.Any]],
        passcode_ref: typing.Union["SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth configures how the Operator authenticates with the Onboardbase API.

        :param api_key_ref: OnboardbaseAPIKey is the APIKey generated by an admin account. It is used to recognize and authorize access to a project and environment within onboardbase
        :param passcode_ref: OnboardbasePasscode is the passcode attached to the API Key.

        :schema: SecretStoreV1Beta1SpecProviderOnboardbaseAuth
        '''
        if isinstance(api_key_ref, dict):
            api_key_ref = SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef(**api_key_ref)
        if isinstance(passcode_ref, dict):
            passcode_ref = SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef(**passcode_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__27d3d52870731bdad3efa483bda2c12fa98b99d06da2ac3c8d51bb74987d8366)
            check_type(argname="argument api_key_ref", value=api_key_ref, expected_type=type_hints["api_key_ref"])
            check_type(argname="argument passcode_ref", value=passcode_ref, expected_type=type_hints["passcode_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api_key_ref": api_key_ref,
            "passcode_ref": passcode_ref,
        }

    @builtins.property
    def api_key_ref(self) -> "SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef":
        '''OnboardbaseAPIKey is the APIKey generated by an admin account.

        It is used to recognize and authorize access to a project and environment within onboardbase

        :schema: SecretStoreV1Beta1SpecProviderOnboardbaseAuth#apiKeyRef
        '''
        result = self._values.get("api_key_ref")
        assert result is not None, "Required property 'api_key_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef", result)

    @builtins.property
    def passcode_ref(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef":
        '''OnboardbasePasscode is the passcode attached to the API Key.

        :schema: SecretStoreV1Beta1SpecProviderOnboardbaseAuth#passcodeRef
        '''
        result = self._values.get("passcode_ref")
        assert result is not None, "Required property 'passcode_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOnboardbaseAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''OnboardbaseAPIKey is the APIKey generated by an admin account.

        It is used to recognize and authorize access to a project and environment within onboardbase

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e793cc39e597aa506da9da0bca2c01ebb177e9ae284121a87ddb4e8bdb7ad74a)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''OnboardbasePasscode is the passcode attached to the API Key.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c1b4261fef432b3a9873355545275d22cda7f776ba4b42b420ca47c56f503270)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOnepassword",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "connect_host": "connectHost", "vaults": "vaults"},
)
class SecretStoreV1Beta1SpecProviderOnepassword:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderOnepasswordAuth", typing.Dict[builtins.str, typing.Any]],
        connect_host: builtins.str,
        vaults: typing.Mapping[builtins.str, jsii.Number],
    ) -> None:
        '''OnePassword configures this store to sync secrets using the 1Password Cloud provider.

        :param auth: Auth defines the information necessary to authenticate against OnePassword Connect Server.
        :param connect_host: ConnectHost defines the OnePassword Connect Server to connect to.
        :param vaults: Vaults defines which OnePassword vaults to search in which order.

        :schema: SecretStoreV1Beta1SpecProviderOnepassword
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderOnepasswordAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f1799d8f5d4e7fd3e38d4ffda5fbe26f701abb1ac72c72e62e17dc32d661c52f)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument connect_host", value=connect_host, expected_type=type_hints["connect_host"])
            check_type(argname="argument vaults", value=vaults, expected_type=type_hints["vaults"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "connect_host": connect_host,
            "vaults": vaults,
        }

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderOnepasswordAuth":
        '''Auth defines the information necessary to authenticate against OnePassword Connect Server.

        :schema: SecretStoreV1Beta1SpecProviderOnepassword#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderOnepasswordAuth", result)

    @builtins.property
    def connect_host(self) -> builtins.str:
        '''ConnectHost defines the OnePassword Connect Server to connect to.

        :schema: SecretStoreV1Beta1SpecProviderOnepassword#connectHost
        '''
        result = self._values.get("connect_host")
        assert result is not None, "Required property 'connect_host' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vaults(self) -> typing.Mapping[builtins.str, jsii.Number]:
        '''Vaults defines which OnePassword vaults to search in which order.

        :schema: SecretStoreV1Beta1SpecProviderOnepassword#vaults
        '''
        result = self._values.get("vaults")
        assert result is not None, "Required property 'vaults' is missing"
        return typing.cast(typing.Mapping[builtins.str, jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOnepassword(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOnepasswordAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderOnepasswordAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth defines the information necessary to authenticate against OnePassword Connect Server.

        :param secret_ref: OnePasswordAuthSecretRef holds secret references for 1Password credentials.

        :schema: SecretStoreV1Beta1SpecProviderOnepasswordAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c9f3cb1f01e83febb00d40ac37067b4cc2c02b4e11d32c06354ac23c9793b112)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef":
        '''OnePasswordAuthSecretRef holds secret references for 1Password credentials.

        :schema: SecretStoreV1Beta1SpecProviderOnepasswordAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOnepasswordAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"connect_token_secret_ref": "connectTokenSecretRef"},
)
class SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef:
    def __init__(
        self,
        *,
        connect_token_secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''OnePasswordAuthSecretRef holds secret references for 1Password credentials.

        :param connect_token_secret_ref: The ConnectToken is used for authentication to a 1Password Connect Server.

        :schema: SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef
        '''
        if isinstance(connect_token_secret_ref, dict):
            connect_token_secret_ref = SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(**connect_token_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0e8a9e24241a42ff9102923f86463f8b2434e409b96b1c3372c47f7d6ee914a5)
            check_type(argname="argument connect_token_secret_ref", value=connect_token_secret_ref, expected_type=type_hints["connect_token_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "connect_token_secret_ref": connect_token_secret_ref,
        }

    @builtins.property
    def connect_token_secret_ref(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef":
        '''The ConnectToken is used for authentication to a 1Password Connect Server.

        :schema: SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef#connectTokenSecretRef
        '''
        result = self._values.get("connect_token_secret_ref")
        assert result is not None, "Required property 'connect_token_secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The ConnectToken is used for authentication to a 1Password Connect Server.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e920371298eef9ef64fd417d1fe1a190eecd25d510ddfae09033af8d91ea611e)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOracle",
    jsii_struct_bases=[],
    name_mapping={
        "region": "region",
        "vault": "vault",
        "auth": "auth",
        "compartment": "compartment",
        "encryption_key": "encryptionKey",
        "principal_type": "principalType",
        "service_account_ref": "serviceAccountRef",
    },
)
class SecretStoreV1Beta1SpecProviderOracle:
    def __init__(
        self,
        *,
        region: builtins.str,
        vault: builtins.str,
        auth: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderOracleAuth", typing.Dict[builtins.str, typing.Any]]] = None,
        compartment: typing.Optional[builtins.str] = None,
        encryption_key: typing.Optional[builtins.str] = None,
        principal_type: typing.Optional["SecretStoreV1Beta1SpecProviderOraclePrincipalType"] = None,
        service_account_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderOracleServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Oracle configures this store to sync secrets using Oracle Vault provider.

        :param region: Region is the region where vault is located.
        :param vault: Vault is the vault's OCID of the specific vault where secret is located.
        :param auth: Auth configures how secret-manager authenticates with the Oracle Vault. If empty, use the instance principal, otherwise the user credentials specified in Auth.
        :param compartment: Compartment is the vault compartment OCID. Required for PushSecret
        :param encryption_key: EncryptionKey is the OCID of the encryption key within the vault. Required for PushSecret
        :param principal_type: The type of principal to use for authentication. If left blank, the Auth struct will determine the principal type. This optional field must be specified if using workload identity.
        :param service_account_ref: ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :schema: SecretStoreV1Beta1SpecProviderOracle
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderOracleAuth(**auth)
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreV1Beta1SpecProviderOracleServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64a73f7d94141f654d20eea2b114031d06b98e3f17f51f9796818f7873200e73)
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument vault", value=vault, expected_type=type_hints["vault"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument compartment", value=compartment, expected_type=type_hints["compartment"])
            check_type(argname="argument encryption_key", value=encryption_key, expected_type=type_hints["encryption_key"])
            check_type(argname="argument principal_type", value=principal_type, expected_type=type_hints["principal_type"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "region": region,
            "vault": vault,
        }
        if auth is not None:
            self._values["auth"] = auth
        if compartment is not None:
            self._values["compartment"] = compartment
        if encryption_key is not None:
            self._values["encryption_key"] = encryption_key
        if principal_type is not None:
            self._values["principal_type"] = principal_type
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def region(self) -> builtins.str:
        '''Region is the region where vault is located.

        :schema: SecretStoreV1Beta1SpecProviderOracle#region
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vault(self) -> builtins.str:
        '''Vault is the vault's OCID of the specific vault where secret is located.

        :schema: SecretStoreV1Beta1SpecProviderOracle#vault
        '''
        result = self._values.get("vault")
        assert result is not None, "Required property 'vault' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderOracleAuth"]:
        '''Auth configures how secret-manager authenticates with the Oracle Vault.

        If empty, use the instance principal, otherwise the user credentials specified in Auth.

        :schema: SecretStoreV1Beta1SpecProviderOracle#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderOracleAuth"], result)

    @builtins.property
    def compartment(self) -> typing.Optional[builtins.str]:
        '''Compartment is the vault compartment OCID.

        Required for PushSecret

        :schema: SecretStoreV1Beta1SpecProviderOracle#compartment
        '''
        result = self._values.get("compartment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def encryption_key(self) -> typing.Optional[builtins.str]:
        '''EncryptionKey is the OCID of the encryption key within the vault.

        Required for PushSecret

        :schema: SecretStoreV1Beta1SpecProviderOracle#encryptionKey
        '''
        result = self._values.get("encryption_key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def principal_type(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderOraclePrincipalType"]:
        '''The type of principal to use for authentication.

        If left blank, the Auth struct will
        determine the principal type. This optional field must be specified if using
        workload identity.

        :schema: SecretStoreV1Beta1SpecProviderOracle#principalType
        '''
        result = self._values.get("principal_type")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderOraclePrincipalType"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderOracleServiceAccountRef"]:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :schema: SecretStoreV1Beta1SpecProviderOracle#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderOracleServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOracle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOracleAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "tenancy": "tenancy", "user": "user"},
)
class SecretStoreV1Beta1SpecProviderOracleAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderOracleAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
        tenancy: builtins.str,
        user: builtins.str,
    ) -> None:
        '''Auth configures how secret-manager authenticates with the Oracle Vault.

        If empty, use the instance principal, otherwise the user credentials specified in Auth.

        :param secret_ref: SecretRef to pass through sensitive information.
        :param tenancy: Tenancy is the tenancy OCID where user is located.
        :param user: User is an access OCID specific to the account.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderOracleAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__40b8eeb85088c31aca7e5df4dc593a08848c08806890a3d02fa7948995f3437c)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument tenancy", value=tenancy, expected_type=type_hints["tenancy"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
            "tenancy": tenancy,
            "user": user,
        }

    @builtins.property
    def secret_ref(self) -> "SecretStoreV1Beta1SpecProviderOracleAuthSecretRef":
        '''SecretRef to pass through sensitive information.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderOracleAuthSecretRef", result)

    @builtins.property
    def tenancy(self) -> builtins.str:
        '''Tenancy is the tenancy OCID where user is located.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuth#tenancy
        '''
        result = self._values.get("tenancy")
        assert result is not None, "Required property 'tenancy' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def user(self) -> builtins.str:
        '''User is an access OCID specific to the account.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuth#user
        '''
        result = self._values.get("user")
        assert result is not None, "Required property 'user' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOracleAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOracleAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"fingerprint": "fingerprint", "privatekey": "privatekey"},
)
class SecretStoreV1Beta1SpecProviderOracleAuthSecretRef:
    def __init__(
        self,
        *,
        fingerprint: typing.Union["SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint", typing.Dict[builtins.str, typing.Any]],
        privatekey: typing.Union["SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''SecretRef to pass through sensitive information.

        :param fingerprint: Fingerprint is the fingerprint of the API private key.
        :param privatekey: PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRef
        '''
        if isinstance(fingerprint, dict):
            fingerprint = SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint(**fingerprint)
        if isinstance(privatekey, dict):
            privatekey = SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey(**privatekey)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__01ef1bc632be3346170362a1c030bf5ed1f64b4233140ff0036f5a882b11c524)
            check_type(argname="argument fingerprint", value=fingerprint, expected_type=type_hints["fingerprint"])
            check_type(argname="argument privatekey", value=privatekey, expected_type=type_hints["privatekey"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "fingerprint": fingerprint,
            "privatekey": privatekey,
        }

    @builtins.property
    def fingerprint(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint":
        '''Fingerprint is the fingerprint of the API private key.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRef#fingerprint
        '''
        result = self._values.get("fingerprint")
        assert result is not None, "Required property 'fingerprint' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint", result)

    @builtins.property
    def privatekey(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey":
        '''PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRef#privatekey
        '''
        result = self._values.get("privatekey")
        assert result is not None, "Required property 'privatekey' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOracleAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Fingerprint is the fingerprint of the API private key.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e820022cd3ecbb7e3073fe7f41bda9fb729f513cd9da4945a925a300cc26d1b)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d4cbeb2d65fda2f0f86577a2ee9cf1784799a03e0ec4de73ae3d4116a51b7c1)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOraclePrincipalType"
)
class SecretStoreV1Beta1SpecProviderOraclePrincipalType(enum.Enum):
    '''The type of principal to use for authentication.

    If left blank, the Auth struct will
    determine the principal type. This optional field must be specified if using
    workload identity.

    :schema: SecretStoreV1Beta1SpecProviderOraclePrincipalType
    '''

    USER_PRINCIPAL = "USER_PRINCIPAL"
    '''UserPrincipal.'''
    INSTANCE_PRINCIPAL = "INSTANCE_PRINCIPAL"
    '''InstancePrincipal.'''
    WORKLOAD = "WORKLOAD"
    '''Workload.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOracleServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderOracleServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderOracleServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab989471fa0c25514c062bf2d2b0a040f69c8f8906d13ac7cd449e6d973fcb07)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderOracleServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreV1Beta1SpecProviderOracleServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderOracleServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOracleServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderPassbolt",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "host": "host"},
)
class SecretStoreV1Beta1SpecProviderPassbolt:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderPassboltAuth", typing.Dict[builtins.str, typing.Any]],
        host: builtins.str,
    ) -> None:
        '''
        :param auth: Auth defines the information necessary to authenticate against Passbolt Server.
        :param host: Host defines the Passbolt Server to connect to.

        :schema: SecretStoreV1Beta1SpecProviderPassbolt
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderPassboltAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c1489eb7e9620965a440726c06aec5ce16ef1b5e841250fcc5024c91215ecb5d)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "host": host,
        }

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderPassboltAuth":
        '''Auth defines the information necessary to authenticate against Passbolt Server.

        :schema: SecretStoreV1Beta1SpecProviderPassbolt#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderPassboltAuth", result)

    @builtins.property
    def host(self) -> builtins.str:
        '''Host defines the Passbolt Server to connect to.

        :schema: SecretStoreV1Beta1SpecProviderPassbolt#host
        '''
        result = self._values.get("host")
        assert result is not None, "Required property 'host' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderPassbolt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderPassboltAuth",
    jsii_struct_bases=[],
    name_mapping={
        "password_secret_ref": "passwordSecretRef",
        "private_key_secret_ref": "privateKeySecretRef",
    },
)
class SecretStoreV1Beta1SpecProviderPassboltAuth:
    def __init__(
        self,
        *,
        password_secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef", typing.Dict[builtins.str, typing.Any]],
        private_key_secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth defines the information necessary to authenticate against Passbolt Server.

        :param password_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.
        :param private_key_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderPassboltAuth
        '''
        if isinstance(password_secret_ref, dict):
            password_secret_ref = SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef(**password_secret_ref)
        if isinstance(private_key_secret_ref, dict):
            private_key_secret_ref = SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef(**private_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__538289df280cd946c84fd37eb4ea94fc8b0ce1695213961d36001d162548db6a)
            check_type(argname="argument password_secret_ref", value=password_secret_ref, expected_type=type_hints["password_secret_ref"])
            check_type(argname="argument private_key_secret_ref", value=private_key_secret_ref, expected_type=type_hints["private_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "password_secret_ref": password_secret_ref,
            "private_key_secret_ref": private_key_secret_ref,
        }

    @builtins.property
    def password_secret_ref(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderPassboltAuth#passwordSecretRef
        '''
        result = self._values.get("password_secret_ref")
        assert result is not None, "Required property 'password_secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef", result)

    @builtins.property
    def private_key_secret_ref(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderPassboltAuth#privateKeySecretRef
        '''
        result = self._values.get("private_key_secret_ref")
        assert result is not None, "Required property 'private_key_secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderPassboltAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4bb9db9eee1ce9a5ca112400260bc8086ba70cc39b797ee628675edf22f744fd)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29ab280066a1eb0cb5742d20eccfc087ef8b391f016590bf1f8d8ffe52b75d48)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderPassworddepot",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "database": "database", "host": "host"},
)
class SecretStoreV1Beta1SpecProviderPassworddepot:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderPassworddepotAuth", typing.Dict[builtins.str, typing.Any]],
        database: builtins.str,
        host: builtins.str,
    ) -> None:
        '''Configures a store to sync secrets with a Password Depot instance.

        :param auth: Auth configures how secret-manager authenticates with a Password Depot instance.
        :param database: Database to use as source.
        :param host: URL configures the Password Depot instance URL.

        :schema: SecretStoreV1Beta1SpecProviderPassworddepot
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderPassworddepotAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c0f976ddef5429db57e42aed47827f8bed0917b9cf825b4f4a67d69f3688518a)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument database", value=database, expected_type=type_hints["database"])
            check_type(argname="argument host", value=host, expected_type=type_hints["host"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "database": database,
            "host": host,
        }

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderPassworddepotAuth":
        '''Auth configures how secret-manager authenticates with a Password Depot instance.

        :schema: SecretStoreV1Beta1SpecProviderPassworddepot#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderPassworddepotAuth", result)

    @builtins.property
    def database(self) -> builtins.str:
        '''Database to use as source.

        :schema: SecretStoreV1Beta1SpecProviderPassworddepot#database
        '''
        result = self._values.get("database")
        assert result is not None, "Required property 'database' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def host(self) -> builtins.str:
        '''URL configures the Password Depot instance URL.

        :schema: SecretStoreV1Beta1SpecProviderPassworddepot#host
        '''
        result = self._values.get("host")
        assert result is not None, "Required property 'host' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderPassworddepot(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderPassworddepotAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderPassworddepotAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth configures how secret-manager authenticates with a Password Depot instance.

        :param secret_ref: 

        :schema: SecretStoreV1Beta1SpecProviderPassworddepotAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d705a50aad2a9503d46ad8df7d7b529abbb45897e6b649a2329c4c293aa5fd62)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef":
        '''
        :schema: SecretStoreV1Beta1SpecProviderPassworddepotAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderPassworddepotAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"credentials": "credentials"},
)
class SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef:
    def __init__(
        self,
        *,
        credentials: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param credentials: Username / Password is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef
        '''
        if isinstance(credentials, dict):
            credentials = SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials(**credentials)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0e52c9857e3f7680b291d78b0c4ddc8089923f4b2d668fb96c0e45ae9c6e0b0c)
            check_type(argname="argument credentials", value=credentials, expected_type=type_hints["credentials"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if credentials is not None:
            self._values["credentials"] = credentials

    @builtins.property
    def credentials(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials"]:
        '''Username / Password is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef#credentials
        '''
        result = self._values.get("credentials")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Username / Password is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0dfaa99e7d51b44c06c1fae991b4fc1c9128eb872d34546de35780afdde50f52)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderPrevider",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "base_uri": "baseUri"},
)
class SecretStoreV1Beta1SpecProviderPrevider:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderPreviderAuth", typing.Dict[builtins.str, typing.Any]],
        base_uri: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Previder configures this store to sync secrets using the Previder provider.

        :param auth: PreviderAuth contains a secretRef for credentials.
        :param base_uri: 

        :schema: SecretStoreV1Beta1SpecProviderPrevider
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderPreviderAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__babedefec800103eeb91b1c15364ad539e08b2a820946c4b4859284011a16617)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument base_uri", value=base_uri, expected_type=type_hints["base_uri"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
        }
        if base_uri is not None:
            self._values["base_uri"] = base_uri

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderPreviderAuth":
        '''PreviderAuth contains a secretRef for credentials.

        :schema: SecretStoreV1Beta1SpecProviderPrevider#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderPreviderAuth", result)

    @builtins.property
    def base_uri(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderPrevider#baseUri
        '''
        result = self._values.get("base_uri")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderPrevider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderPreviderAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderPreviderAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderPreviderAuthSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''PreviderAuth contains a secretRef for credentials.

        :param secret_ref: PreviderAuthSecretRef holds secret references for Previder Vault credentials.

        :schema: SecretStoreV1Beta1SpecProviderPreviderAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderPreviderAuthSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c6778a7517ce1f71b0364fc9df56630ce5e25c06ec8d3981cf1a1683d4990758)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderPreviderAuthSecretRef"]:
        '''PreviderAuthSecretRef holds secret references for Previder Vault credentials.

        :schema: SecretStoreV1Beta1SpecProviderPreviderAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderPreviderAuthSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderPreviderAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderPreviderAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"access_token": "accessToken"},
)
class SecretStoreV1Beta1SpecProviderPreviderAuthSecretRef:
    def __init__(
        self,
        *,
        access_token: typing.Union["SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''PreviderAuthSecretRef holds secret references for Previder Vault credentials.

        :param access_token: The AccessToken is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderPreviderAuthSecretRef
        '''
        if isinstance(access_token, dict):
            access_token = SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken(**access_token)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd05ba6c99b6b1de1e4e775fa231557a0cadf52b20942c670a7c3cfaa784ae6a)
            check_type(argname="argument access_token", value=access_token, expected_type=type_hints["access_token"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "access_token": access_token,
        }

    @builtins.property
    def access_token(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken":
        '''The AccessToken is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderPreviderAuthSecretRef#accessToken
        '''
        result = self._values.get("access_token")
        assert result is not None, "Required property 'access_token' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderPreviderAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessToken is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6aec5feeb407e5f7b6979ad3e7f433706611380fea7ca473c57cf5586a06c9f8)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderPulumi",
    jsii_struct_bases=[],
    name_mapping={
        "access_token": "accessToken",
        "environment": "environment",
        "organization": "organization",
        "project": "project",
        "api_url": "apiUrl",
    },
)
class SecretStoreV1Beta1SpecProviderPulumi:
    def __init__(
        self,
        *,
        access_token: typing.Union["SecretStoreV1Beta1SpecProviderPulumiAccessToken", typing.Dict[builtins.str, typing.Any]],
        environment: builtins.str,
        organization: builtins.str,
        project: builtins.str,
        api_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Pulumi configures this store to sync secrets using the Pulumi provider.

        :param access_token: AccessToken is the access tokens to sign in to the Pulumi Cloud Console.
        :param environment: Environment are YAML documents composed of static key-value pairs, programmatic expressions, dynamically retrieved values from supported providers including all major clouds, and other Pulumi ESC environments. To create a new environment, visit https://www.pulumi.com/docs/esc/environments/ for more information.
        :param organization: Organization are a space to collaborate on shared projects and stacks. To create a new organization, visit https://app.pulumi.com/ and click "New Organization".
        :param project: Project is the name of the Pulumi ESC project the environment belongs to.
        :param api_url: APIURL is the URL of the Pulumi API.

        :schema: SecretStoreV1Beta1SpecProviderPulumi
        '''
        if isinstance(access_token, dict):
            access_token = SecretStoreV1Beta1SpecProviderPulumiAccessToken(**access_token)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__939d01649b08ff60f9a7a30761431e0f272e31bdd0a4b75e5bc6568af08a25b7)
            check_type(argname="argument access_token", value=access_token, expected_type=type_hints["access_token"])
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
            check_type(argname="argument organization", value=organization, expected_type=type_hints["organization"])
            check_type(argname="argument project", value=project, expected_type=type_hints["project"])
            check_type(argname="argument api_url", value=api_url, expected_type=type_hints["api_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "access_token": access_token,
            "environment": environment,
            "organization": organization,
            "project": project,
        }
        if api_url is not None:
            self._values["api_url"] = api_url

    @builtins.property
    def access_token(self) -> "SecretStoreV1Beta1SpecProviderPulumiAccessToken":
        '''AccessToken is the access tokens to sign in to the Pulumi Cloud Console.

        :schema: SecretStoreV1Beta1SpecProviderPulumi#accessToken
        '''
        result = self._values.get("access_token")
        assert result is not None, "Required property 'access_token' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderPulumiAccessToken", result)

    @builtins.property
    def environment(self) -> builtins.str:
        '''Environment are YAML documents composed of static key-value pairs, programmatic expressions, dynamically retrieved values from supported providers including all major clouds, and other Pulumi ESC environments.

        To create a new environment, visit https://www.pulumi.com/docs/esc/environments/ for more information.

        :schema: SecretStoreV1Beta1SpecProviderPulumi#environment
        '''
        result = self._values.get("environment")
        assert result is not None, "Required property 'environment' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def organization(self) -> builtins.str:
        '''Organization are a space to collaborate on shared projects and stacks.

        To create a new organization, visit https://app.pulumi.com/ and click "New Organization".

        :schema: SecretStoreV1Beta1SpecProviderPulumi#organization
        '''
        result = self._values.get("organization")
        assert result is not None, "Required property 'organization' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def project(self) -> builtins.str:
        '''Project is the name of the Pulumi ESC project the environment belongs to.

        :schema: SecretStoreV1Beta1SpecProviderPulumi#project
        '''
        result = self._values.get("project")
        assert result is not None, "Required property 'project' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def api_url(self) -> typing.Optional[builtins.str]:
        '''APIURL is the URL of the Pulumi API.

        :schema: SecretStoreV1Beta1SpecProviderPulumi#apiUrl
        '''
        result = self._values.get("api_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderPulumi(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderPulumiAccessToken",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderPulumiAccessToken:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''AccessToken is the access tokens to sign in to the Pulumi Cloud Console.

        :param secret_ref: SecretRef is a reference to a secret containing the Pulumi API token.

        :schema: SecretStoreV1Beta1SpecProviderPulumiAccessToken
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__49f1e598bc6963cbfc96bb6e5cc69cf9b281444f3b47cfdec842d82b0e927630)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef"]:
        '''SecretRef is a reference to a secret containing the Pulumi API token.

        :schema: SecretStoreV1Beta1SpecProviderPulumiAccessToken#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderPulumiAccessToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef is a reference to a secret containing the Pulumi API token.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba202441e53a6a6e88d62b095d491369de97f4e30a14970f0a02e9fb6da4a987)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderScaleway",
    jsii_struct_bases=[],
    name_mapping={
        "access_key": "accessKey",
        "project_id": "projectId",
        "region": "region",
        "secret_key": "secretKey",
        "api_url": "apiUrl",
    },
)
class SecretStoreV1Beta1SpecProviderScaleway:
    def __init__(
        self,
        *,
        access_key: typing.Union["SecretStoreV1Beta1SpecProviderScalewayAccessKey", typing.Dict[builtins.str, typing.Any]],
        project_id: builtins.str,
        region: builtins.str,
        secret_key: typing.Union["SecretStoreV1Beta1SpecProviderScalewaySecretKey", typing.Dict[builtins.str, typing.Any]],
        api_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Scaleway.

        :param access_key: AccessKey is the non-secret part of the api key.
        :param project_id: ProjectID is the id of your project, which you can find in the console: https://console.scaleway.com/project/settings.
        :param region: Region where your secrets are located: https://developers.scaleway.com/en/quickstart/#region-and-zone.
        :param secret_key: SecretKey is the non-secret part of the api key.
        :param api_url: APIURL is the url of the api to use. Defaults to https://api.scaleway.com Default: https://api.scaleway.com

        :schema: SecretStoreV1Beta1SpecProviderScaleway
        '''
        if isinstance(access_key, dict):
            access_key = SecretStoreV1Beta1SpecProviderScalewayAccessKey(**access_key)
        if isinstance(secret_key, dict):
            secret_key = SecretStoreV1Beta1SpecProviderScalewaySecretKey(**secret_key)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9b2d10d04e4764b296e1ce01f19a28ce1674275dd261d44db6c973b670d9553e)
            check_type(argname="argument access_key", value=access_key, expected_type=type_hints["access_key"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument secret_key", value=secret_key, expected_type=type_hints["secret_key"])
            check_type(argname="argument api_url", value=api_url, expected_type=type_hints["api_url"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "access_key": access_key,
            "project_id": project_id,
            "region": region,
            "secret_key": secret_key,
        }
        if api_url is not None:
            self._values["api_url"] = api_url

    @builtins.property
    def access_key(self) -> "SecretStoreV1Beta1SpecProviderScalewayAccessKey":
        '''AccessKey is the non-secret part of the api key.

        :schema: SecretStoreV1Beta1SpecProviderScaleway#accessKey
        '''
        result = self._values.get("access_key")
        assert result is not None, "Required property 'access_key' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderScalewayAccessKey", result)

    @builtins.property
    def project_id(self) -> builtins.str:
        '''ProjectID is the id of your project, which you can find in the console: https://console.scaleway.com/project/settings.

        :schema: SecretStoreV1Beta1SpecProviderScaleway#projectId
        '''
        result = self._values.get("project_id")
        assert result is not None, "Required property 'project_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def region(self) -> builtins.str:
        '''Region where your secrets are located: https://developers.scaleway.com/en/quickstart/#region-and-zone.

        :schema: SecretStoreV1Beta1SpecProviderScaleway#region
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_key(self) -> "SecretStoreV1Beta1SpecProviderScalewaySecretKey":
        '''SecretKey is the non-secret part of the api key.

        :schema: SecretStoreV1Beta1SpecProviderScaleway#secretKey
        '''
        result = self._values.get("secret_key")
        assert result is not None, "Required property 'secret_key' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderScalewaySecretKey", result)

    @builtins.property
    def api_url(self) -> typing.Optional[builtins.str]:
        '''APIURL is the url of the api to use.

        Defaults to https://api.scaleway.com

        :default: https://api.scaleway.com

        :schema: SecretStoreV1Beta1SpecProviderScaleway#apiUrl
        '''
        result = self._values.get("api_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderScaleway(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderScalewayAccessKey",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class SecretStoreV1Beta1SpecProviderScalewayAccessKey:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AccessKey is the non-secret part of the api key.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderScalewayAccessKey
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__29b7f6cff88adde0cb6aa42b024e4018d4eccfbf09612f896f5ecbf9a61dc6f1)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: SecretStoreV1Beta1SpecProviderScalewayAccessKey#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderScalewayAccessKey#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderScalewayAccessKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3f5808fec9ce03b84e369eccce3001cd6d2e2fd5560f997dfd3f81874fbfdb9c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderScalewaySecretKey",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class SecretStoreV1Beta1SpecProviderScalewaySecretKey:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretKey is the non-secret part of the api key.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderScalewaySecretKey
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__112ea142f158b916d10c0740099450f071bb6f572710e341958d8031399f2162)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: SecretStoreV1Beta1SpecProviderScalewaySecretKey#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderScalewaySecretKey#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderScalewaySecretKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3551e0f6019901c6c11d84a411d92ab9633cb1873225cc3a8771d935ced0fa9b)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderSecretserver",
    jsii_struct_bases=[],
    name_mapping={
        "password": "password",
        "server_url": "serverUrl",
        "username": "username",
    },
)
class SecretStoreV1Beta1SpecProviderSecretserver:
    def __init__(
        self,
        *,
        password: typing.Union["SecretStoreV1Beta1SpecProviderSecretserverPassword", typing.Dict[builtins.str, typing.Any]],
        server_url: builtins.str,
        username: typing.Union["SecretStoreV1Beta1SpecProviderSecretserverUsername", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''SecretServer configures this store to sync secrets using SecretServer provider https://docs.delinea.com/online-help/secret-server/start.htm.

        :param password: Password is the secret server account password.
        :param server_url: ServerURL URL to your secret server installation.
        :param username: Username is the secret server account username.

        :schema: SecretStoreV1Beta1SpecProviderSecretserver
        '''
        if isinstance(password, dict):
            password = SecretStoreV1Beta1SpecProviderSecretserverPassword(**password)
        if isinstance(username, dict):
            username = SecretStoreV1Beta1SpecProviderSecretserverUsername(**username)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__13781ade5f94390998a6da226871bb47a3c51ad3790cc560e496aea1d66f6f99)
            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
            check_type(argname="argument server_url", value=server_url, expected_type=type_hints["server_url"])
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "password": password,
            "server_url": server_url,
            "username": username,
        }

    @builtins.property
    def password(self) -> "SecretStoreV1Beta1SpecProviderSecretserverPassword":
        '''Password is the secret server account password.

        :schema: SecretStoreV1Beta1SpecProviderSecretserver#password
        '''
        result = self._values.get("password")
        assert result is not None, "Required property 'password' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderSecretserverPassword", result)

    @builtins.property
    def server_url(self) -> builtins.str:
        '''ServerURL URL to your secret server installation.

        :schema: SecretStoreV1Beta1SpecProviderSecretserver#serverURL
        '''
        result = self._values.get("server_url")
        assert result is not None, "Required property 'server_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def username(self) -> "SecretStoreV1Beta1SpecProviderSecretserverUsername":
        '''Username is the secret server account username.

        :schema: SecretStoreV1Beta1SpecProviderSecretserver#username
        '''
        result = self._values.get("username")
        assert result is not None, "Required property 'username' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderSecretserverUsername", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderSecretserver(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderSecretserverPassword",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class SecretStoreV1Beta1SpecProviderSecretserverPassword:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Password is the secret server account password.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderSecretserverPassword
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__449c9b93d6a8245d810a4a4d832a539cfe5e94a3c4285b45d068ed30ce907ac5)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: SecretStoreV1Beta1SpecProviderSecretserverPassword#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderSecretserverPassword#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderSecretserverPassword(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__400e4a893248023f91ef1e932a023f78127f60a1bd1c7e685829bd6d3fc79f90)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderSecretserverUsername",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "value": "value"},
)
class SecretStoreV1Beta1SpecProviderSecretserverUsername:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        value: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Username is the secret server account username.

        :param secret_ref: SecretRef references a key in a secret that will be used as value.
        :param value: Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderSecretserverUsername
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d79d2ce11d0089be20cf521c666a4d737e1a2ef75c92e06b465c5ddd34b2e1a4)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if value is not None:
            self._values["value"] = value

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef"]:
        '''SecretRef references a key in a secret that will be used as value.

        :schema: SecretStoreV1Beta1SpecProviderSecretserverUsername#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef"], result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''Value can be specified directly to set a value without using a secret.

        :schema: SecretStoreV1Beta1SpecProviderSecretserverUsername#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderSecretserverUsername(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef references a key in a secret that will be used as value.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__66f78c2d1700f6bcadf580c5fce02b69dab1944e7eb6bffe4d465e175d3ffcb8)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderSenhasegura",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "module": "module",
        "url": "url",
        "ignore_ssl_certificate": "ignoreSslCertificate",
    },
)
class SecretStoreV1Beta1SpecProviderSenhasegura:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderSenhaseguraAuth", typing.Dict[builtins.str, typing.Any]],
        module: builtins.str,
        url: builtins.str,
        ignore_ssl_certificate: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Senhasegura configures this store to sync secrets using senhasegura provider.

        :param auth: Auth defines parameters to authenticate in senhasegura.
        :param module: Module defines which senhasegura module should be used to get secrets.
        :param url: URL of senhasegura.
        :param ignore_ssl_certificate: IgnoreSslCertificate defines if SSL certificate must be ignored.

        :schema: SecretStoreV1Beta1SpecProviderSenhasegura
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderSenhaseguraAuth(**auth)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__78623254f8b4480d65a04e698f672f51438d8f6ad30f23ac1407edfaba7874bf)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument module", value=module, expected_type=type_hints["module"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
            check_type(argname="argument ignore_ssl_certificate", value=ignore_ssl_certificate, expected_type=type_hints["ignore_ssl_certificate"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "module": module,
            "url": url,
        }
        if ignore_ssl_certificate is not None:
            self._values["ignore_ssl_certificate"] = ignore_ssl_certificate

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderSenhaseguraAuth":
        '''Auth defines parameters to authenticate in senhasegura.

        :schema: SecretStoreV1Beta1SpecProviderSenhasegura#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderSenhaseguraAuth", result)

    @builtins.property
    def module(self) -> builtins.str:
        '''Module defines which senhasegura module should be used to get secrets.

        :schema: SecretStoreV1Beta1SpecProviderSenhasegura#module
        '''
        result = self._values.get("module")
        assert result is not None, "Required property 'module' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def url(self) -> builtins.str:
        '''URL of senhasegura.

        :schema: SecretStoreV1Beta1SpecProviderSenhasegura#url
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ignore_ssl_certificate(self) -> typing.Optional[builtins.bool]:
        '''IgnoreSslCertificate defines if SSL certificate must be ignored.

        :schema: SecretStoreV1Beta1SpecProviderSenhasegura#ignoreSslCertificate
        '''
        result = self._values.get("ignore_ssl_certificate")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderSenhasegura(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderSenhaseguraAuth",
    jsii_struct_bases=[],
    name_mapping={
        "client_id": "clientId",
        "client_secret_secret_ref": "clientSecretSecretRef",
    },
)
class SecretStoreV1Beta1SpecProviderSenhaseguraAuth:
    def __init__(
        self,
        *,
        client_id: builtins.str,
        client_secret_secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''Auth defines parameters to authenticate in senhasegura.

        :param client_id: 
        :param client_secret_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderSenhaseguraAuth
        '''
        if isinstance(client_secret_secret_ref, dict):
            client_secret_secret_ref = SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef(**client_secret_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b2808e6be5de7fcbdf0e82d2a489f69451abfdc33dc24f27bda74709537de26)
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret_secret_ref", value=client_secret_secret_ref, expected_type=type_hints["client_secret_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "client_id": client_id,
            "client_secret_secret_ref": client_secret_secret_ref,
        }

    @builtins.property
    def client_id(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderSenhaseguraAuth#clientId
        '''
        result = self._values.get("client_id")
        assert result is not None, "Required property 'client_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def client_secret_secret_ref(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef":
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderSenhaseguraAuth#clientSecretSecretRef
        '''
        result = self._values.get("client_secret_secret_ref")
        assert result is not None, "Required property 'client_secret_secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderSenhaseguraAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bea4e571f5932fe123738bee25182a721382ee4f520f5c5424bdf47102fc5952)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVault",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "server": "server",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
        "forward_inconsistent": "forwardInconsistent",
        "headers": "headers",
        "namespace": "namespace",
        "path": "path",
        "read_your_writes": "readYourWrites",
        "tls": "tls",
        "version": "version",
    },
)
class SecretStoreV1Beta1SpecProviderVault:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderVaultAuth", typing.Dict[builtins.str, typing.Any]],
        server: builtins.str,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
        forward_inconsistent: typing.Optional[builtins.bool] = None,
        headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
        path: typing.Optional[builtins.str] = None,
        read_your_writes: typing.Optional[builtins.bool] = None,
        tls: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultTls", typing.Dict[builtins.str, typing.Any]]] = None,
        version: typing.Optional["SecretStoreV1Beta1SpecProviderVaultVersion"] = None,
    ) -> None:
        '''Vault configures this store to sync secrets using Hashi provider.

        :param auth: Auth configures how secret-manager authenticates with the Vault server.
        :param server: Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
        :param ca_bundle: PEM encoded CA bundle used to validate Vault server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
        :param ca_provider: The provider for the CA bundle to use to validate Vault server certificate.
        :param forward_inconsistent: ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop. This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
        :param headers: Headers to be added in Vault request.
        :param namespace: Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
        :param path: Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.
        :param read_your_writes: ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request. More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency
        :param tls: The configuration used for client side related TLS communication, when the Vault server requires mutual authentication. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. It's worth noting this configuration is different from the "TLS certificates auth method", which is available under the ``auth.cert`` section.
        :param version: Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".

        :schema: SecretStoreV1Beta1SpecProviderVault
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderVaultAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreV1Beta1SpecProviderVaultCaProvider(**ca_provider)
        if isinstance(tls, dict):
            tls = SecretStoreV1Beta1SpecProviderVaultTls(**tls)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9fc4023c465f1be1a5c234fc3840fd441fe986a5b257d0ae414a562c34af5757)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument forward_inconsistent", value=forward_inconsistent, expected_type=type_hints["forward_inconsistent"])
            check_type(argname="argument headers", value=headers, expected_type=type_hints["headers"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument read_your_writes", value=read_your_writes, expected_type=type_hints["read_your_writes"])
            check_type(argname="argument tls", value=tls, expected_type=type_hints["tls"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
            "server": server,
        }
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if forward_inconsistent is not None:
            self._values["forward_inconsistent"] = forward_inconsistent
        if headers is not None:
            self._values["headers"] = headers
        if namespace is not None:
            self._values["namespace"] = namespace
        if path is not None:
            self._values["path"] = path
        if read_your_writes is not None:
            self._values["read_your_writes"] = read_your_writes
        if tls is not None:
            self._values["tls"] = tls
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderVaultAuth":
        '''Auth configures how secret-manager authenticates with the Vault server.

        :schema: SecretStoreV1Beta1SpecProviderVault#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderVaultAuth", result)

    @builtins.property
    def server(self) -> builtins.str:
        '''Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".

        :schema: SecretStoreV1Beta1SpecProviderVault#server
        '''
        result = self._values.get("server")
        assert result is not None, "Required property 'server' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''PEM encoded CA bundle used to validate Vault server certificate.

        Only used
        if the Server URL is using HTTPS protocol. This parameter is ignored for
        plain HTTP protocol connection. If not set the system root certificates
        are used to validate the TLS connection.

        :schema: SecretStoreV1Beta1SpecProviderVault#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultCaProvider"]:
        '''The provider for the CA bundle to use to validate Vault server certificate.

        :schema: SecretStoreV1Beta1SpecProviderVault#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultCaProvider"], result)

    @builtins.property
    def forward_inconsistent(self) -> typing.Optional[builtins.bool]:
        '''ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop.

        This can increase performance if
        the option is enabled serverside.
        https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header

        :schema: SecretStoreV1Beta1SpecProviderVault#forwardInconsistent
        '''
        result = self._values.get("forward_inconsistent")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def headers(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Headers to be added in Vault request.

        :schema: SecretStoreV1Beta1SpecProviderVault#headers
        '''
        result = self._values.get("headers")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Name of the vault namespace.

        Namespaces is a set of features within Vault Enterprise that allows
        Vault environments to support Secure Multi-tenancy. e.g: "ns1".
        More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces

        :schema: SecretStoreV1Beta1SpecProviderVault#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.

        :schema: SecretStoreV1Beta1SpecProviderVault#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_your_writes(self) -> typing.Optional[builtins.bool]:
        '''ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request.

        More information about eventual consistency in Vault can be found here
        https://www.vaultproject.io/docs/enterprise/consistency

        :schema: SecretStoreV1Beta1SpecProviderVault#readYourWrites
        '''
        result = self._values.get("read_your_writes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def tls(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultTls"]:
        '''The configuration used for client side related TLS communication, when the Vault server requires mutual authentication.

        Only used if the Server URL is using HTTPS protocol.
        This parameter is ignored for plain HTTP protocol connection.
        It's worth noting this configuration is different from the "TLS certificates auth method",
        which is available under the ``auth.cert`` section.

        :schema: SecretStoreV1Beta1SpecProviderVault#tls
        '''
        result = self._values.get("tls")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultTls"], result)

    @builtins.property
    def version(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultVersion"]:
        '''Version is the Vault KV secret engine version.

        This can be either "v1" or
        "v2". Version defaults to "v2".

        :schema: SecretStoreV1Beta1SpecProviderVault#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultVersion"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVault(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuth",
    jsii_struct_bases=[],
    name_mapping={
        "app_role": "appRole",
        "cert": "cert",
        "iam": "iam",
        "jwt": "jwt",
        "kubernetes": "kubernetes",
        "ldap": "ldap",
        "namespace": "namespace",
        "token_secret_ref": "tokenSecretRef",
        "user_pass": "userPass",
    },
)
class SecretStoreV1Beta1SpecProviderVaultAuth:
    def __init__(
        self,
        *,
        app_role: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthAppRole", typing.Dict[builtins.str, typing.Any]]] = None,
        cert: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthCert", typing.Dict[builtins.str, typing.Any]]] = None,
        iam: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthIam", typing.Dict[builtins.str, typing.Any]]] = None,
        jwt: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthJwt", typing.Dict[builtins.str, typing.Any]]] = None,
        kubernetes: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthKubernetes", typing.Dict[builtins.str, typing.Any]]] = None,
        ldap: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthLdap", typing.Dict[builtins.str, typing.Any]]] = None,
        namespace: typing.Optional[builtins.str] = None,
        token_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        user_pass: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthUserPass", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how secret-manager authenticates with the Vault server.

        :param app_role: AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
        :param cert: Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.
        :param iam: Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials AWS IAM authentication method.
        :param jwt: Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.
        :param kubernetes: Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
        :param ldap: Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.
        :param namespace: Name of the vault namespace to authenticate to. This can be different than the namespace your secret is in. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces This will default to Vault.Namespace field if set, or empty otherwise
        :param token_secret_ref: TokenSecretRef authenticates with Vault by presenting a token.
        :param user_pass: UserPass authenticates with Vault by passing username/password pair.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuth
        '''
        if isinstance(app_role, dict):
            app_role = SecretStoreV1Beta1SpecProviderVaultAuthAppRole(**app_role)
        if isinstance(cert, dict):
            cert = SecretStoreV1Beta1SpecProviderVaultAuthCert(**cert)
        if isinstance(iam, dict):
            iam = SecretStoreV1Beta1SpecProviderVaultAuthIam(**iam)
        if isinstance(jwt, dict):
            jwt = SecretStoreV1Beta1SpecProviderVaultAuthJwt(**jwt)
        if isinstance(kubernetes, dict):
            kubernetes = SecretStoreV1Beta1SpecProviderVaultAuthKubernetes(**kubernetes)
        if isinstance(ldap, dict):
            ldap = SecretStoreV1Beta1SpecProviderVaultAuthLdap(**ldap)
        if isinstance(token_secret_ref, dict):
            token_secret_ref = SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef(**token_secret_ref)
        if isinstance(user_pass, dict):
            user_pass = SecretStoreV1Beta1SpecProviderVaultAuthUserPass(**user_pass)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__400104a61eab9ca884187e2efbafa3aa344cc85d8fcba6bbf7136fc0639c2284)
            check_type(argname="argument app_role", value=app_role, expected_type=type_hints["app_role"])
            check_type(argname="argument cert", value=cert, expected_type=type_hints["cert"])
            check_type(argname="argument iam", value=iam, expected_type=type_hints["iam"])
            check_type(argname="argument jwt", value=jwt, expected_type=type_hints["jwt"])
            check_type(argname="argument kubernetes", value=kubernetes, expected_type=type_hints["kubernetes"])
            check_type(argname="argument ldap", value=ldap, expected_type=type_hints["ldap"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument token_secret_ref", value=token_secret_ref, expected_type=type_hints["token_secret_ref"])
            check_type(argname="argument user_pass", value=user_pass, expected_type=type_hints["user_pass"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if app_role is not None:
            self._values["app_role"] = app_role
        if cert is not None:
            self._values["cert"] = cert
        if iam is not None:
            self._values["iam"] = iam
        if jwt is not None:
            self._values["jwt"] = jwt
        if kubernetes is not None:
            self._values["kubernetes"] = kubernetes
        if ldap is not None:
            self._values["ldap"] = ldap
        if namespace is not None:
            self._values["namespace"] = namespace
        if token_secret_ref is not None:
            self._values["token_secret_ref"] = token_secret_ref
        if user_pass is not None:
            self._values["user_pass"] = user_pass

    @builtins.property
    def app_role(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthAppRole"]:
        '''AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuth#appRole
        '''
        result = self._values.get("app_role")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthAppRole"], result)

    @builtins.property
    def cert(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthCert"]:
        '''Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuth#cert
        '''
        result = self._values.get("cert")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthCert"], result)

    @builtins.property
    def iam(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthIam"]:
        '''Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials AWS IAM authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuth#iam
        '''
        result = self._values.get("iam")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthIam"], result)

    @builtins.property
    def jwt(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthJwt"]:
        '''Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuth#jwt
        '''
        result = self._values.get("jwt")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthJwt"], result)

    @builtins.property
    def kubernetes(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthKubernetes"]:
        '''Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuth#kubernetes
        '''
        result = self._values.get("kubernetes")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthKubernetes"], result)

    @builtins.property
    def ldap(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthLdap"]:
        '''Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuth#ldap
        '''
        result = self._values.get("ldap")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthLdap"], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Name of the vault namespace to authenticate to.

        This can be different than the namespace your secret is in.
        Namespaces is a set of features within Vault Enterprise that allows
        Vault environments to support Secure Multi-tenancy. e.g: "ns1".
        More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
        This will default to Vault.Namespace field if set, or empty otherwise

        :schema: SecretStoreV1Beta1SpecProviderVaultAuth#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def token_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef"]:
        '''TokenSecretRef authenticates with Vault by presenting a token.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuth#tokenSecretRef
        '''
        result = self._values.get("token_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef"], result)

    @builtins.property
    def user_pass(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthUserPass"]:
        '''UserPass authenticates with Vault by passing username/password pair.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuth#userPass
        '''
        result = self._values.get("user_pass")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthUserPass"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthAppRole",
    jsii_struct_bases=[],
    name_mapping={
        "path": "path",
        "secret_ref": "secretRef",
        "role_id": "roleId",
        "role_ref": "roleRef",
    },
)
class SecretStoreV1Beta1SpecProviderVaultAuthAppRole:
    def __init__(
        self,
        *,
        path: builtins.str,
        secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef", typing.Dict[builtins.str, typing.Any]],
        role_id: typing.Optional[builtins.str] = None,
        role_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.

        :param path: Path where the App Role authentication backend is mounted in Vault, e.g: "approle".
        :param secret_ref: Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The ``key`` field must be specified and denotes which entry within the Secret resource is used as the app role secret.
        :param role_id: RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.
        :param role_ref: Reference to a key in a Secret that contains the App Role ID used to authenticate with Vault. The ``key`` field must be specified and denotes which entry within the Secret resource is used as the app role id.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRole
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef(**secret_ref)
        if isinstance(role_ref, dict):
            role_ref = SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef(**role_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2612fd31ff239b5943a7df02b5760bc325d209684ea6b63f06098ab23d9a896b)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument role_id", value=role_id, expected_type=type_hints["role_id"])
            check_type(argname="argument role_ref", value=role_ref, expected_type=type_hints["role_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
            "secret_ref": secret_ref,
        }
        if role_id is not None:
            self._values["role_id"] = role_id
        if role_ref is not None:
            self._values["role_ref"] = role_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the App Role authentication backend is mounted in Vault, e.g: "approle".

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRole#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(self) -> "SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef":
        '''Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret
        resource is used as the app role secret.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRole#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef", result)

    @builtins.property
    def role_id(self) -> typing.Optional[builtins.str]:
        '''RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRole#roleId
        '''
        result = self._values.get("role_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef"]:
        '''Reference to a key in a Secret that contains the App Role ID used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret
        resource is used as the app role id.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRole#roleRef
        '''
        result = self._values.get("role_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthAppRole(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to a key in a Secret that contains the App Role ID used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret
        resource is used as the app role id.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b4c16b55f19c130c4ce14b1c9d8b43aa77fec107e12f8b4c4a0935b9424e2136)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret
        resource is used as the app role secret.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3eedd159a87fe07e72cce871971add22df1a8d80a195cfeacb05a624140b9884)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthCert",
    jsii_struct_bases=[],
    name_mapping={"client_cert": "clientCert", "secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthCert:
    def __init__(
        self,
        *,
        client_cert: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.

        :param client_cert: ClientCert is a certificate to authenticate using the Cert Vault authentication method.
        :param secret_ref: SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCert
        '''
        if isinstance(client_cert, dict):
            client_cert = SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert(**client_cert)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a2b41d62225e08c00b6e892d8bf36e67169f93c0a408c744fe8a1d0619927eaf)
            check_type(argname="argument client_cert", value=client_cert, expected_type=type_hints["client_cert"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if client_cert is not None:
            self._values["client_cert"] = client_cert
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def client_cert(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert"]:
        '''ClientCert is a certificate to authenticate using the Cert Vault authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCert#clientCert
        '''
        result = self._values.get("client_cert")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef"]:
        '''SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCert#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ClientCert is a certificate to authenticate using the Cert Vault authentication method.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__81b9aa8a124bab828cff9a54e645168f18bd4cb1346e28b31c135ec26d61be17)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__657764136effba05124a02f44146e137354371a76c2326fe46f2a98a9578d15c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthIam",
    jsii_struct_bases=[],
    name_mapping={
        "vault_role": "vaultRole",
        "external_id": "externalId",
        "jwt": "jwt",
        "path": "path",
        "region": "region",
        "role": "role",
        "secret_ref": "secretRef",
        "vault_aws_iam_server_id": "vaultAwsIamServerId",
    },
)
class SecretStoreV1Beta1SpecProviderVaultAuthIam:
    def __init__(
        self,
        *,
        vault_role: builtins.str,
        external_id: typing.Optional[builtins.str] = None,
        jwt: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthIamJwt", typing.Dict[builtins.str, typing.Any]]] = None,
        path: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        role: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        vault_aws_iam_server_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials AWS IAM authentication method.

        :param vault_role: Vault Role. In vault, a role describes an identity with a set of permissions, groups, or policies you want to attach a user of the secrets engine
        :param external_id: AWS External ID set on assumed IAM roles.
        :param jwt: Specify a service account with IRSA enabled.
        :param path: Path where the AWS auth method is enabled in Vault, e.g: "aws".
        :param region: AWS region.
        :param role: This is the AWS role to be assumed before talking to vault.
        :param secret_ref: Specify credentials in a Secret object.
        :param vault_aws_iam_server_id: X-Vault-AWS-IAM-Server-ID is an additional header used by Vault IAM auth method to mitigate against different types of replay attacks. More details here: https://developer.hashicorp.com/vault/docs/auth/aws

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIam
        '''
        if isinstance(jwt, dict):
            jwt = SecretStoreV1Beta1SpecProviderVaultAuthIamJwt(**jwt)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f468cd0ca129fbfeaf1ca590f1fa7be7924ebb8fc7a88dbb6a302c3ba4cacde7)
            check_type(argname="argument vault_role", value=vault_role, expected_type=type_hints["vault_role"])
            check_type(argname="argument external_id", value=external_id, expected_type=type_hints["external_id"])
            check_type(argname="argument jwt", value=jwt, expected_type=type_hints["jwt"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument vault_aws_iam_server_id", value=vault_aws_iam_server_id, expected_type=type_hints["vault_aws_iam_server_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vault_role": vault_role,
        }
        if external_id is not None:
            self._values["external_id"] = external_id
        if jwt is not None:
            self._values["jwt"] = jwt
        if path is not None:
            self._values["path"] = path
        if region is not None:
            self._values["region"] = region
        if role is not None:
            self._values["role"] = role
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if vault_aws_iam_server_id is not None:
            self._values["vault_aws_iam_server_id"] = vault_aws_iam_server_id

    @builtins.property
    def vault_role(self) -> builtins.str:
        '''Vault Role.

        In vault, a role describes an identity with a set of permissions, groups, or policies you want to attach a user of the secrets engine

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIam#vaultRole
        '''
        result = self._values.get("vault_role")
        assert result is not None, "Required property 'vault_role' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def external_id(self) -> typing.Optional[builtins.str]:
        '''AWS External ID set on assumed IAM roles.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIam#externalID
        '''
        result = self._values.get("external_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def jwt(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthIamJwt"]:
        '''Specify a service account with IRSA enabled.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIam#jwt
        '''
        result = self._values.get("jwt")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthIamJwt"], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''Path where the AWS auth method is enabled in Vault, e.g: "aws".

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIam#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''AWS region.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIam#region
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''This is the AWS role to be assumed before talking to vault.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIam#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef"]:
        '''Specify credentials in a Secret object.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIam#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef"], result)

    @builtins.property
    def vault_aws_iam_server_id(self) -> typing.Optional[builtins.str]:
        '''X-Vault-AWS-IAM-Server-ID is an additional header used by Vault IAM auth method to mitigate against different types of replay attacks.

        More details here: https://developer.hashicorp.com/vault/docs/auth/aws

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIam#vaultAwsIamServerID
        '''
        result = self._values.get("vault_aws_iam_server_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthIam(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthIamJwt",
    jsii_struct_bases=[],
    name_mapping={"service_account_ref": "serviceAccountRef"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthIamJwt:
    def __init__(
        self,
        *,
        service_account_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Specify a service account with IRSA enabled.

        :param service_account_ref: A reference to a ServiceAccount resource.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamJwt
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c8f4b2ded0305473504456d4e0e3ee262917925163178794b1eeef16e025e6f1)
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef"]:
        '''A reference to a ServiceAccount resource.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamJwt#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthIamJwt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7346dc011e1a6503794428c85d02111448071c64e9eccec71123823e461d2e43)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_key_id_secret_ref": "accessKeyIdSecretRef",
        "secret_access_key_secret_ref": "secretAccessKeySecretRef",
        "session_token_secret_ref": "sessionTokenSecretRef",
    },
)
class SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef:
    def __init__(
        self,
        *,
        access_key_id_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        secret_access_key_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        session_token_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Specify credentials in a Secret object.

        :param access_key_id_secret_ref: The AccessKeyID is used for authentication.
        :param secret_access_key_secret_ref: The SecretAccessKey is used for authentication.
        :param session_token_secret_ref: The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef
        '''
        if isinstance(access_key_id_secret_ref, dict):
            access_key_id_secret_ref = SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef(**access_key_id_secret_ref)
        if isinstance(secret_access_key_secret_ref, dict):
            secret_access_key_secret_ref = SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef(**secret_access_key_secret_ref)
        if isinstance(session_token_secret_ref, dict):
            session_token_secret_ref = SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef(**session_token_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2460e7bc5089e6de0bf5b9e8882808c76d0e830b52b941edef97dc327188b612)
            check_type(argname="argument access_key_id_secret_ref", value=access_key_id_secret_ref, expected_type=type_hints["access_key_id_secret_ref"])
            check_type(argname="argument secret_access_key_secret_ref", value=secret_access_key_secret_ref, expected_type=type_hints["secret_access_key_secret_ref"])
            check_type(argname="argument session_token_secret_ref", value=session_token_secret_ref, expected_type=type_hints["session_token_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if access_key_id_secret_ref is not None:
            self._values["access_key_id_secret_ref"] = access_key_id_secret_ref
        if secret_access_key_secret_ref is not None:
            self._values["secret_access_key_secret_ref"] = secret_access_key_secret_ref
        if session_token_secret_ref is not None:
            self._values["session_token_secret_ref"] = session_token_secret_ref

    @builtins.property
    def access_key_id_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef"]:
        '''The AccessKeyID is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#accessKeyIDSecretRef
        '''
        result = self._values.get("access_key_id_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef"], result)

    @builtins.property
    def secret_access_key_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#secretAccessKeySecretRef
        '''
        result = self._values.get("secret_access_key_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef"], result)

    @builtins.property
    def session_token_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef"]:
        '''The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#sessionTokenSecretRef
        '''
        result = self._values.get("session_token_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeyID is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bee80d133343a363e678632de3cd08f225089721a9fd0cf312c8e0a0a92f8608)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2c2b5d787d2bc8de48162516483e085294330f9cedebb9b400821e8a4cc772a)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b36a03a3c010f24ddce190cc4932b49fad407b9d9efe43dbb0a45bcd301ab372)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthJwt",
    jsii_struct_bases=[],
    name_mapping={
        "path": "path",
        "kubernetes_service_account_token": "kubernetesServiceAccountToken",
        "role": "role",
        "secret_ref": "secretRef",
    },
)
class SecretStoreV1Beta1SpecProviderVaultAuthJwt:
    def __init__(
        self,
        *,
        path: builtins.str,
        kubernetes_service_account_token: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken", typing.Dict[builtins.str, typing.Any]]] = None,
        role: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.

        :param path: Path where the JWT authentication backend is mounted in Vault, e.g: "jwt".
        :param kubernetes_service_account_token: Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.
        :param role: Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method.
        :param secret_ref: Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwt
        '''
        if isinstance(kubernetes_service_account_token, dict):
            kubernetes_service_account_token = SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken(**kubernetes_service_account_token)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6d12691f0946a3be88b3813dd9e0f8618296ec3e293c8acdabef8eacd866a2c0)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument kubernetes_service_account_token", value=kubernetes_service_account_token, expected_type=type_hints["kubernetes_service_account_token"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
        }
        if kubernetes_service_account_token is not None:
            self._values["kubernetes_service_account_token"] = kubernetes_service_account_token
        if role is not None:
            self._values["role"] = role
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the JWT authentication backend is mounted in Vault, e.g: "jwt".

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwt#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def kubernetes_service_account_token(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken"]:
        '''Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwt#kubernetesServiceAccountToken
        '''
        result = self._values.get("kubernetes_service_account_token")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken"], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwt#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef"]:
        '''Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwt#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthJwt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken",
    jsii_struct_bases=[],
    name_mapping={
        "service_account_ref": "serviceAccountRef",
        "audiences": "audiences",
        "expiration_seconds": "expirationSeconds",
    },
)
class SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken:
    def __init__(
        self,
        *,
        service_account_ref: typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef", typing.Dict[builtins.str, typing.Any]],
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        expiration_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :param service_account_ref: Service account field containing the name of a kubernetes ServiceAccount.
        :param audiences: Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``. Defaults to a single audience ``vault`` it not specified. Deprecated: use serviceAccountRef.Audiences instead Default: a single audience ``vault`` it not specified.
        :param expiration_seconds: Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``. Deprecated: this will be removed in the future. Defaults to 10 minutes. Default: 10 minutes.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c244c831d1b55ba6714b2abfe1ec15f86e2d2e02854d87e4b37e4b5fa8cf5aac)
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument expiration_seconds", value=expiration_seconds, expected_type=type_hints["expiration_seconds"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "service_account_ref": service_account_ref,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if expiration_seconds is not None:
            self._values["expiration_seconds"] = expiration_seconds

    @builtins.property
    def service_account_ref(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef":
        '''Service account field containing the name of a kubernetes ServiceAccount.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        assert result is not None, "Required property 'service_account_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef", result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``.

        Defaults to a single audience ``vault`` it not specified.
        Deprecated: use serviceAccountRef.Audiences instead

        :default: a single audience ``vault`` it not specified.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def expiration_seconds(self) -> typing.Optional[jsii.Number]:
        '''Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``.

        Deprecated: this will be removed in the future.
        Defaults to 10 minutes.

        :default: 10 minutes.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#expirationSeconds
        '''
        result = self._values.get("expiration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Service account field containing the name of a kubernetes ServiceAccount.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__581d82abfc24873710a507cda618c0e4e6ae222d91b35a395a9b26c7d8017c4f)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4ef4ba406e97456fd40e81e83a1b292cf26640faa7de7c46bc8d554c0d636659)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthKubernetes",
    jsii_struct_bases=[],
    name_mapping={
        "mount_path": "mountPath",
        "role": "role",
        "secret_ref": "secretRef",
        "service_account_ref": "serviceAccountRef",
    },
)
class SecretStoreV1Beta1SpecProviderVaultAuthKubernetes:
    def __init__(
        self,
        *,
        mount_path: builtins.str,
        role: builtins.str,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        service_account_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.

        :param mount_path: Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes".
        :param role: A required field containing the Vault Role to assume. A Role binds a Kubernetes ServiceAccount with a set of Vault policies.
        :param secret_ref: Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.
        :param service_account_ref: Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetes
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef(**secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef(**service_account_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1336a204e0559ec7dfb15e3a1be1add384c119b846b080cc482c4ca2dbc0f301)
            check_type(argname="argument mount_path", value=mount_path, expected_type=type_hints["mount_path"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "mount_path": mount_path,
            "role": role,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def mount_path(self) -> builtins.str:
        '''Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes".

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetes#mountPath
        '''
        result = self._values.get("mount_path")
        assert result is not None, "Required property 'mount_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role(self) -> builtins.str:
        '''A required field containing the Vault Role to assume.

        A Role binds a
        Kubernetes ServiceAccount with a set of Vault policies.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetes#role
        '''
        result = self._values.get("role")
        assert result is not None, "Required property 'role' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef"]:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault.

        If a name is specified without a key,
        ``token`` is the default. If one is not specified, the one bound to
        the controller will be used.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetes#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef"]:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used
        for authenticating with Vault. If the service account selector is not supplied,
        the secretRef will be used instead.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetes#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthKubernetes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault.

        If a name is specified without a key,
        ``token`` is the default. If one is not specified, the one bound to
        the controller will be used.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f9c90383fbc90b9ffe85575c9a5dab35b486f50b27d31d5d2c4c44954cc18ad)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used
        for authenticating with Vault. If the service account selector is not supplied,
        the secretRef will be used instead.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__22b5d8d69b247e7e694dbd8a0366bd7c5c79be42ffba34090f076bba7dfc8150)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthLdap",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "username": "username", "secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthLdap:
    def __init__(
        self,
        *,
        path: builtins.str,
        username: builtins.str,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.

        :param path: Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap".
        :param username: Username is a LDAP user name used to authenticate using the LDAP Vault authentication method.
        :param secret_ref: SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthLdap
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e2b90e477cfebcc2b16c4c2fcce1ab775265e753d97d71cc18bf29c5cde3a9c9)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
            "username": username,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap".

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthLdap#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def username(self) -> builtins.str:
        '''Username is a LDAP user name used to authenticate using the LDAP Vault authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthLdap#username
        '''
        result = self._values.get("username")
        assert result is not None, "Required property 'username' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef"]:
        '''SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthLdap#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthLdap(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b3e2b5ca54356668b28b28010a671ca9c9051d330ec2474db708d50ec1cafc20)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''TokenSecretRef authenticates with Vault by presenting a token.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d517595b96eeeec71f466e5bfb29bd6b5c39213c8c5e12d513ed5717a5e79f6c)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthUserPass",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "username": "username", "secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthUserPass:
    def __init__(
        self,
        *,
        path: builtins.str,
        username: builtins.str,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''UserPass authenticates with Vault by passing username/password pair.

        :param path: Path where the UserPassword authentication backend is mounted in Vault, e.g: "user".
        :param username: Username is a user name used to authenticate using the UserPass Vault authentication method.
        :param secret_ref: SecretRef to a key in a Secret resource containing password for the user used to authenticate with Vault using the UserPass authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthUserPass
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__26b580e6525ab3445d9b91a981e063443ceb4b0e487369d400b953f01d78bb0d)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "path": path,
            "username": username,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the UserPassword authentication backend is mounted in Vault, e.g: "user".

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthUserPass#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def username(self) -> builtins.str:
        '''Username is a user name used to authenticate using the UserPass Vault authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthUserPass#username
        '''
        result = self._values.get("username")
        assert result is not None, "Required property 'username' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef"]:
        '''SecretRef to a key in a Secret resource containing password for the user used to authenticate with Vault using the UserPass authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthUserPass#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthUserPass(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef to a key in a Secret resource containing password for the user used to authenticate with Vault using the UserPass authentication method.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__194772104ad7af101c2de89b6ad71d08cfd0b369fe1e71b9d9f4735a47320e52)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class SecretStoreV1Beta1SpecProviderVaultCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "SecretStoreV1Beta1SpecProviderVaultCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Vault server certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.

        :schema: SecretStoreV1Beta1SpecProviderVaultCaProvider
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__32dea37cf93e2ea75f29adf17d3938b2218a712b370866878b2757313182fb2d)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: SecretStoreV1Beta1SpecProviderVaultCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "SecretStoreV1Beta1SpecProviderVaultCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: SecretStoreV1Beta1SpecProviderVaultCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderVaultCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: SecretStoreV1Beta1SpecProviderVaultCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        Can only be defined when used in a ClusterSecretStore.

        :schema: SecretStoreV1Beta1SpecProviderVaultCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultCaProviderType"
)
class SecretStoreV1Beta1SpecProviderVaultCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: SecretStoreV1Beta1SpecProviderVaultCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultTls",
    jsii_struct_bases=[],
    name_mapping={
        "cert_secret_ref": "certSecretRef",
        "key_secret_ref": "keySecretRef",
    },
)
class SecretStoreV1Beta1SpecProviderVaultTls:
    def __init__(
        self,
        *,
        cert_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
        key_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''The configuration used for client side related TLS communication, when the Vault server requires mutual authentication.

        Only used if the Server URL is using HTTPS protocol.
        This parameter is ignored for plain HTTP protocol connection.
        It's worth noting this configuration is different from the "TLS certificates auth method",
        which is available under the ``auth.cert`` section.

        :param cert_secret_ref: CertSecretRef is a certificate added to the transport layer when communicating with the Vault server. If no key for the Secret is specified, external-secret will default to 'tls.crt'.
        :param key_secret_ref: KeySecretRef to a key in a Secret resource containing client private key added to the transport layer when communicating with the Vault server. If no key for the Secret is specified, external-secret will default to 'tls.key'.

        :schema: SecretStoreV1Beta1SpecProviderVaultTls
        '''
        if isinstance(cert_secret_ref, dict):
            cert_secret_ref = SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef(**cert_secret_ref)
        if isinstance(key_secret_ref, dict):
            key_secret_ref = SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef(**key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fab4fa2118e761f43d471939d2609be45e644e4caad93f6c1903c7e2891f558b)
            check_type(argname="argument cert_secret_ref", value=cert_secret_ref, expected_type=type_hints["cert_secret_ref"])
            check_type(argname="argument key_secret_ref", value=key_secret_ref, expected_type=type_hints["key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cert_secret_ref is not None:
            self._values["cert_secret_ref"] = cert_secret_ref
        if key_secret_ref is not None:
            self._values["key_secret_ref"] = key_secret_ref

    @builtins.property
    def cert_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef"]:
        '''CertSecretRef is a certificate added to the transport layer when communicating with the Vault server.

        If no key for the Secret is specified, external-secret will default to 'tls.crt'.

        :schema: SecretStoreV1Beta1SpecProviderVaultTls#certSecretRef
        '''
        result = self._values.get("cert_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef"], result)

    @builtins.property
    def key_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef"]:
        '''KeySecretRef to a key in a Secret resource containing client private key added to the transport layer when communicating with the Vault server.

        If no key for the Secret is specified, external-secret will default to 'tls.key'.

        :schema: SecretStoreV1Beta1SpecProviderVaultTls#keySecretRef
        '''
        result = self._values.get("key_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultTls(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''CertSecretRef is a certificate added to the transport layer when communicating with the Vault server.

        If no key for the Secret is specified, external-secret will default to 'tls.crt'.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b5f1f826ab42f41a7a85805f377a816e90679ccc5ac3167e7de43fc68e87c137)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''KeySecretRef to a key in a Secret resource containing client private key added to the transport layer when communicating with the Vault server.

        If no key for the Secret is specified, external-secret will default to 'tls.key'.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7c2580e3c74388f828c123433a329221fa36b0958fcfd40ad56bbc96daad799e)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultVersion")
class SecretStoreV1Beta1SpecProviderVaultVersion(enum.Enum):
    '''Version is the Vault KV secret engine version.

    This can be either "v1" or
    "v2". Version defaults to "v2".

    :schema: SecretStoreV1Beta1SpecProviderVaultVersion
    '''

    V1 = "V1"
    '''v1.'''
    V2 = "V2"
    '''v2.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderWebhook",
    jsii_struct_bases=[],
    name_mapping={
        "result": "result",
        "url": "url",
        "body": "body",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
        "headers": "headers",
        "method": "method",
        "secrets": "secrets",
        "timeout": "timeout",
    },
)
class SecretStoreV1Beta1SpecProviderWebhook:
    def __init__(
        self,
        *,
        result: typing.Union["SecretStoreV1Beta1SpecProviderWebhookResult", typing.Dict[builtins.str, typing.Any]],
        url: builtins.str,
        body: typing.Optional[builtins.str] = None,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderWebhookCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
        headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        method: typing.Optional[builtins.str] = None,
        secrets: typing.Optional[typing.Sequence[typing.Union["SecretStoreV1Beta1SpecProviderWebhookSecrets", typing.Dict[builtins.str, typing.Any]]]] = None,
        timeout: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Webhook configures this store to sync secrets using a generic templated webhook.

        :param result: Result formatting.
        :param url: Webhook url to call.
        :param body: Body.
        :param ca_bundle: PEM encoded CA bundle used to validate webhook server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
        :param ca_provider: The provider for the CA bundle to use to validate webhook server certificate.
        :param headers: Headers.
        :param method: Webhook Method.
        :param secrets: Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name.
        :param timeout: Timeout.

        :schema: SecretStoreV1Beta1SpecProviderWebhook
        '''
        if isinstance(result, dict):
            result = SecretStoreV1Beta1SpecProviderWebhookResult(**result)
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreV1Beta1SpecProviderWebhookCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf5abb92c60012a2736376d90e7ef4e3c9cd3bcf7cf74f99e2df1cd1a13680c0)
            check_type(argname="argument result", value=result, expected_type=type_hints["result"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
            check_type(argname="argument body", value=body, expected_type=type_hints["body"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument headers", value=headers, expected_type=type_hints["headers"])
            check_type(argname="argument method", value=method, expected_type=type_hints["method"])
            check_type(argname="argument secrets", value=secrets, expected_type=type_hints["secrets"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "result": result,
            "url": url,
        }
        if body is not None:
            self._values["body"] = body
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if headers is not None:
            self._values["headers"] = headers
        if method is not None:
            self._values["method"] = method
        if secrets is not None:
            self._values["secrets"] = secrets
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def result(self) -> "SecretStoreV1Beta1SpecProviderWebhookResult":
        '''Result formatting.

        :schema: SecretStoreV1Beta1SpecProviderWebhook#result
        '''
        result = self._values.get("result")
        assert result is not None, "Required property 'result' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderWebhookResult", result)

    @builtins.property
    def url(self) -> builtins.str:
        '''Webhook url to call.

        :schema: SecretStoreV1Beta1SpecProviderWebhook#url
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def body(self) -> typing.Optional[builtins.str]:
        '''Body.

        :schema: SecretStoreV1Beta1SpecProviderWebhook#body
        '''
        result = self._values.get("body")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''PEM encoded CA bundle used to validate webhook server certificate.

        Only used
        if the Server URL is using HTTPS protocol. This parameter is ignored for
        plain HTTP protocol connection. If not set the system root certificates
        are used to validate the TLS connection.

        :schema: SecretStoreV1Beta1SpecProviderWebhook#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderWebhookCaProvider"]:
        '''The provider for the CA bundle to use to validate webhook server certificate.

        :schema: SecretStoreV1Beta1SpecProviderWebhook#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderWebhookCaProvider"], result)

    @builtins.property
    def headers(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Headers.

        :schema: SecretStoreV1Beta1SpecProviderWebhook#headers
        '''
        result = self._values.get("headers")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def method(self) -> typing.Optional[builtins.str]:
        '''Webhook Method.

        :schema: SecretStoreV1Beta1SpecProviderWebhook#method
        '''
        result = self._values.get("method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secrets(
        self,
    ) -> typing.Optional[typing.List["SecretStoreV1Beta1SpecProviderWebhookSecrets"]]:
        '''Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name.

        :schema: SecretStoreV1Beta1SpecProviderWebhook#secrets
        '''
        result = self._values.get("secrets")
        return typing.cast(typing.Optional[typing.List["SecretStoreV1Beta1SpecProviderWebhookSecrets"]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[builtins.str]:
        '''Timeout.

        :schema: SecretStoreV1Beta1SpecProviderWebhook#timeout
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderWebhook(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderWebhookCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class SecretStoreV1Beta1SpecProviderWebhookCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "SecretStoreV1Beta1SpecProviderWebhookCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate webhook server certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in.

        :schema: SecretStoreV1Beta1SpecProviderWebhookCaProvider
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5fce432ce0e2eae6e5a8f1412837e18641603a6e8b15d4aec34e332993b5462d)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: SecretStoreV1Beta1SpecProviderWebhookCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "SecretStoreV1Beta1SpecProviderWebhookCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: SecretStoreV1Beta1SpecProviderWebhookCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderWebhookCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: SecretStoreV1Beta1SpecProviderWebhookCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        :schema: SecretStoreV1Beta1SpecProviderWebhookCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderWebhookCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderWebhookCaProviderType"
)
class SecretStoreV1Beta1SpecProviderWebhookCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: SecretStoreV1Beta1SpecProviderWebhookCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderWebhookResult",
    jsii_struct_bases=[],
    name_mapping={"json_path": "jsonPath"},
)
class SecretStoreV1Beta1SpecProviderWebhookResult:
    def __init__(self, *, json_path: typing.Optional[builtins.str] = None) -> None:
        '''Result formatting.

        :param json_path: Json path of return value.

        :schema: SecretStoreV1Beta1SpecProviderWebhookResult
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__58b32e121616882afc75d18b197bdf2ce88622a99c612074a8bd3b067ca6b802)
            check_type(argname="argument json_path", value=json_path, expected_type=type_hints["json_path"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if json_path is not None:
            self._values["json_path"] = json_path

    @builtins.property
    def json_path(self) -> typing.Optional[builtins.str]:
        '''Json path of return value.

        :schema: SecretStoreV1Beta1SpecProviderWebhookResult#jsonPath
        '''
        result = self._values.get("json_path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderWebhookResult(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderWebhookSecrets",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderWebhookSecrets:
    def __init__(
        self,
        *,
        name: builtins.str,
        secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef", typing.Dict[builtins.str, typing.Any]],
    ) -> None:
        '''
        :param name: Name of this secret in templates.
        :param secret_ref: Secret ref to fill in credentials.

        :schema: SecretStoreV1Beta1SpecProviderWebhookSecrets
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef(**secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__778a8f2be6f5511228d406820684a94d08bd1a9b6159ffdc456566fb25eb337c)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "name": name,
            "secret_ref": secret_ref,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of this secret in templates.

        :schema: SecretStoreV1Beta1SpecProviderWebhookSecrets#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(self) -> "SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef":
        '''Secret ref to fill in credentials.

        :schema: SecretStoreV1Beta1SpecProviderWebhookSecrets#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderWebhookSecrets(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Secret ref to fill in credentials.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d7dca2ad9349a9d2fe7a5896781f6b52ecbf67e082b9d411ea3413a41b00a7e2)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderYandexcertificatemanager",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "api_endpoint": "apiEndpoint",
        "ca_provider": "caProvider",
    },
)
class SecretStoreV1Beta1SpecProviderYandexcertificatemanager:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth", typing.Dict[builtins.str, typing.Any]],
        api_endpoint: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider.

        :param auth: Auth defines the information necessary to authenticate against Yandex Certificate Manager.
        :param api_endpoint: Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').
        :param ca_provider: The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanager
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__08d808c8d7f62d085e205bb96b9a022d41d531ac28d062038109210ab5c79576)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument api_endpoint", value=api_endpoint, expected_type=type_hints["api_endpoint"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
        }
        if api_endpoint is not None:
            self._values["api_endpoint"] = api_endpoint
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth":
        '''Auth defines the information necessary to authenticate against Yandex Certificate Manager.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanager#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth", result)

    @builtins.property
    def api_endpoint(self) -> typing.Optional[builtins.str]:
        '''Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanager#apiEndpoint
        '''
        result = self._values.get("api_endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider"]:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanager#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderYandexcertificatemanager(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth",
    jsii_struct_bases=[],
    name_mapping={"authorized_key_secret_ref": "authorizedKeySecretRef"},
)
class SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth:
    def __init__(
        self,
        *,
        authorized_key_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against Yandex Certificate Manager.

        :param authorized_key_secret_ref: The authorized key used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth
        '''
        if isinstance(authorized_key_secret_ref, dict):
            authorized_key_secret_ref = SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(**authorized_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ddd2993bc954fd084ce9e84b9bbea1a36c9f386d6fe8911f4f2f6fd2d5960b5c)
            check_type(argname="argument authorized_key_secret_ref", value=authorized_key_secret_ref, expected_type=type_hints["authorized_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if authorized_key_secret_ref is not None:
            self._values["authorized_key_secret_ref"] = authorized_key_secret_ref

    @builtins.property
    def authorized_key_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef"]:
        '''The authorized key used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth#authorizedKeySecretRef
        '''
        result = self._values.get("authorized_key_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The authorized key used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cfe09b0333f706d3c8197ef3f83ef7d4cc18d05556e2702e2179d843c118df6d)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider",
    jsii_struct_bases=[],
    name_mapping={"cert_secret_ref": "certSecretRef"},
)
class SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider:
    def __init__(
        self,
        *,
        cert_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :param cert_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider
        '''
        if isinstance(cert_secret_ref, dict):
            cert_secret_ref = SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef(**cert_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d449498ebeb1647186fb96828f0f757a8d444078c80997ab79f408890f18fb19)
            check_type(argname="argument cert_secret_ref", value=cert_secret_ref, expected_type=type_hints["cert_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cert_secret_ref is not None:
            self._values["cert_secret_ref"] = cert_secret_ref

    @builtins.property
    def cert_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider#certSecretRef
        '''
        result = self._values.get("cert_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__58a3bafa9427d99fbe6f7e616a670af9a996c35120dd0ab4a536cff4eb503180)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderYandexlockbox",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "api_endpoint": "apiEndpoint",
        "ca_provider": "caProvider",
    },
)
class SecretStoreV1Beta1SpecProviderYandexlockbox:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderYandexlockboxAuth", typing.Dict[builtins.str, typing.Any]],
        api_endpoint: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :param auth: Auth defines the information necessary to authenticate against Yandex Lockbox.
        :param api_endpoint: Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').
        :param ca_provider: The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockbox
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderYandexlockboxAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider(**ca_provider)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bf99b289f0ca917180063a71bc7afdafa9ac3bbfc28ac2c699675e6901606a6d)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument api_endpoint", value=api_endpoint, expected_type=type_hints["api_endpoint"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auth": auth,
        }
        if api_endpoint is not None:
            self._values["api_endpoint"] = api_endpoint
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderYandexlockboxAuth":
        '''Auth defines the information necessary to authenticate against Yandex Lockbox.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockbox#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderYandexlockboxAuth", result)

    @builtins.property
    def api_endpoint(self) -> typing.Optional[builtins.str]:
        '''Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').

        :schema: SecretStoreV1Beta1SpecProviderYandexlockbox#apiEndpoint
        '''
        result = self._values.get("api_endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider"]:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockbox#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderYandexlockbox(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderYandexlockboxAuth",
    jsii_struct_bases=[],
    name_mapping={"authorized_key_secret_ref": "authorizedKeySecretRef"},
)
class SecretStoreV1Beta1SpecProviderYandexlockboxAuth:
    def __init__(
        self,
        *,
        authorized_key_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against Yandex Lockbox.

        :param authorized_key_secret_ref: The authorized key used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxAuth
        '''
        if isinstance(authorized_key_secret_ref, dict):
            authorized_key_secret_ref = SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef(**authorized_key_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__320475850982319810875521d97ba7cfe93494d4e6f6a9a7089951c51615ec74)
            check_type(argname="argument authorized_key_secret_ref", value=authorized_key_secret_ref, expected_type=type_hints["authorized_key_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if authorized_key_secret_ref is not None:
            self._values["authorized_key_secret_ref"] = authorized_key_secret_ref

    @builtins.property
    def authorized_key_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef"]:
        '''The authorized key used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxAuth#authorizedKeySecretRef
        '''
        result = self._values.get("authorized_key_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderYandexlockboxAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The authorized key used for authentication.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__46b50c4851b420ec30ee452030b4a8396b34001ade1064d279f4751c9ee31d43)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider",
    jsii_struct_bases=[],
    name_mapping={"cert_secret_ref": "certSecretRef"},
)
class SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider:
    def __init__(
        self,
        *,
        cert_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :param cert_secret_ref: A reference to a specific 'key' within a Secret resource. In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider
        '''
        if isinstance(cert_secret_ref, dict):
            cert_secret_ref = SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef(**cert_secret_ref)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d16120f78f7e83f30028a83b52f165e3bf6cc402c2caf7b6507c86dc972c9a6b)
            check_type(argname="argument cert_secret_ref", value=cert_secret_ref, expected_type=type_hints["cert_secret_ref"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cert_secret_ref is not None:
            self._values["cert_secret_ref"] = cert_secret_ref

    @builtins.property
    def cert_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef"]:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider#certSecretRef
        '''
        result = self._values.get("cert_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource.

        In some instances, ``key`` is a required field.

        :param key: A key in the referenced Secret. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: The namespace of the Secret resource being referred to. Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8756909219ad777e25fd1653205d832b6153e484056da252932b6eceb6f5fe7b)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''A key in the referenced Secret.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace of the Secret resource being referred to.

        Ignored if referent is not cluster-scoped, otherwise defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecRetrySettings",
    jsii_struct_bases=[],
    name_mapping={"max_retries": "maxRetries", "retry_interval": "retryInterval"},
)
class SecretStoreV1Beta1SpecRetrySettings:
    def __init__(
        self,
        *,
        max_retries: typing.Optional[jsii.Number] = None,
        retry_interval: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Used to configure http retries if failed.

        :param max_retries: 
        :param retry_interval: 

        :schema: SecretStoreV1Beta1SpecRetrySettings
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ad5b45d0afd8807d66e967985db427563f25d7a6fb6ec3e2329dbe8187b09b1)
            check_type(argname="argument max_retries", value=max_retries, expected_type=type_hints["max_retries"])
            check_type(argname="argument retry_interval", value=retry_interval, expected_type=type_hints["retry_interval"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if max_retries is not None:
            self._values["max_retries"] = max_retries
        if retry_interval is not None:
            self._values["retry_interval"] = retry_interval

    @builtins.property
    def max_retries(self) -> typing.Optional[jsii.Number]:
        '''
        :schema: SecretStoreV1Beta1SpecRetrySettings#maxRetries
        '''
        result = self._values.get("max_retries")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def retry_interval(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreV1Beta1SpecRetrySettings#retryInterval
        '''
        result = self._values.get("retry_interval")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecRetrySettings(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "ClusterExternalSecret",
    "ClusterExternalSecretProps",
    "ClusterExternalSecretSpec",
    "ClusterExternalSecretSpecExternalSecretMetadata",
    "ClusterExternalSecretSpecExternalSecretSpec",
    "ClusterExternalSecretSpecExternalSecretSpecData",
    "ClusterExternalSecretSpecExternalSecretSpecDataFrom",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromExtract",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromExtractConversionStrategy",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromExtractDecodingStrategy",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromExtractMetadataPolicy",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromFind",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromFindConversionStrategy",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromFindDecodingStrategy",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromFindName",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRefKind",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRefKind",
    "ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef",
    "ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefConversionStrategy",
    "ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefDecodingStrategy",
    "ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefMetadataPolicy",
    "ClusterExternalSecretSpecExternalSecretSpecDataSourceRef",
    "ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef",
    "ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRefKind",
    "ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef",
    "ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRefKind",
    "ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef",
    "ClusterExternalSecretSpecExternalSecretSpecSecretStoreRefKind",
    "ClusterExternalSecretSpecExternalSecretSpecTarget",
    "ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy",
    "ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy",
    "ClusterExternalSecretSpecExternalSecretSpecTargetTemplate",
    "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateEngineVersion",
    "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMergePolicy",
    "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata",
    "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom",
    "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap",
    "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems",
    "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItemsTemplateAs",
    "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret",
    "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems",
    "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItemsTemplateAs",
    "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromTarget",
    "ClusterExternalSecretSpecNamespaceSelector",
    "ClusterExternalSecretSpecNamespaceSelectorMatchExpressions",
    "ClusterExternalSecretSpecNamespaceSelectors",
    "ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions",
    "ClusterSecretStore",
    "ClusterSecretStoreProps",
    "ClusterSecretStoreSpec",
    "ClusterSecretStoreSpecProvider",
    "ClusterSecretStoreSpecProviderAkeyless",
    "ClusterSecretStoreSpecProviderAkeylessAuthSecretRef",
    "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth",
    "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef",
    "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef",
    "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef",
    "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId",
    "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType",
    "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam",
    "ClusterSecretStoreSpecProviderAkeylessCaProvider",
    "ClusterSecretStoreSpecProviderAkeylessCaProviderType",
    "ClusterSecretStoreSpecProviderAlibaba",
    "ClusterSecretStoreSpecProviderAlibabaAuth",
    "ClusterSecretStoreSpecProviderAlibabaAuthRrsa",
    "ClusterSecretStoreSpecProviderAlibabaAuthSecretRef",
    "ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef",
    "ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef",
    "ClusterSecretStoreSpecProviderAws",
    "ClusterSecretStoreSpecProviderAwsAuth",
    "ClusterSecretStoreSpecProviderAwsAuthJwt",
    "ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef",
    "ClusterSecretStoreSpecProviderAwsAuthSecretRef",
    "ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef",
    "ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef",
    "ClusterSecretStoreSpecProviderAwsService",
    "ClusterSecretStoreSpecProviderAzurekv",
    "ClusterSecretStoreSpecProviderAzurekvAuthSecretRef",
    "ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId",
    "ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret",
    "ClusterSecretStoreSpecProviderAzurekvAuthType",
    "ClusterSecretStoreSpecProviderAzurekvServiceAccountRef",
    "ClusterSecretStoreSpecProviderFake",
    "ClusterSecretStoreSpecProviderFakeData",
    "ClusterSecretStoreSpecProviderGcpsm",
    "ClusterSecretStoreSpecProviderGcpsmAuth",
    "ClusterSecretStoreSpecProviderGcpsmAuthSecretRef",
    "ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef",
    "ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity",
    "ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef",
    "ClusterSecretStoreSpecProviderGitlab",
    "ClusterSecretStoreSpecProviderGitlabAuth",
    "ClusterSecretStoreSpecProviderGitlabAuthSecretRef",
    "ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken",
    "ClusterSecretStoreSpecProviderIbm",
    "ClusterSecretStoreSpecProviderIbmAuth",
    "ClusterSecretStoreSpecProviderIbmAuthSecretRef",
    "ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef",
    "ClusterSecretStoreSpecProviderKubernetes",
    "ClusterSecretStoreSpecProviderKubernetesAuth",
    "ClusterSecretStoreSpecProviderKubernetesAuthCert",
    "ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert",
    "ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey",
    "ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount",
    "ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount",
    "ClusterSecretStoreSpecProviderKubernetesAuthToken",
    "ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken",
    "ClusterSecretStoreSpecProviderKubernetesServer",
    "ClusterSecretStoreSpecProviderKubernetesServerCaProvider",
    "ClusterSecretStoreSpecProviderKubernetesServerCaProviderType",
    "ClusterSecretStoreSpecProviderOracle",
    "ClusterSecretStoreSpecProviderOracleAuth",
    "ClusterSecretStoreSpecProviderOracleAuthSecretRef",
    "ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint",
    "ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey",
    "ClusterSecretStoreSpecProviderOraclePrincipalType",
    "ClusterSecretStoreSpecProviderOracleServiceAccountRef",
    "ClusterSecretStoreSpecProviderPassworddepot",
    "ClusterSecretStoreSpecProviderPassworddepotAuth",
    "ClusterSecretStoreSpecProviderPassworddepotAuthSecretRef",
    "ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials",
    "ClusterSecretStoreSpecProviderVault",
    "ClusterSecretStoreSpecProviderVaultAuth",
    "ClusterSecretStoreSpecProviderVaultAuthAppRole",
    "ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef",
    "ClusterSecretStoreSpecProviderVaultAuthCert",
    "ClusterSecretStoreSpecProviderVaultAuthCertClientCert",
    "ClusterSecretStoreSpecProviderVaultAuthCertSecretRef",
    "ClusterSecretStoreSpecProviderVaultAuthJwt",
    "ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken",
    "ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef",
    "ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef",
    "ClusterSecretStoreSpecProviderVaultAuthKubernetes",
    "ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef",
    "ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef",
    "ClusterSecretStoreSpecProviderVaultAuthLdap",
    "ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef",
    "ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef",
    "ClusterSecretStoreSpecProviderVaultCaProvider",
    "ClusterSecretStoreSpecProviderVaultCaProviderType",
    "ClusterSecretStoreSpecProviderVaultVersion",
    "ClusterSecretStoreSpecProviderWebhook",
    "ClusterSecretStoreSpecProviderWebhookCaProvider",
    "ClusterSecretStoreSpecProviderWebhookCaProviderType",
    "ClusterSecretStoreSpecProviderWebhookResult",
    "ClusterSecretStoreSpecProviderWebhookSecrets",
    "ClusterSecretStoreSpecProviderWebhookSecretsSecretRef",
    "ClusterSecretStoreSpecProviderYandexlockbox",
    "ClusterSecretStoreSpecProviderYandexlockboxAuth",
    "ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef",
    "ClusterSecretStoreSpecProviderYandexlockboxCaProvider",
    "ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef",
    "ClusterSecretStoreSpecRetrySettings",
    "ClusterSecretStoreV1Beta1",
    "ClusterSecretStoreV1Beta1Props",
    "ClusterSecretStoreV1Beta1Spec",
    "ClusterSecretStoreV1Beta1SpecConditions",
    "ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector",
    "ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions",
    "ClusterSecretStoreV1Beta1SpecProvider",
    "ClusterSecretStoreV1Beta1SpecProviderAkeyless",
    "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth",
    "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef",
    "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId",
    "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType",
    "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam",
    "ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider",
    "ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProviderType",
    "ClusterSecretStoreV1Beta1SpecProviderAlibaba",
    "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth",
    "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa",
    "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAws",
    "ClusterSecretStoreV1Beta1SpecProviderAwsAuth",
    "ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt",
    "ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef",
    "ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager",
    "ClusterSecretStoreV1Beta1SpecProviderAwsService",
    "ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags",
    "ClusterSecretStoreV1Beta1SpecProviderAzurekv",
    "ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate",
    "ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId",
    "ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret",
    "ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId",
    "ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType",
    "ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType",
    "ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef",
    "ClusterSecretStoreV1Beta1SpecProviderBeyondtrust",
    "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth",
    "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey",
    "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate",
    "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey",
    "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId",
    "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret",
    "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer",
    "ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager",
    "ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth",
    "ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials",
    "ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider",
    "ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType",
    "ClusterSecretStoreV1Beta1SpecProviderChef",
    "ClusterSecretStoreV1Beta1SpecProviderChefAuth",
    "ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderConjur",
    "ClusterSecretStoreV1Beta1SpecProviderConjurAuth",
    "ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey",
    "ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef",
    "ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef",
    "ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt",
    "ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef",
    "ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider",
    "ClusterSecretStoreV1Beta1SpecProviderConjurCaProviderType",
    "ClusterSecretStoreV1Beta1SpecProviderDelinea",
    "ClusterSecretStoreV1Beta1SpecProviderDelineaClientId",
    "ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret",
    "ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderDevice42",
    "ClusterSecretStoreV1Beta1SpecProviderDevice42Auth",
    "ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials",
    "ClusterSecretStoreV1Beta1SpecProviderDoppler",
    "ClusterSecretStoreV1Beta1SpecProviderDopplerAuth",
    "ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken",
    "ClusterSecretStoreV1Beta1SpecProviderDopplerFormat",
    "ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer",
    "ClusterSecretStoreV1Beta1SpecProviderFake",
    "ClusterSecretStoreV1Beta1SpecProviderFakeData",
    "ClusterSecretStoreV1Beta1SpecProviderFortanix",
    "ClusterSecretStoreV1Beta1SpecProviderFortanixApiKey",
    "ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderGcpsm",
    "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth",
    "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity",
    "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef",
    "ClusterSecretStoreV1Beta1SpecProviderGitlab",
    "ClusterSecretStoreV1Beta1SpecProviderGitlabAuth",
    "ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken",
    "ClusterSecretStoreV1Beta1SpecProviderIbm",
    "ClusterSecretStoreV1Beta1SpecProviderIbmAuth",
    "ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth",
    "ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderInfisical",
    "ClusterSecretStoreV1Beta1SpecProviderInfisicalAuth",
    "ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials",
    "ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId",
    "ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret",
    "ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope",
    "ClusterSecretStoreV1Beta1SpecProviderKeepersecurity",
    "ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetes",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesServer",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType",
    "ClusterSecretStoreV1Beta1SpecProviderOnboardbase",
    "ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth",
    "ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef",
    "ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef",
    "ClusterSecretStoreV1Beta1SpecProviderOnepassword",
    "ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth",
    "ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderOracle",
    "ClusterSecretStoreV1Beta1SpecProviderOracleAuth",
    "ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint",
    "ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey",
    "ClusterSecretStoreV1Beta1SpecProviderOraclePrincipalType",
    "ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef",
    "ClusterSecretStoreV1Beta1SpecProviderPassbolt",
    "ClusterSecretStoreV1Beta1SpecProviderPassboltAuth",
    "ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderPassworddepot",
    "ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuth",
    "ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials",
    "ClusterSecretStoreV1Beta1SpecProviderPrevider",
    "ClusterSecretStoreV1Beta1SpecProviderPreviderAuth",
    "ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken",
    "ClusterSecretStoreV1Beta1SpecProviderPulumi",
    "ClusterSecretStoreV1Beta1SpecProviderPulumiAccessToken",
    "ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderScaleway",
    "ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey",
    "ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey",
    "ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderSecretserver",
    "ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword",
    "ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername",
    "ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderSenhasegura",
    "ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth",
    "ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVault",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuth",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider",
    "ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType",
    "ClusterSecretStoreV1Beta1SpecProviderVaultTls",
    "ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultVersion",
    "ClusterSecretStoreV1Beta1SpecProviderWebhook",
    "ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider",
    "ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType",
    "ClusterSecretStoreV1Beta1SpecProviderWebhookResult",
    "ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets",
    "ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager",
    "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth",
    "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider",
    "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderYandexlockbox",
    "ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth",
    "ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider",
    "ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef",
    "ClusterSecretStoreV1Beta1SpecRetrySettings",
    "ExternalSecret",
    "ExternalSecretProps",
    "ExternalSecretSpec",
    "ExternalSecretSpecData",
    "ExternalSecretSpecDataFrom",
    "ExternalSecretSpecDataFromConversionStrategy",
    "ExternalSecretSpecDataRemoteRef",
    "ExternalSecretSpecDataRemoteRefConversionStrategy",
    "ExternalSecretSpecSecretStoreRef",
    "ExternalSecretSpecSecretStoreRefKind",
    "ExternalSecretSpecTarget",
    "ExternalSecretSpecTargetCreationPolicy",
    "ExternalSecretSpecTargetTemplate",
    "ExternalSecretSpecTargetTemplateEngineVersion",
    "ExternalSecretSpecTargetTemplateMetadata",
    "ExternalSecretSpecTargetTemplateTemplateFrom",
    "ExternalSecretSpecTargetTemplateTemplateFromConfigMap",
    "ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems",
    "ExternalSecretSpecTargetTemplateTemplateFromSecret",
    "ExternalSecretSpecTargetTemplateTemplateFromSecretItems",
    "ExternalSecretV1Beta1",
    "ExternalSecretV1Beta1Props",
    "ExternalSecretV1Beta1Spec",
    "ExternalSecretV1Beta1SpecData",
    "ExternalSecretV1Beta1SpecDataFrom",
    "ExternalSecretV1Beta1SpecDataFromExtract",
    "ExternalSecretV1Beta1SpecDataFromExtractConversionStrategy",
    "ExternalSecretV1Beta1SpecDataFromExtractDecodingStrategy",
    "ExternalSecretV1Beta1SpecDataFromExtractMetadataPolicy",
    "ExternalSecretV1Beta1SpecDataFromFind",
    "ExternalSecretV1Beta1SpecDataFromFindConversionStrategy",
    "ExternalSecretV1Beta1SpecDataFromFindDecodingStrategy",
    "ExternalSecretV1Beta1SpecDataFromFindName",
    "ExternalSecretV1Beta1SpecDataFromRewrite",
    "ExternalSecretV1Beta1SpecDataFromRewriteRegexp",
    "ExternalSecretV1Beta1SpecDataFromRewriteTransform",
    "ExternalSecretV1Beta1SpecDataFromSourceRef",
    "ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef",
    "ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRefKind",
    "ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef",
    "ExternalSecretV1Beta1SpecDataFromSourceRefStoreRefKind",
    "ExternalSecretV1Beta1SpecDataRemoteRef",
    "ExternalSecretV1Beta1SpecDataRemoteRefConversionStrategy",
    "ExternalSecretV1Beta1SpecDataRemoteRefDecodingStrategy",
    "ExternalSecretV1Beta1SpecDataRemoteRefMetadataPolicy",
    "ExternalSecretV1Beta1SpecDataSourceRef",
    "ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef",
    "ExternalSecretV1Beta1SpecDataSourceRefGeneratorRefKind",
    "ExternalSecretV1Beta1SpecDataSourceRefStoreRef",
    "ExternalSecretV1Beta1SpecDataSourceRefStoreRefKind",
    "ExternalSecretV1Beta1SpecSecretStoreRef",
    "ExternalSecretV1Beta1SpecSecretStoreRefKind",
    "ExternalSecretV1Beta1SpecTarget",
    "ExternalSecretV1Beta1SpecTargetCreationPolicy",
    "ExternalSecretV1Beta1SpecTargetDeletionPolicy",
    "ExternalSecretV1Beta1SpecTargetTemplate",
    "ExternalSecretV1Beta1SpecTargetTemplateEngineVersion",
    "ExternalSecretV1Beta1SpecTargetTemplateMergePolicy",
    "ExternalSecretV1Beta1SpecTargetTemplateMetadata",
    "ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom",
    "ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap",
    "ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems",
    "ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItemsTemplateAs",
    "ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret",
    "ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems",
    "ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItemsTemplateAs",
    "ExternalSecretV1Beta1SpecTargetTemplateTemplateFromTarget",
    "PushSecret",
    "PushSecretProps",
    "PushSecretSpec",
    "PushSecretSpecData",
    "PushSecretSpecDataConversionStrategy",
    "PushSecretSpecDataMatch",
    "PushSecretSpecDataMatchRemoteRef",
    "PushSecretSpecDeletionPolicy",
    "PushSecretSpecSecretStoreRefs",
    "PushSecretSpecSecretStoreRefsKind",
    "PushSecretSpecSecretStoreRefsLabelSelector",
    "PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions",
    "PushSecretSpecSelector",
    "PushSecretSpecSelectorGeneratorRef",
    "PushSecretSpecSelectorGeneratorRefKind",
    "PushSecretSpecSelectorSecret",
    "PushSecretSpecTemplate",
    "PushSecretSpecTemplateEngineVersion",
    "PushSecretSpecTemplateMergePolicy",
    "PushSecretSpecTemplateMetadata",
    "PushSecretSpecTemplateTemplateFrom",
    "PushSecretSpecTemplateTemplateFromConfigMap",
    "PushSecretSpecTemplateTemplateFromConfigMapItems",
    "PushSecretSpecTemplateTemplateFromConfigMapItemsTemplateAs",
    "PushSecretSpecTemplateTemplateFromSecret",
    "PushSecretSpecTemplateTemplateFromSecretItems",
    "PushSecretSpecTemplateTemplateFromSecretItemsTemplateAs",
    "PushSecretSpecTemplateTemplateFromTarget",
    "PushSecretSpecUpdatePolicy",
    "SecretStore",
    "SecretStoreProps",
    "SecretStoreSpec",
    "SecretStoreSpecProvider",
    "SecretStoreSpecProviderAkeyless",
    "SecretStoreSpecProviderAkeylessAuthSecretRef",
    "SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth",
    "SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef",
    "SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef",
    "SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef",
    "SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId",
    "SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType",
    "SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam",
    "SecretStoreSpecProviderAkeylessCaProvider",
    "SecretStoreSpecProviderAkeylessCaProviderType",
    "SecretStoreSpecProviderAlibaba",
    "SecretStoreSpecProviderAlibabaAuth",
    "SecretStoreSpecProviderAlibabaAuthRrsa",
    "SecretStoreSpecProviderAlibabaAuthSecretRef",
    "SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef",
    "SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef",
    "SecretStoreSpecProviderAws",
    "SecretStoreSpecProviderAwsAuth",
    "SecretStoreSpecProviderAwsAuthJwt",
    "SecretStoreSpecProviderAwsAuthJwtServiceAccountRef",
    "SecretStoreSpecProviderAwsAuthSecretRef",
    "SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef",
    "SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef",
    "SecretStoreSpecProviderAwsService",
    "SecretStoreSpecProviderAzurekv",
    "SecretStoreSpecProviderAzurekvAuthSecretRef",
    "SecretStoreSpecProviderAzurekvAuthSecretRefClientId",
    "SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret",
    "SecretStoreSpecProviderAzurekvAuthType",
    "SecretStoreSpecProviderAzurekvServiceAccountRef",
    "SecretStoreSpecProviderFake",
    "SecretStoreSpecProviderFakeData",
    "SecretStoreSpecProviderGcpsm",
    "SecretStoreSpecProviderGcpsmAuth",
    "SecretStoreSpecProviderGcpsmAuthSecretRef",
    "SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef",
    "SecretStoreSpecProviderGcpsmAuthWorkloadIdentity",
    "SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef",
    "SecretStoreSpecProviderGitlab",
    "SecretStoreSpecProviderGitlabAuth",
    "SecretStoreSpecProviderGitlabAuthSecretRef",
    "SecretStoreSpecProviderGitlabAuthSecretRefAccessToken",
    "SecretStoreSpecProviderIbm",
    "SecretStoreSpecProviderIbmAuth",
    "SecretStoreSpecProviderIbmAuthSecretRef",
    "SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef",
    "SecretStoreSpecProviderKubernetes",
    "SecretStoreSpecProviderKubernetesAuth",
    "SecretStoreSpecProviderKubernetesAuthCert",
    "SecretStoreSpecProviderKubernetesAuthCertClientCert",
    "SecretStoreSpecProviderKubernetesAuthCertClientKey",
    "SecretStoreSpecProviderKubernetesAuthServiceAccount",
    "SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount",
    "SecretStoreSpecProviderKubernetesAuthToken",
    "SecretStoreSpecProviderKubernetesAuthTokenBearerToken",
    "SecretStoreSpecProviderKubernetesServer",
    "SecretStoreSpecProviderKubernetesServerCaProvider",
    "SecretStoreSpecProviderKubernetesServerCaProviderType",
    "SecretStoreSpecProviderOracle",
    "SecretStoreSpecProviderOracleAuth",
    "SecretStoreSpecProviderOracleAuthSecretRef",
    "SecretStoreSpecProviderOracleAuthSecretRefFingerprint",
    "SecretStoreSpecProviderOracleAuthSecretRefPrivatekey",
    "SecretStoreSpecProviderOraclePrincipalType",
    "SecretStoreSpecProviderOracleServiceAccountRef",
    "SecretStoreSpecProviderPassworddepot",
    "SecretStoreSpecProviderPassworddepotAuth",
    "SecretStoreSpecProviderPassworddepotAuthSecretRef",
    "SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials",
    "SecretStoreSpecProviderVault",
    "SecretStoreSpecProviderVaultAuth",
    "SecretStoreSpecProviderVaultAuthAppRole",
    "SecretStoreSpecProviderVaultAuthAppRoleSecretRef",
    "SecretStoreSpecProviderVaultAuthCert",
    "SecretStoreSpecProviderVaultAuthCertClientCert",
    "SecretStoreSpecProviderVaultAuthCertSecretRef",
    "SecretStoreSpecProviderVaultAuthJwt",
    "SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken",
    "SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef",
    "SecretStoreSpecProviderVaultAuthJwtSecretRef",
    "SecretStoreSpecProviderVaultAuthKubernetes",
    "SecretStoreSpecProviderVaultAuthKubernetesSecretRef",
    "SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef",
    "SecretStoreSpecProviderVaultAuthLdap",
    "SecretStoreSpecProviderVaultAuthLdapSecretRef",
    "SecretStoreSpecProviderVaultAuthTokenSecretRef",
    "SecretStoreSpecProviderVaultCaProvider",
    "SecretStoreSpecProviderVaultCaProviderType",
    "SecretStoreSpecProviderVaultVersion",
    "SecretStoreSpecProviderWebhook",
    "SecretStoreSpecProviderWebhookCaProvider",
    "SecretStoreSpecProviderWebhookCaProviderType",
    "SecretStoreSpecProviderWebhookResult",
    "SecretStoreSpecProviderWebhookSecrets",
    "SecretStoreSpecProviderWebhookSecretsSecretRef",
    "SecretStoreSpecProviderYandexlockbox",
    "SecretStoreSpecProviderYandexlockboxAuth",
    "SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef",
    "SecretStoreSpecProviderYandexlockboxCaProvider",
    "SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef",
    "SecretStoreSpecRetrySettings",
    "SecretStoreV1Beta1",
    "SecretStoreV1Beta1Props",
    "SecretStoreV1Beta1Spec",
    "SecretStoreV1Beta1SpecConditions",
    "SecretStoreV1Beta1SpecConditionsNamespaceSelector",
    "SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions",
    "SecretStoreV1Beta1SpecProvider",
    "SecretStoreV1Beta1SpecProviderAkeyless",
    "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth",
    "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef",
    "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef",
    "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId",
    "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType",
    "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam",
    "SecretStoreV1Beta1SpecProviderAkeylessCaProvider",
    "SecretStoreV1Beta1SpecProviderAkeylessCaProviderType",
    "SecretStoreV1Beta1SpecProviderAlibaba",
    "SecretStoreV1Beta1SpecProviderAlibabaAuth",
    "SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa",
    "SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef",
    "SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef",
    "SecretStoreV1Beta1SpecProviderAws",
    "SecretStoreV1Beta1SpecProviderAwsAuth",
    "SecretStoreV1Beta1SpecProviderAwsAuthJwt",
    "SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef",
    "SecretStoreV1Beta1SpecProviderAwsAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef",
    "SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef",
    "SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef",
    "SecretStoreV1Beta1SpecProviderAwsSecretsManager",
    "SecretStoreV1Beta1SpecProviderAwsService",
    "SecretStoreV1Beta1SpecProviderAwsSessionTags",
    "SecretStoreV1Beta1SpecProviderAzurekv",
    "SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate",
    "SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId",
    "SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret",
    "SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId",
    "SecretStoreV1Beta1SpecProviderAzurekvAuthType",
    "SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType",
    "SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef",
    "SecretStoreV1Beta1SpecProviderBeyondtrust",
    "SecretStoreV1Beta1SpecProviderBeyondtrustAuth",
    "SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey",
    "SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef",
    "SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate",
    "SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey",
    "SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef",
    "SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef",
    "SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId",
    "SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef",
    "SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret",
    "SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef",
    "SecretStoreV1Beta1SpecProviderBeyondtrustServer",
    "SecretStoreV1Beta1SpecProviderBitwardensecretsmanager",
    "SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth",
    "SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials",
    "SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider",
    "SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType",
    "SecretStoreV1Beta1SpecProviderChef",
    "SecretStoreV1Beta1SpecProviderChefAuth",
    "SecretStoreV1Beta1SpecProviderChefAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef",
    "SecretStoreV1Beta1SpecProviderConjur",
    "SecretStoreV1Beta1SpecProviderConjurAuth",
    "SecretStoreV1Beta1SpecProviderConjurAuthApikey",
    "SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef",
    "SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef",
    "SecretStoreV1Beta1SpecProviderConjurAuthJwt",
    "SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef",
    "SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef",
    "SecretStoreV1Beta1SpecProviderConjurCaProvider",
    "SecretStoreV1Beta1SpecProviderConjurCaProviderType",
    "SecretStoreV1Beta1SpecProviderDelinea",
    "SecretStoreV1Beta1SpecProviderDelineaClientId",
    "SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef",
    "SecretStoreV1Beta1SpecProviderDelineaClientSecret",
    "SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef",
    "SecretStoreV1Beta1SpecProviderDevice42",
    "SecretStoreV1Beta1SpecProviderDevice42Auth",
    "SecretStoreV1Beta1SpecProviderDevice42AuthSecretRef",
    "SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials",
    "SecretStoreV1Beta1SpecProviderDoppler",
    "SecretStoreV1Beta1SpecProviderDopplerAuth",
    "SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken",
    "SecretStoreV1Beta1SpecProviderDopplerFormat",
    "SecretStoreV1Beta1SpecProviderDopplerNameTransformer",
    "SecretStoreV1Beta1SpecProviderFake",
    "SecretStoreV1Beta1SpecProviderFakeData",
    "SecretStoreV1Beta1SpecProviderFortanix",
    "SecretStoreV1Beta1SpecProviderFortanixApiKey",
    "SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef",
    "SecretStoreV1Beta1SpecProviderGcpsm",
    "SecretStoreV1Beta1SpecProviderGcpsmAuth",
    "SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef",
    "SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity",
    "SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef",
    "SecretStoreV1Beta1SpecProviderGitlab",
    "SecretStoreV1Beta1SpecProviderGitlabAuth",
    "SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken",
    "SecretStoreV1Beta1SpecProviderIbm",
    "SecretStoreV1Beta1SpecProviderIbmAuth",
    "SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth",
    "SecretStoreV1Beta1SpecProviderIbmAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef",
    "SecretStoreV1Beta1SpecProviderInfisical",
    "SecretStoreV1Beta1SpecProviderInfisicalAuth",
    "SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials",
    "SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId",
    "SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret",
    "SecretStoreV1Beta1SpecProviderInfisicalSecretsScope",
    "SecretStoreV1Beta1SpecProviderKeepersecurity",
    "SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef",
    "SecretStoreV1Beta1SpecProviderKubernetes",
    "SecretStoreV1Beta1SpecProviderKubernetesAuth",
    "SecretStoreV1Beta1SpecProviderKubernetesAuthCert",
    "SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert",
    "SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey",
    "SecretStoreV1Beta1SpecProviderKubernetesAuthRef",
    "SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount",
    "SecretStoreV1Beta1SpecProviderKubernetesAuthToken",
    "SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken",
    "SecretStoreV1Beta1SpecProviderKubernetesServer",
    "SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider",
    "SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType",
    "SecretStoreV1Beta1SpecProviderOnboardbase",
    "SecretStoreV1Beta1SpecProviderOnboardbaseAuth",
    "SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef",
    "SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef",
    "SecretStoreV1Beta1SpecProviderOnepassword",
    "SecretStoreV1Beta1SpecProviderOnepasswordAuth",
    "SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef",
    "SecretStoreV1Beta1SpecProviderOracle",
    "SecretStoreV1Beta1SpecProviderOracleAuth",
    "SecretStoreV1Beta1SpecProviderOracleAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint",
    "SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey",
    "SecretStoreV1Beta1SpecProviderOraclePrincipalType",
    "SecretStoreV1Beta1SpecProviderOracleServiceAccountRef",
    "SecretStoreV1Beta1SpecProviderPassbolt",
    "SecretStoreV1Beta1SpecProviderPassboltAuth",
    "SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef",
    "SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef",
    "SecretStoreV1Beta1SpecProviderPassworddepot",
    "SecretStoreV1Beta1SpecProviderPassworddepotAuth",
    "SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials",
    "SecretStoreV1Beta1SpecProviderPrevider",
    "SecretStoreV1Beta1SpecProviderPreviderAuth",
    "SecretStoreV1Beta1SpecProviderPreviderAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken",
    "SecretStoreV1Beta1SpecProviderPulumi",
    "SecretStoreV1Beta1SpecProviderPulumiAccessToken",
    "SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef",
    "SecretStoreV1Beta1SpecProviderScaleway",
    "SecretStoreV1Beta1SpecProviderScalewayAccessKey",
    "SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef",
    "SecretStoreV1Beta1SpecProviderScalewaySecretKey",
    "SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef",
    "SecretStoreV1Beta1SpecProviderSecretserver",
    "SecretStoreV1Beta1SpecProviderSecretserverPassword",
    "SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef",
    "SecretStoreV1Beta1SpecProviderSecretserverUsername",
    "SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef",
    "SecretStoreV1Beta1SpecProviderSenhasegura",
    "SecretStoreV1Beta1SpecProviderSenhaseguraAuth",
    "SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef",
    "SecretStoreV1Beta1SpecProviderVault",
    "SecretStoreV1Beta1SpecProviderVaultAuth",
    "SecretStoreV1Beta1SpecProviderVaultAuthAppRole",
    "SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthCert",
    "SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert",
    "SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthIam",
    "SecretStoreV1Beta1SpecProviderVaultAuthIamJwt",
    "SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthJwt",
    "SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken",
    "SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthKubernetes",
    "SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthLdap",
    "SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthUserPass",
    "SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef",
    "SecretStoreV1Beta1SpecProviderVaultCaProvider",
    "SecretStoreV1Beta1SpecProviderVaultCaProviderType",
    "SecretStoreV1Beta1SpecProviderVaultTls",
    "SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef",
    "SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef",
    "SecretStoreV1Beta1SpecProviderVaultVersion",
    "SecretStoreV1Beta1SpecProviderWebhook",
    "SecretStoreV1Beta1SpecProviderWebhookCaProvider",
    "SecretStoreV1Beta1SpecProviderWebhookCaProviderType",
    "SecretStoreV1Beta1SpecProviderWebhookResult",
    "SecretStoreV1Beta1SpecProviderWebhookSecrets",
    "SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef",
    "SecretStoreV1Beta1SpecProviderYandexcertificatemanager",
    "SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth",
    "SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef",
    "SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider",
    "SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef",
    "SecretStoreV1Beta1SpecProviderYandexlockbox",
    "SecretStoreV1Beta1SpecProviderYandexlockboxAuth",
    "SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef",
    "SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider",
    "SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef",
    "SecretStoreV1Beta1SpecRetrySettings",
]

publication.publish()

def _typecheckingstub__94e60b949b245b48a41fb74f8b3d1eb0f99bd46fa142d6bbb376323f6a4b972a(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[ClusterExternalSecretSpec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f74e2ba2ccb6cd4ff807d66b5a3c6750a98bf9aadca80dd11e5f2ce993d61ce5(
    *,
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[ClusterExternalSecretSpec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8ef14ba98eb89c9ca89bac0d3d6a848b1d08606ee897d4645723837a3a0c8363(
    *,
    external_secret_spec: typing.Union[ClusterExternalSecretSpecExternalSecretSpec, typing.Dict[builtins.str, typing.Any]],
    external_secret_metadata: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    external_secret_name: typing.Optional[builtins.str] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[ClusterExternalSecretSpecNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    namespace_selectors: typing.Optional[typing.Sequence[typing.Union[ClusterExternalSecretSpecNamespaceSelectors, typing.Dict[builtins.str, typing.Any]]]] = None,
    refresh_time: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b5df8c612d909cfd3ff0b36342a11dca19f3ff5c30f04aefcbfcc75c64315a69(
    *,
    annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e3cb3046c16e6500023803a31ec0aefdedf2075416c3070aa91ce798a65a14b2(
    *,
    data: typing.Optional[typing.Sequence[typing.Union[ClusterExternalSecretSpecExternalSecretSpecData, typing.Dict[builtins.str, typing.Any]]]] = None,
    data_from: typing.Optional[typing.Sequence[typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataFrom, typing.Dict[builtins.str, typing.Any]]]] = None,
    refresh_interval: typing.Optional[builtins.str] = None,
    secret_store_ref: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef, typing.Dict[builtins.str, typing.Any]]] = None,
    target: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecTarget, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__698893d044926c5b5ba8069507216c8ba018dab3a976050e982d04ab806c4f9c(
    *,
    remote_ref: typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef, typing.Dict[builtins.str, typing.Any]],
    secret_key: builtins.str,
    source_ref: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataSourceRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab42e9c8e44193a216bc48255b69844a18cb95933d526955a5d60b90a2fe67fa(
    *,
    extract: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataFromExtract, typing.Dict[builtins.str, typing.Any]]] = None,
    find: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataFromFind, typing.Dict[builtins.str, typing.Any]]] = None,
    rewrite: typing.Optional[typing.Sequence[typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite, typing.Dict[builtins.str, typing.Any]]]] = None,
    source_ref: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4e03ff5f59a1789f7214696b1cee4651df4495261ab18a2629aa1a0b877896e6(
    *,
    key: builtins.str,
    conversion_strategy: typing.Optional[ClusterExternalSecretSpecExternalSecretSpecDataFromExtractConversionStrategy] = None,
    decoding_strategy: typing.Optional[ClusterExternalSecretSpecExternalSecretSpecDataFromExtractDecodingStrategy] = None,
    metadata_policy: typing.Optional[ClusterExternalSecretSpecExternalSecretSpecDataFromExtractMetadataPolicy] = None,
    property: typing.Optional[builtins.str] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__92077ca7c2f4d118e3eed11ddd89115353a2bba1dbb58f94f8e98f0407ce8371(
    *,
    conversion_strategy: typing.Optional[ClusterExternalSecretSpecExternalSecretSpecDataFromFindConversionStrategy] = None,
    decoding_strategy: typing.Optional[ClusterExternalSecretSpecExternalSecretSpecDataFromFindDecodingStrategy] = None,
    name: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataFromFindName, typing.Dict[builtins.str, typing.Any]]] = None,
    path: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5968a6b40dcf2aead8c61044c5dee50fa9d4651e3d45dc7f12383fe7760e25ac(
    *,
    regexp: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f601bc7c910f4395527a2edbe9ff719509d7d8808af893ad08740c049a2c5b76(
    *,
    regexp: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp, typing.Dict[builtins.str, typing.Any]]] = None,
    transform: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteTransform, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b713d8124b2c817097f753f8dc9f6051b182ef78b70ea61bbbb37b1e8c58d59(
    *,
    source: builtins.str,
    target: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__593d67339e08298e9ffe3df7a50137c1841d53b5c13926c5f369a4f3172e807f(
    *,
    template: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f63e50d7ff4b9cb977470145546ff8b96ba9cecf3ea10b6d66a80ffeec2c911(
    *,
    generator_ref: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRef, typing.Dict[builtins.str, typing.Any]]] = None,
    store_ref: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4bc9961f5d7205cf72d9098890a30f80bd7454ee336863badedda3141aefda17(
    *,
    kind: ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefGeneratorRefKind,
    name: builtins.str,
    api_version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__082917a72761ed0c1f366e52e34edade80e2390cdd82c1afa6c6598822467105(
    *,
    kind: typing.Optional[ClusterExternalSecretSpecExternalSecretSpecDataFromSourceRefStoreRefKind] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e6f3244609ebbc535f95a19792829d629cfcad19ee4566882417287402c07f3f(
    *,
    key: builtins.str,
    conversion_strategy: typing.Optional[ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefConversionStrategy] = None,
    decoding_strategy: typing.Optional[ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefDecodingStrategy] = None,
    metadata_policy: typing.Optional[ClusterExternalSecretSpecExternalSecretSpecDataRemoteRefMetadataPolicy] = None,
    property: typing.Optional[builtins.str] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5561d58e41708dd168e9146076dbca74f307d640d7394ba6e3efbac3d41839a(
    *,
    generator_ref: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRef, typing.Dict[builtins.str, typing.Any]]] = None,
    store_ref: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ea867ab7ffd78985b5466cb669c1f19364ef24ebebfa02dc826fe1699e74668(
    *,
    kind: ClusterExternalSecretSpecExternalSecretSpecDataSourceRefGeneratorRefKind,
    name: builtins.str,
    api_version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e3dac67fdb5213d238cd0251a7010fac0f8e7b8a057409fb1a8bee6f32d9f70a(
    *,
    kind: typing.Optional[ClusterExternalSecretSpecExternalSecretSpecDataSourceRefStoreRefKind] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bbbc20c608aad33b8e32e75a11fc646a7ee61bc1d1f2e94de5bf32865235fd04(
    *,
    kind: typing.Optional[ClusterExternalSecretSpecExternalSecretSpecSecretStoreRefKind] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d7d283c53e5807e3a14479debfe5a62ad7d33bbe1884db78b4005c97d7f9e572(
    *,
    creation_policy: typing.Optional[ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy] = None,
    deletion_policy: typing.Optional[ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy] = None,
    immutable: typing.Optional[builtins.bool] = None,
    name: typing.Optional[builtins.str] = None,
    template: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecTargetTemplate, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e17311f817cc6c3870009753fdfc8659a03aed047d52e1c28f68c66c22f4326d(
    *,
    data: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    engine_version: typing.Optional[ClusterExternalSecretSpecExternalSecretSpecTargetTemplateEngineVersion] = None,
    merge_policy: typing.Optional[ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMergePolicy] = None,
    metadata: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    template_from: typing.Optional[typing.Sequence[typing.Union[ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom, typing.Dict[builtins.str, typing.Any]]]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e700cd106840de6b6b862611a9af63e0d1be6bba0dd554c7aed6acca92d19244(
    *,
    annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6afaa4c609906e7626220c4fddf4bc3a8fcc807598ec8beb344f6b9de0f6269b(
    *,
    config_map: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap, typing.Dict[builtins.str, typing.Any]]] = None,
    literal: typing.Optional[builtins.str] = None,
    secret: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret, typing.Dict[builtins.str, typing.Any]]] = None,
    target: typing.Optional[ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromTarget] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e735e4983134a60d5944c221483b47abb6e945d1e4363c5bd39324ef1f6d902e(
    *,
    items: typing.Sequence[typing.Union[ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems, typing.Dict[builtins.str, typing.Any]]],
    name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4cea9f6b57f176e25de456cef3b2ecab038f70307e22ed475c43feffc210d187(
    *,
    key: builtins.str,
    template_as: typing.Optional[ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItemsTemplateAs] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__57da7f59eff3d4d95d8055111305c41a7897499965ce955542ca053061957d87(
    *,
    items: typing.Sequence[typing.Union[ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems, typing.Dict[builtins.str, typing.Any]]],
    name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__679753049e28b5f77ae12540862ccff4cbfe346de1a2af57688741fa5517fdcf(
    *,
    key: builtins.str,
    template_as: typing.Optional[ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItemsTemplateAs] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e67e15ae7413ec89e9e1b028ba41fd1a6808fa4799949e1144033db1bce9375f(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterExternalSecretSpecNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29a0c54f3edfd70da195fb2028a37b74ef6137c8c5c102801f6e46ea8544e824(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__63f9a14423beda1e46223e279f4c160319ad2adb6f5680b3a0eddf15e36a736e(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterExternalSecretSpecNamespaceSelectorsMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d206e1e151bff3e2c286fdc18e8127271e514c58791c38b149828428eb62bf7(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8dd63b4b951d1c0f1810393f2ea2739eb3c8df2dbba5c1c17c9369fa23105354(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[ClusterSecretStoreSpec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e52cd74f3e3dc5a6f5e0e0439c1ee7ea1bd2ae23d61a00f1d7d48f492e9adc87(
    *,
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[ClusterSecretStoreSpec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__57b6b1dbca3a9f2481bd32974c96162d85bfa5e7fd9e1324c70c72f4c047323e(
    *,
    provider: typing.Union[ClusterSecretStoreSpecProvider, typing.Dict[builtins.str, typing.Any]],
    controller: typing.Optional[builtins.str] = None,
    retry_settings: typing.Optional[typing.Union[ClusterSecretStoreSpecRetrySettings, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b577f0ccbbef07f08ad1ab52f92fc2ed139f3591354a8294c647ea76a6470491(
    *,
    akeyless: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAkeyless, typing.Dict[builtins.str, typing.Any]]] = None,
    alibaba: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAlibaba, typing.Dict[builtins.str, typing.Any]]] = None,
    aws: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAws, typing.Dict[builtins.str, typing.Any]]] = None,
    azurekv: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAzurekv, typing.Dict[builtins.str, typing.Any]]] = None,
    fake: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderFake, typing.Dict[builtins.str, typing.Any]]] = None,
    gcpsm: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderGcpsm, typing.Dict[builtins.str, typing.Any]]] = None,
    gitlab: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderGitlab, typing.Dict[builtins.str, typing.Any]]] = None,
    ibm: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderIbm, typing.Dict[builtins.str, typing.Any]]] = None,
    kubernetes: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderKubernetes, typing.Dict[builtins.str, typing.Any]]] = None,
    oracle: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderOracle, typing.Dict[builtins.str, typing.Any]]] = None,
    passworddepot: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderPassworddepot, typing.Dict[builtins.str, typing.Any]]] = None,
    vault: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVault, typing.Dict[builtins.str, typing.Any]]] = None,
    webhook: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderWebhook, typing.Dict[builtins.str, typing.Any]]] = None,
    yandexlockbox: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderYandexlockbox, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb1f3b613f8eb456b5c2efddbc3a0dcaaa7290a58a21df5ba0e0ad6d189c7245(
    *,
    akeyless_gw_api_url: builtins.str,
    auth_secret_ref: typing.Union[ClusterSecretStoreSpecProviderAkeylessAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAkeylessCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a1add6ad905d4b2103c32761e6970d8d214a73ed5201b1a98c08d00a43c853f7(
    *,
    kubernetes_auth: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__09e802798f87b8377e20a5baa142f3095f97079a62d35b23ac9b89263cbfac51(
    *,
    access_id: builtins.str,
    k8_s_conf_name: builtins.str,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe2322d9ce4d70c2c6498168db62dc60ec37d6d55fbdb7b4595d224eadbb7f4d(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c89202b1ec979b714ae00fcaa502eaf9b609424705834f082bf349b7f789d59(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__035cb6945bc194f917abd47ca70a68244da344a68f14f7f033c3b028e0dee454(
    *,
    access_id: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId, typing.Dict[builtins.str, typing.Any]]] = None,
    access_type: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType, typing.Dict[builtins.str, typing.Any]]] = None,
    access_type_param: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a938d7a10afd24ef476da4a5595b2a159a6ff353311720640d3183cab2237e9b(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__762aa62305da5c5cd7def193e14a6fa135c8f017f035428cf738add22df97bc8(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2dcf00eb7f5ff015d34783bafe7aaa9f134a7caabbca3827419d5ae0205adbc9(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c007e96589ec6b2844631ca03619f1b0870c03d301b7192f5f353c30385f176(
    *,
    name: builtins.str,
    type: ClusterSecretStoreSpecProviderAkeylessCaProviderType,
    key: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a5ff624b83768ab7e3f6981bd9dbaf0c920598597111dc90a49f4e43af854503(
    *,
    auth: typing.Union[ClusterSecretStoreSpecProviderAlibabaAuth, typing.Dict[builtins.str, typing.Any]],
    region_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a3e71811aee1daf711f7bac2275e4c3a683aa7203798d77f39b0ef34d5bd4d8f(
    *,
    rrsa: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAlibabaAuthRrsa, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAlibabaAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c9b387e718990c982ab8ed3bda219992a33a3611431a7be98fa20bfdec2d8004(
    *,
    oidc_provider_arn: builtins.str,
    oidc_token_file_path: builtins.str,
    role_arn: builtins.str,
    session_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91e926199bf20fc1a102ce65ad3b639e0398edcf53243008995020f063edf9ab(
    *,
    access_key_id_secret_ref: typing.Union[ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef, typing.Dict[builtins.str, typing.Any]],
    access_key_secret_secret_ref: typing.Union[ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__577c863fea491e359b51abf5fe73e1d4acc1c81ea7401361e1c6cd8c07c011ee(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__48b18145fd0d8fe181e65bd8874d2e03b8e44f3a00137400c5dc630d92c474bb(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b890d76e5f0d682e477d7b20c0020358b39d98bd01a9432e52c7c4a8ac616f0(
    *,
    region: builtins.str,
    service: ClusterSecretStoreSpecProviderAwsService,
    auth: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAwsAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    role: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a6dd72e093e44f4d176c7ac71615a880705b99b630555e7ce1e4ea69742c5efb(
    *,
    jwt: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAwsAuthJwt, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAwsAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e7d772d91778f286ba674c40734f79974636800252dcb80ba3aedb4417ec64cb(
    *,
    service_account_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de10cf2ddb938d6fc92b26c35d489e4b0afd1f528224b33c4acedc8f7b7c55d4(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__382d054259503c641b10cacac05db506fe361c058f5e49c99de7f0f9505e7137(
    *,
    access_key_id_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_access_key_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6651cda229033cd18398fe288cd6b6e8a7837eb3b8dcacc21b46f1303f7ab9fb(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__14d2105b0a56fd40c4ef74beca49699465299985a43951d9b6c98760df53d36d(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c241f0bdca3970aef7e1768427fdaa91976bc172e6a9adf9266bf73940958d82(
    *,
    vault_url: builtins.str,
    auth_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAzurekvAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    auth_type: typing.Optional[ClusterSecretStoreSpecProviderAzurekvAuthType] = None,
    identity_id: typing.Optional[builtins.str] = None,
    service_account_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAzurekvServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
    tenant_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__50107c061e058c695ef89a240623f5c9f9c8bdec05e3550652703edc1613a9d6(
    *,
    client_id: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId, typing.Dict[builtins.str, typing.Any]]] = None,
    client_secret: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__07b0ecddeaed41a84aa2643dd718d462b1146ec6772530b4f5c3c47e1b733cf5(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__68559f3a5d6b2b8a93dcb32624f88b8d3a6cfd24de8ffe4e2e190efd3965eba4(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f9bc3908e702dbfc1f5487ab0c0ab8d9ac9fbe77dc944911fa425330ed9bf8c(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f2d1b2afe891f49350ca0f79d38693b672edb585eb22bca05a5a2a9cc67c77a0(
    *,
    data: typing.Sequence[typing.Union[ClusterSecretStoreSpecProviderFakeData, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06c3a06c0205d70bc5e04befc5fa15e0d81efb1d139829a1b10122852ccddee3(
    *,
    key: builtins.str,
    value: typing.Optional[builtins.str] = None,
    value_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fc3cec52aba3dbdf7d2c68d2cdddb38491fbe4a67b6aa1610ba59832fa6a4e41(
    *,
    auth: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderGcpsmAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    project_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2178385ff92d231b452c07f1848576db93a846b578537d723ad23942c8b8f59(
    *,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderGcpsmAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    workload_identity: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8b68c9d3be6662c6d5127a4f57c77b4fa8ec1231c6761283310dd0437fa26405(
    *,
    secret_access_key_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ae3e18a30bbb404e9e981c4110af8ad2c78dced856b1094667d4d8757f4bea3(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__998b6e77f1f37298ed0da77f6068e5d0e918cf71ed7b2bfdbcba34ba026e718a(
    *,
    cluster_location: builtins.str,
    cluster_name: builtins.str,
    service_account_ref: typing.Union[ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef, typing.Dict[builtins.str, typing.Any]],
    cluster_project_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__99dacaa9d9ab0fbbdd69de40485d6ea7f5b6f30154d2c2f17a52d025fcda16dc(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cd6c28ce03a61453b779c63be95c17f14c569df7b7901767be17f3b916f7b7b9(
    *,
    auth: typing.Union[ClusterSecretStoreSpecProviderGitlabAuth, typing.Dict[builtins.str, typing.Any]],
    project_id: typing.Optional[builtins.str] = None,
    url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d971866ec4831049f0c5995bf4f89457244b6a35dbd74909afa8f7d95a5fc3b6(
    *,
    secret_ref: typing.Union[ClusterSecretStoreSpecProviderGitlabAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__adda72bd6677360eef05f5b60cec8e46b4703afb4f11ce2fe2c17d0af65b64f9(
    *,
    access_token: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__511067b3b8641da6fae0b888268797929d1d7d4597ddb24ebbdc23c763a8daf5(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__568b57667a8f87d52e74f6c92542b41178d303a303d0f63f1ad0201e4e4f6e85(
    *,
    auth: typing.Union[ClusterSecretStoreSpecProviderIbmAuth, typing.Dict[builtins.str, typing.Any]],
    service_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b8ba31df5a3dec6ffb4e43109f3b738a61dd208cf1d49917f4a5d9e2ed7016ba(
    *,
    secret_ref: typing.Union[ClusterSecretStoreSpecProviderIbmAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d26bdf357d63f5060f85dd85dfff97aea5186ba28331fba88305c92f7bf2bee(
    *,
    secret_api_key_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f2338fd96004be09c4ba23dde6c13751a616732acd950c786cd2d83bf1b80e0(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a875c33cb733cde737d2ea40684faf938dd9c5fcfe7ad0f13f5323f4fc03599(
    *,
    auth: typing.Union[ClusterSecretStoreSpecProviderKubernetesAuth, typing.Dict[builtins.str, typing.Any]],
    remote_namespace: typing.Optional[builtins.str] = None,
    server: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderKubernetesServer, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e4a87865577536425d7db2b507a944df25c5643ebce9d8f972d9d17bf404d2a(
    *,
    cert: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderKubernetesAuthCert, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount, typing.Dict[builtins.str, typing.Any]]] = None,
    token: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderKubernetesAuthToken, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cc095c5099a968982782878a596ee1c32a31cf4bdb1595995f7aa2fd8ff43b5b(
    *,
    client_cert: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert, typing.Dict[builtins.str, typing.Any]]] = None,
    client_key: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__503bdfbb632686635165459120fcc39e2961fcc53fedf28a69b21f187ec6435c(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f49b9d81a293f0e46cea1637a6e7534771c88694becfeb4b3af69ee54782ec9c(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ebcfbd9e4143ba94379ca90a47ef3b5d8e1544a99ce7a639bbd61a7e7c6b4666(
    *,
    service_account: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be61c3feb305ef226f10dab3e8225b282e360f0182870360ffdbca079919d353(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ba41a3478e9d8ac767c1a13cc7dd298a12d94292b029f7fa8368b3d3e44096b(
    *,
    bearer_token: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df798fd077691a5778cc00f1de4848673a52dac5d0d5ebe0d03af6720cbc95d2(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29f1d40a83933b0205abc121837f1b6a50b2409b7fb1e5f58dade818e3e3a609(
    *,
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderKubernetesServerCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
    url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df516d591cd72e3ccea6b112524dbfa0323479fb2ee403ab24a5bbaddb4efd8c(
    *,
    name: builtins.str,
    type: ClusterSecretStoreSpecProviderKubernetesServerCaProviderType,
    key: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d51df236a603c6f74a911105acff1a4f51f5d893faa22fc50dae2e587588ebc8(
    *,
    region: builtins.str,
    vault: builtins.str,
    auth: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderOracleAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    compartment: typing.Optional[builtins.str] = None,
    encryption_key: typing.Optional[builtins.str] = None,
    principal_type: typing.Optional[ClusterSecretStoreSpecProviderOraclePrincipalType] = None,
    service_account_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderOracleServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8747f797eb13c03383ce6b0134915d891783a8be5d68b6ee24b3c6cb9fbd4985(
    *,
    secret_ref: typing.Union[ClusterSecretStoreSpecProviderOracleAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
    tenancy: builtins.str,
    user: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c97225be105acf4e293cecfb2d1feaa37ea94578c86cdf4d2e336b439a2559a(
    *,
    fingerprint: typing.Union[ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint, typing.Dict[builtins.str, typing.Any]],
    privatekey: typing.Union[ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c531d2ca3bee95d25c32bb91772fb25d1b2643838ab4bc843e512cb39e63bb61(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f4eb6469dd176c588e8c4a9bd39111e7f84482a99f9af9e62ed077924beaf37f(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b2c2b61ca17414c8f7ada351a498ac1a2d985e403dcc1fe15eef63e22d74207a(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__72d2dda8f33fd1e3871450460f964c43585b0825137f24072af76f387fdb8f53(
    *,
    auth: typing.Union[ClusterSecretStoreSpecProviderPassworddepotAuth, typing.Dict[builtins.str, typing.Any]],
    database: builtins.str,
    host: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b6b6ea9a2b87f39442403b43f12453ef96e7f78fd325509788386688440d487b(
    *,
    secret_ref: typing.Union[ClusterSecretStoreSpecProviderPassworddepotAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9d6e961d14c0b06bf046bf2b304ec7d6ec46e370ab98ee8caa1ead22a914088(
    *,
    credentials: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderPassworddepotAuthSecretRefCredentials, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4dc2de537e242a05d9395953fcfbf59daabc5a55a600ae989930d018a6751dd6(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef68b3d001dc894733c01b794ca1a457786564b75fec9c23ebf82feb51a68d1c(
    *,
    auth: typing.Union[ClusterSecretStoreSpecProviderVaultAuth, typing.Dict[builtins.str, typing.Any]],
    server: builtins.str,
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
    forward_inconsistent: typing.Optional[builtins.bool] = None,
    namespace: typing.Optional[builtins.str] = None,
    path: typing.Optional[builtins.str] = None,
    read_your_writes: typing.Optional[builtins.bool] = None,
    version: typing.Optional[ClusterSecretStoreSpecProviderVaultVersion] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__edca367d70e999e0f4d8dd93f60480965022b2731a2804bfea499b897354fe2e(
    *,
    app_role: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthAppRole, typing.Dict[builtins.str, typing.Any]]] = None,
    cert: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthCert, typing.Dict[builtins.str, typing.Any]]] = None,
    jwt: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthJwt, typing.Dict[builtins.str, typing.Any]]] = None,
    kubernetes: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthKubernetes, typing.Dict[builtins.str, typing.Any]]] = None,
    ldap: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthLdap, typing.Dict[builtins.str, typing.Any]]] = None,
    token_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d653069145d43079e69f7719f5cc231f7e70d871ff44e92d01049340d8bb524(
    *,
    path: builtins.str,
    role_id: builtins.str,
    secret_ref: typing.Union[ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f35712d423d432dfcb07ff112a69b3cfbd19b55783043b4a29d483f336f4a433(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__07ecf610e8623a95c7882b7b3820871610e76bb4497f36c406038735e020e9dd(
    *,
    client_cert: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthCertClientCert, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthCertSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4b68473b3bece52963e18111c31aa00fc82a8ebd6235ce6cdc6d52305f88978b(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__297cfe9ec7b6f0ff6acb7be39420d3c9df2218f1bf1753129109b58cb815db1c(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c70b5f2d0d755f91281254925c299e6b7812ab873f8af74181b9bed9ddf549d3(
    *,
    path: builtins.str,
    kubernetes_service_account_token: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken, typing.Dict[builtins.str, typing.Any]]] = None,
    role: typing.Optional[builtins.str] = None,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__079c46fff0c57b42b35cdf20bd2601cdf20258393616adf107cd21057b8a5756(
    *,
    service_account_ref: typing.Union[ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef, typing.Dict[builtins.str, typing.Any]],
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    expiration_seconds: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf1afed0cbd44ce1e181c71dfbce5c80cec5b966a2a854753d10efa060ee9f6f(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a340df94e1a417e5d884f82e933c5560f15f85713299092866951369e007294(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e0431af4eda83f334246027b08a06ec6fc9a31808931500a0447cbf67873dc8(
    *,
    mount_path: builtins.str,
    role: builtins.str,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7378e072626052b95a87646e5ef2b5aff3fbcb23a3222fc3bdb7a5423e66529(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e39b709ef4e009ad2207ce73f97c37c051ea9f48db9c0406f1c522ebaacfb7ca(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8666d1368531371d385fa490f9ec11641fb095a166fb9e1b592dcc40182fa86b(
    *,
    path: builtins.str,
    username: builtins.str,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__55cf6198c624abda137c052d1dc014ca36b71dd2d46492befe116265455ee36d(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__19291a9702423000e44c226f201a482aea5e992dd47a71153ebb3070b6856b2d(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__595609c1cb77ac8d0172cebab30d5f44428ed4331922d82d47b326431302591b(
    *,
    name: builtins.str,
    type: ClusterSecretStoreSpecProviderVaultCaProviderType,
    key: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__567875e5230d606c5c4ae9dfad288f18e0d73f5564ac4e3e6ec54c667c14e548(
    *,
    result: typing.Union[ClusterSecretStoreSpecProviderWebhookResult, typing.Dict[builtins.str, typing.Any]],
    url: builtins.str,
    body: typing.Optional[builtins.str] = None,
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderWebhookCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
    headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    method: typing.Optional[builtins.str] = None,
    secrets: typing.Optional[typing.Sequence[typing.Union[ClusterSecretStoreSpecProviderWebhookSecrets, typing.Dict[builtins.str, typing.Any]]]] = None,
    timeout: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6af71527adcfa428fc129c129960c07c67fa441f1545f10e5dcefc09fca81c33(
    *,
    name: builtins.str,
    type: ClusterSecretStoreSpecProviderWebhookCaProviderType,
    key: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb7bc09013491f073871fae2ceecbef13b45de0131befa24ed148a2477ce78d4(
    *,
    json_path: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d5b27c62208713fb27769c2499653451dbf2faa38b53342a2fb2e0a38cb9b74(
    *,
    name: builtins.str,
    secret_ref: typing.Union[ClusterSecretStoreSpecProviderWebhookSecretsSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2cb2e940c5c2aaaf9bab8c136ca4833e3d43a06ef0d1472d9c82372927475b73(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2c07a0a205f8c8fe18207380dcf1b0dfd37eee884a6e932cd28cc4f665d658d7(
    *,
    auth: typing.Union[ClusterSecretStoreSpecProviderYandexlockboxAuth, typing.Dict[builtins.str, typing.Any]],
    api_endpoint: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderYandexlockboxCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f7af5ccd38a738e138a4da5ed3536313b5fe188c2b865f812b232b7860654d44(
    *,
    authorized_key_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__84df0d5ae303fe803ec5407c1564c124f89ce2f877cf951164b5346e358facc7(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__76304aa64a9b969f7e70594f92303a19605c96d6cc52a1e762c1f60949328f79(
    *,
    cert_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bdd207953372b8d88637204be9363b54f139d39e52bca9557f9caf7bd4d55bc8(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e47d412c07158576d9f7496f0a0011a69595d8febfe76d46ed415887b59df8a3(
    *,
    max_retries: typing.Optional[jsii.Number] = None,
    retry_interval: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8dc69ba83ec04594930db7e5543a7852c705a1ef67b59aa2efb6d2f5fad31ca0(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1Spec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__37dcaec4116fd103182a4f47c276c1a112b670414846040cdef450a01c9e5a73(
    *,
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1Spec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__96137c80a93e24eeba29fafca095a8203971811207350934aeba8d7893de9dc3(
    *,
    provider: typing.Union[ClusterSecretStoreV1Beta1SpecProvider, typing.Dict[builtins.str, typing.Any]],
    conditions: typing.Optional[typing.Sequence[typing.Union[ClusterSecretStoreV1Beta1SpecConditions, typing.Dict[builtins.str, typing.Any]]]] = None,
    controller: typing.Optional[builtins.str] = None,
    refresh_interval: typing.Optional[jsii.Number] = None,
    retry_settings: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecRetrySettings, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a0202bb2fa72e90fc4694fed122e588c991e624b62e6209c28dc3a91ec50c85(
    *,
    namespace_regexes: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__60d6e4eff1efa2b67d55a0694a4bc3737bb79c33a7e3ef1e953aded7c9e48b6a(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f6837a7309a755123acc2e7f78d1774390ea2fa5b1b52a1281d7fe46f9b6fa9(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__68ba9e9c4c46e5f6c6fca915ad8c80109c0ed4a1cdb61ca84e474072d126bde6(
    *,
    akeyless: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAkeyless, typing.Dict[builtins.str, typing.Any]]] = None,
    alibaba: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAlibaba, typing.Dict[builtins.str, typing.Any]]] = None,
    aws: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAws, typing.Dict[builtins.str, typing.Any]]] = None,
    azurekv: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAzurekv, typing.Dict[builtins.str, typing.Any]]] = None,
    beyondtrust: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderBeyondtrust, typing.Dict[builtins.str, typing.Any]]] = None,
    bitwardensecretsmanager: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanager, typing.Dict[builtins.str, typing.Any]]] = None,
    chef: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderChef, typing.Dict[builtins.str, typing.Any]]] = None,
    conjur: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderConjur, typing.Dict[builtins.str, typing.Any]]] = None,
    delinea: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderDelinea, typing.Dict[builtins.str, typing.Any]]] = None,
    device42: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderDevice42, typing.Dict[builtins.str, typing.Any]]] = None,
    doppler: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderDoppler, typing.Dict[builtins.str, typing.Any]]] = None,
    fake: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderFake, typing.Dict[builtins.str, typing.Any]]] = None,
    fortanix: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderFortanix, typing.Dict[builtins.str, typing.Any]]] = None,
    gcpsm: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderGcpsm, typing.Dict[builtins.str, typing.Any]]] = None,
    gitlab: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderGitlab, typing.Dict[builtins.str, typing.Any]]] = None,
    ibm: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderIbm, typing.Dict[builtins.str, typing.Any]]] = None,
    infisical: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderInfisical, typing.Dict[builtins.str, typing.Any]]] = None,
    keepersecurity: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKeepersecurity, typing.Dict[builtins.str, typing.Any]]] = None,
    kubernetes: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetes, typing.Dict[builtins.str, typing.Any]]] = None,
    onboardbase: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderOnboardbase, typing.Dict[builtins.str, typing.Any]]] = None,
    onepassword: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderOnepassword, typing.Dict[builtins.str, typing.Any]]] = None,
    oracle: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderOracle, typing.Dict[builtins.str, typing.Any]]] = None,
    passbolt: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderPassbolt, typing.Dict[builtins.str, typing.Any]]] = None,
    passworddepot: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderPassworddepot, typing.Dict[builtins.str, typing.Any]]] = None,
    previder: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderPrevider, typing.Dict[builtins.str, typing.Any]]] = None,
    pulumi: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderPulumi, typing.Dict[builtins.str, typing.Any]]] = None,
    scaleway: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderScaleway, typing.Dict[builtins.str, typing.Any]]] = None,
    secretserver: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderSecretserver, typing.Dict[builtins.str, typing.Any]]] = None,
    senhasegura: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderSenhasegura, typing.Dict[builtins.str, typing.Any]]] = None,
    vault: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVault, typing.Dict[builtins.str, typing.Any]]] = None,
    webhook: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderWebhook, typing.Dict[builtins.str, typing.Any]]] = None,
    yandexcertificatemanager: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager, typing.Dict[builtins.str, typing.Any]]] = None,
    yandexlockbox: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderYandexlockbox, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df929457145ba1be8a095a8bc3301089b349253206306ae5f336cd315970c692(
    *,
    akeyless_gw_api_url: builtins.str,
    auth_secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__abebeff323eca27bea60a3ac92c48bbbc7420eab45f346bf2c362df8bbb1c671(
    *,
    kubernetes_auth: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__192a0fd934e6a1d07615d2afd0795c3df7c4aa34d47ff452bedf3fc29fa86266(
    *,
    access_id: builtins.str,
    k8_s_conf_name: builtins.str,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c14314d094e94d395d2ccff2cf0206fe712c51cc34cb705d9bc8551ecd029b3(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f478b9b41d5e678b636bd675c0ec2c7f55c4865d490d5fcc185441264c97d93(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__60e63983e9ec9d9bfcca0afd0a14c5370b8a8c7b94a6b979643b8044b38aa115(
    *,
    access_id: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId, typing.Dict[builtins.str, typing.Any]]] = None,
    access_type: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType, typing.Dict[builtins.str, typing.Any]]] = None,
    access_type_param: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__590589c4f0ffc4f7a23fc7be01fd06b9606c7490a060d9b41f3fce96cd350a4b(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6833336a565db04ecd89b0aa463de48ce00c5f1b845b44dd43ce9dab14465672(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d06232497d385b58bfbdd183ed5f662b436ad66cd940f49635d36c2df433b70d(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9cc55aad529f682a5ebb094a2bfdb40ac255aabd37ddb0785bbd5aaff3c48947(
    *,
    name: builtins.str,
    type: ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProviderType,
    key: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3eb80c03d9d589e644cb87d2292cd9b0100e384bc2944213b7aa5376062baa73(
    *,
    auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth, typing.Dict[builtins.str, typing.Any]],
    region_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f66b02e4c9c411cbc556b143e0d872bfef186a37724247912aa8fcc440a97ef5(
    *,
    rrsa: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6fe999b1094de39ca60a20138e20aa8cb22ff83d307bc0d4cce40257546baddb(
    *,
    oidc_provider_arn: builtins.str,
    oidc_token_file_path: builtins.str,
    role_arn: builtins.str,
    session_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9952ed78896c2d9e3124276209d8d30534064f05539cbe262b52dc19a0d35935(
    *,
    access_key_id_secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef, typing.Dict[builtins.str, typing.Any]],
    access_key_secret_secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a0a97c63b2968bfb08081c4620d8d386f9d89e66db4ee38df5e4cc06736a7481(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0b830df319081a50f248ad0423e39dc55ca4f62f813b541532fe44af6c0cb6c5(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6627988073d9ff383a854cf295ddb2aa2cfe69af584935d6041de0fd6369c2f2(
    *,
    region: builtins.str,
    service: ClusterSecretStoreV1Beta1SpecProviderAwsService,
    additional_roles: typing.Optional[typing.Sequence[builtins.str]] = None,
    auth: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAwsAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    external_id: typing.Optional[builtins.str] = None,
    prefix: typing.Optional[builtins.str] = None,
    role: typing.Optional[builtins.str] = None,
    secrets_manager: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager, typing.Dict[builtins.str, typing.Any]]] = None,
    session_tags: typing.Optional[typing.Sequence[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags, typing.Dict[builtins.str, typing.Any]]]] = None,
    transitive_tag_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9edc5295784c46ee0e2ea751f45dd384e14e357e55ab66dbd253a053803e6150(
    *,
    jwt: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9184e71a5ae0b63160a31c441f3e767c7e9fe4ccdeb7eb6d0313b1e446630e7c(
    *,
    service_account_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__870111368203389e739228502d0d717a15cc9b15fa8225662b2e8b801afa6d57(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e52b02bc80a06882a9b54890d7cfecec33b6ea34945389922ff0d8635877f5c5(
    *,
    access_key_id_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_access_key_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    session_token_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ce640ed09fb68e1ec7ffae5b6f1bdeeb3b0254c8fe3a3a1ca738807848e9bef(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__594f5480cf09e605b57bbf933433bc689ecce1570797dbdf19a46e8f5ddf16c1(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3912a4e98840489edf6e5dfa8970de8ea9724ef8f4ceffd39602443613a6428e(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__48c5a27c67d8d807c1dae77d0c9163e10b98d1c6749b78b57aafbce00783830e(
    *,
    force_delete_without_recovery: typing.Optional[builtins.bool] = None,
    recovery_window_in_days: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ca4d5f8d4561743bd341a8ef02e3fe43606734481120c4be650df99a50ee88ad(
    *,
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__abf7c19186023102b0e55132e0eeb8f816d43879e662f9fc61393882d66c7d54(
    *,
    vault_url: builtins.str,
    auth_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    auth_type: typing.Optional[ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType] = None,
    environment_type: typing.Optional[ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType] = None,
    identity_id: typing.Optional[builtins.str] = None,
    service_account_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
    tenant_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b5c6576dd0bcff847eb542793197cccaed967a7895b6800a3297ababb2258a6(
    *,
    client_certificate: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate, typing.Dict[builtins.str, typing.Any]]] = None,
    client_id: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId, typing.Dict[builtins.str, typing.Any]]] = None,
    client_secret: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret, typing.Dict[builtins.str, typing.Any]]] = None,
    tenant_id: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a020b2caecfdbe5ac6df9941e14be21d70df6d9ac4b30816931e54e3377ba0fd(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c666df2b9f723e3fa73884c25af477951655f8afbb53d585a2431dff1d9219de(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__00f7e356b48005cce89b72ead3be30d457b3e32c2e5bcf50f43bdf1678d0c242(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e4429b736687abdfd285a8c1cb74d70991015d3ce65c34dc4a97d594505bd73c(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__99524d6c465621fc67233b99280c814ee97e0c6e2aaad7b7fb19183628a5f5f4(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d644083390ae86be080b7b78b4a9c7b7aa264b442a65dbf9a388d197bc165a1d(
    *,
    auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuth, typing.Dict[builtins.str, typing.Any]],
    server: typing.Union[ClusterSecretStoreV1Beta1SpecProviderBeyondtrustServer, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__633161e913a2859366f023110b06233f7cf1844be7aef44152fa242ca4621b09(
    *,
    api_key: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey, typing.Dict[builtins.str, typing.Any]]] = None,
    certificate: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate, typing.Dict[builtins.str, typing.Any]]] = None,
    certificate_key: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey, typing.Dict[builtins.str, typing.Any]]] = None,
    client_id: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId, typing.Dict[builtins.str, typing.Any]]] = None,
    client_secret: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8d9d7143675bb5d0e9087d8f6f37cccc9cc6c95a6f1574de2d135f9b1463497c(
    *,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__948205cc7184f02cd4534675d47617eefccf3104d8165f307f28740db0defffd(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__975e1de3279673de7785d9b68c3942b01752e64b62905ea701ddb2b6f2739f32(
    *,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f06f99a6a008040c5d148cb69c449b9d369d6e1ba95b780c3bc7a917970520f2(
    *,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee54b4a14c99f657cd27156f8aaa80f6c3cb0fb5db165fa6e6119b372c477ccf(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f3912a938c200533a74da924ad1dc5e0f108fdb412a0772177bd1e4c2cef79ae(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9cd2d63679cfab15fe0a2bf8c273bc3355d8307c4c83345cca4ca88d305c3366(
    *,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c8e080233c8166cea6abb12bd265800513cbfafc45139268edd115e69544e72(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f9061130cc3bab5ac590ef17e5a1fd14e83b348557933868a465db939ea4706(
    *,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__82d267d257ce408851b390ddef2f738c01183df9901d1ffd9b84c1236c4b46d4(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4baad16e8885afc816e35320219242f427726fad7c713c13199df71c35bdef69(
    *,
    api_url: builtins.str,
    verify_ca: builtins.bool,
    client_time_out_seconds: typing.Optional[jsii.Number] = None,
    retrieval_type: typing.Optional[builtins.str] = None,
    separator: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b07a083bd35c1b15a717d8b98648c746372913d80ab988028269e75bcde9c07d(
    *,
    auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth, typing.Dict[builtins.str, typing.Any]],
    organization_id: builtins.str,
    project_id: builtins.str,
    api_url: typing.Optional[builtins.str] = None,
    bitwarden_server_sdkurl: typing.Optional[builtins.str] = None,
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
    identity_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd4378a13039dccc79aeba3872fc79064498fda4999957b79a3f7a9a484e2f69(
    *,
    secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__52c242f39cff7fd6216a580f410e51eddafe9b1f9fb8c18c493093360a6fd2dd(
    *,
    credentials: typing.Union[ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aa7d0e432a84d9e3f26b069e720b2909ccee1af438a93f280763dee4e58436e7(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a7cc5cae6f2ee50679b7aee052961c0b79b936ec2ce85c4cb7d8b7b081a102ac(
    *,
    name: builtins.str,
    type: ClusterSecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType,
    key: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__88acac78c56cdf7d7b25b35249fe8c901d534be93b0484bde9c8d649b70de553(
    *,
    auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderChefAuth, typing.Dict[builtins.str, typing.Any]],
    server_url: builtins.str,
    username: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b37a2cbd8da0cdf523622a0f633b0d18512951980846f004df6a950b8d7942b8(
    *,
    secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f25b6de66eaab11b8c4daae7eec60aebf678febadf1761328a10c1b73ed2feaa(
    *,
    private_key_secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__83670b4c46a4338b8b67fec9e6cc81a8b7c03be59f98d76ae4db7578f48def37(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd13f006bb522b34918dd83f7d4520b4c3e8918fa9caea1a889a5fcb2c0b858a(
    *,
    auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderConjurAuth, typing.Dict[builtins.str, typing.Any]],
    url: builtins.str,
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4d3a7eca64b061adc53eed42df575bd0efc70846535a2435a0368c7b48c0eff1(
    *,
    apikey: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey, typing.Dict[builtins.str, typing.Any]]] = None,
    jwt: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__38e11fae4b238e011d9b6fee89fbbae87134a2791c0867754810c1c576f12b1b(
    *,
    account: builtins.str,
    api_key_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef, typing.Dict[builtins.str, typing.Any]],
    user_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__83ce4c1e32adde35b044f533d42f205da4eea6cf33cc0897f609eb92e7ef6d1a(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c532b61284b3c9f148319362b064408e397299e4acc7f3b5161bd2c953ce1d3(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__52b0f350eacc0c9b57a1b6713a56af5acafeba5eba98459f04a1fe98b1f41edb(
    *,
    account: builtins.str,
    service_id: builtins.str,
    host_id: typing.Optional[builtins.str] = None,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2477a088fdf273a37514328ebdad8069af4b5f06af6d86c3cb8020519cd3c403(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__da5e48d7b0634d1d4a4d79c54da3733a03b4bef7c946793c4591d0a9a5b6ee8d(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1347e7dc64bf4b13a7b4244986cd88a94b1dc46cc1f507df56bb3d0e3a2e2ce1(
    *,
    name: builtins.str,
    type: ClusterSecretStoreV1Beta1SpecProviderConjurCaProviderType,
    key: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c9c22fd860711f10bf88c00390f6e46f0802ca37379946c521d4e9ebeb7cc7e(
    *,
    client_id: typing.Union[ClusterSecretStoreV1Beta1SpecProviderDelineaClientId, typing.Dict[builtins.str, typing.Any]],
    client_secret: typing.Union[ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret, typing.Dict[builtins.str, typing.Any]],
    tenant: builtins.str,
    tld: typing.Optional[builtins.str] = None,
    url_template: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2ea7aae16245ad8cf9caf1186fa7177409c930575e68754a2252261c057c1ffa(
    *,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9201b74bb763bb0bc6023542238fd42abe759b34ac2a2ec1d6310851edf2637(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__66414b93ae21bb01c7e9b3c1db5dd435ea5fe139479f594cdc500ffa568fc722(
    *,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5908b4bc02092249d33dbcadae84f4a7d842359ffb9c4c89101a5b1f32935fc(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__732c32bec4317884277fa27eabf3d3de36118bbcdb3dfc58168326549400f0e0(
    *,
    auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderDevice42Auth, typing.Dict[builtins.str, typing.Any]],
    host: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a90242fb595b2168fa71b2d5cac81e56e8e5e75d8e8b81e5bfd3c11e5d47ce14(
    *,
    secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__102e02c8a6c4f30acb49b5df90d4a0ed5d0a516908e54ac6bd941a1593776dab(
    *,
    credentials: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cc60ef3c6f35b0553d188d1313416883a1f7116bc7a1b565ded5cd69652a0ecd(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d8dabb978cd9c207e6c33f6b87227d8fceb1a850813a315b0fb3daf464977a0e(
    *,
    auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderDopplerAuth, typing.Dict[builtins.str, typing.Any]],
    config: typing.Optional[builtins.str] = None,
    format: typing.Optional[ClusterSecretStoreV1Beta1SpecProviderDopplerFormat] = None,
    name_transformer: typing.Optional[ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer] = None,
    project: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__562144337f6c00cb855087476ff46a1b6075c3696089e7f7cb03e95e120c00bf(
    *,
    secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__00f6e9b3449566bea57b329f0ae730c49bd1c1c616b069d52c0775f572e041b5(
    *,
    doppler_token: typing.Union[ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__77ea0d87e66e97c0e9723355f88c6c77c3cbfd9c14f230f8c829e375f9d83cee(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4a19fbd425ec3f1bcd367c838d58b4bccdcdecc7d9b6f0bb62ff3321bf204aa7(
    *,
    data: typing.Sequence[typing.Union[ClusterSecretStoreV1Beta1SpecProviderFakeData, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aecd81391352349eccc8183460b87996d0fb8c9e4bd5f75c376baf485f1b6934(
    *,
    key: builtins.str,
    value: typing.Optional[builtins.str] = None,
    value_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__23f53b5511de04a43eca076d3113fbd4876b859968943ded73579584b830281b(
    *,
    api_key: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderFortanixApiKey, typing.Dict[builtins.str, typing.Any]]] = None,
    api_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4d4be3708e44244dbee2a11e44eb789795cfe48c43302b71a8a433000e9efcc3(
    *,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91961b519bcb0f662eabc09b7254758dc88f1b7138634b36f11b7124f01dd138(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__611ca919961e90d0ef7f227bbac8c881013ca7cc44d14799bbb24bc4f0eb3677(
    *,
    auth: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    location: typing.Optional[builtins.str] = None,
    project_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__24c1979ee54e5143d4359a3a275ddd182b9dd1799b60c36713217703ba84b3c8(
    *,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    workload_identity: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8d5ae13c791298e83966ee3151a839a5800890f0e978cc6f5f8bcbf799102c7d(
    *,
    secret_access_key_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__befcc03dadc53716c9f45d6c64f5ca1f64c5c39f92273dce93970a6ea7cb2afc(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0ad5be2b93a35f2cf663f2139d82f10ed2303f6fd46bcd8be22dfb7c6d07ce9d(
    *,
    cluster_location: builtins.str,
    cluster_name: builtins.str,
    service_account_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef, typing.Dict[builtins.str, typing.Any]],
    cluster_project_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dbbfaf536015025ead4874e316b663e27b4c506f8792288c86be86d4e197205d(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b842bc57f7fd92b2b56e655e52606a5bebb9bcb992f4ddde8e086b665b8aba49(
    *,
    auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderGitlabAuth, typing.Dict[builtins.str, typing.Any]],
    environment: typing.Optional[builtins.str] = None,
    group_i_ds: typing.Optional[typing.Sequence[builtins.str]] = None,
    inherit_from_groups: typing.Optional[builtins.bool] = None,
    project_id: typing.Optional[builtins.str] = None,
    url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d5e2849acdcd3f4807f8b1d36de4a61ceec968c342a5f01c5a86f3125aecbb7(
    *,
    secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__04f95d713ed9c72c3c6ac92864bfa1ad99f6fdfbe237d224b272b47c56f183eb(
    *,
    access_token: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e80400499c318d990d15b26a86d2debab77bc685ec0bdf02963692ecfb1024b5(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f963142b89244cfeecfff807ef899252614263348620700809657bec1f530b9(
    *,
    auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderIbmAuth, typing.Dict[builtins.str, typing.Any]],
    service_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__89b06a143259e47bb87419627c763e0e429b891a2be7d13124c04b8311b2569a(
    *,
    container_auth: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab7f9219b29d2442359e806a87ce2a170537b2e8f66c99292e852859d2d501e2(
    *,
    profile: builtins.str,
    iam_endpoint: typing.Optional[builtins.str] = None,
    token_location: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__103f7d95032cc629e6d26292a6477d0ed74e34827b75d026c15ecc133c641e07(
    *,
    secret_api_key_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e5730dcd5a104ceac8cb1e536a747e8d4666a82d2bcfb90eaa96292a77009ea(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__433f40dccc25d4ea1ded25dfa0c8a7e2f2e1b2196f131019c9915b8405daf90d(
    *,
    auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderInfisicalAuth, typing.Dict[builtins.str, typing.Any]],
    secrets_scope: typing.Union[ClusterSecretStoreV1Beta1SpecProviderInfisicalSecretsScope, typing.Dict[builtins.str, typing.Any]],
    host_api: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8bf2f01b51b662801580545841b2829b0a1876bfec76fb7dec629e037d69034c(
    *,
    universal_auth_credentials: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dcbc59bb27692d8e371d6c510a9c5f75543d6ea509762ca6584dc59eab9292a6(
    *,
    client_id: typing.Union[ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId, typing.Dict[builtins.str, typing.Any]],
    client_secret: typing.Union[ClusterSecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__53cf2f6b49226b98a3669bbac517568bb383b82080fe36dea245ff7765eeec17(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a66cfd6286a33a8c66010c07dde69bfc97e9e160868c96a369aa7f7238be0309(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12df93e3ea954e29712e9ad1f4243a67dc232cb13e920189ecdaacd7718aa991(
    *,
    environment_slug: builtins.str,
    project_slug: builtins.str,
    recursive: typing.Optional[builtins.bool] = None,
    secrets_path: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__065b85cf10ae98230a4d3cf137fb837a286a95931000e9c2a9ddf1fa0e5396d7(
    *,
    auth_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef, typing.Dict[builtins.str, typing.Any]],
    folder_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2aa1a183ead69b64d91b71a278641ffca7b9351511afafd45bf2698b2e9a8cb3(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__649ae35e91afd368380d7dcf6b83dcb17d871a308c44fa3c417593e5eb164998(
    *,
    auth: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    auth_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthRef, typing.Dict[builtins.str, typing.Any]]] = None,
    remote_namespace: typing.Optional[builtins.str] = None,
    server: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetesServer, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aa84d767397938230357c9460f0da92fd27caf2560c4febd4db2b1946dbc1a5a(
    *,
    cert: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount, typing.Dict[builtins.str, typing.Any]]] = None,
    token: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__575fe398163e0264fc9cc318f5b63077e40822b1e8607c6f85b40057e5a91186(
    *,
    client_cert: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert, typing.Dict[builtins.str, typing.Any]]] = None,
    client_key: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__221783d76f7a636012233fe6be08a91a99912dd5418e80c4f5e22a44a9b16cf3(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6dfe1da476f2ed826b423e04e21f7ee460e7f9163e2c8242f2cb83e8ff997e81(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b3f63c6cffd29f4a4808e7fd7ad6778b84f6572853a314c62266537b7e9c1738(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0efc0826b2f3217518a7e2c85f96d8b9872418b61e028eac0ae806c4e580bb3d(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__db5aaa410704bbf457b4dcbf24af03e4aaab852ef8f192060599932d0d94ed2f(
    *,
    bearer_token: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f8a74ed4d0d51a9d802908b11ac516af3b90bbe5e93a70c4f766f84a2b3d33a8(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__334ade9bed56e5f41ca8625f7989056de67a4ab314b2d286d7c305cef1d84b45(
    *,
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
    url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b4e3f7f956c039a12dbeed25ac8b12f48c513e3306b05774406b2ce6fe2661f7(
    *,
    name: builtins.str,
    type: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType,
    key: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fef0fe20d06010db0b115f64a6faaeae6035afd6ee50023dd2905ba6edb385d9(
    *,
    api_host: builtins.str,
    auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuth, typing.Dict[builtins.str, typing.Any]],
    environment: builtins.str,
    project: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d1cbb2018cddeec517a9daacbd3efacd9e12b372cdda0ccf5f1c4e390b0a3187(
    *,
    api_key_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef, typing.Dict[builtins.str, typing.Any]],
    passcode_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e48908cdfeadc38509946151999d447e24d1ae1619cc7a9071c10f1e788238b0(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__96c99d992290dc70599e2af41c3bea41966ab99f0af0c5260d74a5302466d420(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e7023e452cdb4cf6a57594c3ae644dd93fd67ddecc86ef9bcc979edb5f9aebe4(
    *,
    auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth, typing.Dict[builtins.str, typing.Any]],
    connect_host: builtins.str,
    vaults: typing.Mapping[builtins.str, jsii.Number],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__774fac14fd73ee729045af64d77ecd440ce05c35c3e5a53f860c8d58b15dc3e1(
    *,
    secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d3aba248a06dd8137580c089c2215674acf58e010721b05475ec86c4c4a00214(
    *,
    connect_token_secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e77c7583da6824bee3f7242200e93b841cf55888927c6900b619907c5e020884(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8799a207c6f9af8f59bb32f362d3937320020eec54a1cc499d831392110f8a7a(
    *,
    region: builtins.str,
    vault: builtins.str,
    auth: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderOracleAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    compartment: typing.Optional[builtins.str] = None,
    encryption_key: typing.Optional[builtins.str] = None,
    principal_type: typing.Optional[ClusterSecretStoreV1Beta1SpecProviderOraclePrincipalType] = None,
    service_account_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1059d0e050af9730791fb51609c13da6c9e6644134ff8920a849b11fc9530224(
    *,
    secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
    tenancy: builtins.str,
    user: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6066dd054248d30379dd581e24cbdc9afe6660138d4ad8fa3fc38af7347a3990(
    *,
    fingerprint: typing.Union[ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint, typing.Dict[builtins.str, typing.Any]],
    privatekey: typing.Union[ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__287e9ae6268a6e788ae12f7ac12e8fbb9c885f4ff3d45a0caf28cd5b8d169176(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5ef933a14bdabe16081013d01aaf091a9b526ae2581143345eefebbda8c252e6(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bdc362d2dc657faa25b2dd71b2ac7510e47044f7a095df7486825735173be01e(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a5bdf2a0b57968765bc44e2884c1669c82fec7a7708fe5dca91387ae68da08e(
    *,
    auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderPassboltAuth, typing.Dict[builtins.str, typing.Any]],
    host: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__483cad95d0042cdbab9a60c81b20980557e0b60689450c8717896ab6c1d6e15f(
    *,
    password_secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef, typing.Dict[builtins.str, typing.Any]],
    private_key_secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__642fd1ce8f6dea3187f6aee48bbbe2e1933e1c9c53f560119d3d1841066fbc78(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__59ae23d4cc00631d4f90cb043b7bc74c3052fd82a2664116f490110123809074(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b3e4ac61bac2d763c98707b1962c58667b9ac61ee2b2dea402f347b1c481fb79(
    *,
    auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuth, typing.Dict[builtins.str, typing.Any]],
    database: builtins.str,
    host: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__05c65e058ced4bdb5cef3641cc9e5cfaae0387cd9db325478de3ddeda13003c7(
    *,
    secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6de977b5878b841de2449126618c6a83ce9e9bea33c1d98d8a99425cdf649481(
    *,
    credentials: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2ed80b8a0ccff8d950eb589785a3db8eda34428f58f04ec1844c28d4d1b9dd2a(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__924872030e44d3ecd52de749e7dfc24284bd7a32d6106c1c35a38e9a05bd53d0(
    *,
    auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderPreviderAuth, typing.Dict[builtins.str, typing.Any]],
    base_uri: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b84707fdc9bd6eb9bd787c836e511a5a7292d579ed9f7e3ea2bdf76b803be5e1(
    *,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7d35b300a5d3d17a972507e059cf1b7c7ce5dc548d7626f4b72592c159e7577(
    *,
    access_token: typing.Union[ClusterSecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c23e7cae4da282bd243d4f801f0019cbfbcec800546fb8976422c523e4d82deb(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a3d514f7841dfe014761e2c7d90549223f920bae7e524a1516bfa510a96c06f(
    *,
    access_token: typing.Union[ClusterSecretStoreV1Beta1SpecProviderPulumiAccessToken, typing.Dict[builtins.str, typing.Any]],
    environment: builtins.str,
    organization: builtins.str,
    project: builtins.str,
    api_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8ce20bfd85695402dc2849f6d7d6aa51cffd3b4566344bb15cb2a217d2c57995(
    *,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__803f54068a7a9a3d2dd582de1857a6521e55ab7acbd0a7fd47cda1cd02fd01af(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__34a650bc4b0a2bc1f9f27e56bc55b81edf43ce63c03c1f2688ccfcb6c0edb300(
    *,
    access_key: typing.Union[ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey, typing.Dict[builtins.str, typing.Any]],
    project_id: builtins.str,
    region: builtins.str,
    secret_key: typing.Union[ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey, typing.Dict[builtins.str, typing.Any]],
    api_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f30cfa9a739a56c761461f061f73a9b640a983d8a1a701a1fefe3d789730c70(
    *,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f9043fea830d3be2007d12b48e16e9e86cda92767498fdfdd2ccb99c9219cc6(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eace41394372d69255d6903c1697729bd6838c548cb8800015bc9ef27ebafc6c(
    *,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2416ae63f6956e1362be588c0f9dcd24e011f9246db6e363300071963649becf(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e5cc7e570ee07bfa3e1df100121363b4e855684c4d46acc2a6f13f8134621e29(
    *,
    password: typing.Union[ClusterSecretStoreV1Beta1SpecProviderSecretserverPassword, typing.Dict[builtins.str, typing.Any]],
    server_url: builtins.str,
    username: typing.Union[ClusterSecretStoreV1Beta1SpecProviderSecretserverUsername, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__abd70d527f4be3d9bdaae30b0afbc845b6c753bf4e3a173d3bac4b31e8d276eb(
    *,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e84cb0430452796bee1e109b2a29e189b02433f3d46fe2e69304fedebde1caf(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4792ee1a300e27f94432d14b0d25bdd28980ab37a7f9d1d9965a80e89ba55a81(
    *,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__42005e28034a3b0e045aca385b095bf85d822a6601f9d62cee4d6f22d42af191(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__784088abfe52d375c8846da70040ac2e8a3a7fa8b88275b3433f77ed7167b0bb(
    *,
    auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth, typing.Dict[builtins.str, typing.Any]],
    module: builtins.str,
    url: builtins.str,
    ignore_ssl_certificate: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0968cf6c587cfe7e19f4d78b9bfccbab47ad4922f6924b0e57fee2840889975f(
    *,
    client_id: builtins.str,
    client_secret_secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e46f714e97c2c006c0dbdfdddca33d85e4f65fd4e9785f239d767d95af2ea339(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d1ed82d254940b706af74554873fa54b86cd8804d7fee8da566eedeb386d5b29(
    *,
    auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuth, typing.Dict[builtins.str, typing.Any]],
    server: builtins.str,
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
    forward_inconsistent: typing.Optional[builtins.bool] = None,
    headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
    path: typing.Optional[builtins.str] = None,
    read_your_writes: typing.Optional[builtins.bool] = None,
    tls: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultTls, typing.Dict[builtins.str, typing.Any]]] = None,
    version: typing.Optional[ClusterSecretStoreV1Beta1SpecProviderVaultVersion] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fa1611c7ca8d9fedadb92afb290e6c41419ad09bd43146b4bdf9c1d75b8a578a(
    *,
    app_role: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole, typing.Dict[builtins.str, typing.Any]]] = None,
    cert: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert, typing.Dict[builtins.str, typing.Any]]] = None,
    iam: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam, typing.Dict[builtins.str, typing.Any]]] = None,
    jwt: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt, typing.Dict[builtins.str, typing.Any]]] = None,
    kubernetes: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes, typing.Dict[builtins.str, typing.Any]]] = None,
    ldap: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap, typing.Dict[builtins.str, typing.Any]]] = None,
    namespace: typing.Optional[builtins.str] = None,
    token_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    user_pass: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__37344579b6c7a990af00af0b70741d46bed82ecd50a1667f46a0a209f98d358e(
    *,
    path: builtins.str,
    secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef, typing.Dict[builtins.str, typing.Any]],
    role_id: typing.Optional[builtins.str] = None,
    role_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c591a929d806d0bc633717d6ac586352f779f400859e5e98ed0ce52f7af3792(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1a567a5819c4a04fddc6a249b2d5873b97787e972002e493d8366c84cf35e833(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f25011ba998dabb5c8c1b1408c88fa08a117eed82a2c013e79cfb8818779b7df(
    *,
    client_cert: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c2ad4618f79f3d33c7e840b1487a7f1d766d69e4eb44fdf9127c82a83ab3cd28(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2be91ee51069c6922509e3c0ea70cb74f2e82e7f7a28829a95990ebbe870adf0(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b9b3df7c0ff0150a6463318d5b62350d5d7e04d3b1eb897eebbdd93e18a98cbf(
    *,
    vault_role: builtins.str,
    external_id: typing.Optional[builtins.str] = None,
    jwt: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt, typing.Dict[builtins.str, typing.Any]]] = None,
    path: typing.Optional[builtins.str] = None,
    region: typing.Optional[builtins.str] = None,
    role: typing.Optional[builtins.str] = None,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    vault_aws_iam_server_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__019f3c4eab657ae326a7dd6cf588d6c0e7fc7cd0100d6597235c2daf872a8828(
    *,
    service_account_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1e4339e57d4fc718d534d25d88487de69ddec8b14087869cf5f6ec3356ac95a2(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4e26debb848eba1761e7a29aa1f5c26d6bb051db041f63f3fffb358634fb771f(
    *,
    access_key_id_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_access_key_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    session_token_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d4d492e83e6ee1993a1214e3829da5aee6ad02ebea107b47c4588ecc8720551(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29972b8bca5810c125c0e9273056ab82c6ff7aff2213cf3b23262d6e8ef82bff(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__547a0f0f9de6f03c6e61437c6cfeb30ebe2cf91ea045878f7bdb09680145ecb3(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0516f9862f945b4b6129c24cc3a1ecb2da2a492e6c162dc238992faf6ad42566(
    *,
    path: builtins.str,
    kubernetes_service_account_token: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken, typing.Dict[builtins.str, typing.Any]]] = None,
    role: typing.Optional[builtins.str] = None,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9635b4909e716c335632ee7fbb0defc729d2aa215fa0e2ecf9b58c670ed974b(
    *,
    service_account_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef, typing.Dict[builtins.str, typing.Any]],
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    expiration_seconds: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__503a402a2f8a60f71248b4d66efb68127bb876fab9dc95581f2ab8c3dc6766f7(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__27456e5e3297f3a6c07e214fd809cfe592c755afe64370c36586faf0b4ff536a(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e3234a480af19889bfdd0bcf31963e9ffcca79ad4549d1c673c3d21aa0be1f89(
    *,
    mount_path: builtins.str,
    role: builtins.str,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a7c01ad25d6903e2b94170c5306163dc83c37d167d03d2e947b8dfbce92360c9(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__68e19fd3a505ed8443bd824708b4f25994c9d40acb32b52b89a503ed39bc5c8e(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e8f4902f761c246ffc6f920fc8bd963e2f8140fd3d65b4da75c7025dcec6765c(
    *,
    path: builtins.str,
    username: builtins.str,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a061597668e45a3b5881fb989859fa9ba9fa59812f88447e7d1fb50d91d4578c(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f030b58112bf019c388c92034c3321dfa7a6cf28ed27ede3f4de94d581d5035b(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c0b94cc77dbc9bf5d277f712c6c780f02d800403f0170161b6ce6b1c7f0fb83(
    *,
    path: builtins.str,
    username: builtins.str,
    secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e305806b5153df3a1a44c0688c27cfc4e9ac43a5df5c628abb8767da22caba6d(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__614ead02a45818d7b842fdb84071c31ffdc2fa1b565a7ebdc48c6a9773ceeb9e(
    *,
    name: builtins.str,
    type: ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType,
    key: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__60e9db85165a8f05f9caf59c9ac1e9d32997804e3ffd2311317fbadc5f4781a4(
    *,
    cert_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    key_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__01682b1e5411c8e610560ab926f0f147190ed85dfac508657bb97191c51301b8(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__be1cc6ff896b92e00f1824eb023193a80c1e140bd11b60acb0549f8bb4fd2523(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__541a85086d1f97223810cca4d54c92f289ed5a73007e8e7009b98285d97578ca(
    *,
    result: typing.Union[ClusterSecretStoreV1Beta1SpecProviderWebhookResult, typing.Dict[builtins.str, typing.Any]],
    url: builtins.str,
    body: typing.Optional[builtins.str] = None,
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
    headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    method: typing.Optional[builtins.str] = None,
    secrets: typing.Optional[typing.Sequence[typing.Union[ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets, typing.Dict[builtins.str, typing.Any]]]] = None,
    timeout: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__68283da0c213c61ac76c8b9dc18fd6a446a8666903a6779c4e450ffbb7638d41(
    *,
    name: builtins.str,
    type: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType,
    key: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ffe032a875d453ef67efba038253b55e781313fcf9727a2e190e0f07bc7a7781(
    *,
    json_path: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a4adfaf99cc3249a4b88e7b23a2ff492e444c10ff063c6260a50441d20189774(
    *,
    name: builtins.str,
    secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b04a124282f6cc28a9350a757f666203390ebbfddda7e54a523fdeba3026ceaa(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ff9cd98361d4846493719df1ded33affcd4d8eace2485af38ef75d671c1dfbb(
    *,
    auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth, typing.Dict[builtins.str, typing.Any]],
    api_endpoint: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__51a1a90bc0ea5f1d7006ba171eeb03cabe219c2e3b1a59e18c03f47111a2886e(
    *,
    authorized_key_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c5002745ef7984d16f7c455def03b6a31678dc133c5daf8bf4c6847270703834(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb4082ecd7921b9fbfec3f37b117a6e5cbf96687643a0da1deb5e9606facb5cb(
    *,
    cert_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__031cafe781180219b4b5259d9846e47719fde28b6e66b15223a100bd6914f19f(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d723d21a6c0b24e7b6edf9808d7e46ac0dbf01d99571c220621355462524b02(
    *,
    auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth, typing.Dict[builtins.str, typing.Any]],
    api_endpoint: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__550fc853f971ebf114ea0c29cde1e781f93eb593ff32b6f1d018ad5990e4710f(
    *,
    authorized_key_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c3f7bb16b26a20247381202a6e31627cab93618b40ec15086c087dff5bf26be9(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64744aa417489ee5da00031086b34f8bb9d5d1e2842de076efd366b85e968725(
    *,
    cert_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e64f2aba41167a866d087c9b87db2a78c49a3c78a857f4d63a3332b8dc04c173(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6cfd20d24fce68320069ccd4f9b78ce19df25d0bfb6d04f99d46f3caf0d6c97e(
    *,
    max_retries: typing.Optional[jsii.Number] = None,
    retry_interval: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c3b70f22c7723f819f402a6957ab71e8991db57a58ba85047be7a2faaad81e0(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[ExternalSecretSpec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__37e904970e3dbc8f880d53222da8b9d6ad0e642ffbccba70fe72cb9cdfbe3289(
    *,
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[ExternalSecretSpec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__074b53f8506e2f7772a36a26ed9736680e0342754c5f0ccf2218c6fef874937d(
    *,
    secret_store_ref: typing.Union[ExternalSecretSpecSecretStoreRef, typing.Dict[builtins.str, typing.Any]],
    target: typing.Union[ExternalSecretSpecTarget, typing.Dict[builtins.str, typing.Any]],
    data: typing.Optional[typing.Sequence[typing.Union[ExternalSecretSpecData, typing.Dict[builtins.str, typing.Any]]]] = None,
    data_from: typing.Optional[typing.Sequence[typing.Union[ExternalSecretSpecDataFrom, typing.Dict[builtins.str, typing.Any]]]] = None,
    refresh_interval: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__475d807ac9fbc706d9ba6234ed898b602897f6af687b51a5cfabc7a77de0d4ce(
    *,
    remote_ref: typing.Union[ExternalSecretSpecDataRemoteRef, typing.Dict[builtins.str, typing.Any]],
    secret_key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5652c1cf0894311801be60a13dd81647750db80e32bc8f49fe3e8235021c6c91(
    *,
    key: builtins.str,
    conversion_strategy: typing.Optional[ExternalSecretSpecDataFromConversionStrategy] = None,
    property: typing.Optional[builtins.str] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8fa135eb71c3b0e514a59fb4221d3694ecf54b320c828591b0435c574fdfb02c(
    *,
    key: builtins.str,
    conversion_strategy: typing.Optional[ExternalSecretSpecDataRemoteRefConversionStrategy] = None,
    property: typing.Optional[builtins.str] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6387a5fae9528a5204090c40d2c2889305f5e0931cd3c9f56f16b857a47f6aab(
    *,
    kind: typing.Optional[ExternalSecretSpecSecretStoreRefKind] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__827bc50a1daa2c072beabe447d39f5aa425b2533370b434284005378aa9a35c4(
    *,
    creation_policy: typing.Optional[ExternalSecretSpecTargetCreationPolicy] = None,
    immutable: typing.Optional[builtins.bool] = None,
    name: typing.Optional[builtins.str] = None,
    template: typing.Optional[typing.Union[ExternalSecretSpecTargetTemplate, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8a97a9d748a88e76340582885a47a889666e169b36bf601e948fa8fbaf8eacb8(
    *,
    data: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    engine_version: typing.Optional[ExternalSecretSpecTargetTemplateEngineVersion] = None,
    metadata: typing.Optional[typing.Union[ExternalSecretSpecTargetTemplateMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    template_from: typing.Optional[typing.Sequence[typing.Union[ExternalSecretSpecTargetTemplateTemplateFrom, typing.Dict[builtins.str, typing.Any]]]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fd5588a79e0c2ae668496ad557535214d7832b67410c55764b5ebcb0df34aa6e(
    *,
    annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__31faa86a5c98b99d6ee0e61c7febcb6d057f4f2d66a77088ff59e58fd22c0e21(
    *,
    config_map: typing.Optional[typing.Union[ExternalSecretSpecTargetTemplateTemplateFromConfigMap, typing.Dict[builtins.str, typing.Any]]] = None,
    secret: typing.Optional[typing.Union[ExternalSecretSpecTargetTemplateTemplateFromSecret, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__02bb153304316c1d27d8cc2666b4bffdf0b5ee46f914eb90f501ff4d279aff79(
    *,
    items: typing.Sequence[typing.Union[ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems, typing.Dict[builtins.str, typing.Any]]],
    name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__183828d27464f0cb7be30c7fcfa871d537b68ad5d70c9895876220619c3ee123(
    *,
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a0091308b64027190e4220f919c8b9fe8606081a83a7cac89b8d6f66850f27d9(
    *,
    items: typing.Sequence[typing.Union[ExternalSecretSpecTargetTemplateTemplateFromSecretItems, typing.Dict[builtins.str, typing.Any]]],
    name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd62afc90b918a7a93df148a8f114e0416daaaa6276fbdd86d8d0b7a8b3a5886(
    *,
    key: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cfd09e377328d190f8f7b77670ab85f29c4518dcbb58d06f05a9a27a25809189(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[ExternalSecretV1Beta1Spec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__461761ed0edddc73d403b793c8ed04d0bc0a2534dd95e8eae4158f95cf880b21(
    *,
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[ExternalSecretV1Beta1Spec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__93f730c43130f4e637999febc8307761ffd7173d07e0fb0252beb9d33999daae(
    *,
    data: typing.Optional[typing.Sequence[typing.Union[ExternalSecretV1Beta1SpecData, typing.Dict[builtins.str, typing.Any]]]] = None,
    data_from: typing.Optional[typing.Sequence[typing.Union[ExternalSecretV1Beta1SpecDataFrom, typing.Dict[builtins.str, typing.Any]]]] = None,
    refresh_interval: typing.Optional[builtins.str] = None,
    secret_store_ref: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecSecretStoreRef, typing.Dict[builtins.str, typing.Any]]] = None,
    target: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecTarget, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__57cac15896a1d924720292c54c0d0f922c9daf2aa81f875475449aef38e0e295(
    *,
    remote_ref: typing.Union[ExternalSecretV1Beta1SpecDataRemoteRef, typing.Dict[builtins.str, typing.Any]],
    secret_key: builtins.str,
    source_ref: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecDataSourceRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a22f4fe792b72c3eaf030666d89e08718509ca8d74cccad99560062b6eeb559(
    *,
    extract: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecDataFromExtract, typing.Dict[builtins.str, typing.Any]]] = None,
    find: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecDataFromFind, typing.Dict[builtins.str, typing.Any]]] = None,
    rewrite: typing.Optional[typing.Sequence[typing.Union[ExternalSecretV1Beta1SpecDataFromRewrite, typing.Dict[builtins.str, typing.Any]]]] = None,
    source_ref: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecDataFromSourceRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4470abe995b704cbdcdf0492e1e91e23a97f5bd83a22269ccf3af13015136970(
    *,
    key: builtins.str,
    conversion_strategy: typing.Optional[ExternalSecretV1Beta1SpecDataFromExtractConversionStrategy] = None,
    decoding_strategy: typing.Optional[ExternalSecretV1Beta1SpecDataFromExtractDecodingStrategy] = None,
    metadata_policy: typing.Optional[ExternalSecretV1Beta1SpecDataFromExtractMetadataPolicy] = None,
    property: typing.Optional[builtins.str] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__22b4b957dbb9cd8460e4e930700a48d34f638298827b6fe53d68d1b82de6f401(
    *,
    conversion_strategy: typing.Optional[ExternalSecretV1Beta1SpecDataFromFindConversionStrategy] = None,
    decoding_strategy: typing.Optional[ExternalSecretV1Beta1SpecDataFromFindDecodingStrategy] = None,
    name: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecDataFromFindName, typing.Dict[builtins.str, typing.Any]]] = None,
    path: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f615a184713f5d364337da92283293111522fd42282ad325a8afbd2d1962916(
    *,
    regexp: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__454681f1cc3a392e81ef5c92bfa786dde1e38e7aaa5f2a3ed665e0b4cb009c13(
    *,
    regexp: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecDataFromRewriteRegexp, typing.Dict[builtins.str, typing.Any]]] = None,
    transform: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecDataFromRewriteTransform, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__22d63d6e820ab00e4df04c49344342bd4731978ef6611c06c5ac4b5332794e7c(
    *,
    source: builtins.str,
    target: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d47b0f8c8a5dc70763b8dc023f9180f55c381aaf0b4f19237eb10dcd1ac06128(
    *,
    template: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1e31764683713a9a8f8bf7cbe8fa64128cb17a25250a39a9dce43346a98e28ed(
    *,
    generator_ref: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef, typing.Dict[builtins.str, typing.Any]]] = None,
    store_ref: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a25657d5911002a9ed43593a36ebeae2b366d18947f1a909c37401825186ff0e(
    *,
    kind: ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRefKind,
    name: builtins.str,
    api_version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__313a803335f1a3dcc9bd5c2b02ad7bab54c82cffdedec119f8d273c3ca941610(
    *,
    kind: typing.Optional[ExternalSecretV1Beta1SpecDataFromSourceRefStoreRefKind] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__823faeef50b2c0df69c9ae99b8ab132511378b031b5042afba0c9fe24ba93dd4(
    *,
    key: builtins.str,
    conversion_strategy: typing.Optional[ExternalSecretV1Beta1SpecDataRemoteRefConversionStrategy] = None,
    decoding_strategy: typing.Optional[ExternalSecretV1Beta1SpecDataRemoteRefDecodingStrategy] = None,
    metadata_policy: typing.Optional[ExternalSecretV1Beta1SpecDataRemoteRefMetadataPolicy] = None,
    property: typing.Optional[builtins.str] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ddbbc6e6e35a17c0e134f27793083186c7768306a73ee6e63372b5181a919122(
    *,
    generator_ref: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef, typing.Dict[builtins.str, typing.Any]]] = None,
    store_ref: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecDataSourceRefStoreRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__294137a19635c86246291dbae5ba6d655fd0cc9233328d9348f5622e2d5487eb(
    *,
    kind: ExternalSecretV1Beta1SpecDataSourceRefGeneratorRefKind,
    name: builtins.str,
    api_version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ee05ae4a797f40081b7fc7ff7fbe24176ce4f18ec8da215e046951f11bebeca(
    *,
    kind: typing.Optional[ExternalSecretV1Beta1SpecDataSourceRefStoreRefKind] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f1f99a615b28ea8c79a67cd067ee214dfafc7d9ce344d5895cdcba82c5d4337(
    *,
    kind: typing.Optional[ExternalSecretV1Beta1SpecSecretStoreRefKind] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__137058ee7bb8bbf207a1c6bea2d7edc847fcb8e66808b8a474d9e3f6cf606abd(
    *,
    creation_policy: typing.Optional[ExternalSecretV1Beta1SpecTargetCreationPolicy] = None,
    deletion_policy: typing.Optional[ExternalSecretV1Beta1SpecTargetDeletionPolicy] = None,
    immutable: typing.Optional[builtins.bool] = None,
    name: typing.Optional[builtins.str] = None,
    template: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecTargetTemplate, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0845c9cb8505c291793a6fac848aa5d4340d17ecc2e58386511e13ecba7b0d77(
    *,
    data: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    engine_version: typing.Optional[ExternalSecretV1Beta1SpecTargetTemplateEngineVersion] = None,
    merge_policy: typing.Optional[ExternalSecretV1Beta1SpecTargetTemplateMergePolicy] = None,
    metadata: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecTargetTemplateMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    template_from: typing.Optional[typing.Sequence[typing.Union[ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom, typing.Dict[builtins.str, typing.Any]]]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__018d8922bc23dbcc72288a6bb9df1ee13ec20a354c2863ebe6f5778d0547c2b9(
    *,
    annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf8068a43ca684f4a943d7d5e82ab5f65a31b37cd2681ead194fa54dd950d01d(
    *,
    config_map: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap, typing.Dict[builtins.str, typing.Any]]] = None,
    literal: typing.Optional[builtins.str] = None,
    secret: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret, typing.Dict[builtins.str, typing.Any]]] = None,
    target: typing.Optional[ExternalSecretV1Beta1SpecTargetTemplateTemplateFromTarget] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d4521141f13b4bd1ec1e9d03377bb4f8fb99f832992af18de111f17b9698448(
    *,
    items: typing.Sequence[typing.Union[ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems, typing.Dict[builtins.str, typing.Any]]],
    name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__450b9bfafc5b457a75263d0420c05dfd89276947b601ed2cd9c63bca7bc8c6ed(
    *,
    key: builtins.str,
    template_as: typing.Optional[ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItemsTemplateAs] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a4a2e35d3be01cb8a634eeb73ba90e80dfeb0ffe5653a7d44637ac186ee815e7(
    *,
    items: typing.Sequence[typing.Union[ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems, typing.Dict[builtins.str, typing.Any]]],
    name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2623eb672daf55d319267bd37583020eebefd412a2e3fa6a451b378cf22e9522(
    *,
    key: builtins.str,
    template_as: typing.Optional[ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItemsTemplateAs] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0475c36ad45a857daad5f71ebc1259c46fc794d0a66fbf4e2f6f16e2b36672cc(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[PushSecretSpec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6298d58475c4a0eeeb4db1a4072c8490107e3409332c3f4e24092ab4f4bf0097(
    *,
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[PushSecretSpec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__01e12d461460e19379d69e28b07562f8ff407ec647ae133368d5aebd3e1bad6b(
    *,
    secret_store_refs: typing.Sequence[typing.Union[PushSecretSpecSecretStoreRefs, typing.Dict[builtins.str, typing.Any]]],
    selector: typing.Union[PushSecretSpecSelector, typing.Dict[builtins.str, typing.Any]],
    data: typing.Optional[typing.Sequence[typing.Union[PushSecretSpecData, typing.Dict[builtins.str, typing.Any]]]] = None,
    deletion_policy: typing.Optional[PushSecretSpecDeletionPolicy] = None,
    refresh_interval: typing.Optional[builtins.str] = None,
    template: typing.Optional[typing.Union[PushSecretSpecTemplate, typing.Dict[builtins.str, typing.Any]]] = None,
    update_policy: typing.Optional[PushSecretSpecUpdatePolicy] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e69051c5188259a4dc4335438fe6e7bbda39d93381fe4f0033cda0f3f3bfcf8(
    *,
    match: typing.Union[PushSecretSpecDataMatch, typing.Dict[builtins.str, typing.Any]],
    conversion_strategy: typing.Optional[PushSecretSpecDataConversionStrategy] = None,
    metadata: typing.Any = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2ac875402ec72b0e6df3e3764db655ec5d29fa1a690e7cb0cec2838ae0d9e339(
    *,
    remote_ref: typing.Union[PushSecretSpecDataMatchRemoteRef, typing.Dict[builtins.str, typing.Any]],
    secret_key: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e133030e524ef8e2d29add5377ec0a66cf7ab81602d9fd744ca787e2c66078a2(
    *,
    remote_key: builtins.str,
    property: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df1c4f5b609f7859699b7e14f448e08967d0f3942b0f5ee5bbd5045392427b6a(
    *,
    kind: typing.Optional[PushSecretSpecSecretStoreRefsKind] = None,
    label_selector: typing.Optional[typing.Union[PushSecretSpecSecretStoreRefsLabelSelector, typing.Dict[builtins.str, typing.Any]]] = None,
    name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__570699534ed6780f5603a7134b0003f72230f360397d88e8c85caed17f8d7592(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[PushSecretSpecSecretStoreRefsLabelSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f0b7a6f1944a19aa57cbe54d5958b908824e4a80e11d401870c40abcd1fe19f(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d7a3f2adcf7de568e829e7d5eee2938ce2ab1a46b00124f458bd6972df2704b(
    *,
    generator_ref: typing.Optional[typing.Union[PushSecretSpecSelectorGeneratorRef, typing.Dict[builtins.str, typing.Any]]] = None,
    secret: typing.Optional[typing.Union[PushSecretSpecSelectorSecret, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a43726c25cc295cb5613a0efacde6c953b6d66e651c10de9a43522604161262(
    *,
    kind: PushSecretSpecSelectorGeneratorRefKind,
    name: builtins.str,
    api_version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f7b91364067418846d0a3b2395366778e11064c3f9e61a8308636472ad20c561(
    *,
    name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__043efa311dbe27603a426dd211a811e5149303d0034c83846ba775fa2e9085f5(
    *,
    data: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    engine_version: typing.Optional[PushSecretSpecTemplateEngineVersion] = None,
    merge_policy: typing.Optional[PushSecretSpecTemplateMergePolicy] = None,
    metadata: typing.Optional[typing.Union[PushSecretSpecTemplateMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    template_from: typing.Optional[typing.Sequence[typing.Union[PushSecretSpecTemplateTemplateFrom, typing.Dict[builtins.str, typing.Any]]]] = None,
    type: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d52589b70a620d8ac512086f76140bbf322ad60786b3dec8258b5b52f568600(
    *,
    annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f4a614224c0c7c641288cae1b707047dac305041493dfd9c87bbabace35f1620(
    *,
    config_map: typing.Optional[typing.Union[PushSecretSpecTemplateTemplateFromConfigMap, typing.Dict[builtins.str, typing.Any]]] = None,
    literal: typing.Optional[builtins.str] = None,
    secret: typing.Optional[typing.Union[PushSecretSpecTemplateTemplateFromSecret, typing.Dict[builtins.str, typing.Any]]] = None,
    target: typing.Optional[PushSecretSpecTemplateTemplateFromTarget] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab8fa0fe2413fb0ecd9497afcfe96a9033efa9c944df15e078cf2dbb321fdd8c(
    *,
    items: typing.Sequence[typing.Union[PushSecretSpecTemplateTemplateFromConfigMapItems, typing.Dict[builtins.str, typing.Any]]],
    name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e6db7a84c42a39b4216b7fad6296c30fafe517dddacb69bc4a4cec9f07552b2a(
    *,
    key: builtins.str,
    template_as: typing.Optional[PushSecretSpecTemplateTemplateFromConfigMapItemsTemplateAs] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cc8257e94fa508bc1d240a1c74aee6b95681f4425961467f7052144b089177af(
    *,
    items: typing.Sequence[typing.Union[PushSecretSpecTemplateTemplateFromSecretItems, typing.Dict[builtins.str, typing.Any]]],
    name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9339fc9558b78011b1c6592c9f29be59728aad524684c223264d0508baaf19cd(
    *,
    key: builtins.str,
    template_as: typing.Optional[PushSecretSpecTemplateTemplateFromSecretItemsTemplateAs] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__180aec373b8c9c56e68a264b2b4b4d292b94771886f0aa691cf5bb6dbec97d6b(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[SecretStoreSpec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d1dab5bf5499b6000b83acce303ccadfb92208c478648fa8e4071edb8459ed03(
    *,
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[SecretStoreSpec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba085ab3c8441d364a5007e3094da84533695a382d5308b8e6f1b321858ef625(
    *,
    provider: typing.Union[SecretStoreSpecProvider, typing.Dict[builtins.str, typing.Any]],
    controller: typing.Optional[builtins.str] = None,
    retry_settings: typing.Optional[typing.Union[SecretStoreSpecRetrySettings, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c530965dc9a8ce9c6b19c8fa2f1a1209e5d3f087076176d43c9a82a73ad3e971(
    *,
    akeyless: typing.Optional[typing.Union[SecretStoreSpecProviderAkeyless, typing.Dict[builtins.str, typing.Any]]] = None,
    alibaba: typing.Optional[typing.Union[SecretStoreSpecProviderAlibaba, typing.Dict[builtins.str, typing.Any]]] = None,
    aws: typing.Optional[typing.Union[SecretStoreSpecProviderAws, typing.Dict[builtins.str, typing.Any]]] = None,
    azurekv: typing.Optional[typing.Union[SecretStoreSpecProviderAzurekv, typing.Dict[builtins.str, typing.Any]]] = None,
    fake: typing.Optional[typing.Union[SecretStoreSpecProviderFake, typing.Dict[builtins.str, typing.Any]]] = None,
    gcpsm: typing.Optional[typing.Union[SecretStoreSpecProviderGcpsm, typing.Dict[builtins.str, typing.Any]]] = None,
    gitlab: typing.Optional[typing.Union[SecretStoreSpecProviderGitlab, typing.Dict[builtins.str, typing.Any]]] = None,
    ibm: typing.Optional[typing.Union[SecretStoreSpecProviderIbm, typing.Dict[builtins.str, typing.Any]]] = None,
    kubernetes: typing.Optional[typing.Union[SecretStoreSpecProviderKubernetes, typing.Dict[builtins.str, typing.Any]]] = None,
    oracle: typing.Optional[typing.Union[SecretStoreSpecProviderOracle, typing.Dict[builtins.str, typing.Any]]] = None,
    passworddepot: typing.Optional[typing.Union[SecretStoreSpecProviderPassworddepot, typing.Dict[builtins.str, typing.Any]]] = None,
    vault: typing.Optional[typing.Union[SecretStoreSpecProviderVault, typing.Dict[builtins.str, typing.Any]]] = None,
    webhook: typing.Optional[typing.Union[SecretStoreSpecProviderWebhook, typing.Dict[builtins.str, typing.Any]]] = None,
    yandexlockbox: typing.Optional[typing.Union[SecretStoreSpecProviderYandexlockbox, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f597bf285afb5c633e38c431ce82655d4616622b525a2d703b9381af3a1804f2(
    *,
    akeyless_gw_api_url: builtins.str,
    auth_secret_ref: typing.Union[SecretStoreSpecProviderAkeylessAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[SecretStoreSpecProviderAkeylessCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cda0f12fb61f2949b2c77d5bb0d1e8a9b9b4301454fc1cffb9952a3b1658e2cc(
    *,
    kubernetes_auth: typing.Optional[typing.Union[SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae1d5d2c1b8d1b1723c903970ab7cdf664c090a69850bbe33bba4d43dc332342(
    *,
    access_id: builtins.str,
    k8_s_conf_name: builtins.str,
    secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account_ref: typing.Optional[typing.Union[SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e370d9d39bba6f7ee010e33d276f110d5075548ecb7b73f373d703f886030b6c(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35cb94b11cba70c093368a79eb257455da6fabf4fac8ef68d4d39b90bf654dee(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f212895f3238ae558cc70d86c5e96033e438ae08bbac34bb207c998d69db8b4a(
    *,
    access_id: typing.Optional[typing.Union[SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId, typing.Dict[builtins.str, typing.Any]]] = None,
    access_type: typing.Optional[typing.Union[SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType, typing.Dict[builtins.str, typing.Any]]] = None,
    access_type_param: typing.Optional[typing.Union[SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e9bc19061bf794b228ae3c85bd2c8a539641c474838c3d24b0534ac2df4a3000(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64d37657fe77dbb1beb16d7928cf21adb979d050e6ff461f18aed915d564ebd6(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a8a8e97d38f881fa234c143b578f9406cde35bb5cb65d61338b15321de80fc9e(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f9c3b2ffab421d502bfac8a63fe44a7a580876ac897a20ca7ef6da1d7ac1475(
    *,
    name: builtins.str,
    type: SecretStoreSpecProviderAkeylessCaProviderType,
    key: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__160555d984538fdfb12b506e87bb6765d149005405f5ae079b3691db6a1d770f(
    *,
    auth: typing.Union[SecretStoreSpecProviderAlibabaAuth, typing.Dict[builtins.str, typing.Any]],
    region_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d8b50e50e137fe4e3f84cfad896da01555d6ac69b57ae5d2e585611bb05e278(
    *,
    rrsa: typing.Optional[typing.Union[SecretStoreSpecProviderAlibabaAuthRrsa, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderAlibabaAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__22fd549ae04f8c34cf4357cee9af0ba1a090b8e6889bbb1347558106e5e66c4f(
    *,
    oidc_provider_arn: builtins.str,
    oidc_token_file_path: builtins.str,
    role_arn: builtins.str,
    session_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__83b732209a24571a7a96042e186e91398c6b74cf7cb865114ea675a90ddfc6e2(
    *,
    access_key_id_secret_ref: typing.Union[SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef, typing.Dict[builtins.str, typing.Any]],
    access_key_secret_secret_ref: typing.Union[SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c21bb376b2e3a0198bfcc4ef9da1f454aec69fed4187ddac868a437f5508e1de(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__26d4e7fa82cee06a66db9f84afb99426b45555f9719c95d7984dc5ae97cec7b4(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b934c6cb3d89ed6210132277f1834ba27f8d6f93e4b788d15911d29aeb2a073b(
    *,
    region: builtins.str,
    service: SecretStoreSpecProviderAwsService,
    auth: typing.Optional[typing.Union[SecretStoreSpecProviderAwsAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    role: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__95a0f277ee0cad3e87fc8f88b3beed52a176e997459eb96b21bfc2cd7e6867ce(
    *,
    jwt: typing.Optional[typing.Union[SecretStoreSpecProviderAwsAuthJwt, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderAwsAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a2de8e353bd8a9c6b2b307f5edcfd83259dd689ddb1c7bcd7cba6aebd896d14(
    *,
    service_account_ref: typing.Optional[typing.Union[SecretStoreSpecProviderAwsAuthJwtServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee83739484981a1313ee3e396d008fd0daa33cea2f3bd4c940e1bdf71a18c74a(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70319a335a332153f12e762b41f5b67aee107bc3136ea70ae53f2a2c716a612a(
    *,
    access_key_id_secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_access_key_secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6cd067b142a207713dbe0c26baf3421dbaec7cf34b10e08c3a3958201b4d09fb(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0cbfd65dc9abbf06dee97c10e01c18ce7e875a3784134a02e09c54fe3a7fa425(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3fff1dbb3fb26f345ccf9d164d11d27cdf0bf449ee80995bab7f58ed4e6cb4bf(
    *,
    vault_url: builtins.str,
    auth_secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderAzurekvAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    auth_type: typing.Optional[SecretStoreSpecProviderAzurekvAuthType] = None,
    identity_id: typing.Optional[builtins.str] = None,
    service_account_ref: typing.Optional[typing.Union[SecretStoreSpecProviderAzurekvServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
    tenant_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__218003f6825cc8cc0f958bebabc2f3bdbc7a157e9b92d6f96a4ff08a85a92c40(
    *,
    client_id: typing.Optional[typing.Union[SecretStoreSpecProviderAzurekvAuthSecretRefClientId, typing.Dict[builtins.str, typing.Any]]] = None,
    client_secret: typing.Optional[typing.Union[SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e73937a53a8dc05dc2cb3c6f7e3d8c47478e39bae10ddb5f9395a603af3ed23b(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__94e37ecd5e686fb55810fc919ea1112f411c31d0570fa8910d7e09c861c65366(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6270c5495b069a85f3a72915c6c9d3b066899e220bc6fe5e733e75e8528cd46c(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee8ed03db2e828edd909617b817e612179bd4710b9592d45bedc827e7382a817(
    *,
    data: typing.Sequence[typing.Union[SecretStoreSpecProviderFakeData, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9ee3f4b0c98c7c6c6914d11356c215cf3cf27d54394699eb8536a18709255bde(
    *,
    key: builtins.str,
    value: typing.Optional[builtins.str] = None,
    value_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__433356edd23ff339815e78dd403eb845c5557e0e984de228fc0019869438b798(
    *,
    auth: typing.Optional[typing.Union[SecretStoreSpecProviderGcpsmAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    project_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c3dac985af09163062ee0f100a6f27f060ab84a70f92e464b0e33f194f9d2144(
    *,
    secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderGcpsmAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    workload_identity: typing.Optional[typing.Union[SecretStoreSpecProviderGcpsmAuthWorkloadIdentity, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3ca5c2e53d8308a5605105725f2c5e7bdd938b3d8ecb9bea29c97128ee49603c(
    *,
    secret_access_key_secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d6e8ae2d693f0cb3bb2f015f58e3bdbb1cf79d29d3c7d7a1da2a8f171c0b9b0d(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__545f2582e9eda3209742adff37223ac38c989705d97ddaaaf2d68951ec464e1b(
    *,
    cluster_location: builtins.str,
    cluster_name: builtins.str,
    service_account_ref: typing.Union[SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef, typing.Dict[builtins.str, typing.Any]],
    cluster_project_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__00880ada914c2988e4f81a2bbf81f548e12d991c753f3632924ed040061739f9(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__74a9704961b5ebc67a85b13e3ea0b0eecabb2dbda2aee0064fc2ce88d60d1a03(
    *,
    auth: typing.Union[SecretStoreSpecProviderGitlabAuth, typing.Dict[builtins.str, typing.Any]],
    project_id: typing.Optional[builtins.str] = None,
    url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__46cdf91513510c8d21322132a5945d246a0875325bc127c14fdce554439269e1(
    *,
    secret_ref: typing.Union[SecretStoreSpecProviderGitlabAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d22720edc8e41b53bce4c708816fbc06868a093474e54079ed99d225ce461ee(
    *,
    access_token: typing.Optional[typing.Union[SecretStoreSpecProviderGitlabAuthSecretRefAccessToken, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__09362b98cec758e02e93e69b896f7fb16827ce7a4e50ce19232e7d22f62986e3(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__087ffef410337619c50c121e7ef3359e554a57b9a10ce1edf8770b3d81e0ed8e(
    *,
    auth: typing.Union[SecretStoreSpecProviderIbmAuth, typing.Dict[builtins.str, typing.Any]],
    service_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f61c15804c1ea14aba8f3312c92149924d5fc9171c095620ebd5ce368db03750(
    *,
    secret_ref: typing.Union[SecretStoreSpecProviderIbmAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__07e5284d9a003aeaf572246b0e4192e0b1555336a7526ede354d24b2bfa9117d(
    *,
    secret_api_key_secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af92c8b92be448c0919d7ddf59d73c1f0547837b33364f979a4c39d387ae914d(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__904b128b7718fcd2bf2de42ebd0e146d997e1d49742e3ca3719f98eb5ebb46c7(
    *,
    auth: typing.Union[SecretStoreSpecProviderKubernetesAuth, typing.Dict[builtins.str, typing.Any]],
    remote_namespace: typing.Optional[builtins.str] = None,
    server: typing.Optional[typing.Union[SecretStoreSpecProviderKubernetesServer, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__151388d9b4c0b03790206cc929e9596ecfff49de852b599072600264a970c257(
    *,
    cert: typing.Optional[typing.Union[SecretStoreSpecProviderKubernetesAuthCert, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account: typing.Optional[typing.Union[SecretStoreSpecProviderKubernetesAuthServiceAccount, typing.Dict[builtins.str, typing.Any]]] = None,
    token: typing.Optional[typing.Union[SecretStoreSpecProviderKubernetesAuthToken, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a96c6e462ac166552fd43d6e853ebe6677ad7313751774413548c4dc9d9cbd6d(
    *,
    client_cert: typing.Optional[typing.Union[SecretStoreSpecProviderKubernetesAuthCertClientCert, typing.Dict[builtins.str, typing.Any]]] = None,
    client_key: typing.Optional[typing.Union[SecretStoreSpecProviderKubernetesAuthCertClientKey, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f622c6fa4b3f98c8c90256538cfe1195389eea246105b866e4f8226a3e11a92(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ee6e0f3141539f98753d7f8c7f84109da05ee28cbb2496c62158aa37893c4e1f(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4a38f6830f593f71ee328bf0bb7a2d5348dbd4c5a2a2c8ccab3acbabf77e63fc(
    *,
    service_account: typing.Optional[typing.Union[SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__586cee09f8cca7480473d65c3cc68fe9848fa4209f08b883dea677a950b66013(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1581d621227fc42b2bc6fab0466a744ec14017ab25b27c4f605a3d67acfbe832(
    *,
    bearer_token: typing.Optional[typing.Union[SecretStoreSpecProviderKubernetesAuthTokenBearerToken, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__341d7ee7c9f1813146f595b6ac86827f52e296fbd90e305fbe30e75e6d1d7f0c(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__49350e64932573067989f27f2c978c32a0b68db7780223b97496498ba0769b76(
    *,
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[SecretStoreSpecProviderKubernetesServerCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
    url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__363e9db3b763eedad22dc94f5b2adaec3fea7bb6f5e0ffec6fb69f3806f91fe2(
    *,
    name: builtins.str,
    type: SecretStoreSpecProviderKubernetesServerCaProviderType,
    key: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c20124e1b995d76a5c23860f9ecff1ebac42889eac56116daf01652dc9c1605(
    *,
    region: builtins.str,
    vault: builtins.str,
    auth: typing.Optional[typing.Union[SecretStoreSpecProviderOracleAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    compartment: typing.Optional[builtins.str] = None,
    encryption_key: typing.Optional[builtins.str] = None,
    principal_type: typing.Optional[SecretStoreSpecProviderOraclePrincipalType] = None,
    service_account_ref: typing.Optional[typing.Union[SecretStoreSpecProviderOracleServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8b0d6d1c44297738b31436d4946a4a8ce29246ad70f9d793df2188ecdc9b9017(
    *,
    secret_ref: typing.Union[SecretStoreSpecProviderOracleAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
    tenancy: builtins.str,
    user: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb3832cb9223d922c95e110bd9960a050b0d42eb510f564caa0903e89a57f31e(
    *,
    fingerprint: typing.Union[SecretStoreSpecProviderOracleAuthSecretRefFingerprint, typing.Dict[builtins.str, typing.Any]],
    privatekey: typing.Union[SecretStoreSpecProviderOracleAuthSecretRefPrivatekey, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a8123501f8e589da765eda43eddefc179135d62dafdff666b2dc162230854b9(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a26c7af5eb3d372a1a790a6143a7ae00bd502b4516c33828cd4f888eff60809f(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__97202d07f8a20c377da4a4404da5930f6c1182c8d25b0837a4ffd53826a2bd5c(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9210cc06755b6f79ef88436221883e23a6bc7877dd0f395c4cd16ac6a07cf1b7(
    *,
    auth: typing.Union[SecretStoreSpecProviderPassworddepotAuth, typing.Dict[builtins.str, typing.Any]],
    database: builtins.str,
    host: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__feb83c7479202ef875edec190269329957bcb4a5f12a7ddb3764ed63f3198eae(
    *,
    secret_ref: typing.Union[SecretStoreSpecProviderPassworddepotAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__385e5404d7188efbe5c105cd17b7472fdbe052f3dbb8ac60cc6cffbd88bd05a0(
    *,
    credentials: typing.Optional[typing.Union[SecretStoreSpecProviderPassworddepotAuthSecretRefCredentials, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__959a3bfa5af19658f93dc84d289d96c810eeb3219467e12a36491d3bcf6bc0d1(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4ae354c0bc0f63e88460e1b51ccf0b056861e4af5089834a48e7ffbaa7318995(
    *,
    auth: typing.Union[SecretStoreSpecProviderVaultAuth, typing.Dict[builtins.str, typing.Any]],
    server: builtins.str,
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[SecretStoreSpecProviderVaultCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
    forward_inconsistent: typing.Optional[builtins.bool] = None,
    namespace: typing.Optional[builtins.str] = None,
    path: typing.Optional[builtins.str] = None,
    read_your_writes: typing.Optional[builtins.bool] = None,
    version: typing.Optional[SecretStoreSpecProviderVaultVersion] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a906da5a2a53f521d3aa7cb2ceff2f87f28a7ec0f7ac71cdcd6107bccdff2daa(
    *,
    app_role: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthAppRole, typing.Dict[builtins.str, typing.Any]]] = None,
    cert: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthCert, typing.Dict[builtins.str, typing.Any]]] = None,
    jwt: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthJwt, typing.Dict[builtins.str, typing.Any]]] = None,
    kubernetes: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthKubernetes, typing.Dict[builtins.str, typing.Any]]] = None,
    ldap: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthLdap, typing.Dict[builtins.str, typing.Any]]] = None,
    token_secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthTokenSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__91ec9daf30d4aa20417e9735e38cf1e7dc0f2bba40719ebfe97b72e5371bbd5b(
    *,
    path: builtins.str,
    role_id: builtins.str,
    secret_ref: typing.Union[SecretStoreSpecProviderVaultAuthAppRoleSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3c921248240c9e8f809f8693886a7967a63ac9e70ce931585f66f97fd47efbc4(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__926989828203f27389b7a872e486f9f7c761453b969101d248844147a4d6af7e(
    *,
    client_cert: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthCertClientCert, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthCertSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de593eb1b62d872aa65a4baa74a37a4975d8e4386948886c952b85872f5397de(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8f69eeab4ca0ffa1bd204d31e5ed09f8168d70e5803d92d9f822a900f1b42155(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2641227e47ad754e8439010181c6cc78330135cee499741a0a3871027938bf40(
    *,
    path: builtins.str,
    kubernetes_service_account_token: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken, typing.Dict[builtins.str, typing.Any]]] = None,
    role: typing.Optional[builtins.str] = None,
    secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthJwtSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__746f956d1234f789608405b291bad7714e1859d2bf8667f7c8135f4799fd156b(
    *,
    service_account_ref: typing.Union[SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef, typing.Dict[builtins.str, typing.Any]],
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    expiration_seconds: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe5149b96feef31ec30a430a00c72547d518e3e2b7d981a8647dc81c003207bd(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d4bd1e46d55696da0dd1d35870cc436c6ed2e3062fd0765d4f20fe3651d10c5(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ca939cc68749570d2ef4889f201ab3b3fd38c8f6dcd83bf12fe08aaab436b8fb(
    *,
    mount_path: builtins.str,
    role: builtins.str,
    secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthKubernetesSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account_ref: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5576d3db2bcf7331d72c3646834111e13f1a9b0768bd6843887a4bfb2a37c2b7(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1902bb9d0d46785a88bbf171a4e8d3512c9b72ff2e89a4e8d8cdaf67c675514c(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__54daf7044cfb5a8fba7a5cc3a68df9e10b72c56cc5b8c6bb1588d528e2890dc1(
    *,
    path: builtins.str,
    username: builtins.str,
    secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthLdapSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3781d82032a4838e8854e5d94439e01ad2c1ec8dbaf02e83334a9a1204deb736(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7e96f47c442da148ae8f99573a79d554a4379a383748a113ceb3bd9974830296(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a7694f04b7ccf70eddb5e62a956b1c20f67af5fdd544be8ab6f057460eaf8e64(
    *,
    name: builtins.str,
    type: SecretStoreSpecProviderVaultCaProviderType,
    key: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d1fafecaff262b0c905232c30dcb29512b172ba2eadfc2e0fbd39779df81871c(
    *,
    result: typing.Union[SecretStoreSpecProviderWebhookResult, typing.Dict[builtins.str, typing.Any]],
    url: builtins.str,
    body: typing.Optional[builtins.str] = None,
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[SecretStoreSpecProviderWebhookCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
    headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    method: typing.Optional[builtins.str] = None,
    secrets: typing.Optional[typing.Sequence[typing.Union[SecretStoreSpecProviderWebhookSecrets, typing.Dict[builtins.str, typing.Any]]]] = None,
    timeout: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f39587f1eb17b18ee2e637058f85bf78cfe6380cb981390c8095b0f017c4e18e(
    *,
    name: builtins.str,
    type: SecretStoreSpecProviderWebhookCaProviderType,
    key: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cafbe3e08c7de16cc8da33377789a932dd134a8b6b6e0f97dd20f9ad9855b525(
    *,
    json_path: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e93ce843f65bae96c79261461e439cfe309d889743e564fb465715ac0c23a02(
    *,
    name: builtins.str,
    secret_ref: typing.Union[SecretStoreSpecProviderWebhookSecretsSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea63366696c859af5d2a5362752db30665aea1a23df692b606dd25c3c877c26f(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__96053fb82850a86b14c63904db9ada416f60bfc3669c2d8475be1a94daf8b13d(
    *,
    auth: typing.Union[SecretStoreSpecProviderYandexlockboxAuth, typing.Dict[builtins.str, typing.Any]],
    api_endpoint: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[SecretStoreSpecProviderYandexlockboxCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__63938f9991ccca07eaa1b529f96cc1fd913594543c10333f42261d9982731728(
    *,
    authorized_key_secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a751dc60535eb863895eb7c23eb9dcea4fb168088a67affab4456e33bfde401c(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d9055787165578835dde87a2c4abe39336ef0799f4ac41721d94cbc23f3325e(
    *,
    cert_secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__27b77f15061632174e6c2312f622d30ab57aa2a455aca37f308b86a7d9850d4e(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab1b2959f3a84685392b7376862f54f9c2af1a3c8607a0325c24aa2e5739ede8(
    *,
    max_retries: typing.Optional[jsii.Number] = None,
    retry_interval: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7f3552b2035d2dc266ffbe6203fea53942c8094aacfba3f6974b214efef55f98(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[SecretStoreV1Beta1Spec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dfa8dbd2d0c2a721eab5f6a87539e2f56289de2b823686d13df4bbaf39467296(
    *,
    metadata: typing.Optional[typing.Union[_cdk8s_d3d9af27.ApiObjectMetadata, typing.Dict[builtins.str, typing.Any]]] = None,
    spec: typing.Optional[typing.Union[SecretStoreV1Beta1Spec, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e887ced4c6bd3b61a242644b3eeab6a61e1a3f1981cea3e885f9d1548225d729(
    *,
    provider: typing.Union[SecretStoreV1Beta1SpecProvider, typing.Dict[builtins.str, typing.Any]],
    conditions: typing.Optional[typing.Sequence[typing.Union[SecretStoreV1Beta1SpecConditions, typing.Dict[builtins.str, typing.Any]]]] = None,
    controller: typing.Optional[builtins.str] = None,
    refresh_interval: typing.Optional[jsii.Number] = None,
    retry_settings: typing.Optional[typing.Union[SecretStoreV1Beta1SpecRetrySettings, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__781f0a3fce525ee313d188cf41c0cb440a85aa5de7791f933d055b4023d7ff2e(
    *,
    namespace_regexes: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace_selector: typing.Optional[typing.Union[SecretStoreV1Beta1SpecConditionsNamespaceSelector, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2044c5fddb5d84a07100f5e6505b6d7c7423848a6be1069e04b243a1af9d8134(
    *,
    match_expressions: typing.Optional[typing.Sequence[typing.Union[SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions, typing.Dict[builtins.str, typing.Any]]]] = None,
    match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__39b5ca4819b9b954dfdfd05453fcef64f9e52a3792efaa16ae3fa7fb24d8740a(
    *,
    key: builtins.str,
    operator: builtins.str,
    values: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea7dd9e387afcb814f7b73b94bda5cdd7dfdba58759fb42c1d35129125adb364(
    *,
    akeyless: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAkeyless, typing.Dict[builtins.str, typing.Any]]] = None,
    alibaba: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAlibaba, typing.Dict[builtins.str, typing.Any]]] = None,
    aws: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAws, typing.Dict[builtins.str, typing.Any]]] = None,
    azurekv: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAzurekv, typing.Dict[builtins.str, typing.Any]]] = None,
    beyondtrust: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderBeyondtrust, typing.Dict[builtins.str, typing.Any]]] = None,
    bitwardensecretsmanager: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderBitwardensecretsmanager, typing.Dict[builtins.str, typing.Any]]] = None,
    chef: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderChef, typing.Dict[builtins.str, typing.Any]]] = None,
    conjur: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderConjur, typing.Dict[builtins.str, typing.Any]]] = None,
    delinea: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderDelinea, typing.Dict[builtins.str, typing.Any]]] = None,
    device42: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderDevice42, typing.Dict[builtins.str, typing.Any]]] = None,
    doppler: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderDoppler, typing.Dict[builtins.str, typing.Any]]] = None,
    fake: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderFake, typing.Dict[builtins.str, typing.Any]]] = None,
    fortanix: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderFortanix, typing.Dict[builtins.str, typing.Any]]] = None,
    gcpsm: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderGcpsm, typing.Dict[builtins.str, typing.Any]]] = None,
    gitlab: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderGitlab, typing.Dict[builtins.str, typing.Any]]] = None,
    ibm: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderIbm, typing.Dict[builtins.str, typing.Any]]] = None,
    infisical: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderInfisical, typing.Dict[builtins.str, typing.Any]]] = None,
    keepersecurity: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKeepersecurity, typing.Dict[builtins.str, typing.Any]]] = None,
    kubernetes: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKubernetes, typing.Dict[builtins.str, typing.Any]]] = None,
    onboardbase: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderOnboardbase, typing.Dict[builtins.str, typing.Any]]] = None,
    onepassword: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderOnepassword, typing.Dict[builtins.str, typing.Any]]] = None,
    oracle: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderOracle, typing.Dict[builtins.str, typing.Any]]] = None,
    passbolt: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderPassbolt, typing.Dict[builtins.str, typing.Any]]] = None,
    passworddepot: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderPassworddepot, typing.Dict[builtins.str, typing.Any]]] = None,
    previder: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderPrevider, typing.Dict[builtins.str, typing.Any]]] = None,
    pulumi: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderPulumi, typing.Dict[builtins.str, typing.Any]]] = None,
    scaleway: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderScaleway, typing.Dict[builtins.str, typing.Any]]] = None,
    secretserver: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderSecretserver, typing.Dict[builtins.str, typing.Any]]] = None,
    senhasegura: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderSenhasegura, typing.Dict[builtins.str, typing.Any]]] = None,
    vault: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVault, typing.Dict[builtins.str, typing.Any]]] = None,
    webhook: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderWebhook, typing.Dict[builtins.str, typing.Any]]] = None,
    yandexcertificatemanager: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderYandexcertificatemanager, typing.Dict[builtins.str, typing.Any]]] = None,
    yandexlockbox: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderYandexlockbox, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bed89082ee43718091d9f91d5d7aa30aeb89d80fd22689743ea9be9a5910bf5b(
    *,
    akeyless_gw_api_url: builtins.str,
    auth_secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAkeylessCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__74121be233be822179e1fffc40d7f70e1bf5baac40b64c026d41ae76c44bbc9e(
    *,
    kubernetes_auth: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__44b30cb7361730d5728dbfc7861be5dacffb630732bbecffb28ad09986b1158d(
    *,
    access_id: builtins.str,
    k8_s_conf_name: builtins.str,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2a4c510b386734e858a3a16c1320574f58f9264bdd1977dead494c9ff909e85c(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a2972b9bdc93422fb8750e2e18bacb0b5b9bcf80476ae1c9bee4a833c9e5ab9a(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d95ece84921a933e967386c74f586317717bf443bedaecf37737f310f3e2270d(
    *,
    access_id: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId, typing.Dict[builtins.str, typing.Any]]] = None,
    access_type: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType, typing.Dict[builtins.str, typing.Any]]] = None,
    access_type_param: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f495e81081fb2ba9d62c740c6018c154847feb6578b054444bda7cf8c2e72e8(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__613c40b00b05241cf57899cf71d7762d8469acdd57708faaf8c9301e21d587ad(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__58018932fd4ec7fd73bc3ed194e6908b462e22712506f25eca23a0d659847886(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b51d00c03b1bba53f1af93434b0eecfd678db38e463beab710d17132b62f9ef8(
    *,
    name: builtins.str,
    type: SecretStoreV1Beta1SpecProviderAkeylessCaProviderType,
    key: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f96a153d300ff01c20e7fb7ab637a3c4d57d1fd8e61d2e8bb6d65f9f38d1896e(
    *,
    auth: typing.Union[SecretStoreV1Beta1SpecProviderAlibabaAuth, typing.Dict[builtins.str, typing.Any]],
    region_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2271b3fcb686cc99d754c4b2b01c0ce3516bdcbb9b0f6136412860adeae20e97(
    *,
    rrsa: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAlibabaAuthRrsa, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e984beed549840ae3cafd984c234e6d2130919e34269fd21cecd0403e2d05419(
    *,
    oidc_provider_arn: builtins.str,
    oidc_token_file_path: builtins.str,
    role_arn: builtins.str,
    session_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0187fad4e721a6222f70c1884497a2f1eddd6e74a1337f9aaaa4c5f758a1ac58(
    *,
    access_key_id_secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef, typing.Dict[builtins.str, typing.Any]],
    access_key_secret_secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6fa998fa7196a6f87d3e357648846c1a7d7b95b2e6022399c6040182086165b1(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e42973e9b7595404724b2fe7f3f242219216c842943642924d043a0da2113ce3(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__62290ee01214cf301e7987fdab68bcb3b685aa43bf724e7dc735e5ac63111a0a(
    *,
    region: builtins.str,
    service: SecretStoreV1Beta1SpecProviderAwsService,
    additional_roles: typing.Optional[typing.Sequence[builtins.str]] = None,
    auth: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAwsAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    external_id: typing.Optional[builtins.str] = None,
    prefix: typing.Optional[builtins.str] = None,
    role: typing.Optional[builtins.str] = None,
    secrets_manager: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAwsSecretsManager, typing.Dict[builtins.str, typing.Any]]] = None,
    session_tags: typing.Optional[typing.Sequence[typing.Union[SecretStoreV1Beta1SpecProviderAwsSessionTags, typing.Dict[builtins.str, typing.Any]]]] = None,
    transitive_tag_keys: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__00dddb0c8e37de3d9e897dfc11a386c82ccfcf7edf6a64799db1526ec6a85166(
    *,
    jwt: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAwsAuthJwt, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAwsAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c8774a4feb5c9e404a52e2e99d1f871029c8430064a6fb0c7ca04e1c1c826f84(
    *,
    service_account_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2394d475836b18dbaa6f40ecb6933020b781a95f1720db6e096a3cc03be94805(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b57dc85c1f30d4578476b7d7451b50a139cc6f25cb7fca4b2c86fa4f34d3b8e(
    *,
    access_key_id_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_access_key_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    session_token_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c1d3d92125450f26fe4347f50a5577043aaca83943223aa5b36e49c2ba807b9(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb31e0cbd82e41937767722aae600636c68f79c57d03b3180dfc1c5e96f96b09(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de5db4fa3573a19186756285ed3f23e894d62d5239c363795d0970988983b329(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fcf0c03abb9abce00a1111221163bdab1cb870b96e6e63cbaef6d4817a797366(
    *,
    force_delete_without_recovery: typing.Optional[builtins.bool] = None,
    recovery_window_in_days: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bec003d532442fc01806938cd60e826bbe59eaf5f2736326a27ddea7d79b6d19(
    *,
    key: builtins.str,
    value: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1102c98a03f32b51f230ee6adf278c19d54673b52c8312fe8182f941b2335ddc(
    *,
    vault_url: builtins.str,
    auth_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    auth_type: typing.Optional[SecretStoreV1Beta1SpecProviderAzurekvAuthType] = None,
    environment_type: typing.Optional[SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType] = None,
    identity_id: typing.Optional[builtins.str] = None,
    service_account_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
    tenant_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a4938b5255f3aa984783f676bc89cdd2bd990505a85f0fd72b37dbaa5f7b4ef(
    *,
    client_certificate: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientCertificate, typing.Dict[builtins.str, typing.Any]]] = None,
    client_id: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId, typing.Dict[builtins.str, typing.Any]]] = None,
    client_secret: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret, typing.Dict[builtins.str, typing.Any]]] = None,
    tenant_id: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefTenantId, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__831c428d32e1809fa8755d7275384249478a2b1b2977461d205882f576150ee7(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1ed9139f1201d752d0544dffe465265042c7b8a6bad36a96c27ac55fb5b4efad(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b5781b1e7d687e6973d4e5221625c7edbeae341526205210eb53c47810c7b1c3(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1681d1ac099829c7e3d7ddc9d8d2171f0c00eac05620d619ba73a164a4ac8b46(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c3701d52a6b4ef32f42230c1c20ac928c8800856543ae008bb3eff3348b988ed(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__720e80a24c1c4b06f96e3eceecdbda8f48e6b69d7995af64a1607377b610b318(
    *,
    auth: typing.Union[SecretStoreV1Beta1SpecProviderBeyondtrustAuth, typing.Dict[builtins.str, typing.Any]],
    server: typing.Union[SecretStoreV1Beta1SpecProviderBeyondtrustServer, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__54972e5e94f17e926be68cda60347f539d02cd6bfafd29d3f2b9919cd7ebc646(
    *,
    api_key: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKey, typing.Dict[builtins.str, typing.Any]]] = None,
    certificate: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificate, typing.Dict[builtins.str, typing.Any]]] = None,
    certificate_key: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKey, typing.Dict[builtins.str, typing.Any]]] = None,
    client_id: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientId, typing.Dict[builtins.str, typing.Any]]] = None,
    client_secret: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecret, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__892b420a6108fe141d09afb8dc5eda04f14e16e0601e0be9a36e6e7dac8b71a9(
    *,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderBeyondtrustAuthApiKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bc626c3c9611371e85ee1efb691d06ee3c414f83f927db995073dd4b2f02e95c(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__da89ad96825b8c076b6ca55337238e7d2f2b5f4496f168b3b2b9d9231065598b(
    *,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e926aea2da7e03a7073e04a82eacc1a75a84ffc3253b7372188ee5057b1e82b(
    *,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderBeyondtrustAuthCertificateKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c787a514860695abc85dae452bb94e1bddd190542f15ae82b8e90d352ce913c(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a3f8310fb041f02baaaf7051f4890ac89513a7a899d2affb277092e38a70d96a(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73df30abc817c56768cbeca733152919a63e432b1e1cf53632439202c3a036e1(
    *,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientIdSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a30c87e91749081367319be2b68ed2d5a9ec0cbe5b725f91272c01b9d8adaa3(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__56c6fef00a69fbe92be8a6b4e831ce232fe37bdeebf76635ac8fe5a3019544a6(
    *,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderBeyondtrustAuthClientSecretSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1d3abe33c96e528155c4d190f7df9607bc55d3cf7f3ac193d91249fdcdea7160(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e3a45e59ccaf8d835902daa56d4287a9108ffbc3c080277441ed37dbf953131a(
    *,
    api_url: builtins.str,
    verify_ca: builtins.bool,
    client_time_out_seconds: typing.Optional[jsii.Number] = None,
    retrieval_type: typing.Optional[builtins.str] = None,
    separator: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__55277eb66e9fbfb21f66e7e9d1697a8d5fa1ee87e8b38cd3da7b0b2c50cacff1(
    *,
    auth: typing.Union[SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuth, typing.Dict[builtins.str, typing.Any]],
    organization_id: builtins.str,
    project_id: builtins.str,
    api_url: typing.Optional[builtins.str] = None,
    bitwarden_server_sdkurl: typing.Optional[builtins.str] = None,
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
    identity_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5d367e7ff8ce82dd30e23386d9a4032977fef60e4cf836b6ece1f98cde8e7ecc(
    *,
    secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9dbb7d348c57c4813bcf9e08f0dc03c486ea20f5c307999e5c0b505865bdfc07(
    *,
    credentials: typing.Union[SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerAuthSecretRefCredentials, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8d34905d4d9793676dd4352f32573dd004d72f7f3f4a4af70ce5a5447f5dba74(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__69bf9b74cef9d53246a6914325039799a3c204d804c76ce54770642198971103(
    *,
    name: builtins.str,
    type: SecretStoreV1Beta1SpecProviderBitwardensecretsmanagerCaProviderType,
    key: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f64e0832ce2e5bdcc4b76418c1c8f6b250a9915dfc564831df334ef7324e7409(
    *,
    auth: typing.Union[SecretStoreV1Beta1SpecProviderChefAuth, typing.Dict[builtins.str, typing.Any]],
    server_url: builtins.str,
    username: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__841e246e57cfb6bedacfdb7742ddc5fb831a8819df60d0fa000de5a0226dd6af(
    *,
    secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderChefAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ccec2280a7834691b1b1a1e3a425d5af5af629d5c5443ff97529003d2afb968e(
    *,
    private_key_secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderChefAuthSecretRefPrivateKeySecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb2b4c047fa2fef18f7acb531b269edb3f14b2cadd6b0e431ebd04ac42fdc47e(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a6f1ef64695568dabb0aa434d8e5124f9a6fabf324198091c3800f51bf04ab96(
    *,
    auth: typing.Union[SecretStoreV1Beta1SpecProviderConjurAuth, typing.Dict[builtins.str, typing.Any]],
    url: builtins.str,
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderConjurCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1daccbc5c2a79286a9b9e0864bdccf07ed80e3907c3261763ab402ab42a84d3a(
    *,
    apikey: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderConjurAuthApikey, typing.Dict[builtins.str, typing.Any]]] = None,
    jwt: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderConjurAuthJwt, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ed432fad15be4faae5317037009e654643e8972dfd7b6a08ff91c1caa5eae286(
    *,
    account: builtins.str,
    api_key_ref: typing.Union[SecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef, typing.Dict[builtins.str, typing.Any]],
    user_ref: typing.Union[SecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8346134db38193c187441717727361b3370751b8ab05b5053122a1829a038380(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__81b4efd14e2dff860aa5f6097b35553e68b70a5eaf21be9f22fe6a7b09757c8d(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a867ef73ed6ba39fbba7a7f6d600f26748884d8042ede3b1085d3dd5f8eb0de3(
    *,
    account: builtins.str,
    service_id: builtins.str,
    host_id: typing.Optional[builtins.str] = None,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ca4251b9478b27f6c74ac35dcd506c5a62a10be258bda857e096dc3e88fabef3(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d8a90af3fcfda6befe66e319ac7847d46dd60c6a7b559554710a2639a361a52b(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35f27de5668b24c62a9ca0d2d74309a50e26ee7a353e45ab9098d8a0984d75b4(
    *,
    name: builtins.str,
    type: SecretStoreV1Beta1SpecProviderConjurCaProviderType,
    key: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__601761258fb268462c478cfa85b6e67a4cf9bf930641b4e2e00d2d7a3f2cb9f8(
    *,
    client_id: typing.Union[SecretStoreV1Beta1SpecProviderDelineaClientId, typing.Dict[builtins.str, typing.Any]],
    client_secret: typing.Union[SecretStoreV1Beta1SpecProviderDelineaClientSecret, typing.Dict[builtins.str, typing.Any]],
    tenant: builtins.str,
    tld: typing.Optional[builtins.str] = None,
    url_template: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__336dbd3d291848be34ee043e586fa144b2f34f8adaf0e9feca36ceedea1ac75c(
    *,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b3cace1d6453ec18e7ecca7917c2a25e5bc6e37590877b17ee084dd5e2dec18(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9739998751454289fb648dedbf7d2915a9e1f7b24989f27a0cb8ab6c46fca6a5(
    *,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b125fc1f8cb496333ab667c850ba2db5a064f7da877a2e734be47bb04171b269(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bec892a00075ae279bbfe350e8f210e622147988c9d51fc3e4ffaeb67c0371d9(
    *,
    auth: typing.Union[SecretStoreV1Beta1SpecProviderDevice42Auth, typing.Dict[builtins.str, typing.Any]],
    host: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8ae510a8d74c46acc4bb83849b8c49eff4c5c023fc270e6bf3beb8ddc415041b(
    *,
    secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderDevice42AuthSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b0789db669755cbf7c67d3705bf8a107cd61abd3fbc811fcda64ad452cff514(
    *,
    credentials: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderDevice42AuthSecretRefCredentials, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c7d3bf3758c964979e101dcaba1bb98cc90cc0d7665254fd9b3945de7447536c(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b0a6de8fe3255ce5836d963fc77fd83dc33e4967030d8a35f633edcc4974573(
    *,
    auth: typing.Union[SecretStoreV1Beta1SpecProviderDopplerAuth, typing.Dict[builtins.str, typing.Any]],
    config: typing.Optional[builtins.str] = None,
    format: typing.Optional[SecretStoreV1Beta1SpecProviderDopplerFormat] = None,
    name_transformer: typing.Optional[SecretStoreV1Beta1SpecProviderDopplerNameTransformer] = None,
    project: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e8841d8359ddc01188720737ada5a706c1619c22e7425a5d663b94eea33309b7(
    *,
    secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4731b7ff6b5f7e1c67462193a0401491586b1d1d2101fea57353fb824e4ced21(
    *,
    doppler_token: typing.Union[SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a1fea7caeb42148ebb3eb2e91a01eb769cb2308b62b93143a35ea56f351310c4(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d93a6c92c9c0b83f9c3884e6f384592e50aa4a8ce8673c5eb495ba612323373b(
    *,
    data: typing.Sequence[typing.Union[SecretStoreV1Beta1SpecProviderFakeData, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29a0c184f90e7b31b38a333f23beda06732b2fd6367a56e1d22e214b8eebaeac(
    *,
    key: builtins.str,
    value: typing.Optional[builtins.str] = None,
    value_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06565003520ed3b4b182cebc0df0782c7397bedc4434807ad14ffd5aec404b33(
    *,
    api_key: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderFortanixApiKey, typing.Dict[builtins.str, typing.Any]]] = None,
    api_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cd5c80b0001695a1fb0fcff73f4aeb88106fef86a38f6efecd70f8518b4c0535(
    *,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderFortanixApiKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e8e0fb3b561b24e961f7cc53b7d7f52995c9a1587f2622d98c62cbd10481f550(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c3ecb75384dd8f76bb3e29feed63aaf82819c4952cd30b31a059d987820d165a(
    *,
    auth: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderGcpsmAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    location: typing.Optional[builtins.str] = None,
    project_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ece6b6ecf5d7444ab38286c886b12f5ae237b3e61e0410bf7a06e137cc5ddcbf(
    *,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    workload_identity: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c1368bb18127d39725cce7022c44341150fd77fd75a76890278cb64f891d90cc(
    *,
    secret_access_key_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__364aa3a256ffb1db5e8aad80987b84984403cd06f707862457451651798f5d95(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b5ffa9b3599a682d44be37badcece2843f9e11c0c3af162dcd58dd5faa12281(
    *,
    cluster_location: builtins.str,
    cluster_name: builtins.str,
    service_account_ref: typing.Union[SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef, typing.Dict[builtins.str, typing.Any]],
    cluster_project_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c85d822f9260d7b2e71fd3554e55b1fb5aafb3791ffbc13548a56267364e098e(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b398588d0e2703fe1f91c36ee1116bd611797b0d35e42ae69ec6f3a660a899aa(
    *,
    auth: typing.Union[SecretStoreV1Beta1SpecProviderGitlabAuth, typing.Dict[builtins.str, typing.Any]],
    environment: typing.Optional[builtins.str] = None,
    group_i_ds: typing.Optional[typing.Sequence[builtins.str]] = None,
    inherit_from_groups: typing.Optional[builtins.bool] = None,
    project_id: typing.Optional[builtins.str] = None,
    url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__20deece46bd316fa7ee77d2cd3ef1138ae550b6a6852687ee249f45373fb65bb(
    *,
    secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9cc2000edfcefc04ea18587adbfe7cc7cccc9ee68e326e76edb3ac39b2d4e766(
    *,
    access_token: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d5024106fecce7059ce27d090bc0293130bbb172a7cd76a1e71a78bb7c515931(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d0267097db94e6dd73fdfcea08ec320aa5df8c05909723119660daa4697d4e89(
    *,
    auth: typing.Union[SecretStoreV1Beta1SpecProviderIbmAuth, typing.Dict[builtins.str, typing.Any]],
    service_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7442a2e4e22992bf0d9ad03fd141ee4789ea32cf7e9bf2c281bf6c2de12799ff(
    *,
    container_auth: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderIbmAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8eb8570d22a9232e49428aadfeff673e7c1bb95db459a128da09d18dd9a877f4(
    *,
    profile: builtins.str,
    iam_endpoint: typing.Optional[builtins.str] = None,
    token_location: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f9228a280e6a7ce80f5fcf86b911b502c8f53a339a0ca0037fc7b01e92346ab2(
    *,
    secret_api_key_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b80417f3083dcb5866dfa1ab42fde962e8a28bdfaebc05ed9c45e28155f05db3(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5696fe83de35c838526a48deb02994a29a952de6385b449b25917008ffd77663(
    *,
    auth: typing.Union[SecretStoreV1Beta1SpecProviderInfisicalAuth, typing.Dict[builtins.str, typing.Any]],
    secrets_scope: typing.Union[SecretStoreV1Beta1SpecProviderInfisicalSecretsScope, typing.Dict[builtins.str, typing.Any]],
    host_api: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__868ceb988e2e935a9fa34a03db92f4ab714652d3311b8aba10406461aa1046bf(
    *,
    universal_auth_credentials: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentials, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2cf2a05ff999605fe493a7341d0a3844820d163b6009e97b4f72c25265b480cc(
    *,
    client_id: typing.Union[SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientId, typing.Dict[builtins.str, typing.Any]],
    client_secret: typing.Union[SecretStoreV1Beta1SpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cafb1b4ef446e23929708e926c3c8fa1b4e9ac2aefec43ec17f969b7821f5c6a(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ed964da6cd2e6f440e3adc9259840a6c0e3abd7880e1cd086947e3afe6ca563e(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__761099bf5f2bb3b5a6bd0a405b68fbdba0412fe5522d7ebddc1daaed13b2874c(
    *,
    environment_slug: builtins.str,
    project_slug: builtins.str,
    recursive: typing.Optional[builtins.bool] = None,
    secrets_path: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__efc55607e2e04fd40e28fde54ad8ce8275d7b1108f41fce4ccd79d1815a9bef8(
    *,
    auth_ref: typing.Union[SecretStoreV1Beta1SpecProviderKeepersecurityAuthRef, typing.Dict[builtins.str, typing.Any]],
    folder_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8bcdaa1ea712d368e5211f754c07a2a5b0ea64ab766fa4ec6d4b63c9269a5540(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0eb51a2fef268ed31500d17e2a6bb9611a7ee40a9b4d213ac395b958c064a2f0(
    *,
    auth: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKubernetesAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    auth_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKubernetesAuthRef, typing.Dict[builtins.str, typing.Any]]] = None,
    remote_namespace: typing.Optional[builtins.str] = None,
    server: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKubernetesServer, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4febf2b0eb0fdcdfa0b17099ffe8a84a5a1941668925d672dbf362202f1660e3(
    *,
    cert: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKubernetesAuthCert, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount, typing.Dict[builtins.str, typing.Any]]] = None,
    token: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKubernetesAuthToken, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__18a4079b17dfbbd744c6cdfc7ae7b0d97805f749bb4c0b3e9619dea0f53e5c7a(
    *,
    client_cert: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert, typing.Dict[builtins.str, typing.Any]]] = None,
    client_key: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d9b3f78cc3bb7658dd3c35554318220b15eb7c942accae3ec4b352f516ebd14c(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__42f24331268dcb0d9cdbf6ec4b18b536c5d9105df0ca060410bcb16e7844262d(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__51599d235d54542b854c563140b4ee7e3a290daada6b217791ae49f0e2f48a9c(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eacf4713dc2dbb9bc810892d116a1fcbcb9d0e0841869a5d07ada3bc56701208(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bec138ba036b38e5ba6a971a6c04acb29aa345aaef6e195f213ad1536637c5a0(
    *,
    bearer_token: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eb2c93bb0eef9af5c6b7d58045d71fc562b13e87a832f12bc87da48410851e8e(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d679aa7557793ca3a8fd37725eb27302305e012ef0651a9008e422fc4c78bc81(
    *,
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
    url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f682dc01ab3544124912213346c39e299a227713b49003eb2742c133629f431(
    *,
    name: builtins.str,
    type: SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType,
    key: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a5297836f61be88e9ba167fa61d792f192e7ee54541be7598800f46cdf85c06f(
    *,
    api_host: builtins.str,
    auth: typing.Union[SecretStoreV1Beta1SpecProviderOnboardbaseAuth, typing.Dict[builtins.str, typing.Any]],
    environment: builtins.str,
    project: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__27d3d52870731bdad3efa483bda2c12fa98b99d06da2ac3c8d51bb74987d8366(
    *,
    api_key_ref: typing.Union[SecretStoreV1Beta1SpecProviderOnboardbaseAuthApiKeyRef, typing.Dict[builtins.str, typing.Any]],
    passcode_ref: typing.Union[SecretStoreV1Beta1SpecProviderOnboardbaseAuthPasscodeRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e793cc39e597aa506da9da0bca2c01ebb177e9ae284121a87ddb4e8bdb7ad74a(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c1b4261fef432b3a9873355545275d22cda7f776ba4b42b420ca47c56f503270(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f1799d8f5d4e7fd3e38d4ffda5fbe26f701abb1ac72c72e62e17dc32d661c52f(
    *,
    auth: typing.Union[SecretStoreV1Beta1SpecProviderOnepasswordAuth, typing.Dict[builtins.str, typing.Any]],
    connect_host: builtins.str,
    vaults: typing.Mapping[builtins.str, jsii.Number],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c9f3cb1f01e83febb00d40ac37067b4cc2c02b4e11d32c06354ac23c9793b112(
    *,
    secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0e8a9e24241a42ff9102923f86463f8b2434e409b96b1c3372c47f7d6ee914a5(
    *,
    connect_token_secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e920371298eef9ef64fd417d1fe1a190eecd25d510ddfae09033af8d91ea611e(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64a73f7d94141f654d20eea2b114031d06b98e3f17f51f9796818f7873200e73(
    *,
    region: builtins.str,
    vault: builtins.str,
    auth: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderOracleAuth, typing.Dict[builtins.str, typing.Any]]] = None,
    compartment: typing.Optional[builtins.str] = None,
    encryption_key: typing.Optional[builtins.str] = None,
    principal_type: typing.Optional[SecretStoreV1Beta1SpecProviderOraclePrincipalType] = None,
    service_account_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderOracleServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__40b8eeb85088c31aca7e5df4dc593a08848c08806890a3d02fa7948995f3437c(
    *,
    secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderOracleAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
    tenancy: builtins.str,
    user: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__01ef1bc632be3346170362a1c030bf5ed1f64b4233140ff0036f5a882b11c524(
    *,
    fingerprint: typing.Union[SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint, typing.Dict[builtins.str, typing.Any]],
    privatekey: typing.Union[SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e820022cd3ecbb7e3073fe7f41bda9fb729f513cd9da4945a925a300cc26d1b(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d4cbeb2d65fda2f0f86577a2ee9cf1784799a03e0ec4de73ae3d4116a51b7c1(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab989471fa0c25514c062bf2d2b0a040f69c8f8906d13ac7cd449e6d973fcb07(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c1489eb7e9620965a440726c06aec5ce16ef1b5e841250fcc5024c91215ecb5d(
    *,
    auth: typing.Union[SecretStoreV1Beta1SpecProviderPassboltAuth, typing.Dict[builtins.str, typing.Any]],
    host: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__538289df280cd946c84fd37eb4ea94fc8b0ce1695213961d36001d162548db6a(
    *,
    password_secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderPassboltAuthPasswordSecretRef, typing.Dict[builtins.str, typing.Any]],
    private_key_secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderPassboltAuthPrivateKeySecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4bb9db9eee1ce9a5ca112400260bc8086ba70cc39b797ee628675edf22f744fd(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29ab280066a1eb0cb5742d20eccfc087ef8b391f016590bf1f8d8ffe52b75d48(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c0f976ddef5429db57e42aed47827f8bed0917b9cf825b4f4a67d69f3688518a(
    *,
    auth: typing.Union[SecretStoreV1Beta1SpecProviderPassworddepotAuth, typing.Dict[builtins.str, typing.Any]],
    database: builtins.str,
    host: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d705a50aad2a9503d46ad8df7d7b529abbb45897e6b649a2329c4c293aa5fd62(
    *,
    secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0e52c9857e3f7680b291d78b0c4ddc8089923f4b2d668fb96c0e45ae9c6e0b0c(
    *,
    credentials: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderPassworddepotAuthSecretRefCredentials, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0dfaa99e7d51b44c06c1fae991b4fc1c9128eb872d34546de35780afdde50f52(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__babedefec800103eeb91b1c15364ad539e08b2a820946c4b4859284011a16617(
    *,
    auth: typing.Union[SecretStoreV1Beta1SpecProviderPreviderAuth, typing.Dict[builtins.str, typing.Any]],
    base_uri: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c6778a7517ce1f71b0364fc9df56630ce5e25c06ec8d3981cf1a1683d4990758(
    *,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderPreviderAuthSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd05ba6c99b6b1de1e4e775fa231557a0cadf52b20942c670a7c3cfaa784ae6a(
    *,
    access_token: typing.Union[SecretStoreV1Beta1SpecProviderPreviderAuthSecretRefAccessToken, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6aec5feeb407e5f7b6979ad3e7f433706611380fea7ca473c57cf5586a06c9f8(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__939d01649b08ff60f9a7a30761431e0f272e31bdd0a4b75e5bc6568af08a25b7(
    *,
    access_token: typing.Union[SecretStoreV1Beta1SpecProviderPulumiAccessToken, typing.Dict[builtins.str, typing.Any]],
    environment: builtins.str,
    organization: builtins.str,
    project: builtins.str,
    api_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__49f1e598bc6963cbfc96bb6e5cc69cf9b281444f3b47cfdec842d82b0e927630(
    *,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderPulumiAccessTokenSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba202441e53a6a6e88d62b095d491369de97f4e30a14970f0a02e9fb6da4a987(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9b2d10d04e4764b296e1ce01f19a28ce1674275dd261d44db6c973b670d9553e(
    *,
    access_key: typing.Union[SecretStoreV1Beta1SpecProviderScalewayAccessKey, typing.Dict[builtins.str, typing.Any]],
    project_id: builtins.str,
    region: builtins.str,
    secret_key: typing.Union[SecretStoreV1Beta1SpecProviderScalewaySecretKey, typing.Dict[builtins.str, typing.Any]],
    api_url: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__29b7f6cff88adde0cb6aa42b024e4018d4eccfbf09612f896f5ecbf9a61dc6f1(
    *,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3f5808fec9ce03b84e369eccce3001cd6d2e2fd5560f997dfd3f81874fbfdb9c(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__112ea142f158b916d10c0740099450f071bb6f572710e341958d8031399f2162(
    *,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3551e0f6019901c6c11d84a411d92ab9633cb1873225cc3a8771d935ced0fa9b(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__13781ade5f94390998a6da226871bb47a3c51ad3790cc560e496aea1d66f6f99(
    *,
    password: typing.Union[SecretStoreV1Beta1SpecProviderSecretserverPassword, typing.Dict[builtins.str, typing.Any]],
    server_url: builtins.str,
    username: typing.Union[SecretStoreV1Beta1SpecProviderSecretserverUsername, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__449c9b93d6a8245d810a4a4d832a539cfe5e94a3c4285b45d068ed30ce907ac5(
    *,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderSecretserverPasswordSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__400e4a893248023f91ef1e932a023f78127f60a1bd1c7e685829bd6d3fc79f90(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d79d2ce11d0089be20cf521c666a4d737e1a2ef75c92e06b465c5ddd34b2e1a4(
    *,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderSecretserverUsernameSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    value: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__66f78c2d1700f6bcadf580c5fce02b69dab1944e7eb6bffe4d465e175d3ffcb8(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__78623254f8b4480d65a04e698f672f51438d8f6ad30f23ac1407edfaba7874bf(
    *,
    auth: typing.Union[SecretStoreV1Beta1SpecProviderSenhaseguraAuth, typing.Dict[builtins.str, typing.Any]],
    module: builtins.str,
    url: builtins.str,
    ignore_ssl_certificate: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b2808e6be5de7fcbdf0e82d2a489f69451abfdc33dc24f27bda74709537de26(
    *,
    client_id: builtins.str,
    client_secret_secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bea4e571f5932fe123738bee25182a721382ee4f520f5c5424bdf47102fc5952(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9fc4023c465f1be1a5c234fc3840fd441fe986a5b257d0ae414a562c34af5757(
    *,
    auth: typing.Union[SecretStoreV1Beta1SpecProviderVaultAuth, typing.Dict[builtins.str, typing.Any]],
    server: builtins.str,
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
    forward_inconsistent: typing.Optional[builtins.bool] = None,
    headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
    path: typing.Optional[builtins.str] = None,
    read_your_writes: typing.Optional[builtins.bool] = None,
    tls: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultTls, typing.Dict[builtins.str, typing.Any]]] = None,
    version: typing.Optional[SecretStoreV1Beta1SpecProviderVaultVersion] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__400104a61eab9ca884187e2efbafa3aa344cc85d8fcba6bbf7136fc0639c2284(
    *,
    app_role: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthAppRole, typing.Dict[builtins.str, typing.Any]]] = None,
    cert: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthCert, typing.Dict[builtins.str, typing.Any]]] = None,
    iam: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthIam, typing.Dict[builtins.str, typing.Any]]] = None,
    jwt: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthJwt, typing.Dict[builtins.str, typing.Any]]] = None,
    kubernetes: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthKubernetes, typing.Dict[builtins.str, typing.Any]]] = None,
    ldap: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthLdap, typing.Dict[builtins.str, typing.Any]]] = None,
    namespace: typing.Optional[builtins.str] = None,
    token_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    user_pass: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthUserPass, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2612fd31ff239b5943a7df02b5760bc325d209684ea6b63f06098ab23d9a896b(
    *,
    path: builtins.str,
    secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef, typing.Dict[builtins.str, typing.Any]],
    role_id: typing.Optional[builtins.str] = None,
    role_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b4c16b55f19c130c4ce14b1c9d8b43aa77fec107e12f8b4c4a0935b9424e2136(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3eedd159a87fe07e72cce871971add22df1a8d80a195cfeacb05a624140b9884(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a2b41d62225e08c00b6e892d8bf36e67169f93c0a408c744fe8a1d0619927eaf(
    *,
    client_cert: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__81b9aa8a124bab828cff9a54e645168f18bd4cb1346e28b31c135ec26d61be17(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__657764136effba05124a02f44146e137354371a76c2326fe46f2a98a9578d15c(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f468cd0ca129fbfeaf1ca590f1fa7be7924ebb8fc7a88dbb6a302c3ba4cacde7(
    *,
    vault_role: builtins.str,
    external_id: typing.Optional[builtins.str] = None,
    jwt: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthIamJwt, typing.Dict[builtins.str, typing.Any]]] = None,
    path: typing.Optional[builtins.str] = None,
    region: typing.Optional[builtins.str] = None,
    role: typing.Optional[builtins.str] = None,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    vault_aws_iam_server_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c8f4b2ded0305473504456d4e0e3ee262917925163178794b1eeef16e025e6f1(
    *,
    service_account_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7346dc011e1a6503794428c85d02111448071c64e9eccec71123823e461d2e43(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2460e7bc5089e6de0bf5b9e8882808c76d0e830b52b941edef97dc327188b612(
    *,
    access_key_id_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    secret_access_key_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    session_token_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bee80d133343a363e678632de3cd08f225089721a9fd0cf312c8e0a0a92f8608(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2c2b5d787d2bc8de48162516483e085294330f9cedebb9b400821e8a4cc772a(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b36a03a3c010f24ddce190cc4932b49fad407b9d9efe43dbb0a45bcd301ab372(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6d12691f0946a3be88b3813dd9e0f8618296ec3e293c8acdabef8eacd866a2c0(
    *,
    path: builtins.str,
    kubernetes_service_account_token: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken, typing.Dict[builtins.str, typing.Any]]] = None,
    role: typing.Optional[builtins.str] = None,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c244c831d1b55ba6714b2abfe1ec15f86e2d2e02854d87e4b37e4b5fa8cf5aac(
    *,
    service_account_ref: typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef, typing.Dict[builtins.str, typing.Any]],
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    expiration_seconds: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__581d82abfc24873710a507cda618c0e4e6ae222d91b35a395a9b26c7d8017c4f(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4ef4ba406e97456fd40e81e83a1b292cf26640faa7de7c46bc8d554c0d636659(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1336a204e0559ec7dfb15e3a1be1add384c119b846b080cc482c4ca2dbc0f301(
    *,
    mount_path: builtins.str,
    role: builtins.str,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    service_account_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f9c90383fbc90b9ffe85575c9a5dab35b486f50b27d31d5d2c4c44954cc18ad(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__22b5d8d69b247e7e694dbd8a0366bd7c5c79be42ffba34090f076bba7dfc8150(
    *,
    name: builtins.str,
    audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2b90e477cfebcc2b16c4c2fcce1ab775265e753d97d71cc18bf29c5cde3a9c9(
    *,
    path: builtins.str,
    username: builtins.str,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b3e2b5ca54356668b28b28010a671ca9c9051d330ec2474db708d50ec1cafc20(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d517595b96eeeec71f466e5bfb29bd6b5c39213c8c5e12d513ed5717a5e79f6c(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__26b580e6525ab3445d9b91a981e063443ceb4b0e487369d400b953f01d78bb0d(
    *,
    path: builtins.str,
    username: builtins.str,
    secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__194772104ad7af101c2de89b6ad71d08cfd0b369fe1e71b9d9f4735a47320e52(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32dea37cf93e2ea75f29adf17d3938b2218a712b370866878b2757313182fb2d(
    *,
    name: builtins.str,
    type: SecretStoreV1Beta1SpecProviderVaultCaProviderType,
    key: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fab4fa2118e761f43d471939d2609be45e644e4caad93f6c1903c7e2891f558b(
    *,
    cert_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultTlsCertSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
    key_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultTlsKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b5f1f826ab42f41a7a85805f377a816e90679ccc5ac3167e7de43fc68e87c137(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7c2580e3c74388f828c123433a329221fa36b0958fcfd40ad56bbc96daad799e(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf5abb92c60012a2736376d90e7ef4e3c9cd3bcf7cf74f99e2df1cd1a13680c0(
    *,
    result: typing.Union[SecretStoreV1Beta1SpecProviderWebhookResult, typing.Dict[builtins.str, typing.Any]],
    url: builtins.str,
    body: typing.Optional[builtins.str] = None,
    ca_bundle: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderWebhookCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
    headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    method: typing.Optional[builtins.str] = None,
    secrets: typing.Optional[typing.Sequence[typing.Union[SecretStoreV1Beta1SpecProviderWebhookSecrets, typing.Dict[builtins.str, typing.Any]]]] = None,
    timeout: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5fce432ce0e2eae6e5a8f1412837e18641603a6e8b15d4aec34e332993b5462d(
    *,
    name: builtins.str,
    type: SecretStoreV1Beta1SpecProviderWebhookCaProviderType,
    key: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__58b32e121616882afc75d18b197bdf2ce88622a99c612074a8bd3b067ca6b802(
    *,
    json_path: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__778a8f2be6f5511228d406820684a94d08bd1a9b6159ffdc456566fb25eb337c(
    *,
    name: builtins.str,
    secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef, typing.Dict[builtins.str, typing.Any]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d7dca2ad9349a9d2fe7a5896781f6b52ecbf67e082b9d411ea3413a41b00a7e2(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__08d808c8d7f62d085e205bb96b9a022d41d531ac28d062038109210ab5c79576(
    *,
    auth: typing.Union[SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth, typing.Dict[builtins.str, typing.Any]],
    api_endpoint: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ddd2993bc954fd084ce9e84b9bbea1a36c9f386d6fe8911f4f2f6fd2d5960b5c(
    *,
    authorized_key_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cfe09b0333f706d3c8197ef3f83ef7d4cc18d05556e2702e2179d843c118df6d(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d449498ebeb1647186fb96828f0f757a8d444078c80997ab79f408890f18fb19(
    *,
    cert_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__58a3bafa9427d99fbe6f7e616a670af9a996c35120dd0ab4a536cff4eb503180(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bf99b289f0ca917180063a71bc7afdafa9ac3bbfc28ac2c699675e6901606a6d(
    *,
    auth: typing.Union[SecretStoreV1Beta1SpecProviderYandexlockboxAuth, typing.Dict[builtins.str, typing.Any]],
    api_endpoint: typing.Optional[builtins.str] = None,
    ca_provider: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__320475850982319810875521d97ba7cfe93494d4e6f6a9a7089951c51615ec74(
    *,
    authorized_key_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__46b50c4851b420ec30ee452030b4a8396b34001ade1064d279f4751c9ee31d43(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d16120f78f7e83f30028a83b52f165e3bf6cc402c2caf7b6507c86dc972c9a6b(
    *,
    cert_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8756909219ad777e25fd1653205d832b6153e484056da252932b6eceb6f5fe7b(
    *,
    key: typing.Optional[builtins.str] = None,
    name: typing.Optional[builtins.str] = None,
    namespace: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ad5b45d0afd8807d66e967985db427563f25d7a6fb6ec3e2329dbe8187b09b1(
    *,
    max_retries: typing.Optional[jsii.Number] = None,
    retry_interval: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass
