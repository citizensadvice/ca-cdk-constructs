import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ._jsii import *

import cdk8s
import constructs


class ClusterExternalSecret(
    cdk8s.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="ioexternal-secrets.ClusterExternalSecret",
):
    '''ClusterExternalSecret is the Schema for the clusterexternalsecrets API.

    :schema: ClusterExternalSecret
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ClusterExternalSecretSpec", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Defines a "ClusterExternalSecret" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param metadata: 
        :param spec: ClusterExternalSecretSpec defines the desired state of ClusterExternalSecret.
        '''
        if __debug__:
            def stub(
                scope: constructs.Construct,
                id: builtins.str,
                *,
                metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
                spec: typing.Optional[typing.Union[ClusterExternalSecretSpec, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ClusterExternalSecretProps(metadata=metadata, spec=spec)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest")
    @builtins.classmethod
    def manifest(
        cls,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ClusterExternalSecretSpec", typing.Dict[str, typing.Any]]] = None,
    ) -> typing.Any:
        '''Renders a Kubernetes manifest for "ClusterExternalSecret".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param metadata: 
        :param spec: ClusterExternalSecretSpec defines the desired state of ClusterExternalSecret.
        '''
        props = ClusterExternalSecretProps(metadata=metadata, spec=spec)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''Renders the object to Kubernetes JSON.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> cdk8s.GroupVersionKind:
        '''Returns the apiVersion and kind for "ClusterExternalSecret".'''
        return typing.cast(cdk8s.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretProps",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class ClusterExternalSecretProps:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ClusterExternalSecretSpec", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''ClusterExternalSecret is the Schema for the clusterexternalsecrets API.

        :param metadata: 
        :param spec: ClusterExternalSecretSpec defines the desired state of ClusterExternalSecret.

        :schema: ClusterExternalSecret
        '''
        if isinstance(metadata, dict):
            metadata = cdk8s.ApiObjectMetadata(**metadata)
        if isinstance(spec, dict):
            spec = ClusterExternalSecretSpec(**spec)
        if __debug__:
            def stub(
                *,
                metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
                spec: typing.Optional[typing.Union[ClusterExternalSecretSpec, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(self) -> typing.Optional[cdk8s.ApiObjectMetadata]:
        '''
        :schema: ClusterExternalSecret#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[cdk8s.ApiObjectMetadata], result)

    @builtins.property
    def spec(self) -> typing.Optional["ClusterExternalSecretSpec"]:
        '''ClusterExternalSecretSpec defines the desired state of ClusterExternalSecret.

        :schema: ClusterExternalSecret#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["ClusterExternalSecretSpec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpec",
    jsii_struct_bases=[],
    name_mapping={
        "external_secret_spec": "externalSecretSpec",
        "namespace_selector": "namespaceSelector",
        "external_secret_name": "externalSecretName",
        "refresh_time": "refreshTime",
    },
)
class ClusterExternalSecretSpec:
    def __init__(
        self,
        *,
        external_secret_spec: typing.Union["ClusterExternalSecretSpecExternalSecretSpec", typing.Dict[str, typing.Any]],
        namespace_selector: typing.Union["ClusterExternalSecretSpecNamespaceSelector", typing.Dict[str, typing.Any]],
        external_secret_name: typing.Optional[builtins.str] = None,
        refresh_time: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ClusterExternalSecretSpec defines the desired state of ClusterExternalSecret.

        :param external_secret_spec: The spec for the ExternalSecrets to be created.
        :param namespace_selector: The labels to select by to find the Namespaces to create the ExternalSecrets in.
        :param external_secret_name: The name of the external secrets to be created defaults to the name of the ClusterExternalSecret.
        :param refresh_time: The time in which the controller should reconcile it's objects and recheck namespaces for labels.

        :schema: ClusterExternalSecretSpec
        '''
        if isinstance(external_secret_spec, dict):
            external_secret_spec = ClusterExternalSecretSpecExternalSecretSpec(**external_secret_spec)
        if isinstance(namespace_selector, dict):
            namespace_selector = ClusterExternalSecretSpecNamespaceSelector(**namespace_selector)
        if __debug__:
            def stub(
                *,
                external_secret_spec: typing.Union[ClusterExternalSecretSpecExternalSecretSpec, typing.Dict[str, typing.Any]],
                namespace_selector: typing.Union[ClusterExternalSecretSpecNamespaceSelector, typing.Dict[str, typing.Any]],
                external_secret_name: typing.Optional[builtins.str] = None,
                refresh_time: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument external_secret_spec", value=external_secret_spec, expected_type=type_hints["external_secret_spec"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
            check_type(argname="argument external_secret_name", value=external_secret_name, expected_type=type_hints["external_secret_name"])
            check_type(argname="argument refresh_time", value=refresh_time, expected_type=type_hints["refresh_time"])
        self._values: typing.Dict[str, typing.Any] = {
            "external_secret_spec": external_secret_spec,
            "namespace_selector": namespace_selector,
        }
        if external_secret_name is not None:
            self._values["external_secret_name"] = external_secret_name
        if refresh_time is not None:
            self._values["refresh_time"] = refresh_time

    @builtins.property
    def external_secret_spec(self) -> "ClusterExternalSecretSpecExternalSecretSpec":
        '''The spec for the ExternalSecrets to be created.

        :schema: ClusterExternalSecretSpec#externalSecretSpec
        '''
        result = self._values.get("external_secret_spec")
        assert result is not None, "Required property 'external_secret_spec' is missing"
        return typing.cast("ClusterExternalSecretSpecExternalSecretSpec", result)

    @builtins.property
    def namespace_selector(self) -> "ClusterExternalSecretSpecNamespaceSelector":
        '''The labels to select by to find the Namespaces to create the ExternalSecrets in.

        :schema: ClusterExternalSecretSpec#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        assert result is not None, "Required property 'namespace_selector' is missing"
        return typing.cast("ClusterExternalSecretSpecNamespaceSelector", result)

    @builtins.property
    def external_secret_name(self) -> typing.Optional[builtins.str]:
        '''The name of the external secrets to be created defaults to the name of the ClusterExternalSecret.

        :schema: ClusterExternalSecretSpec#externalSecretName
        '''
        result = self._values.get("external_secret_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def refresh_time(self) -> typing.Optional[builtins.str]:
        '''The time in which the controller should reconcile it's objects and recheck namespaces for labels.

        :schema: ClusterExternalSecretSpec#refreshTime
        '''
        result = self._values.get("refresh_time")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpec",
    jsii_struct_bases=[],
    name_mapping={
        "secret_store_ref": "secretStoreRef",
        "data": "data",
        "data_from": "dataFrom",
        "refresh_interval": "refreshInterval",
        "target": "target",
    },
)
class ClusterExternalSecretSpecExternalSecretSpec:
    def __init__(
        self,
        *,
        secret_store_ref: typing.Union["ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef", typing.Dict[str, typing.Any]],
        data: typing.Optional[typing.Sequence[typing.Union["ClusterExternalSecretSpecExternalSecretSpecData", typing.Dict[str, typing.Any]]]] = None,
        data_from: typing.Optional[typing.Sequence[typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataFrom", typing.Dict[str, typing.Any]]]] = None,
        refresh_interval: typing.Optional[builtins.str] = None,
        target: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecTarget", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''The spec for the ExternalSecrets to be created.

        :param secret_store_ref: SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
        :param data: Data defines the connection between the Kubernetes Secret keys and the Provider data.
        :param data_from: DataFrom is used to fetch all properties from a specific Provider data If multiple entries are specified, the Secret keys are merged in the specified order.
        :param refresh_interval: RefreshInterval is the amount of time before the values are read again from the SecretStore provider Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h" May be set to zero to fetch and create it once. Defaults to 1h. Default: 1h.
        :param target: ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.

        :schema: ClusterExternalSecretSpecExternalSecretSpec
        '''
        if isinstance(secret_store_ref, dict):
            secret_store_ref = ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef(**secret_store_ref)
        if isinstance(target, dict):
            target = ClusterExternalSecretSpecExternalSecretSpecTarget(**target)
        if __debug__:
            def stub(
                *,
                secret_store_ref: typing.Union[ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef, typing.Dict[str, typing.Any]],
                data: typing.Optional[typing.Sequence[typing.Union[ClusterExternalSecretSpecExternalSecretSpecData, typing.Dict[str, typing.Any]]]] = None,
                data_from: typing.Optional[typing.Sequence[typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataFrom, typing.Dict[str, typing.Any]]]] = None,
                refresh_interval: typing.Optional[builtins.str] = None,
                target: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecTarget, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_store_ref", value=secret_store_ref, expected_type=type_hints["secret_store_ref"])
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
            check_type(argname="argument data_from", value=data_from, expected_type=type_hints["data_from"])
            check_type(argname="argument refresh_interval", value=refresh_interval, expected_type=type_hints["refresh_interval"])
            check_type(argname="argument target", value=target, expected_type=type_hints["target"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_store_ref": secret_store_ref,
        }
        if data is not None:
            self._values["data"] = data
        if data_from is not None:
            self._values["data_from"] = data_from
        if refresh_interval is not None:
            self._values["refresh_interval"] = refresh_interval
        if target is not None:
            self._values["target"] = target

    @builtins.property
    def secret_store_ref(
        self,
    ) -> "ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef":
        '''SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :schema: ClusterExternalSecretSpecExternalSecretSpec#secretStoreRef
        '''
        result = self._values.get("secret_store_ref")
        assert result is not None, "Required property 'secret_store_ref' is missing"
        return typing.cast("ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef", result)

    @builtins.property
    def data(
        self,
    ) -> typing.Optional[typing.List["ClusterExternalSecretSpecExternalSecretSpecData"]]:
        '''Data defines the connection between the Kubernetes Secret keys and the Provider data.

        :schema: ClusterExternalSecretSpecExternalSecretSpec#data
        '''
        result = self._values.get("data")
        return typing.cast(typing.Optional[typing.List["ClusterExternalSecretSpecExternalSecretSpecData"]], result)

    @builtins.property
    def data_from(
        self,
    ) -> typing.Optional[typing.List["ClusterExternalSecretSpecExternalSecretSpecDataFrom"]]:
        '''DataFrom is used to fetch all properties from a specific Provider data If multiple entries are specified, the Secret keys are merged in the specified order.

        :schema: ClusterExternalSecretSpecExternalSecretSpec#dataFrom
        '''
        result = self._values.get("data_from")
        return typing.cast(typing.Optional[typing.List["ClusterExternalSecretSpecExternalSecretSpecDataFrom"]], result)

    @builtins.property
    def refresh_interval(self) -> typing.Optional[builtins.str]:
        '''RefreshInterval is the amount of time before the values are read again from the SecretStore provider Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h" May be set to zero to fetch and create it once.

        Defaults to 1h.

        :default: 1h.

        :schema: ClusterExternalSecretSpecExternalSecretSpec#refreshInterval
        '''
        result = self._values.get("refresh_interval")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def target(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTarget"]:
        '''ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.

        :schema: ClusterExternalSecretSpecExternalSecretSpec#target
        '''
        result = self._values.get("target")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTarget"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecData",
    jsii_struct_bases=[],
    name_mapping={"remote_ref": "remoteRef", "secret_key": "secretKey"},
)
class ClusterExternalSecretSpecExternalSecretSpecData:
    def __init__(
        self,
        *,
        remote_ref: typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef", typing.Dict[str, typing.Any]],
        secret_key: builtins.str,
    ) -> None:
        '''ExternalSecretData defines the connection between the Kubernetes Secret key (spec.data.) and the Provider data.

        :param remote_ref: ExternalSecretDataRemoteRef defines Provider data location.
        :param secret_key: 

        :schema: ClusterExternalSecretSpecExternalSecretSpecData
        '''
        if isinstance(remote_ref, dict):
            remote_ref = ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef(**remote_ref)
        if __debug__:
            def stub(
                *,
                remote_ref: typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef, typing.Dict[str, typing.Any]],
                secret_key: builtins.str,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument remote_ref", value=remote_ref, expected_type=type_hints["remote_ref"])
            check_type(argname="argument secret_key", value=secret_key, expected_type=type_hints["secret_key"])
        self._values: typing.Dict[str, typing.Any] = {
            "remote_ref": remote_ref,
            "secret_key": secret_key,
        }

    @builtins.property
    def remote_ref(self) -> "ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef":
        '''ExternalSecretDataRemoteRef defines Provider data location.

        :schema: ClusterExternalSecretSpecExternalSecretSpecData#remoteRef
        '''
        result = self._values.get("remote_ref")
        assert result is not None, "Required property 'remote_ref' is missing"
        return typing.cast("ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef", result)

    @builtins.property
    def secret_key(self) -> builtins.str:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecData#secretKey
        '''
        result = self._values.get("secret_key")
        assert result is not None, "Required property 'secret_key' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecData(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFrom",
    jsii_struct_bases=[],
    name_mapping={"extract": "extract", "find": "find", "rewrite": "rewrite"},
)
class ClusterExternalSecretSpecExternalSecretSpecDataFrom:
    def __init__(
        self,
        *,
        extract: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataFromExtract", typing.Dict[str, typing.Any]]] = None,
        find: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataFromFind", typing.Dict[str, typing.Any]]] = None,
        rewrite: typing.Optional[typing.Sequence[typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param extract: Used to extract multiple key/value pairs from one secret.
        :param find: Used to find secrets based on tags or regular expressions.
        :param rewrite: Used to rewrite secret Keys after getting them from the secret Provider Multiple Rewrite operations can be provided. They are applied in a layered order (first to last)

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFrom
        '''
        if isinstance(extract, dict):
            extract = ClusterExternalSecretSpecExternalSecretSpecDataFromExtract(**extract)
        if isinstance(find, dict):
            find = ClusterExternalSecretSpecExternalSecretSpecDataFromFind(**find)
        if __debug__:
            def stub(
                *,
                extract: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataFromExtract, typing.Dict[str, typing.Any]]] = None,
                find: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataFromFind, typing.Dict[str, typing.Any]]] = None,
                rewrite: typing.Optional[typing.Sequence[typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite, typing.Dict[str, typing.Any]]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument extract", value=extract, expected_type=type_hints["extract"])
            check_type(argname="argument find", value=find, expected_type=type_hints["find"])
            check_type(argname="argument rewrite", value=rewrite, expected_type=type_hints["rewrite"])
        self._values: typing.Dict[str, typing.Any] = {}
        if extract is not None:
            self._values["extract"] = extract
        if find is not None:
            self._values["find"] = find
        if rewrite is not None:
            self._values["rewrite"] = rewrite

    @builtins.property
    def extract(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromExtract"]:
        '''Used to extract multiple key/value pairs from one secret.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFrom#extract
        '''
        result = self._values.get("extract")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromExtract"], result)

    @builtins.property
    def find(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromFind"]:
        '''Used to find secrets based on tags or regular expressions.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFrom#find
        '''
        result = self._values.get("find")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromFind"], result)

    @builtins.property
    def rewrite(
        self,
    ) -> typing.Optional[typing.List["ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite"]]:
        '''Used to rewrite secret Keys after getting them from the secret Provider Multiple Rewrite operations can be provided.

        They are applied in a layered order (first to last)

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFrom#rewrite
        '''
        result = self._values.get("rewrite")
        return typing.cast(typing.Optional[typing.List["ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromExtract",
    jsii_struct_bases=[],
    name_mapping={
        "key": "key",
        "conversion_strategy": "conversionStrategy",
        "decoding_strategy": "decodingStrategy",
        "metadata_policy": "metadataPolicy",
        "property": "property",
        "version": "version",
    },
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromExtract:
    def __init__(
        self,
        *,
        key: builtins.str,
        conversion_strategy: typing.Optional[builtins.str] = None,
        decoding_strategy: typing.Optional[builtins.str] = None,
        metadata_policy: typing.Optional[builtins.str] = None,
        property: typing.Optional[builtins.str] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Used to extract multiple key/value pairs from one secret.

        :param key: Key is the key used in the Provider, mandatory.
        :param conversion_strategy: Used to define a conversion Strategy.
        :param decoding_strategy: Used to define a decoding Strategy.
        :param metadata_policy: Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None Default: None
        :param property: Used to select a specific property of the Provider value (if a map), if supported.
        :param version: Used to select a specific version of the Provider value, if supported.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromExtract
        '''
        if __debug__:
            def stub(
                *,
                key: builtins.str,
                conversion_strategy: typing.Optional[builtins.str] = None,
                decoding_strategy: typing.Optional[builtins.str] = None,
                metadata_policy: typing.Optional[builtins.str] = None,
                property: typing.Optional[builtins.str] = None,
                version: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument conversion_strategy", value=conversion_strategy, expected_type=type_hints["conversion_strategy"])
            check_type(argname="argument decoding_strategy", value=decoding_strategy, expected_type=type_hints["decoding_strategy"])
            check_type(argname="argument metadata_policy", value=metadata_policy, expected_type=type_hints["metadata_policy"])
            check_type(argname="argument property", value=property, expected_type=type_hints["property"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }
        if conversion_strategy is not None:
            self._values["conversion_strategy"] = conversion_strategy
        if decoding_strategy is not None:
            self._values["decoding_strategy"] = decoding_strategy
        if metadata_policy is not None:
            self._values["metadata_policy"] = metadata_policy
        if property is not None:
            self._values["property"] = property
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def key(self) -> builtins.str:
        '''Key is the key used in the Provider, mandatory.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def conversion_strategy(self) -> typing.Optional[builtins.str]:
        '''Used to define a conversion Strategy.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#conversionStrategy
        '''
        result = self._values.get("conversion_strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def decoding_strategy(self) -> typing.Optional[builtins.str]:
        '''Used to define a decoding Strategy.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#decodingStrategy
        '''
        result = self._values.get("decoding_strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metadata_policy(self) -> typing.Optional[builtins.str]:
        '''Policy for fetching tags/labels from provider secrets, possible options are Fetch, None.

        Defaults to None

        :default: None

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#metadataPolicy
        '''
        result = self._values.get("metadata_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def property(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific property of the Provider value (if a map), if supported.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#property
        '''
        result = self._values.get("property")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific version of the Provider value, if supported.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromExtract#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataFromExtract(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromFind",
    jsii_struct_bases=[],
    name_mapping={
        "conversion_strategy": "conversionStrategy",
        "decoding_strategy": "decodingStrategy",
        "name": "name",
        "path": "path",
        "tags": "tags",
    },
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromFind:
    def __init__(
        self,
        *,
        conversion_strategy: typing.Optional[builtins.str] = None,
        decoding_strategy: typing.Optional[builtins.str] = None,
        name: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataFromFindName", typing.Dict[str, typing.Any]]] = None,
        path: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Used to find secrets based on tags or regular expressions.

        :param conversion_strategy: Used to define a conversion Strategy.
        :param decoding_strategy: Used to define a decoding Strategy.
        :param name: Finds secrets based on the name.
        :param path: A root path to start the find operations.
        :param tags: Find secrets based on tags.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromFind
        '''
        if isinstance(name, dict):
            name = ClusterExternalSecretSpecExternalSecretSpecDataFromFindName(**name)
        if __debug__:
            def stub(
                *,
                conversion_strategy: typing.Optional[builtins.str] = None,
                decoding_strategy: typing.Optional[builtins.str] = None,
                name: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataFromFindName, typing.Dict[str, typing.Any]]] = None,
                path: typing.Optional[builtins.str] = None,
                tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument conversion_strategy", value=conversion_strategy, expected_type=type_hints["conversion_strategy"])
            check_type(argname="argument decoding_strategy", value=decoding_strategy, expected_type=type_hints["decoding_strategy"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[str, typing.Any] = {}
        if conversion_strategy is not None:
            self._values["conversion_strategy"] = conversion_strategy
        if decoding_strategy is not None:
            self._values["decoding_strategy"] = decoding_strategy
        if name is not None:
            self._values["name"] = name
        if path is not None:
            self._values["path"] = path
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def conversion_strategy(self) -> typing.Optional[builtins.str]:
        '''Used to define a conversion Strategy.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromFind#conversionStrategy
        '''
        result = self._values.get("conversion_strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def decoding_strategy(self) -> typing.Optional[builtins.str]:
        '''Used to define a decoding Strategy.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromFind#decodingStrategy
        '''
        result = self._values.get("decoding_strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromFindName"]:
        '''Finds secrets based on the name.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromFind#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromFindName"], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''A root path to start the find operations.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromFind#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Find secrets based on tags.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromFind#tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataFromFind(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromFindName",
    jsii_struct_bases=[],
    name_mapping={"regexp": "regexp"},
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromFindName:
    def __init__(self, *, regexp: typing.Optional[builtins.str] = None) -> None:
        '''Finds secrets based on the name.

        :param regexp: Finds secrets base.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromFindName
        '''
        if __debug__:
            def stub(*, regexp: typing.Optional[builtins.str] = None) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument regexp", value=regexp, expected_type=type_hints["regexp"])
        self._values: typing.Dict[str, typing.Any] = {}
        if regexp is not None:
            self._values["regexp"] = regexp

    @builtins.property
    def regexp(self) -> typing.Optional[builtins.str]:
        '''Finds secrets base.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromFindName#regexp
        '''
        result = self._values.get("regexp")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataFromFindName(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite",
    jsii_struct_bases=[],
    name_mapping={"regexp": "regexp"},
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite:
    def __init__(
        self,
        *,
        regexp: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param regexp: Used to rewrite with regular expressions. The resulting key will be the output of a regexp.ReplaceAll operation.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite
        '''
        if isinstance(regexp, dict):
            regexp = ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp(**regexp)
        if __debug__:
            def stub(
                *,
                regexp: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument regexp", value=regexp, expected_type=type_hints["regexp"])
        self._values: typing.Dict[str, typing.Any] = {}
        if regexp is not None:
            self._values["regexp"] = regexp

    @builtins.property
    def regexp(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp"]:
        '''Used to rewrite with regular expressions.

        The resulting key will be the output of a regexp.ReplaceAll operation.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite#regexp
        '''
        result = self._values.get("regexp")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp",
    jsii_struct_bases=[],
    name_mapping={"source": "source", "target": "target"},
)
class ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp:
    def __init__(self, *, source: builtins.str, target: builtins.str) -> None:
        '''Used to rewrite with regular expressions.

        The resulting key will be the output of a regexp.ReplaceAll operation.

        :param source: Used to define the regular expression of a re.Compiler.
        :param target: Used to define the target pattern of a ReplaceAll operation.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp
        '''
        if __debug__:
            def stub(*, source: builtins.str, target: builtins.str) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument source", value=source, expected_type=type_hints["source"])
            check_type(argname="argument target", value=target, expected_type=type_hints["target"])
        self._values: typing.Dict[str, typing.Any] = {
            "source": source,
            "target": target,
        }

    @builtins.property
    def source(self) -> builtins.str:
        '''Used to define the regular expression of a re.Compiler.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp#source
        '''
        result = self._values.get("source")
        assert result is not None, "Required property 'source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target(self) -> builtins.str:
        '''Used to define the target pattern of a ReplaceAll operation.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp#target
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef",
    jsii_struct_bases=[],
    name_mapping={
        "key": "key",
        "conversion_strategy": "conversionStrategy",
        "decoding_strategy": "decodingStrategy",
        "metadata_policy": "metadataPolicy",
        "property": "property",
        "version": "version",
    },
)
class ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef:
    def __init__(
        self,
        *,
        key: builtins.str,
        conversion_strategy: typing.Optional[builtins.str] = None,
        decoding_strategy: typing.Optional[builtins.str] = None,
        metadata_policy: typing.Optional[builtins.str] = None,
        property: typing.Optional[builtins.str] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ExternalSecretDataRemoteRef defines Provider data location.

        :param key: Key is the key used in the Provider, mandatory.
        :param conversion_strategy: Used to define a conversion Strategy.
        :param decoding_strategy: Used to define a decoding Strategy.
        :param metadata_policy: Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None Default: None
        :param property: Used to select a specific property of the Provider value (if a map), if supported.
        :param version: Used to select a specific version of the Provider value, if supported.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef
        '''
        if __debug__:
            def stub(
                *,
                key: builtins.str,
                conversion_strategy: typing.Optional[builtins.str] = None,
                decoding_strategy: typing.Optional[builtins.str] = None,
                metadata_policy: typing.Optional[builtins.str] = None,
                property: typing.Optional[builtins.str] = None,
                version: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument conversion_strategy", value=conversion_strategy, expected_type=type_hints["conversion_strategy"])
            check_type(argname="argument decoding_strategy", value=decoding_strategy, expected_type=type_hints["decoding_strategy"])
            check_type(argname="argument metadata_policy", value=metadata_policy, expected_type=type_hints["metadata_policy"])
            check_type(argname="argument property", value=property, expected_type=type_hints["property"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }
        if conversion_strategy is not None:
            self._values["conversion_strategy"] = conversion_strategy
        if decoding_strategy is not None:
            self._values["decoding_strategy"] = decoding_strategy
        if metadata_policy is not None:
            self._values["metadata_policy"] = metadata_policy
        if property is not None:
            self._values["property"] = property
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def key(self) -> builtins.str:
        '''Key is the key used in the Provider, mandatory.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def conversion_strategy(self) -> typing.Optional[builtins.str]:
        '''Used to define a conversion Strategy.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#conversionStrategy
        '''
        result = self._values.get("conversion_strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def decoding_strategy(self) -> typing.Optional[builtins.str]:
        '''Used to define a decoding Strategy.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#decodingStrategy
        '''
        result = self._values.get("decoding_strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metadata_policy(self) -> typing.Optional[builtins.str]:
        '''Policy for fetching tags/labels from provider secrets, possible options are Fetch, None.

        Defaults to None

        :default: None

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#metadataPolicy
        '''
        result = self._values.get("metadata_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def property(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific property of the Provider value (if a map), if supported.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#property
        '''
        result = self._values.get("property")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific version of the Provider value, if supported.

        :schema: ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "kind": "kind"},
)
class ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        kind: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :param name: Name of the SecretStore resource.
        :param kind: Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``. Default: SecretStore`

        :schema: ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                kind: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if kind is not None:
            self._values["kind"] = kind

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the SecretStore resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def kind(self) -> typing.Optional[builtins.str]:
        '''Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``.

        :default: SecretStore`

        :schema: ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTarget",
    jsii_struct_bases=[],
    name_mapping={
        "creation_policy": "creationPolicy",
        "deletion_policy": "deletionPolicy",
        "immutable": "immutable",
        "name": "name",
        "template": "template",
    },
)
class ClusterExternalSecretSpecExternalSecretSpecTarget:
    def __init__(
        self,
        *,
        creation_policy: typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy"] = None,
        deletion_policy: typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy"] = None,
        immutable: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
        template: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecTargetTemplate", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.

        :param creation_policy: CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'. Default: Owner'
        :param deletion_policy: DeletionPolicy defines rules on how to delete the resulting Secret Defaults to 'Retain'. Default: Retain'
        :param immutable: Immutable defines if the final secret will be immutable.
        :param name: Name defines the name of the Secret resource to be managed This field is immutable Defaults to the .metadata.name of the ExternalSecret resource. Default: the .metadata.name of the ExternalSecret resource
        :param template: Template defines a blueprint for the created Secret resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecTarget
        '''
        if isinstance(template, dict):
            template = ClusterExternalSecretSpecExternalSecretSpecTargetTemplate(**template)
        if __debug__:
            def stub(
                *,
                creation_policy: typing.Optional[ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy] = None,
                deletion_policy: typing.Optional[ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy] = None,
                immutable: typing.Optional[builtins.bool] = None,
                name: typing.Optional[builtins.str] = None,
                template: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecTargetTemplate, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument creation_policy", value=creation_policy, expected_type=type_hints["creation_policy"])
            check_type(argname="argument deletion_policy", value=deletion_policy, expected_type=type_hints["deletion_policy"])
            check_type(argname="argument immutable", value=immutable, expected_type=type_hints["immutable"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument template", value=template, expected_type=type_hints["template"])
        self._values: typing.Dict[str, typing.Any] = {}
        if creation_policy is not None:
            self._values["creation_policy"] = creation_policy
        if deletion_policy is not None:
            self._values["deletion_policy"] = deletion_policy
        if immutable is not None:
            self._values["immutable"] = immutable
        if name is not None:
            self._values["name"] = name
        if template is not None:
            self._values["template"] = template

    @builtins.property
    def creation_policy(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy"]:
        '''CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'.

        :default: Owner'

        :schema: ClusterExternalSecretSpecExternalSecretSpecTarget#creationPolicy
        '''
        result = self._values.get("creation_policy")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy"], result)

    @builtins.property
    def deletion_policy(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy"]:
        '''DeletionPolicy defines rules on how to delete the resulting Secret Defaults to 'Retain'.

        :default: Retain'

        :schema: ClusterExternalSecretSpecExternalSecretSpecTarget#deletionPolicy
        '''
        result = self._values.get("deletion_policy")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy"], result)

    @builtins.property
    def immutable(self) -> typing.Optional[builtins.bool]:
        '''Immutable defines if the final secret will be immutable.

        :schema: ClusterExternalSecretSpecExternalSecretSpecTarget#immutable
        '''
        result = self._values.get("immutable")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name defines the name of the Secret resource to be managed This field is immutable Defaults to the .metadata.name of the ExternalSecret resource.

        :default: the .metadata.name of the ExternalSecret resource

        :schema: ClusterExternalSecretSpecExternalSecretSpecTarget#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def template(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplate"]:
        '''Template defines a blueprint for the created Secret resource.

        :schema: ClusterExternalSecretSpecExternalSecretSpecTarget#template
        '''
        result = self._values.get("template")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplate"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecTarget(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy"
)
class ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy(enum.Enum):
    '''CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'.

    :default: Owner'

    :schema: ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy
    '''

    OWNER = "OWNER"
    '''Owner.'''
    ORPHAN = "ORPHAN"
    '''Orphan.'''
    MERGE = "MERGE"
    '''Merge.'''
    NONE = "NONE"
    '''None.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy"
)
class ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy(enum.Enum):
    '''DeletionPolicy defines rules on how to delete the resulting Secret Defaults to 'Retain'.

    :default: Retain'

    :schema: ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy
    '''

    DELETE = "DELETE"
    '''Delete.'''
    MERGE = "MERGE"
    '''Merge.'''
    RETAIN = "RETAIN"
    '''Retain.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetTemplate",
    jsii_struct_bases=[],
    name_mapping={
        "data": "data",
        "engine_version": "engineVersion",
        "metadata": "metadata",
        "template_from": "templateFrom",
        "type": "type",
    },
)
class ClusterExternalSecretSpecExternalSecretSpecTargetTemplate:
    def __init__(
        self,
        *,
        data: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        engine_version: typing.Optional[builtins.str] = None,
        metadata: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata", typing.Dict[str, typing.Any]]] = None,
        template_from: typing.Optional[typing.Sequence[typing.Union["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom", typing.Dict[str, typing.Any]]]] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Template defines a blueprint for the created Secret resource.

        :param data: 
        :param engine_version: 
        :param metadata: ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
        :param template_from: 
        :param type: 

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplate
        '''
        if isinstance(metadata, dict):
            metadata = ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata(**metadata)
        if __debug__:
            def stub(
                *,
                data: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
                engine_version: typing.Optional[builtins.str] = None,
                metadata: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata, typing.Dict[str, typing.Any]]] = None,
                template_from: typing.Optional[typing.Sequence[typing.Union[ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom, typing.Dict[str, typing.Any]]]] = None,
                type: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
            check_type(argname="argument engine_version", value=engine_version, expected_type=type_hints["engine_version"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument template_from", value=template_from, expected_type=type_hints["template_from"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[str, typing.Any] = {}
        if data is not None:
            self._values["data"] = data
        if engine_version is not None:
            self._values["engine_version"] = engine_version
        if metadata is not None:
            self._values["metadata"] = metadata
        if template_from is not None:
            self._values["template_from"] = template_from
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def data(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#data
        '''
        result = self._values.get("data")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def engine_version(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#engineVersion
        '''
        result = self._values.get("engine_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metadata(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata"]:
        '''ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata"], result)

    @builtins.property
    def template_from(
        self,
    ) -> typing.Optional[typing.List["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom"]]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#templateFrom
        '''
        result = self._values.get("template_from")
        return typing.cast(typing.Optional[typing.List["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom"]], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplate#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecTargetTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata",
    jsii_struct_bases=[],
    name_mapping={"annotations": "annotations", "labels": "labels"},
)
class ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.

        :param annotations: 
        :param labels: 

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata
        '''
        if __debug__:
            def stub(
                *,
                annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
                labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if labels is not None:
            self._values["labels"] = labels

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom",
    jsii_struct_bases=[],
    name_mapping={"config_map": "configMap", "secret": "secret"},
)
class ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom:
    def __init__(
        self,
        *,
        config_map: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap", typing.Dict[str, typing.Any]]] = None,
        secret: typing.Optional[typing.Union["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param config_map: 
        :param secret: 

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom
        '''
        if isinstance(config_map, dict):
            config_map = ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap(**config_map)
        if isinstance(secret, dict):
            secret = ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret(**secret)
        if __debug__:
            def stub(
                *,
                config_map: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap, typing.Dict[str, typing.Any]]] = None,
                secret: typing.Optional[typing.Union[ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument config_map", value=config_map, expected_type=type_hints["config_map"])
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
        self._values: typing.Dict[str, typing.Any] = {}
        if config_map is not None:
            self._values["config_map"] = config_map
        if secret is not None:
            self._values["secret"] = secret

    @builtins.property
    def config_map(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap"]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom#configMap
        '''
        result = self._values.get("config_map")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap"], result)

    @builtins.property
    def secret(
        self,
    ) -> typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret"]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom#secret
        '''
        result = self._values.get("secret")
        return typing.cast(typing.Optional["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap",
    jsii_struct_bases=[],
    name_mapping={"items": "items", "name": "name"},
)
class ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap:
    def __init__(
        self,
        *,
        items: typing.Sequence[typing.Union["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems", typing.Dict[str, typing.Any]]],
        name: builtins.str,
    ) -> None:
        '''
        :param items: 
        :param name: 

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap
        '''
        if __debug__:
            def stub(
                *,
                items: typing.Sequence[typing.Union[ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems, typing.Dict[str, typing.Any]]],
                name: builtins.str,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {
            "items": items,
            "name": name,
        }

    @builtins.property
    def items(
        self,
    ) -> typing.List["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems"]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap#items
        '''
        result = self._values.get("items")
        assert result is not None, "Required property 'items' is missing"
        return typing.cast(typing.List["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems"], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key"},
)
class ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems:
    def __init__(self, *, key: builtins.str) -> None:
        '''
        :param key: 

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems
        '''
        if __debug__:
            def stub(*, key: builtins.str) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret",
    jsii_struct_bases=[],
    name_mapping={"items": "items", "name": "name"},
)
class ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret:
    def __init__(
        self,
        *,
        items: typing.Sequence[typing.Union["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems", typing.Dict[str, typing.Any]]],
        name: builtins.str,
    ) -> None:
        '''
        :param items: 
        :param name: 

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret
        '''
        if __debug__:
            def stub(
                *,
                items: typing.Sequence[typing.Union[ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems, typing.Dict[str, typing.Any]]],
                name: builtins.str,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {
            "items": items,
            "name": name,
        }

    @builtins.property
    def items(
        self,
    ) -> typing.List["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems"]:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret#items
        '''
        result = self._values.get("items")
        assert result is not None, "Required property 'items' is missing"
        return typing.cast(typing.List["ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems"], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key"},
)
class ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems:
    def __init__(self, *, key: builtins.str) -> None:
        '''
        :param key: 

        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems
        '''
        if __debug__:
            def stub(*, key: builtins.str) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :schema: ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterExternalSecretSpecNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterExternalSecretSpecNamespaceSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''The labels to select by to find the Namespaces to create the ExternalSecrets in.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterExternalSecretSpecNamespaceSelector
        '''
        if __debug__:
            def stub(
                *,
                match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterExternalSecretSpecNamespaceSelectorMatchExpressions, typing.Dict[str, typing.Any]]]] = None,
                match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterExternalSecretSpecNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterExternalSecretSpecNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterExternalSecretSpecNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterExternalSecretSpecNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterExternalSecretSpecNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterExternalSecretSpecNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterExternalSecretSpecNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            def stub(
                *,
                key: builtins.str,
                operator: builtins.str,
                values: typing.Optional[typing.Sequence[builtins.str]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterExternalSecretSpecNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterExternalSecretSpecNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterExternalSecretSpecNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterExternalSecretSpecNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ClusterSecretStore(
    cdk8s.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="ioexternal-secrets.ClusterSecretStore",
):
    '''ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of ``storeRef`` fields.

    :schema: ClusterSecretStore
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ClusterSecretStoreSpec", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Defines a "ClusterSecretStore" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.
        '''
        if __debug__:
            def stub(
                scope: constructs.Construct,
                id: builtins.str,
                *,
                metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
                spec: typing.Optional[typing.Union[ClusterSecretStoreSpec, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ClusterSecretStoreProps(metadata=metadata, spec=spec)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest")
    @builtins.classmethod
    def manifest(
        cls,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ClusterSecretStoreSpec", typing.Dict[str, typing.Any]]] = None,
    ) -> typing.Any:
        '''Renders a Kubernetes manifest for "ClusterSecretStore".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.
        '''
        props = ClusterSecretStoreProps(metadata=metadata, spec=spec)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''Renders the object to Kubernetes JSON.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> cdk8s.GroupVersionKind:
        '''Returns the apiVersion and kind for "ClusterSecretStore".'''
        return typing.cast(cdk8s.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreProps",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class ClusterSecretStoreProps:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ClusterSecretStoreSpec", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of ``storeRef`` fields.

        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.

        :schema: ClusterSecretStore
        '''
        if isinstance(metadata, dict):
            metadata = cdk8s.ApiObjectMetadata(**metadata)
        if isinstance(spec, dict):
            spec = ClusterSecretStoreSpec(**spec)
        if __debug__:
            def stub(
                *,
                metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
                spec: typing.Optional[typing.Union[ClusterSecretStoreSpec, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(self) -> typing.Optional[cdk8s.ApiObjectMetadata]:
        '''
        :schema: ClusterSecretStore#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[cdk8s.ApiObjectMetadata], result)

    @builtins.property
    def spec(self) -> typing.Optional["ClusterSecretStoreSpec"]:
        '''SecretStoreSpec defines the desired state of SecretStore.

        :schema: ClusterSecretStore#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["ClusterSecretStoreSpec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpec",
    jsii_struct_bases=[],
    name_mapping={
        "provider": "provider",
        "controller": "controller",
        "retry_settings": "retrySettings",
    },
)
class ClusterSecretStoreSpec:
    def __init__(
        self,
        *,
        provider: typing.Union["ClusterSecretStoreSpecProvider", typing.Dict[str, typing.Any]],
        controller: typing.Optional[builtins.str] = None,
        retry_settings: typing.Optional[typing.Union["ClusterSecretStoreSpecRetrySettings", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''SecretStoreSpec defines the desired state of SecretStore.

        :param provider: Used to configure the provider. Only one provider may be set
        :param controller: Used to select the correct KES controller (think: ingress.ingressClassName) The KES controller is instantiated with a specific controller name and filters ES based on this property.
        :param retry_settings: Used to configure http retries if failed.

        :schema: ClusterSecretStoreSpec
        '''
        if isinstance(provider, dict):
            provider = ClusterSecretStoreSpecProvider(**provider)
        if isinstance(retry_settings, dict):
            retry_settings = ClusterSecretStoreSpecRetrySettings(**retry_settings)
        if __debug__:
            def stub(
                *,
                provider: typing.Union[ClusterSecretStoreSpecProvider, typing.Dict[str, typing.Any]],
                controller: typing.Optional[builtins.str] = None,
                retry_settings: typing.Optional[typing.Union[ClusterSecretStoreSpecRetrySettings, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument controller", value=controller, expected_type=type_hints["controller"])
            check_type(argname="argument retry_settings", value=retry_settings, expected_type=type_hints["retry_settings"])
        self._values: typing.Dict[str, typing.Any] = {
            "provider": provider,
        }
        if controller is not None:
            self._values["controller"] = controller
        if retry_settings is not None:
            self._values["retry_settings"] = retry_settings

    @builtins.property
    def provider(self) -> "ClusterSecretStoreSpecProvider":
        '''Used to configure the provider.

        Only one provider may be set

        :schema: ClusterSecretStoreSpec#provider
        '''
        result = self._values.get("provider")
        assert result is not None, "Required property 'provider' is missing"
        return typing.cast("ClusterSecretStoreSpecProvider", result)

    @builtins.property
    def controller(self) -> typing.Optional[builtins.str]:
        '''Used to select the correct KES controller (think: ingress.ingressClassName) The KES controller is instantiated with a specific controller name and filters ES based on this property.

        :schema: ClusterSecretStoreSpec#controller
        '''
        result = self._values.get("controller")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def retry_settings(self) -> typing.Optional["ClusterSecretStoreSpecRetrySettings"]:
        '''Used to configure http retries if failed.

        :schema: ClusterSecretStoreSpec#retrySettings
        '''
        result = self._values.get("retry_settings")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecRetrySettings"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProvider",
    jsii_struct_bases=[],
    name_mapping={
        "akeyless": "akeyless",
        "alibaba": "alibaba",
        "aws": "aws",
        "azurekv": "azurekv",
        "fake": "fake",
        "gcpsm": "gcpsm",
        "gitlab": "gitlab",
        "ibm": "ibm",
        "kubernetes": "kubernetes",
        "oracle": "oracle",
        "vault": "vault",
        "webhook": "webhook",
        "yandexlockbox": "yandexlockbox",
    },
)
class ClusterSecretStoreSpecProvider:
    def __init__(
        self,
        *,
        akeyless: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAkeyless", typing.Dict[str, typing.Any]]] = None,
        alibaba: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAlibaba", typing.Dict[str, typing.Any]]] = None,
        aws: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAws", typing.Dict[str, typing.Any]]] = None,
        azurekv: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAzurekv", typing.Dict[str, typing.Any]]] = None,
        fake: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderFake", typing.Dict[str, typing.Any]]] = None,
        gcpsm: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderGcpsm", typing.Dict[str, typing.Any]]] = None,
        gitlab: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderGitlab", typing.Dict[str, typing.Any]]] = None,
        ibm: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderIbm", typing.Dict[str, typing.Any]]] = None,
        kubernetes: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderKubernetes", typing.Dict[str, typing.Any]]] = None,
        oracle: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderOracle", typing.Dict[str, typing.Any]]] = None,
        vault: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVault", typing.Dict[str, typing.Any]]] = None,
        webhook: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderWebhook", typing.Dict[str, typing.Any]]] = None,
        yandexlockbox: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderYandexlockbox", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Used to configure the provider.

        Only one provider may be set

        :param akeyless: Akeyless configures this store to sync secrets using Akeyless Vault provider.
        :param alibaba: Alibaba configures this store to sync secrets using Alibaba Cloud provider.
        :param aws: AWS configures this store to sync secrets using AWS Secret Manager provider.
        :param azurekv: AzureKV configures this store to sync secrets using Azure Key Vault provider.
        :param fake: Fake configures a store with static key/value pairs.
        :param gcpsm: GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.
        :param gitlab: Gitlab configures this store to sync secrets using Gitlab Variables provider.
        :param ibm: IBM configures this store to sync secrets using IBM Cloud provider.
        :param kubernetes: Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.
        :param oracle: Oracle configures this store to sync secrets using Oracle Vault provider.
        :param vault: Vault configures this store to sync secrets using Hashi provider.
        :param webhook: Webhook configures this store to sync secrets using a generic templated webhook.
        :param yandexlockbox: YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :schema: ClusterSecretStoreSpecProvider
        '''
        if isinstance(akeyless, dict):
            akeyless = ClusterSecretStoreSpecProviderAkeyless(**akeyless)
        if isinstance(alibaba, dict):
            alibaba = ClusterSecretStoreSpecProviderAlibaba(**alibaba)
        if isinstance(aws, dict):
            aws = ClusterSecretStoreSpecProviderAws(**aws)
        if isinstance(azurekv, dict):
            azurekv = ClusterSecretStoreSpecProviderAzurekv(**azurekv)
        if isinstance(fake, dict):
            fake = ClusterSecretStoreSpecProviderFake(**fake)
        if isinstance(gcpsm, dict):
            gcpsm = ClusterSecretStoreSpecProviderGcpsm(**gcpsm)
        if isinstance(gitlab, dict):
            gitlab = ClusterSecretStoreSpecProviderGitlab(**gitlab)
        if isinstance(ibm, dict):
            ibm = ClusterSecretStoreSpecProviderIbm(**ibm)
        if isinstance(kubernetes, dict):
            kubernetes = ClusterSecretStoreSpecProviderKubernetes(**kubernetes)
        if isinstance(oracle, dict):
            oracle = ClusterSecretStoreSpecProviderOracle(**oracle)
        if isinstance(vault, dict):
            vault = ClusterSecretStoreSpecProviderVault(**vault)
        if isinstance(webhook, dict):
            webhook = ClusterSecretStoreSpecProviderWebhook(**webhook)
        if isinstance(yandexlockbox, dict):
            yandexlockbox = ClusterSecretStoreSpecProviderYandexlockbox(**yandexlockbox)
        if __debug__:
            def stub(
                *,
                akeyless: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAkeyless, typing.Dict[str, typing.Any]]] = None,
                alibaba: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAlibaba, typing.Dict[str, typing.Any]]] = None,
                aws: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAws, typing.Dict[str, typing.Any]]] = None,
                azurekv: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAzurekv, typing.Dict[str, typing.Any]]] = None,
                fake: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderFake, typing.Dict[str, typing.Any]]] = None,
                gcpsm: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderGcpsm, typing.Dict[str, typing.Any]]] = None,
                gitlab: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderGitlab, typing.Dict[str, typing.Any]]] = None,
                ibm: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderIbm, typing.Dict[str, typing.Any]]] = None,
                kubernetes: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderKubernetes, typing.Dict[str, typing.Any]]] = None,
                oracle: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderOracle, typing.Dict[str, typing.Any]]] = None,
                vault: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVault, typing.Dict[str, typing.Any]]] = None,
                webhook: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderWebhook, typing.Dict[str, typing.Any]]] = None,
                yandexlockbox: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderYandexlockbox, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument akeyless", value=akeyless, expected_type=type_hints["akeyless"])
            check_type(argname="argument alibaba", value=alibaba, expected_type=type_hints["alibaba"])
            check_type(argname="argument aws", value=aws, expected_type=type_hints["aws"])
            check_type(argname="argument azurekv", value=azurekv, expected_type=type_hints["azurekv"])
            check_type(argname="argument fake", value=fake, expected_type=type_hints["fake"])
            check_type(argname="argument gcpsm", value=gcpsm, expected_type=type_hints["gcpsm"])
            check_type(argname="argument gitlab", value=gitlab, expected_type=type_hints["gitlab"])
            check_type(argname="argument ibm", value=ibm, expected_type=type_hints["ibm"])
            check_type(argname="argument kubernetes", value=kubernetes, expected_type=type_hints["kubernetes"])
            check_type(argname="argument oracle", value=oracle, expected_type=type_hints["oracle"])
            check_type(argname="argument vault", value=vault, expected_type=type_hints["vault"])
            check_type(argname="argument webhook", value=webhook, expected_type=type_hints["webhook"])
            check_type(argname="argument yandexlockbox", value=yandexlockbox, expected_type=type_hints["yandexlockbox"])
        self._values: typing.Dict[str, typing.Any] = {}
        if akeyless is not None:
            self._values["akeyless"] = akeyless
        if alibaba is not None:
            self._values["alibaba"] = alibaba
        if aws is not None:
            self._values["aws"] = aws
        if azurekv is not None:
            self._values["azurekv"] = azurekv
        if fake is not None:
            self._values["fake"] = fake
        if gcpsm is not None:
            self._values["gcpsm"] = gcpsm
        if gitlab is not None:
            self._values["gitlab"] = gitlab
        if ibm is not None:
            self._values["ibm"] = ibm
        if kubernetes is not None:
            self._values["kubernetes"] = kubernetes
        if oracle is not None:
            self._values["oracle"] = oracle
        if vault is not None:
            self._values["vault"] = vault
        if webhook is not None:
            self._values["webhook"] = webhook
        if yandexlockbox is not None:
            self._values["yandexlockbox"] = yandexlockbox

    @builtins.property
    def akeyless(self) -> typing.Optional["ClusterSecretStoreSpecProviderAkeyless"]:
        '''Akeyless configures this store to sync secrets using Akeyless Vault provider.

        :schema: ClusterSecretStoreSpecProvider#akeyless
        '''
        result = self._values.get("akeyless")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAkeyless"], result)

    @builtins.property
    def alibaba(self) -> typing.Optional["ClusterSecretStoreSpecProviderAlibaba"]:
        '''Alibaba configures this store to sync secrets using Alibaba Cloud provider.

        :schema: ClusterSecretStoreSpecProvider#alibaba
        '''
        result = self._values.get("alibaba")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAlibaba"], result)

    @builtins.property
    def aws(self) -> typing.Optional["ClusterSecretStoreSpecProviderAws"]:
        '''AWS configures this store to sync secrets using AWS Secret Manager provider.

        :schema: ClusterSecretStoreSpecProvider#aws
        '''
        result = self._values.get("aws")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAws"], result)

    @builtins.property
    def azurekv(self) -> typing.Optional["ClusterSecretStoreSpecProviderAzurekv"]:
        '''AzureKV configures this store to sync secrets using Azure Key Vault provider.

        :schema: ClusterSecretStoreSpecProvider#azurekv
        '''
        result = self._values.get("azurekv")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAzurekv"], result)

    @builtins.property
    def fake(self) -> typing.Optional["ClusterSecretStoreSpecProviderFake"]:
        '''Fake configures a store with static key/value pairs.

        :schema: ClusterSecretStoreSpecProvider#fake
        '''
        result = self._values.get("fake")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderFake"], result)

    @builtins.property
    def gcpsm(self) -> typing.Optional["ClusterSecretStoreSpecProviderGcpsm"]:
        '''GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.

        :schema: ClusterSecretStoreSpecProvider#gcpsm
        '''
        result = self._values.get("gcpsm")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderGcpsm"], result)

    @builtins.property
    def gitlab(self) -> typing.Optional["ClusterSecretStoreSpecProviderGitlab"]:
        '''Gitlab configures this store to sync secrets using Gitlab Variables provider.

        :schema: ClusterSecretStoreSpecProvider#gitlab
        '''
        result = self._values.get("gitlab")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderGitlab"], result)

    @builtins.property
    def ibm(self) -> typing.Optional["ClusterSecretStoreSpecProviderIbm"]:
        '''IBM configures this store to sync secrets using IBM Cloud provider.

        :schema: ClusterSecretStoreSpecProvider#ibm
        '''
        result = self._values.get("ibm")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderIbm"], result)

    @builtins.property
    def kubernetes(self) -> typing.Optional["ClusterSecretStoreSpecProviderKubernetes"]:
        '''Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.

        :schema: ClusterSecretStoreSpecProvider#kubernetes
        '''
        result = self._values.get("kubernetes")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderKubernetes"], result)

    @builtins.property
    def oracle(self) -> typing.Optional["ClusterSecretStoreSpecProviderOracle"]:
        '''Oracle configures this store to sync secrets using Oracle Vault provider.

        :schema: ClusterSecretStoreSpecProvider#oracle
        '''
        result = self._values.get("oracle")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderOracle"], result)

    @builtins.property
    def vault(self) -> typing.Optional["ClusterSecretStoreSpecProviderVault"]:
        '''Vault configures this store to sync secrets using Hashi provider.

        :schema: ClusterSecretStoreSpecProvider#vault
        '''
        result = self._values.get("vault")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVault"], result)

    @builtins.property
    def webhook(self) -> typing.Optional["ClusterSecretStoreSpecProviderWebhook"]:
        '''Webhook configures this store to sync secrets using a generic templated webhook.

        :schema: ClusterSecretStoreSpecProvider#webhook
        '''
        result = self._values.get("webhook")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderWebhook"], result)

    @builtins.property
    def yandexlockbox(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderYandexlockbox"]:
        '''YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :schema: ClusterSecretStoreSpecProvider#yandexlockbox
        '''
        result = self._values.get("yandexlockbox")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderYandexlockbox"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAkeyless",
    jsii_struct_bases=[],
    name_mapping={
        "akeyless_gw_api_url": "akeylessGwApiUrl",
        "auth_secret_ref": "authSecretRef",
    },
)
class ClusterSecretStoreSpecProviderAkeyless:
    def __init__(
        self,
        *,
        akeyless_gw_api_url: builtins.str,
        auth_secret_ref: typing.Union["ClusterSecretStoreSpecProviderAkeylessAuthSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''Akeyless configures this store to sync secrets using Akeyless Vault provider.

        :param akeyless_gw_api_url: Akeyless GW API Url from which the secrets to be fetched from.
        :param auth_secret_ref: Auth configures how the operator authenticates with Akeyless.

        :schema: ClusterSecretStoreSpecProviderAkeyless
        '''
        if isinstance(auth_secret_ref, dict):
            auth_secret_ref = ClusterSecretStoreSpecProviderAkeylessAuthSecretRef(**auth_secret_ref)
        if __debug__:
            def stub(
                *,
                akeyless_gw_api_url: builtins.str,
                auth_secret_ref: typing.Union[ClusterSecretStoreSpecProviderAkeylessAuthSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument akeyless_gw_api_url", value=akeyless_gw_api_url, expected_type=type_hints["akeyless_gw_api_url"])
            check_type(argname="argument auth_secret_ref", value=auth_secret_ref, expected_type=type_hints["auth_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "akeyless_gw_api_url": akeyless_gw_api_url,
            "auth_secret_ref": auth_secret_ref,
        }

    @builtins.property
    def akeyless_gw_api_url(self) -> builtins.str:
        '''Akeyless GW API Url from which the secrets to be fetched from.

        :schema: ClusterSecretStoreSpecProviderAkeyless#akeylessGWApiURL
        '''
        result = self._values.get("akeyless_gw_api_url")
        assert result is not None, "Required property 'akeyless_gw_api_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth_secret_ref(self) -> "ClusterSecretStoreSpecProviderAkeylessAuthSecretRef":
        '''Auth configures how the operator authenticates with Akeyless.

        :schema: ClusterSecretStoreSpecProviderAkeyless#authSecretRef
        '''
        result = self._values.get("auth_secret_ref")
        assert result is not None, "Required property 'auth_secret_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderAkeylessAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAkeyless(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAkeylessAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"kubernetes_auth": "kubernetesAuth", "secret_ref": "secretRef"},
)
class ClusterSecretStoreSpecProviderAkeylessAuthSecretRef:
    def __init__(
        self,
        *,
        kubernetes_auth: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth", typing.Dict[str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how the operator authenticates with Akeyless.

        :param kubernetes_auth: Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
        :param secret_ref: Reference to a Secret that contains the details to authenticate with Akeyless.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRef
        '''
        if isinstance(kubernetes_auth, dict):
            kubernetes_auth = ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth(**kubernetes_auth)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                kubernetes_auth: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth, typing.Dict[str, typing.Any]]] = None,
                secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument kubernetes_auth", value=kubernetes_auth, expected_type=type_hints["kubernetes_auth"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if kubernetes_auth is not None:
            self._values["kubernetes_auth"] = kubernetes_auth
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def kubernetes_auth(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth"]:
        '''Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRef#kubernetesAuth
        '''
        result = self._values.get("kubernetes_auth")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef"]:
        '''Reference to a Secret that contains the details to authenticate with Akeyless.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRef#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAkeylessAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth",
    jsii_struct_bases=[],
    name_mapping={
        "access_id": "accessId",
        "k8_s_conf_name": "k8SConfName",
        "secret_ref": "secretRef",
        "service_account_ref": "serviceAccountRef",
    },
)
class ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth:
    def __init__(
        self,
        *,
        access_id: builtins.str,
        k8_s_conf_name: builtins.str,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef", typing.Dict[str, typing.Any]]] = None,
        service_account_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.

        :param access_id: the Akeyless Kubernetes auth-method access-id.
        :param k8_s_conf_name: Kubernetes-auth configuration name in Akeyless-Gateway.
        :param secret_ref: Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.
        :param service_account_ref: Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(**secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                access_id: builtins.str,
                k8_s_conf_name: builtins.str,
                secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef, typing.Dict[str, typing.Any]]] = None,
                service_account_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument access_id", value=access_id, expected_type=type_hints["access_id"])
            check_type(argname="argument k8_s_conf_name", value=k8_s_conf_name, expected_type=type_hints["k8_s_conf_name"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "access_id": access_id,
            "k8_s_conf_name": k8_s_conf_name,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def access_id(self) -> builtins.str:
        '''the Akeyless Kubernetes auth-method access-id.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#accessID
        '''
        result = self._values.get("access_id")
        assert result is not None, "Required property 'access_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def k8_s_conf_name(self) -> builtins.str:
        '''Kubernetes-auth configuration name in Akeyless-Gateway.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#k8sConfName
        '''
        result = self._values.get("k8_s_conf_name")
        assert result is not None, "Required property 'k8_s_conf_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef"]:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless.

        If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef"]:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless.

        If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_id": "accessId",
        "access_type": "accessType",
        "access_type_param": "accessTypeParam",
    },
)
class ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef:
    def __init__(
        self,
        *,
        access_id: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId", typing.Dict[str, typing.Any]]] = None,
        access_type: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType", typing.Dict[str, typing.Any]]] = None,
        access_type_param: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Reference to a Secret that contains the details to authenticate with Akeyless.

        :param access_id: The SecretAccessID is used for authentication.
        :param access_type: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.
        :param access_type_param: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef
        '''
        if isinstance(access_id, dict):
            access_id = ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId(**access_id)
        if isinstance(access_type, dict):
            access_type = ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType(**access_type)
        if isinstance(access_type_param, dict):
            access_type_param = ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(**access_type_param)
        if __debug__:
            def stub(
                *,
                access_id: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId, typing.Dict[str, typing.Any]]] = None,
                access_type: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType, typing.Dict[str, typing.Any]]] = None,
                access_type_param: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument access_id", value=access_id, expected_type=type_hints["access_id"])
            check_type(argname="argument access_type", value=access_type, expected_type=type_hints["access_type"])
            check_type(argname="argument access_type_param", value=access_type_param, expected_type=type_hints["access_type_param"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_id is not None:
            self._values["access_id"] = access_id
        if access_type is not None:
            self._values["access_type"] = access_type
        if access_type_param is not None:
            self._values["access_type_param"] = access_type_param

    @builtins.property
    def access_id(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId"]:
        '''The SecretAccessID is used for authentication.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessID
        '''
        result = self._values.get("access_id")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId"], result)

    @builtins.property
    def access_type(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessType
        '''
        result = self._values.get("access_type")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType"], result)

    @builtins.property
    def access_type_param(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessTypeParam
        '''
        result = self._values.get("access_type_param")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessID is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAlibaba",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "region_id": "regionId", "endpoint": "endpoint"},
)
class ClusterSecretStoreSpecProviderAlibaba:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreSpecProviderAlibabaAuth", typing.Dict[str, typing.Any]],
        region_id: builtins.str,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Alibaba configures this store to sync secrets using Alibaba Cloud provider.

        :param auth: AlibabaAuth contains a secretRef for credentials.
        :param region_id: Alibaba Region to be used for the provider.
        :param endpoint: 

        :schema: ClusterSecretStoreSpecProviderAlibaba
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreSpecProviderAlibabaAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[ClusterSecretStoreSpecProviderAlibabaAuth, typing.Dict[str, typing.Any]],
                region_id: builtins.str,
                endpoint: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument region_id", value=region_id, expected_type=type_hints["region_id"])
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
            "region_id": region_id,
        }
        if endpoint is not None:
            self._values["endpoint"] = endpoint

    @builtins.property
    def auth(self) -> "ClusterSecretStoreSpecProviderAlibabaAuth":
        '''AlibabaAuth contains a secretRef for credentials.

        :schema: ClusterSecretStoreSpecProviderAlibaba#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderAlibabaAuth", result)

    @builtins.property
    def region_id(self) -> builtins.str:
        '''Alibaba Region to be used for the provider.

        :schema: ClusterSecretStoreSpecProviderAlibaba#regionID
        '''
        result = self._values.get("region_id")
        assert result is not None, "Required property 'region_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def endpoint(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreSpecProviderAlibaba#endpoint
        '''
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAlibaba(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAlibabaAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class ClusterSecretStoreSpecProviderAlibabaAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreSpecProviderAlibabaAuthSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''AlibabaAuth contains a secretRef for credentials.

        :param secret_ref: AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderAlibabaAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Union[ClusterSecretStoreSpecProviderAlibabaAuthSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "ClusterSecretStoreSpecProviderAlibabaAuthSecretRef":
        '''AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderAlibabaAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAlibabaAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAlibabaAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_key_id_secret_ref": "accessKeyIdSecretRef",
        "access_key_secret_secret_ref": "accessKeySecretSecretRef",
    },
)
class ClusterSecretStoreSpecProviderAlibabaAuthSecretRef:
    def __init__(
        self,
        *,
        access_key_id_secret_ref: typing.Union["ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef", typing.Dict[str, typing.Any]],
        access_key_secret_secret_ref: typing.Union["ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :param access_key_id_secret_ref: The AccessKeyID is used for authentication.
        :param access_key_secret_secret_ref: The AccessKeySecret is used for authentication.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRef
        '''
        if isinstance(access_key_id_secret_ref, dict):
            access_key_id_secret_ref = ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(**access_key_id_secret_ref)
        if isinstance(access_key_secret_secret_ref, dict):
            access_key_secret_secret_ref = ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(**access_key_secret_secret_ref)
        if __debug__:
            def stub(
                *,
                access_key_id_secret_ref: typing.Union[ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef, typing.Dict[str, typing.Any]],
                access_key_secret_secret_ref: typing.Union[ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument access_key_id_secret_ref", value=access_key_id_secret_ref, expected_type=type_hints["access_key_id_secret_ref"])
            check_type(argname="argument access_key_secret_secret_ref", value=access_key_secret_secret_ref, expected_type=type_hints["access_key_secret_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "access_key_id_secret_ref": access_key_id_secret_ref,
            "access_key_secret_secret_ref": access_key_secret_secret_ref,
        }

    @builtins.property
    def access_key_id_secret_ref(
        self,
    ) -> "ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef":
        '''The AccessKeyID is used for authentication.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRef#accessKeyIDSecretRef
        '''
        result = self._values.get("access_key_id_secret_ref")
        assert result is not None, "Required property 'access_key_id_secret_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef", result)

    @builtins.property
    def access_key_secret_secret_ref(
        self,
    ) -> "ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef":
        '''The AccessKeySecret is used for authentication.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRef#accessKeySecretSecretRef
        '''
        result = self._values.get("access_key_secret_secret_ref")
        assert result is not None, "Required property 'access_key_secret_secret_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAlibabaAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeyID is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeySecret is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAws",
    jsii_struct_bases=[],
    name_mapping={
        "region": "region",
        "service": "service",
        "auth": "auth",
        "role": "role",
    },
)
class ClusterSecretStoreSpecProviderAws:
    def __init__(
        self,
        *,
        region: builtins.str,
        service: "ClusterSecretStoreSpecProviderAwsService",
        auth: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAwsAuth", typing.Dict[str, typing.Any]]] = None,
        role: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AWS configures this store to sync secrets using AWS Secret Manager provider.

        :param region: AWS Region to be used for the provider.
        :param service: Service defines which service should be used to fetch the secrets.
        :param auth: Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.
        :param role: Role is a Role ARN which the SecretManager provider will assume.

        :schema: ClusterSecretStoreSpecProviderAws
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreSpecProviderAwsAuth(**auth)
        if __debug__:
            def stub(
                *,
                region: builtins.str,
                service: ClusterSecretStoreSpecProviderAwsService,
                auth: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAwsAuth, typing.Dict[str, typing.Any]]] = None,
                role: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
        self._values: typing.Dict[str, typing.Any] = {
            "region": region,
            "service": service,
        }
        if auth is not None:
            self._values["auth"] = auth
        if role is not None:
            self._values["role"] = role

    @builtins.property
    def region(self) -> builtins.str:
        '''AWS Region to be used for the provider.

        :schema: ClusterSecretStoreSpecProviderAws#region
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service(self) -> "ClusterSecretStoreSpecProviderAwsService":
        '''Service defines which service should be used to fetch the secrets.

        :schema: ClusterSecretStoreSpecProviderAws#service
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderAwsService", result)

    @builtins.property
    def auth(self) -> typing.Optional["ClusterSecretStoreSpecProviderAwsAuth"]:
        '''Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.

        :schema: ClusterSecretStoreSpecProviderAws#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAwsAuth"], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a Role ARN which the SecretManager provider will assume.

        :schema: ClusterSecretStoreSpecProviderAws#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAws(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAwsAuth",
    jsii_struct_bases=[],
    name_mapping={"jwt": "jwt", "secret_ref": "secretRef"},
)
class ClusterSecretStoreSpecProviderAwsAuth:
    def __init__(
        self,
        *,
        jwt: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAwsAuthJwt", typing.Dict[str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAwsAuthSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.

        :param jwt: Authenticate against AWS using service account tokens.
        :param secret_ref: AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :schema: ClusterSecretStoreSpecProviderAwsAuth
        '''
        if isinstance(jwt, dict):
            jwt = ClusterSecretStoreSpecProviderAwsAuthJwt(**jwt)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderAwsAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                jwt: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAwsAuthJwt, typing.Dict[str, typing.Any]]] = None,
                secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAwsAuthSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument jwt", value=jwt, expected_type=type_hints["jwt"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if jwt is not None:
            self._values["jwt"] = jwt
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def jwt(self) -> typing.Optional["ClusterSecretStoreSpecProviderAwsAuthJwt"]:
        '''Authenticate against AWS using service account tokens.

        :schema: ClusterSecretStoreSpecProviderAwsAuth#jwt
        '''
        result = self._values.get("jwt")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAwsAuthJwt"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAwsAuthSecretRef"]:
        '''AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :schema: ClusterSecretStoreSpecProviderAwsAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAwsAuthSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAwsAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAwsAuthJwt",
    jsii_struct_bases=[],
    name_mapping={"service_account_ref": "serviceAccountRef"},
)
class ClusterSecretStoreSpecProviderAwsAuthJwt:
    def __init__(
        self,
        *,
        service_account_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Authenticate against AWS using service account tokens.

        :param service_account_ref: A reference to a ServiceAccount resource.

        :schema: ClusterSecretStoreSpecProviderAwsAuthJwt
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                service_account_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef"]:
        '''A reference to a ServiceAccount resource.

        :schema: ClusterSecretStoreSpecProviderAwsAuthJwt#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAwsAuthJwt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAwsAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_key_id_secret_ref": "accessKeyIdSecretRef",
        "secret_access_key_secret_ref": "secretAccessKeySecretRef",
    },
)
class ClusterSecretStoreSpecProviderAwsAuthSecretRef:
    def __init__(
        self,
        *,
        access_key_id_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef", typing.Dict[str, typing.Any]]] = None,
        secret_access_key_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :param access_key_id_secret_ref: The AccessKeyID is used for authentication.
        :param secret_access_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRef
        '''
        if isinstance(access_key_id_secret_ref, dict):
            access_key_id_secret_ref = ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(**access_key_id_secret_ref)
        if isinstance(secret_access_key_secret_ref, dict):
            secret_access_key_secret_ref = ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(**secret_access_key_secret_ref)
        if __debug__:
            def stub(
                *,
                access_key_id_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef, typing.Dict[str, typing.Any]]] = None,
                secret_access_key_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument access_key_id_secret_ref", value=access_key_id_secret_ref, expected_type=type_hints["access_key_id_secret_ref"])
            check_type(argname="argument secret_access_key_secret_ref", value=secret_access_key_secret_ref, expected_type=type_hints["secret_access_key_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_key_id_secret_ref is not None:
            self._values["access_key_id_secret_ref"] = access_key_id_secret_ref
        if secret_access_key_secret_ref is not None:
            self._values["secret_access_key_secret_ref"] = secret_access_key_secret_ref

    @builtins.property
    def access_key_id_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef"]:
        '''The AccessKeyID is used for authentication.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRef#accessKeyIDSecretRef
        '''
        result = self._values.get("access_key_id_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef"], result)

    @builtins.property
    def secret_access_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRef#secretAccessKeySecretRef
        '''
        result = self._values.get("secret_access_key_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAwsAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeyID is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAwsService")
class ClusterSecretStoreSpecProviderAwsService(enum.Enum):
    '''Service defines which service should be used to fetch the secrets.

    :schema: ClusterSecretStoreSpecProviderAwsService
    '''

    SECRETS_MANAGER = "SECRETS_MANAGER"
    '''SecretsManager.'''
    PARAMETER_STORE = "PARAMETER_STORE"
    '''ParameterStore.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAzurekv",
    jsii_struct_bases=[],
    name_mapping={
        "vault_url": "vaultUrl",
        "auth_secret_ref": "authSecretRef",
        "auth_type": "authType",
        "identity_id": "identityId",
        "service_account_ref": "serviceAccountRef",
        "tenant_id": "tenantId",
    },
)
class ClusterSecretStoreSpecProviderAzurekv:
    def __init__(
        self,
        *,
        vault_url: builtins.str,
        auth_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAzurekvAuthSecretRef", typing.Dict[str, typing.Any]]] = None,
        auth_type: typing.Optional["ClusterSecretStoreSpecProviderAzurekvAuthType"] = None,
        identity_id: typing.Optional[builtins.str] = None,
        service_account_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAzurekvServiceAccountRef", typing.Dict[str, typing.Any]]] = None,
        tenant_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AzureKV configures this store to sync secrets using Azure Key Vault provider.

        :param vault_url: Vault Url from which the secrets to be fetched from.
        :param auth_secret_ref: Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type.
        :param auth_type: Auth type defines how to authenticate to the keyvault service. Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
        :param identity_id: If multiple Managed Identity is assigned to the pod, you can select the one to be used.
        :param service_account_ref: ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
        :param tenant_id: TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type.

        :schema: ClusterSecretStoreSpecProviderAzurekv
        '''
        if isinstance(auth_secret_ref, dict):
            auth_secret_ref = ClusterSecretStoreSpecProviderAzurekvAuthSecretRef(**auth_secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreSpecProviderAzurekvServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                vault_url: builtins.str,
                auth_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAzurekvAuthSecretRef, typing.Dict[str, typing.Any]]] = None,
                auth_type: typing.Optional[ClusterSecretStoreSpecProviderAzurekvAuthType] = None,
                identity_id: typing.Optional[builtins.str] = None,
                service_account_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAzurekvServiceAccountRef, typing.Dict[str, typing.Any]]] = None,
                tenant_id: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument vault_url", value=vault_url, expected_type=type_hints["vault_url"])
            check_type(argname="argument auth_secret_ref", value=auth_secret_ref, expected_type=type_hints["auth_secret_ref"])
            check_type(argname="argument auth_type", value=auth_type, expected_type=type_hints["auth_type"])
            check_type(argname="argument identity_id", value=identity_id, expected_type=type_hints["identity_id"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument tenant_id", value=tenant_id, expected_type=type_hints["tenant_id"])
        self._values: typing.Dict[str, typing.Any] = {
            "vault_url": vault_url,
        }
        if auth_secret_ref is not None:
            self._values["auth_secret_ref"] = auth_secret_ref
        if auth_type is not None:
            self._values["auth_type"] = auth_type
        if identity_id is not None:
            self._values["identity_id"] = identity_id
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref
        if tenant_id is not None:
            self._values["tenant_id"] = tenant_id

    @builtins.property
    def vault_url(self) -> builtins.str:
        '''Vault Url from which the secrets to be fetched from.

        :schema: ClusterSecretStoreSpecProviderAzurekv#vaultUrl
        '''
        result = self._values.get("vault_url")
        assert result is not None, "Required property 'vault_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAzurekvAuthSecretRef"]:
        '''Auth configures how the operator authenticates with Azure.

        Required for ServicePrincipal auth type.

        :schema: ClusterSecretStoreSpecProviderAzurekv#authSecretRef
        '''
        result = self._values.get("auth_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAzurekvAuthSecretRef"], result)

    @builtins.property
    def auth_type(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAzurekvAuthType"]:
        '''Auth type defines how to authenticate to the keyvault service.

        Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)

        :schema: ClusterSecretStoreSpecProviderAzurekv#authType
        '''
        result = self._values.get("auth_type")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAzurekvAuthType"], result)

    @builtins.property
    def identity_id(self) -> typing.Optional[builtins.str]:
        '''If multiple Managed Identity is assigned to the pod, you can select the one to be used.

        :schema: ClusterSecretStoreSpecProviderAzurekv#identityId
        '''
        result = self._values.get("identity_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAzurekvServiceAccountRef"]:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :schema: ClusterSecretStoreSpecProviderAzurekv#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAzurekvServiceAccountRef"], result)

    @builtins.property
    def tenant_id(self) -> typing.Optional[builtins.str]:
        '''TenantID configures the Azure Tenant to send requests to.

        Required for ServicePrincipal auth type.

        :schema: ClusterSecretStoreSpecProviderAzurekv#tenantId
        '''
        result = self._values.get("tenant_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAzurekv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAzurekvAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"client_id": "clientId", "client_secret": "clientSecret"},
)
class ClusterSecretStoreSpecProviderAzurekvAuthSecretRef:
    def __init__(
        self,
        *,
        client_id: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId", typing.Dict[str, typing.Any]]] = None,
        client_secret: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how the operator authenticates with Azure.

        Required for ServicePrincipal auth type.

        :param client_id: The Azure clientId of the service principle used for authentication.
        :param client_secret: The Azure ClientSecret of the service principle used for authentication.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRef
        '''
        if isinstance(client_id, dict):
            client_id = ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId(**client_id)
        if isinstance(client_secret, dict):
            client_secret = ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret(**client_secret)
        if __debug__:
            def stub(
                *,
                client_id: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId, typing.Dict[str, typing.Any]]] = None,
                client_secret: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret", value=client_secret, expected_type=type_hints["client_secret"])
        self._values: typing.Dict[str, typing.Any] = {}
        if client_id is not None:
            self._values["client_id"] = client_id
        if client_secret is not None:
            self._values["client_secret"] = client_secret

    @builtins.property
    def client_id(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId"]:
        '''The Azure clientId of the service principle used for authentication.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRef#clientId
        '''
        result = self._values.get("client_id")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId"], result)

    @builtins.property
    def client_secret(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret"]:
        '''The Azure ClientSecret of the service principle used for authentication.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRef#clientSecret
        '''
        result = self._values.get("client_secret")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAzurekvAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Azure clientId of the service principle used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Azure ClientSecret of the service principle used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAzurekvAuthType"
)
class ClusterSecretStoreSpecProviderAzurekvAuthType(enum.Enum):
    '''Auth type defines how to authenticate to the keyvault service.

    Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)

    :schema: ClusterSecretStoreSpecProviderAzurekvAuthType
    '''

    SERVICE_PRINCIPAL = "SERVICE_PRINCIPAL"
    '''ServicePrincipal.'''
    MANAGED_IDENTITY = "MANAGED_IDENTITY"
    '''ManagedIdentity.'''
    WORKLOAD_IDENTITY = "WORKLOAD_IDENTITY"
    '''WorkloadIdentity.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderAzurekvServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderAzurekvServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAzurekvServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreSpecProviderAzurekvServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreSpecProviderAzurekvServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderAzurekvServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderAzurekvServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderFake",
    jsii_struct_bases=[],
    name_mapping={"data": "data"},
)
class ClusterSecretStoreSpecProviderFake:
    def __init__(
        self,
        *,
        data: typing.Sequence[typing.Union["ClusterSecretStoreSpecProviderFakeData", typing.Dict[str, typing.Any]]],
    ) -> None:
        '''Fake configures a store with static key/value pairs.

        :param data: 

        :schema: ClusterSecretStoreSpecProviderFake
        '''
        if __debug__:
            def stub(
                *,
                data: typing.Sequence[typing.Union[ClusterSecretStoreSpecProviderFakeData, typing.Dict[str, typing.Any]]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
        self._values: typing.Dict[str, typing.Any] = {
            "data": data,
        }

    @builtins.property
    def data(self) -> typing.List["ClusterSecretStoreSpecProviderFakeData"]:
        '''
        :schema: ClusterSecretStoreSpecProviderFake#data
        '''
        result = self._values.get("data")
        assert result is not None, "Required property 'data' is missing"
        return typing.cast(typing.List["ClusterSecretStoreSpecProviderFakeData"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderFake(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderFakeData",
    jsii_struct_bases=[],
    name_mapping={
        "key": "key",
        "value": "value",
        "value_map": "valueMap",
        "version": "version",
    },
)
class ClusterSecretStoreSpecProviderFakeData:
    def __init__(
        self,
        *,
        key: builtins.str,
        value: typing.Optional[builtins.str] = None,
        value_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param key: 
        :param value: 
        :param value_map: 
        :param version: 

        :schema: ClusterSecretStoreSpecProviderFakeData
        '''
        if __debug__:
            def stub(
                *,
                key: builtins.str,
                value: typing.Optional[builtins.str] = None,
                value_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
                version: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            check_type(argname="argument value_map", value=value_map, expected_type=type_hints["value_map"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }
        if value is not None:
            self._values["value"] = value
        if value_map is not None:
            self._values["value_map"] = value_map
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreSpecProviderFakeData#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreSpecProviderFakeData#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value_map(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ClusterSecretStoreSpecProviderFakeData#valueMap
        '''
        result = self._values.get("value_map")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreSpecProviderFakeData#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderFakeData(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderGcpsm",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "project_id": "projectId"},
)
class ClusterSecretStoreSpecProviderGcpsm:
    def __init__(
        self,
        *,
        auth: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderGcpsmAuth", typing.Dict[str, typing.Any]]] = None,
        project_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.

        :param auth: Auth defines the information necessary to authenticate against GCP.
        :param project_id: ProjectID project where secret is located.

        :schema: ClusterSecretStoreSpecProviderGcpsm
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreSpecProviderGcpsmAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderGcpsmAuth, typing.Dict[str, typing.Any]]] = None,
                project_id: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
        self._values: typing.Dict[str, typing.Any] = {}
        if auth is not None:
            self._values["auth"] = auth
        if project_id is not None:
            self._values["project_id"] = project_id

    @builtins.property
    def auth(self) -> typing.Optional["ClusterSecretStoreSpecProviderGcpsmAuth"]:
        '''Auth defines the information necessary to authenticate against GCP.

        :schema: ClusterSecretStoreSpecProviderGcpsm#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderGcpsmAuth"], result)

    @builtins.property
    def project_id(self) -> typing.Optional[builtins.str]:
        '''ProjectID project where secret is located.

        :schema: ClusterSecretStoreSpecProviderGcpsm#projectID
        '''
        result = self._values.get("project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderGcpsm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderGcpsmAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "workload_identity": "workloadIdentity"},
)
class ClusterSecretStoreSpecProviderGcpsmAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderGcpsmAuthSecretRef", typing.Dict[str, typing.Any]]] = None,
        workload_identity: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against GCP.

        :param secret_ref: 
        :param workload_identity: 

        :schema: ClusterSecretStoreSpecProviderGcpsmAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderGcpsmAuthSecretRef(**secret_ref)
        if isinstance(workload_identity, dict):
            workload_identity = ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity(**workload_identity)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderGcpsmAuthSecretRef, typing.Dict[str, typing.Any]]] = None,
                workload_identity: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument workload_identity", value=workload_identity, expected_type=type_hints["workload_identity"])
        self._values: typing.Dict[str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if workload_identity is not None:
            self._values["workload_identity"] = workload_identity

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderGcpsmAuthSecretRef"]:
        '''
        :schema: ClusterSecretStoreSpecProviderGcpsmAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderGcpsmAuthSecretRef"], result)

    @builtins.property
    def workload_identity(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity"]:
        '''
        :schema: ClusterSecretStoreSpecProviderGcpsmAuth#workloadIdentity
        '''
        result = self._values.get("workload_identity")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderGcpsmAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderGcpsmAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"secret_access_key_secret_ref": "secretAccessKeySecretRef"},
)
class ClusterSecretStoreSpecProviderGcpsmAuthSecretRef:
    def __init__(
        self,
        *,
        secret_access_key_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param secret_access_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthSecretRef
        '''
        if isinstance(secret_access_key_secret_ref, dict):
            secret_access_key_secret_ref = ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(**secret_access_key_secret_ref)
        if __debug__:
            def stub(
                *,
                secret_access_key_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_access_key_secret_ref", value=secret_access_key_secret_ref, expected_type=type_hints["secret_access_key_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if secret_access_key_secret_ref is not None:
            self._values["secret_access_key_secret_ref"] = secret_access_key_secret_ref

    @builtins.property
    def secret_access_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthSecretRef#secretAccessKeySecretRef
        '''
        result = self._values.get("secret_access_key_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderGcpsmAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity",
    jsii_struct_bases=[],
    name_mapping={
        "cluster_location": "clusterLocation",
        "cluster_name": "clusterName",
        "service_account_ref": "serviceAccountRef",
        "cluster_project_id": "clusterProjectId",
    },
)
class ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity:
    def __init__(
        self,
        *,
        cluster_location: builtins.str,
        cluster_name: builtins.str,
        service_account_ref: typing.Union["ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef", typing.Dict[str, typing.Any]],
        cluster_project_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param cluster_location: 
        :param cluster_name: 
        :param service_account_ref: A reference to a ServiceAccount resource.
        :param cluster_project_id: 

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                cluster_location: builtins.str,
                cluster_name: builtins.str,
                service_account_ref: typing.Union[ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef, typing.Dict[str, typing.Any]],
                cluster_project_id: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument cluster_location", value=cluster_location, expected_type=type_hints["cluster_location"])
            check_type(argname="argument cluster_name", value=cluster_name, expected_type=type_hints["cluster_name"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument cluster_project_id", value=cluster_project_id, expected_type=type_hints["cluster_project_id"])
        self._values: typing.Dict[str, typing.Any] = {
            "cluster_location": cluster_location,
            "cluster_name": cluster_name,
            "service_account_ref": service_account_ref,
        }
        if cluster_project_id is not None:
            self._values["cluster_project_id"] = cluster_project_id

    @builtins.property
    def cluster_location(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterLocation
        '''
        result = self._values.get("cluster_location")
        assert result is not None, "Required property 'cluster_location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cluster_name(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterName
        '''
        result = self._values.get("cluster_name")
        assert result is not None, "Required property 'cluster_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> "ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef":
        '''A reference to a ServiceAccount resource.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        assert result is not None, "Required property 'service_account_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef", result)

    @builtins.property
    def cluster_project_id(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterProjectID
        '''
        result = self._values.get("cluster_project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderGitlab",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "project_id": "projectId", "url": "url"},
)
class ClusterSecretStoreSpecProviderGitlab:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreSpecProviderGitlabAuth", typing.Dict[str, typing.Any]],
        project_id: typing.Optional[builtins.str] = None,
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Gitlab configures this store to sync secrets using Gitlab Variables provider.

        :param auth: Auth configures how secret-manager authenticates with a GitLab instance.
        :param project_id: ProjectID specifies a project where secrets are located.
        :param url: URL configures the GitLab instance URL. Defaults to https://gitlab.com/. Default: https://gitlab.com/.

        :schema: ClusterSecretStoreSpecProviderGitlab
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreSpecProviderGitlabAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[ClusterSecretStoreSpecProviderGitlabAuth, typing.Dict[str, typing.Any]],
                project_id: typing.Optional[builtins.str] = None,
                url: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
        }
        if project_id is not None:
            self._values["project_id"] = project_id
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def auth(self) -> "ClusterSecretStoreSpecProviderGitlabAuth":
        '''Auth configures how secret-manager authenticates with a GitLab instance.

        :schema: ClusterSecretStoreSpecProviderGitlab#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderGitlabAuth", result)

    @builtins.property
    def project_id(self) -> typing.Optional[builtins.str]:
        '''ProjectID specifies a project where secrets are located.

        :schema: ClusterSecretStoreSpecProviderGitlab#projectID
        '''
        result = self._values.get("project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''URL configures the GitLab instance URL.

        Defaults to https://gitlab.com/.

        :default: https://gitlab.com/.

        :schema: ClusterSecretStoreSpecProviderGitlab#url
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderGitlab(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderGitlabAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class ClusterSecretStoreSpecProviderGitlabAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreSpecProviderGitlabAuthSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''Auth configures how secret-manager authenticates with a GitLab instance.

        :param secret_ref: 

        :schema: ClusterSecretStoreSpecProviderGitlabAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderGitlabAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Union[ClusterSecretStoreSpecProviderGitlabAuthSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "ClusterSecretStoreSpecProviderGitlabAuthSecretRef":
        '''
        :schema: ClusterSecretStoreSpecProviderGitlabAuth#SecretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderGitlabAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderGitlabAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderGitlabAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"access_token": "accessToken"},
)
class ClusterSecretStoreSpecProviderGitlabAuthSecretRef:
    def __init__(
        self,
        *,
        access_token: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param access_token: AccessToken is used for authentication.

        :schema: ClusterSecretStoreSpecProviderGitlabAuthSecretRef
        '''
        if isinstance(access_token, dict):
            access_token = ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken(**access_token)
        if __debug__:
            def stub(
                *,
                access_token: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument access_token", value=access_token, expected_type=type_hints["access_token"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_token is not None:
            self._values["access_token"] = access_token

    @builtins.property
    def access_token(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken"]:
        '''AccessToken is used for authentication.

        :schema: ClusterSecretStoreSpecProviderGitlabAuthSecretRef#accessToken
        '''
        result = self._values.get("access_token")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderGitlabAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AccessToken is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderIbm",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "service_url": "serviceUrl"},
)
class ClusterSecretStoreSpecProviderIbm:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreSpecProviderIbmAuth", typing.Dict[str, typing.Any]],
        service_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''IBM configures this store to sync secrets using IBM Cloud provider.

        :param auth: Auth configures how secret-manager authenticates with the IBM secrets manager.
        :param service_url: ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance.

        :schema: ClusterSecretStoreSpecProviderIbm
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreSpecProviderIbmAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[ClusterSecretStoreSpecProviderIbmAuth, typing.Dict[str, typing.Any]],
                service_url: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument service_url", value=service_url, expected_type=type_hints["service_url"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
        }
        if service_url is not None:
            self._values["service_url"] = service_url

    @builtins.property
    def auth(self) -> "ClusterSecretStoreSpecProviderIbmAuth":
        '''Auth configures how secret-manager authenticates with the IBM secrets manager.

        :schema: ClusterSecretStoreSpecProviderIbm#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderIbmAuth", result)

    @builtins.property
    def service_url(self) -> typing.Optional[builtins.str]:
        '''ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance.

        :schema: ClusterSecretStoreSpecProviderIbm#serviceUrl
        '''
        result = self._values.get("service_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderIbm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderIbmAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class ClusterSecretStoreSpecProviderIbmAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreSpecProviderIbmAuthSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''Auth configures how secret-manager authenticates with the IBM secrets manager.

        :param secret_ref: 

        :schema: ClusterSecretStoreSpecProviderIbmAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderIbmAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Union[ClusterSecretStoreSpecProviderIbmAuthSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "ClusterSecretStoreSpecProviderIbmAuthSecretRef":
        '''
        :schema: ClusterSecretStoreSpecProviderIbmAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderIbmAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderIbmAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderIbmAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"secret_api_key_secret_ref": "secretApiKeySecretRef"},
)
class ClusterSecretStoreSpecProviderIbmAuthSecretRef:
    def __init__(
        self,
        *,
        secret_api_key_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param secret_api_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreSpecProviderIbmAuthSecretRef
        '''
        if isinstance(secret_api_key_secret_ref, dict):
            secret_api_key_secret_ref = ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef(**secret_api_key_secret_ref)
        if __debug__:
            def stub(
                *,
                secret_api_key_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_api_key_secret_ref", value=secret_api_key_secret_ref, expected_type=type_hints["secret_api_key_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if secret_api_key_secret_ref is not None:
            self._values["secret_api_key_secret_ref"] = secret_api_key_secret_ref

    @builtins.property
    def secret_api_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreSpecProviderIbmAuthSecretRef#secretApiKeySecretRef
        '''
        result = self._values.get("secret_api_key_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderIbmAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetes",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "remote_namespace": "remoteNamespace",
        "server": "server",
    },
)
class ClusterSecretStoreSpecProviderKubernetes:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreSpecProviderKubernetesAuth", typing.Dict[str, typing.Any]],
        remote_namespace: typing.Optional[builtins.str] = None,
        server: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderKubernetesServer", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.

        :param auth: Auth configures how secret-manager authenticates with a Kubernetes instance.
        :param remote_namespace: Remote namespace to fetch the secrets from.
        :param server: configures the Kubernetes server Address.

        :schema: ClusterSecretStoreSpecProviderKubernetes
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreSpecProviderKubernetesAuth(**auth)
        if isinstance(server, dict):
            server = ClusterSecretStoreSpecProviderKubernetesServer(**server)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[ClusterSecretStoreSpecProviderKubernetesAuth, typing.Dict[str, typing.Any]],
                remote_namespace: typing.Optional[builtins.str] = None,
                server: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderKubernetesServer, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument remote_namespace", value=remote_namespace, expected_type=type_hints["remote_namespace"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
        }
        if remote_namespace is not None:
            self._values["remote_namespace"] = remote_namespace
        if server is not None:
            self._values["server"] = server

    @builtins.property
    def auth(self) -> "ClusterSecretStoreSpecProviderKubernetesAuth":
        '''Auth configures how secret-manager authenticates with a Kubernetes instance.

        :schema: ClusterSecretStoreSpecProviderKubernetes#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderKubernetesAuth", result)

    @builtins.property
    def remote_namespace(self) -> typing.Optional[builtins.str]:
        '''Remote namespace to fetch the secrets from.

        :schema: ClusterSecretStoreSpecProviderKubernetes#remoteNamespace
        '''
        result = self._values.get("remote_namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def server(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderKubernetesServer"]:
        '''configures the Kubernetes server Address.

        :schema: ClusterSecretStoreSpecProviderKubernetes#server
        '''
        result = self._values.get("server")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderKubernetesServer"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesAuth",
    jsii_struct_bases=[],
    name_mapping={
        "cert": "cert",
        "service_account": "serviceAccount",
        "token": "token",
    },
)
class ClusterSecretStoreSpecProviderKubernetesAuth:
    def __init__(
        self,
        *,
        cert: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderKubernetesAuthCert", typing.Dict[str, typing.Any]]] = None,
        service_account: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount", typing.Dict[str, typing.Any]]] = None,
        token: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderKubernetesAuthToken", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how secret-manager authenticates with a Kubernetes instance.

        :param cert: has both clientCert and clientKey as secretKeySelector.
        :param service_account: points to a service account that should be used for authentication.
        :param token: use static token to authenticate with.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuth
        '''
        if isinstance(cert, dict):
            cert = ClusterSecretStoreSpecProviderKubernetesAuthCert(**cert)
        if isinstance(service_account, dict):
            service_account = ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount(**service_account)
        if isinstance(token, dict):
            token = ClusterSecretStoreSpecProviderKubernetesAuthToken(**token)
        if __debug__:
            def stub(
                *,
                cert: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderKubernetesAuthCert, typing.Dict[str, typing.Any]]] = None,
                service_account: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount, typing.Dict[str, typing.Any]]] = None,
                token: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderKubernetesAuthToken, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument cert", value=cert, expected_type=type_hints["cert"])
            check_type(argname="argument service_account", value=service_account, expected_type=type_hints["service_account"])
            check_type(argname="argument token", value=token, expected_type=type_hints["token"])
        self._values: typing.Dict[str, typing.Any] = {}
        if cert is not None:
            self._values["cert"] = cert
        if service_account is not None:
            self._values["service_account"] = service_account
        if token is not None:
            self._values["token"] = token

    @builtins.property
    def cert(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthCert"]:
        '''has both clientCert and clientKey as secretKeySelector.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuth#cert
        '''
        result = self._values.get("cert")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthCert"], result)

    @builtins.property
    def service_account(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount"]:
        '''points to a service account that should be used for authentication.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuth#serviceAccount
        '''
        result = self._values.get("service_account")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount"], result)

    @builtins.property
    def token(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthToken"]:
        '''use static token to authenticate with.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuth#token
        '''
        result = self._values.get("token")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetesAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesAuthCert",
    jsii_struct_bases=[],
    name_mapping={"client_cert": "clientCert", "client_key": "clientKey"},
)
class ClusterSecretStoreSpecProviderKubernetesAuthCert:
    def __init__(
        self,
        *,
        client_cert: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert", typing.Dict[str, typing.Any]]] = None,
        client_key: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''has both clientCert and clientKey as secretKeySelector.

        :param client_cert: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.
        :param client_key: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCert
        '''
        if isinstance(client_cert, dict):
            client_cert = ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert(**client_cert)
        if isinstance(client_key, dict):
            client_key = ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey(**client_key)
        if __debug__:
            def stub(
                *,
                client_cert: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert, typing.Dict[str, typing.Any]]] = None,
                client_key: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument client_cert", value=client_cert, expected_type=type_hints["client_cert"])
            check_type(argname="argument client_key", value=client_key, expected_type=type_hints["client_key"])
        self._values: typing.Dict[str, typing.Any] = {}
        if client_cert is not None:
            self._values["client_cert"] = client_cert
        if client_key is not None:
            self._values["client_key"] = client_key

    @builtins.property
    def client_cert(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCert#clientCert
        '''
        result = self._values.get("client_cert")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert"], result)

    @builtins.property
    def client_key(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCert#clientKey
        '''
        result = self._values.get("client_key")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetesAuthCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount",
    jsii_struct_bases=[],
    name_mapping={"service_account": "serviceAccount"},
)
class ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount:
    def __init__(
        self,
        *,
        service_account: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''points to a service account that should be used for authentication.

        :param service_account: A reference to a ServiceAccount resource.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount
        '''
        if isinstance(service_account, dict):
            service_account = ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount(**service_account)
        if __debug__:
            def stub(
                *,
                service_account: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument service_account", value=service_account, expected_type=type_hints["service_account"])
        self._values: typing.Dict[str, typing.Any] = {}
        if service_account is not None:
            self._values["service_account"] = service_account

    @builtins.property
    def service_account(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount"]:
        '''A reference to a ServiceAccount resource.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount#serviceAccount
        '''
        result = self._values.get("service_account")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesAuthToken",
    jsii_struct_bases=[],
    name_mapping={"bearer_token": "bearerToken"},
)
class ClusterSecretStoreSpecProviderKubernetesAuthToken:
    def __init__(
        self,
        *,
        bearer_token: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''use static token to authenticate with.

        :param bearer_token: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthToken
        '''
        if isinstance(bearer_token, dict):
            bearer_token = ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken(**bearer_token)
        if __debug__:
            def stub(
                *,
                bearer_token: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument bearer_token", value=bearer_token, expected_type=type_hints["bearer_token"])
        self._values: typing.Dict[str, typing.Any] = {}
        if bearer_token is not None:
            self._values["bearer_token"] = bearer_token

    @builtins.property
    def bearer_token(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthToken#bearerToken
        '''
        result = self._values.get("bearer_token")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetesAuthToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesServer",
    jsii_struct_bases=[],
    name_mapping={"ca_bundle": "caBundle", "ca_provider": "caProvider", "url": "url"},
)
class ClusterSecretStoreSpecProviderKubernetesServer:
    def __init__(
        self,
        *,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderKubernetesServerCaProvider", typing.Dict[str, typing.Any]]] = None,
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''configures the Kubernetes server Address.

        :param ca_bundle: CABundle is a base64-encoded CA certificate.
        :param ca_provider: see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.
        :param url: configures the Kubernetes server Address.

        :schema: ClusterSecretStoreSpecProviderKubernetesServer
        '''
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreSpecProviderKubernetesServerCaProvider(**ca_provider)
        if __debug__:
            def stub(
                *,
                ca_bundle: typing.Optional[builtins.str] = None,
                ca_provider: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderKubernetesServerCaProvider, typing.Dict[str, typing.Any]]] = None,
                url: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[str, typing.Any] = {}
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''CABundle is a base64-encoded CA certificate.

        :schema: ClusterSecretStoreSpecProviderKubernetesServer#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderKubernetesServerCaProvider"]:
        '''see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.

        :schema: ClusterSecretStoreSpecProviderKubernetesServer#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderKubernetesServerCaProvider"], result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''configures the Kubernetes server Address.

        :schema: ClusterSecretStoreSpecProviderKubernetesServer#url
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetesServer(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesServerCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class ClusterSecretStoreSpecProviderKubernetesServerCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "ClusterSecretStoreSpecProviderKubernetesServerCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key the value inside of the provider type to use, only used with "Secret" type.
        :param namespace: The namespace the Provider type is in.

        :schema: ClusterSecretStoreSpecProviderKubernetesServerCaProvider
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                type: ClusterSecretStoreSpecProviderKubernetesServerCaProviderType,
                key: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: ClusterSecretStoreSpecProviderKubernetesServerCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "ClusterSecretStoreSpecProviderKubernetesServerCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: ClusterSecretStoreSpecProviderKubernetesServerCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderKubernetesServerCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key the value inside of the provider type to use, only used with "Secret" type.

        :schema: ClusterSecretStoreSpecProviderKubernetesServerCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        :schema: ClusterSecretStoreSpecProviderKubernetesServerCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderKubernetesServerCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderKubernetesServerCaProviderType"
)
class ClusterSecretStoreSpecProviderKubernetesServerCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: ClusterSecretStoreSpecProviderKubernetesServerCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderOracle",
    jsii_struct_bases=[],
    name_mapping={"region": "region", "vault": "vault", "auth": "auth"},
)
class ClusterSecretStoreSpecProviderOracle:
    def __init__(
        self,
        *,
        region: builtins.str,
        vault: builtins.str,
        auth: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderOracleAuth", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Oracle configures this store to sync secrets using Oracle Vault provider.

        :param region: Region is the region where vault is located.
        :param vault: Vault is the vault's OCID of the specific vault where secret is located.
        :param auth: Auth configures how secret-manager authenticates with the Oracle Vault. If empty, use the instance principal, otherwise the user credentials specified in Auth.

        :schema: ClusterSecretStoreSpecProviderOracle
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreSpecProviderOracleAuth(**auth)
        if __debug__:
            def stub(
                *,
                region: builtins.str,
                vault: builtins.str,
                auth: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderOracleAuth, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument vault", value=vault, expected_type=type_hints["vault"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
        self._values: typing.Dict[str, typing.Any] = {
            "region": region,
            "vault": vault,
        }
        if auth is not None:
            self._values["auth"] = auth

    @builtins.property
    def region(self) -> builtins.str:
        '''Region is the region where vault is located.

        :schema: ClusterSecretStoreSpecProviderOracle#region
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vault(self) -> builtins.str:
        '''Vault is the vault's OCID of the specific vault where secret is located.

        :schema: ClusterSecretStoreSpecProviderOracle#vault
        '''
        result = self._values.get("vault")
        assert result is not None, "Required property 'vault' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth(self) -> typing.Optional["ClusterSecretStoreSpecProviderOracleAuth"]:
        '''Auth configures how secret-manager authenticates with the Oracle Vault.

        If empty, use the instance principal, otherwise the user credentials specified in Auth.

        :schema: ClusterSecretStoreSpecProviderOracle#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderOracleAuth"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderOracle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderOracleAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "tenancy": "tenancy", "user": "user"},
)
class ClusterSecretStoreSpecProviderOracleAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreSpecProviderOracleAuthSecretRef", typing.Dict[str, typing.Any]],
        tenancy: builtins.str,
        user: builtins.str,
    ) -> None:
        '''Auth configures how secret-manager authenticates with the Oracle Vault.

        If empty, use the instance principal, otherwise the user credentials specified in Auth.

        :param secret_ref: SecretRef to pass through sensitive information.
        :param tenancy: Tenancy is the tenancy OCID where user is located.
        :param user: User is an access OCID specific to the account.

        :schema: ClusterSecretStoreSpecProviderOracleAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderOracleAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Union[ClusterSecretStoreSpecProviderOracleAuthSecretRef, typing.Dict[str, typing.Any]],
                tenancy: builtins.str,
                user: builtins.str,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument tenancy", value=tenancy, expected_type=type_hints["tenancy"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_ref": secret_ref,
            "tenancy": tenancy,
            "user": user,
        }

    @builtins.property
    def secret_ref(self) -> "ClusterSecretStoreSpecProviderOracleAuthSecretRef":
        '''SecretRef to pass through sensitive information.

        :schema: ClusterSecretStoreSpecProviderOracleAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderOracleAuthSecretRef", result)

    @builtins.property
    def tenancy(self) -> builtins.str:
        '''Tenancy is the tenancy OCID where user is located.

        :schema: ClusterSecretStoreSpecProviderOracleAuth#tenancy
        '''
        result = self._values.get("tenancy")
        assert result is not None, "Required property 'tenancy' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def user(self) -> builtins.str:
        '''User is an access OCID specific to the account.

        :schema: ClusterSecretStoreSpecProviderOracleAuth#user
        '''
        result = self._values.get("user")
        assert result is not None, "Required property 'user' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderOracleAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderOracleAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"fingerprint": "fingerprint", "privatekey": "privatekey"},
)
class ClusterSecretStoreSpecProviderOracleAuthSecretRef:
    def __init__(
        self,
        *,
        fingerprint: typing.Union["ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint", typing.Dict[str, typing.Any]],
        privatekey: typing.Union["ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey", typing.Dict[str, typing.Any]],
    ) -> None:
        '''SecretRef to pass through sensitive information.

        :param fingerprint: Fingerprint is the fingerprint of the API private key.
        :param privatekey: PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRef
        '''
        if isinstance(fingerprint, dict):
            fingerprint = ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint(**fingerprint)
        if isinstance(privatekey, dict):
            privatekey = ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey(**privatekey)
        if __debug__:
            def stub(
                *,
                fingerprint: typing.Union[ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint, typing.Dict[str, typing.Any]],
                privatekey: typing.Union[ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument fingerprint", value=fingerprint, expected_type=type_hints["fingerprint"])
            check_type(argname="argument privatekey", value=privatekey, expected_type=type_hints["privatekey"])
        self._values: typing.Dict[str, typing.Any] = {
            "fingerprint": fingerprint,
            "privatekey": privatekey,
        }

    @builtins.property
    def fingerprint(
        self,
    ) -> "ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint":
        '''Fingerprint is the fingerprint of the API private key.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRef#fingerprint
        '''
        result = self._values.get("fingerprint")
        assert result is not None, "Required property 'fingerprint' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint", result)

    @builtins.property
    def privatekey(
        self,
    ) -> "ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey":
        '''PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRef#privatekey
        '''
        result = self._values.get("privatekey")
        assert result is not None, "Required property 'privatekey' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderOracleAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Fingerprint is the fingerprint of the API private key.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVault",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "server": "server",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
        "forward_inconsistent": "forwardInconsistent",
        "namespace": "namespace",
        "path": "path",
        "read_your_writes": "readYourWrites",
        "version": "version",
    },
)
class ClusterSecretStoreSpecProviderVault:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreSpecProviderVaultAuth", typing.Dict[str, typing.Any]],
        server: builtins.str,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultCaProvider", typing.Dict[str, typing.Any]]] = None,
        forward_inconsistent: typing.Optional[builtins.bool] = None,
        namespace: typing.Optional[builtins.str] = None,
        path: typing.Optional[builtins.str] = None,
        read_your_writes: typing.Optional[builtins.bool] = None,
        version: typing.Optional["ClusterSecretStoreSpecProviderVaultVersion"] = None,
    ) -> None:
        '''Vault configures this store to sync secrets using Hashi provider.

        :param auth: Auth configures how secret-manager authenticates with the Vault server.
        :param server: Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
        :param ca_bundle: PEM encoded CA bundle used to validate Vault server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
        :param ca_provider: The provider for the CA bundle to use to validate Vault server certificate.
        :param forward_inconsistent: ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop. This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
        :param namespace: Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
        :param path: Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.
        :param read_your_writes: ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request. More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency
        :param version: Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".

        :schema: ClusterSecretStoreSpecProviderVault
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreSpecProviderVaultAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreSpecProviderVaultCaProvider(**ca_provider)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[ClusterSecretStoreSpecProviderVaultAuth, typing.Dict[str, typing.Any]],
                server: builtins.str,
                ca_bundle: typing.Optional[builtins.str] = None,
                ca_provider: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultCaProvider, typing.Dict[str, typing.Any]]] = None,
                forward_inconsistent: typing.Optional[builtins.bool] = None,
                namespace: typing.Optional[builtins.str] = None,
                path: typing.Optional[builtins.str] = None,
                read_your_writes: typing.Optional[builtins.bool] = None,
                version: typing.Optional[ClusterSecretStoreSpecProviderVaultVersion] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument forward_inconsistent", value=forward_inconsistent, expected_type=type_hints["forward_inconsistent"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument read_your_writes", value=read_your_writes, expected_type=type_hints["read_your_writes"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
            "server": server,
        }
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if forward_inconsistent is not None:
            self._values["forward_inconsistent"] = forward_inconsistent
        if namespace is not None:
            self._values["namespace"] = namespace
        if path is not None:
            self._values["path"] = path
        if read_your_writes is not None:
            self._values["read_your_writes"] = read_your_writes
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def auth(self) -> "ClusterSecretStoreSpecProviderVaultAuth":
        '''Auth configures how secret-manager authenticates with the Vault server.

        :schema: ClusterSecretStoreSpecProviderVault#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderVaultAuth", result)

    @builtins.property
    def server(self) -> builtins.str:
        '''Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".

        :schema: ClusterSecretStoreSpecProviderVault#server
        '''
        result = self._values.get("server")
        assert result is not None, "Required property 'server' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''PEM encoded CA bundle used to validate Vault server certificate.

        Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.

        :schema: ClusterSecretStoreSpecProviderVault#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultCaProvider"]:
        '''The provider for the CA bundle to use to validate Vault server certificate.

        :schema: ClusterSecretStoreSpecProviderVault#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultCaProvider"], result)

    @builtins.property
    def forward_inconsistent(self) -> typing.Optional[builtins.bool]:
        '''ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop.

        This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header

        :schema: ClusterSecretStoreSpecProviderVault#forwardInconsistent
        '''
        result = self._values.get("forward_inconsistent")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Name of the vault namespace.

        Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces

        :schema: ClusterSecretStoreSpecProviderVault#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.

        :schema: ClusterSecretStoreSpecProviderVault#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_your_writes(self) -> typing.Optional[builtins.bool]:
        '''ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request.

        More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency

        :schema: ClusterSecretStoreSpecProviderVault#readYourWrites
        '''
        result = self._values.get("read_your_writes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def version(self) -> typing.Optional["ClusterSecretStoreSpecProviderVaultVersion"]:
        '''Version is the Vault KV secret engine version.

        This can be either "v1" or "v2". Version defaults to "v2".

        :schema: ClusterSecretStoreSpecProviderVault#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultVersion"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVault(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuth",
    jsii_struct_bases=[],
    name_mapping={
        "app_role": "appRole",
        "cert": "cert",
        "jwt": "jwt",
        "kubernetes": "kubernetes",
        "ldap": "ldap",
        "token_secret_ref": "tokenSecretRef",
    },
)
class ClusterSecretStoreSpecProviderVaultAuth:
    def __init__(
        self,
        *,
        app_role: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthAppRole", typing.Dict[str, typing.Any]]] = None,
        cert: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthCert", typing.Dict[str, typing.Any]]] = None,
        jwt: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthJwt", typing.Dict[str, typing.Any]]] = None,
        kubernetes: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthKubernetes", typing.Dict[str, typing.Any]]] = None,
        ldap: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthLdap", typing.Dict[str, typing.Any]]] = None,
        token_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how secret-manager authenticates with the Vault server.

        :param app_role: AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
        :param cert: Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.
        :param jwt: Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.
        :param kubernetes: Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
        :param ldap: Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.
        :param token_secret_ref: TokenSecretRef authenticates with Vault by presenting a token.

        :schema: ClusterSecretStoreSpecProviderVaultAuth
        '''
        if isinstance(app_role, dict):
            app_role = ClusterSecretStoreSpecProviderVaultAuthAppRole(**app_role)
        if isinstance(cert, dict):
            cert = ClusterSecretStoreSpecProviderVaultAuthCert(**cert)
        if isinstance(jwt, dict):
            jwt = ClusterSecretStoreSpecProviderVaultAuthJwt(**jwt)
        if isinstance(kubernetes, dict):
            kubernetes = ClusterSecretStoreSpecProviderVaultAuthKubernetes(**kubernetes)
        if isinstance(ldap, dict):
            ldap = ClusterSecretStoreSpecProviderVaultAuthLdap(**ldap)
        if isinstance(token_secret_ref, dict):
            token_secret_ref = ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef(**token_secret_ref)
        if __debug__:
            def stub(
                *,
                app_role: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthAppRole, typing.Dict[str, typing.Any]]] = None,
                cert: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthCert, typing.Dict[str, typing.Any]]] = None,
                jwt: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthJwt, typing.Dict[str, typing.Any]]] = None,
                kubernetes: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthKubernetes, typing.Dict[str, typing.Any]]] = None,
                ldap: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthLdap, typing.Dict[str, typing.Any]]] = None,
                token_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument app_role", value=app_role, expected_type=type_hints["app_role"])
            check_type(argname="argument cert", value=cert, expected_type=type_hints["cert"])
            check_type(argname="argument jwt", value=jwt, expected_type=type_hints["jwt"])
            check_type(argname="argument kubernetes", value=kubernetes, expected_type=type_hints["kubernetes"])
            check_type(argname="argument ldap", value=ldap, expected_type=type_hints["ldap"])
            check_type(argname="argument token_secret_ref", value=token_secret_ref, expected_type=type_hints["token_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if app_role is not None:
            self._values["app_role"] = app_role
        if cert is not None:
            self._values["cert"] = cert
        if jwt is not None:
            self._values["jwt"] = jwt
        if kubernetes is not None:
            self._values["kubernetes"] = kubernetes
        if ldap is not None:
            self._values["ldap"] = ldap
        if token_secret_ref is not None:
            self._values["token_secret_ref"] = token_secret_ref

    @builtins.property
    def app_role(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthAppRole"]:
        '''AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.

        :schema: ClusterSecretStoreSpecProviderVaultAuth#appRole
        '''
        result = self._values.get("app_role")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthAppRole"], result)

    @builtins.property
    def cert(self) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthCert"]:
        '''Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuth#cert
        '''
        result = self._values.get("cert")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthCert"], result)

    @builtins.property
    def jwt(self) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthJwt"]:
        '''Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuth#jwt
        '''
        result = self._values.get("jwt")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthJwt"], result)

    @builtins.property
    def kubernetes(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthKubernetes"]:
        '''Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.

        :schema: ClusterSecretStoreSpecProviderVaultAuth#kubernetes
        '''
        result = self._values.get("kubernetes")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthKubernetes"], result)

    @builtins.property
    def ldap(self) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthLdap"]:
        '''Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuth#ldap
        '''
        result = self._values.get("ldap")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthLdap"], result)

    @builtins.property
    def token_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef"]:
        '''TokenSecretRef authenticates with Vault by presenting a token.

        :schema: ClusterSecretStoreSpecProviderVaultAuth#tokenSecretRef
        '''
        result = self._values.get("token_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthAppRole",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "role_id": "roleId", "secret_ref": "secretRef"},
)
class ClusterSecretStoreSpecProviderVaultAuthAppRole:
    def __init__(
        self,
        *,
        path: builtins.str,
        role_id: builtins.str,
        secret_ref: typing.Union["ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.

        :param path: Path where the App Role authentication backend is mounted in Vault, e.g: "approle".
        :param role_id: RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.
        :param secret_ref: Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The ``key`` field must be specified and denotes which entry within the Secret resource is used as the app role secret.

        :schema: ClusterSecretStoreSpecProviderVaultAuthAppRole
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                path: builtins.str,
                role_id: builtins.str,
                secret_ref: typing.Union[ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument role_id", value=role_id, expected_type=type_hints["role_id"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
            "role_id": role_id,
            "secret_ref": secret_ref,
        }

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the App Role authentication backend is mounted in Vault, e.g: "approle".

        :schema: ClusterSecretStoreSpecProviderVaultAuthAppRole#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role_id(self) -> builtins.str:
        '''RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.

        :schema: ClusterSecretStoreSpecProviderVaultAuthAppRole#roleId
        '''
        result = self._values.get("role_id")
        assert result is not None, "Required property 'role_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(self) -> "ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef":
        '''Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret resource is used as the app role secret.

        :schema: ClusterSecretStoreSpecProviderVaultAuthAppRole#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthAppRole(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret resource is used as the app role secret.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthCert",
    jsii_struct_bases=[],
    name_mapping={"client_cert": "clientCert", "secret_ref": "secretRef"},
)
class ClusterSecretStoreSpecProviderVaultAuthCert:
    def __init__(
        self,
        *,
        client_cert: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthCertClientCert", typing.Dict[str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthCertSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.

        :param client_cert: ClientCert is a certificate to authenticate using the Cert Vault authentication method.
        :param secret_ref: SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCert
        '''
        if isinstance(client_cert, dict):
            client_cert = ClusterSecretStoreSpecProviderVaultAuthCertClientCert(**client_cert)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderVaultAuthCertSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                client_cert: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthCertClientCert, typing.Dict[str, typing.Any]]] = None,
                secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthCertSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument client_cert", value=client_cert, expected_type=type_hints["client_cert"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if client_cert is not None:
            self._values["client_cert"] = client_cert
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def client_cert(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthCertClientCert"]:
        '''ClientCert is a certificate to authenticate using the Cert Vault authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCert#clientCert
        '''
        result = self._values.get("client_cert")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthCertClientCert"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthCertSecretRef"]:
        '''SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCert#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthCertSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthCertClientCert",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderVaultAuthCertClientCert:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ClientCert is a certificate to authenticate using the Cert Vault authentication method.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCertClientCert
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCertClientCert#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCertClientCert#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCertClientCert#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthCertClientCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderVaultAuthCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCertSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthJwt",
    jsii_struct_bases=[],
    name_mapping={
        "path": "path",
        "kubernetes_service_account_token": "kubernetesServiceAccountToken",
        "role": "role",
        "secret_ref": "secretRef",
    },
)
class ClusterSecretStoreSpecProviderVaultAuthJwt:
    def __init__(
        self,
        *,
        path: builtins.str,
        kubernetes_service_account_token: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken", typing.Dict[str, typing.Any]]] = None,
        role: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.

        :param path: Path where the JWT authentication backend is mounted in Vault, e.g: "jwt".
        :param kubernetes_service_account_token: Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.
        :param role: Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method.
        :param secret_ref: Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwt
        '''
        if isinstance(kubernetes_service_account_token, dict):
            kubernetes_service_account_token = ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken(**kubernetes_service_account_token)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                path: builtins.str,
                kubernetes_service_account_token: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken, typing.Dict[str, typing.Any]]] = None,
                role: typing.Optional[builtins.str] = None,
                secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument kubernetes_service_account_token", value=kubernetes_service_account_token, expected_type=type_hints["kubernetes_service_account_token"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
        }
        if kubernetes_service_account_token is not None:
            self._values["kubernetes_service_account_token"] = kubernetes_service_account_token
        if role is not None:
            self._values["role"] = role
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the JWT authentication backend is mounted in Vault, e.g: "jwt".

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwt#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def kubernetes_service_account_token(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken"]:
        '''Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwt#kubernetesServiceAccountToken
        '''
        result = self._values.get("kubernetes_service_account_token")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken"], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwt#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef"]:
        '''Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwt#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthJwt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken",
    jsii_struct_bases=[],
    name_mapping={
        "service_account_ref": "serviceAccountRef",
        "audiences": "audiences",
        "expiration_seconds": "expirationSeconds",
    },
)
class ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken:
    def __init__(
        self,
        *,
        service_account_ref: typing.Union["ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef", typing.Dict[str, typing.Any]],
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        expiration_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :param service_account_ref: Service account field containing the name of a kubernetes ServiceAccount.
        :param audiences: Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``. Defaults to a single audience ``vault`` it not specified. Default: a single audience ``vault`` it not specified.
        :param expiration_seconds: Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``. Defaults to 10 minutes. Default: 10 minutes.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                service_account_ref: typing.Union[ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef, typing.Dict[str, typing.Any]],
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                expiration_seconds: typing.Optional[jsii.Number] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument expiration_seconds", value=expiration_seconds, expected_type=type_hints["expiration_seconds"])
        self._values: typing.Dict[str, typing.Any] = {
            "service_account_ref": service_account_ref,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if expiration_seconds is not None:
            self._values["expiration_seconds"] = expiration_seconds

    @builtins.property
    def service_account_ref(
        self,
    ) -> "ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef":
        '''Service account field containing the name of a kubernetes ServiceAccount.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        assert result is not None, "Required property 'service_account_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef", result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``.

        Defaults to a single audience ``vault`` it not specified.

        :default: a single audience ``vault`` it not specified.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def expiration_seconds(self) -> typing.Optional[jsii.Number]:
        '''Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``.

        Defaults to 10 minutes.

        :default: 10 minutes.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#expirationSeconds
        '''
        result = self._values.get("expiration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Service account field containing the name of a kubernetes ServiceAccount.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthKubernetes",
    jsii_struct_bases=[],
    name_mapping={
        "mount_path": "mountPath",
        "role": "role",
        "secret_ref": "secretRef",
        "service_account_ref": "serviceAccountRef",
    },
)
class ClusterSecretStoreSpecProviderVaultAuthKubernetes:
    def __init__(
        self,
        *,
        mount_path: builtins.str,
        role: builtins.str,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef", typing.Dict[str, typing.Any]]] = None,
        service_account_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.

        :param mount_path: Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes".
        :param role: A required field containing the Vault Role to assume. A Role binds a Kubernetes ServiceAccount with a set of Vault policies.
        :param secret_ref: Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.
        :param service_account_ref: Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetes
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef(**secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                mount_path: builtins.str,
                role: builtins.str,
                secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef, typing.Dict[str, typing.Any]]] = None,
                service_account_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument mount_path", value=mount_path, expected_type=type_hints["mount_path"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "mount_path": mount_path,
            "role": role,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def mount_path(self) -> builtins.str:
        '''Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes".

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetes#mountPath
        '''
        result = self._values.get("mount_path")
        assert result is not None, "Required property 'mount_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role(self) -> builtins.str:
        '''A required field containing the Vault Role to assume.

        A Role binds a Kubernetes ServiceAccount with a set of Vault policies.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetes#role
        '''
        result = self._values.get("role")
        assert result is not None, "Required property 'role' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef"]:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault.

        If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetes#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef"]:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetes#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthKubernetes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault.

        If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthLdap",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "username": "username", "secret_ref": "secretRef"},
)
class ClusterSecretStoreSpecProviderVaultAuthLdap:
    def __init__(
        self,
        *,
        path: builtins.str,
        username: builtins.str,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.

        :param path: Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap".
        :param username: Username is a LDAP user name used to authenticate using the LDAP Vault authentication method.
        :param secret_ref: SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuthLdap
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                path: builtins.str,
                username: builtins.str,
                secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
            "username": username,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap".

        :schema: ClusterSecretStoreSpecProviderVaultAuthLdap#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def username(self) -> builtins.str:
        '''Username is a LDAP user name used to authenticate using the LDAP Vault authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuthLdap#username
        '''
        result = self._values.get("username")
        assert result is not None, "Required property 'username' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef"]:
        '''SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :schema: ClusterSecretStoreSpecProviderVaultAuthLdap#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthLdap(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''TokenSecretRef authenticates with Vault by presenting a token.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class ClusterSecretStoreSpecProviderVaultCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "ClusterSecretStoreSpecProviderVaultCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Vault server certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key the value inside of the provider type to use, only used with "Secret" type.
        :param namespace: The namespace the Provider type is in.

        :schema: ClusterSecretStoreSpecProviderVaultCaProvider
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                type: ClusterSecretStoreSpecProviderVaultCaProviderType,
                key: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: ClusterSecretStoreSpecProviderVaultCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "ClusterSecretStoreSpecProviderVaultCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: ClusterSecretStoreSpecProviderVaultCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderVaultCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key the value inside of the provider type to use, only used with "Secret" type.

        :schema: ClusterSecretStoreSpecProviderVaultCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        :schema: ClusterSecretStoreSpecProviderVaultCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderVaultCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultCaProviderType"
)
class ClusterSecretStoreSpecProviderVaultCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: ClusterSecretStoreSpecProviderVaultCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.enum(jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderVaultVersion")
class ClusterSecretStoreSpecProviderVaultVersion(enum.Enum):
    '''Version is the Vault KV secret engine version.

    This can be either "v1" or "v2". Version defaults to "v2".

    :schema: ClusterSecretStoreSpecProviderVaultVersion
    '''

    V1 = "V1"
    '''v1.'''
    V2 = "V2"
    '''v2.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderWebhook",
    jsii_struct_bases=[],
    name_mapping={
        "result": "result",
        "url": "url",
        "body": "body",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
        "headers": "headers",
        "method": "method",
        "secrets": "secrets",
        "timeout": "timeout",
    },
)
class ClusterSecretStoreSpecProviderWebhook:
    def __init__(
        self,
        *,
        result: typing.Union["ClusterSecretStoreSpecProviderWebhookResult", typing.Dict[str, typing.Any]],
        url: builtins.str,
        body: typing.Optional[builtins.str] = None,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderWebhookCaProvider", typing.Dict[str, typing.Any]]] = None,
        headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        method: typing.Optional[builtins.str] = None,
        secrets: typing.Optional[typing.Sequence[typing.Union["ClusterSecretStoreSpecProviderWebhookSecrets", typing.Dict[str, typing.Any]]]] = None,
        timeout: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Webhook configures this store to sync secrets using a generic templated webhook.

        :param result: Result formatting.
        :param url: Webhook url to call.
        :param body: Body.
        :param ca_bundle: PEM encoded CA bundle used to validate webhook server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
        :param ca_provider: The provider for the CA bundle to use to validate webhook server certificate.
        :param headers: Headers.
        :param method: Webhook Method.
        :param secrets: Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name.
        :param timeout: Timeout.

        :schema: ClusterSecretStoreSpecProviderWebhook
        '''
        if isinstance(result, dict):
            result = ClusterSecretStoreSpecProviderWebhookResult(**result)
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreSpecProviderWebhookCaProvider(**ca_provider)
        if __debug__:
            def stub(
                *,
                result: typing.Union[ClusterSecretStoreSpecProviderWebhookResult, typing.Dict[str, typing.Any]],
                url: builtins.str,
                body: typing.Optional[builtins.str] = None,
                ca_bundle: typing.Optional[builtins.str] = None,
                ca_provider: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderWebhookCaProvider, typing.Dict[str, typing.Any]]] = None,
                headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
                method: typing.Optional[builtins.str] = None,
                secrets: typing.Optional[typing.Sequence[typing.Union[ClusterSecretStoreSpecProviderWebhookSecrets, typing.Dict[str, typing.Any]]]] = None,
                timeout: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument result", value=result, expected_type=type_hints["result"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
            check_type(argname="argument body", value=body, expected_type=type_hints["body"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument headers", value=headers, expected_type=type_hints["headers"])
            check_type(argname="argument method", value=method, expected_type=type_hints["method"])
            check_type(argname="argument secrets", value=secrets, expected_type=type_hints["secrets"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
        self._values: typing.Dict[str, typing.Any] = {
            "result": result,
            "url": url,
        }
        if body is not None:
            self._values["body"] = body
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if headers is not None:
            self._values["headers"] = headers
        if method is not None:
            self._values["method"] = method
        if secrets is not None:
            self._values["secrets"] = secrets
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def result(self) -> "ClusterSecretStoreSpecProviderWebhookResult":
        '''Result formatting.

        :schema: ClusterSecretStoreSpecProviderWebhook#result
        '''
        result = self._values.get("result")
        assert result is not None, "Required property 'result' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderWebhookResult", result)

    @builtins.property
    def url(self) -> builtins.str:
        '''Webhook url to call.

        :schema: ClusterSecretStoreSpecProviderWebhook#url
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def body(self) -> typing.Optional[builtins.str]:
        '''Body.

        :schema: ClusterSecretStoreSpecProviderWebhook#body
        '''
        result = self._values.get("body")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''PEM encoded CA bundle used to validate webhook server certificate.

        Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.

        :schema: ClusterSecretStoreSpecProviderWebhook#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderWebhookCaProvider"]:
        '''The provider for the CA bundle to use to validate webhook server certificate.

        :schema: ClusterSecretStoreSpecProviderWebhook#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderWebhookCaProvider"], result)

    @builtins.property
    def headers(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Headers.

        :schema: ClusterSecretStoreSpecProviderWebhook#headers
        '''
        result = self._values.get("headers")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def method(self) -> typing.Optional[builtins.str]:
        '''Webhook Method.

        :schema: ClusterSecretStoreSpecProviderWebhook#method
        '''
        result = self._values.get("method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secrets(
        self,
    ) -> typing.Optional[typing.List["ClusterSecretStoreSpecProviderWebhookSecrets"]]:
        '''Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name.

        :schema: ClusterSecretStoreSpecProviderWebhook#secrets
        '''
        result = self._values.get("secrets")
        return typing.cast(typing.Optional[typing.List["ClusterSecretStoreSpecProviderWebhookSecrets"]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[builtins.str]:
        '''Timeout.

        :schema: ClusterSecretStoreSpecProviderWebhook#timeout
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderWebhook(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderWebhookCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class ClusterSecretStoreSpecProviderWebhookCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "ClusterSecretStoreSpecProviderWebhookCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate webhook server certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key the value inside of the provider type to use, only used with "Secret" type.
        :param namespace: The namespace the Provider type is in.

        :schema: ClusterSecretStoreSpecProviderWebhookCaProvider
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                type: ClusterSecretStoreSpecProviderWebhookCaProviderType,
                key: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: ClusterSecretStoreSpecProviderWebhookCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "ClusterSecretStoreSpecProviderWebhookCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: ClusterSecretStoreSpecProviderWebhookCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderWebhookCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key the value inside of the provider type to use, only used with "Secret" type.

        :schema: ClusterSecretStoreSpecProviderWebhookCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        :schema: ClusterSecretStoreSpecProviderWebhookCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderWebhookCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderWebhookCaProviderType"
)
class ClusterSecretStoreSpecProviderWebhookCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: ClusterSecretStoreSpecProviderWebhookCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderWebhookResult",
    jsii_struct_bases=[],
    name_mapping={"json_path": "jsonPath"},
)
class ClusterSecretStoreSpecProviderWebhookResult:
    def __init__(self, *, json_path: typing.Optional[builtins.str] = None) -> None:
        '''Result formatting.

        :param json_path: Json path of return value.

        :schema: ClusterSecretStoreSpecProviderWebhookResult
        '''
        if __debug__:
            def stub(*, json_path: typing.Optional[builtins.str] = None) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument json_path", value=json_path, expected_type=type_hints["json_path"])
        self._values: typing.Dict[str, typing.Any] = {}
        if json_path is not None:
            self._values["json_path"] = json_path

    @builtins.property
    def json_path(self) -> typing.Optional[builtins.str]:
        '''Json path of return value.

        :schema: ClusterSecretStoreSpecProviderWebhookResult#jsonPath
        '''
        result = self._values.get("json_path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderWebhookResult(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderWebhookSecrets",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "secret_ref": "secretRef"},
)
class ClusterSecretStoreSpecProviderWebhookSecrets:
    def __init__(
        self,
        *,
        name: builtins.str,
        secret_ref: typing.Union["ClusterSecretStoreSpecProviderWebhookSecretsSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''
        :param name: Name of this secret in templates.
        :param secret_ref: Secret ref to fill in credentials.

        :schema: ClusterSecretStoreSpecProviderWebhookSecrets
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreSpecProviderWebhookSecretsSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                secret_ref: typing.Union[ClusterSecretStoreSpecProviderWebhookSecretsSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "secret_ref": secret_ref,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of this secret in templates.

        :schema: ClusterSecretStoreSpecProviderWebhookSecrets#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(self) -> "ClusterSecretStoreSpecProviderWebhookSecretsSecretRef":
        '''Secret ref to fill in credentials.

        :schema: ClusterSecretStoreSpecProviderWebhookSecrets#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderWebhookSecretsSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderWebhookSecrets(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderWebhookSecretsSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderWebhookSecretsSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Secret ref to fill in credentials.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderWebhookSecretsSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderWebhookSecretsSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderWebhookSecretsSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderWebhookSecretsSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderWebhookSecretsSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderYandexlockbox",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "api_endpoint": "apiEndpoint",
        "ca_provider": "caProvider",
    },
)
class ClusterSecretStoreSpecProviderYandexlockbox:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreSpecProviderYandexlockboxAuth", typing.Dict[str, typing.Any]],
        api_endpoint: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderYandexlockboxCaProvider", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :param auth: Auth defines the information necessary to authenticate against Yandex Lockbox.
        :param api_endpoint: Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').
        :param ca_provider: The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: ClusterSecretStoreSpecProviderYandexlockbox
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreSpecProviderYandexlockboxAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreSpecProviderYandexlockboxCaProvider(**ca_provider)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[ClusterSecretStoreSpecProviderYandexlockboxAuth, typing.Dict[str, typing.Any]],
                api_endpoint: typing.Optional[builtins.str] = None,
                ca_provider: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderYandexlockboxCaProvider, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument api_endpoint", value=api_endpoint, expected_type=type_hints["api_endpoint"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
        }
        if api_endpoint is not None:
            self._values["api_endpoint"] = api_endpoint
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider

    @builtins.property
    def auth(self) -> "ClusterSecretStoreSpecProviderYandexlockboxAuth":
        '''Auth defines the information necessary to authenticate against Yandex Lockbox.

        :schema: ClusterSecretStoreSpecProviderYandexlockbox#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreSpecProviderYandexlockboxAuth", result)

    @builtins.property
    def api_endpoint(self) -> typing.Optional[builtins.str]:
        '''Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').

        :schema: ClusterSecretStoreSpecProviderYandexlockbox#apiEndpoint
        '''
        result = self._values.get("api_endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderYandexlockboxCaProvider"]:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: ClusterSecretStoreSpecProviderYandexlockbox#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderYandexlockboxCaProvider"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderYandexlockbox(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderYandexlockboxAuth",
    jsii_struct_bases=[],
    name_mapping={"authorized_key_secret_ref": "authorizedKeySecretRef"},
)
class ClusterSecretStoreSpecProviderYandexlockboxAuth:
    def __init__(
        self,
        *,
        authorized_key_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against Yandex Lockbox.

        :param authorized_key_secret_ref: The authorized key used for authentication.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxAuth
        '''
        if isinstance(authorized_key_secret_ref, dict):
            authorized_key_secret_ref = ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef(**authorized_key_secret_ref)
        if __debug__:
            def stub(
                *,
                authorized_key_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument authorized_key_secret_ref", value=authorized_key_secret_ref, expected_type=type_hints["authorized_key_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if authorized_key_secret_ref is not None:
            self._values["authorized_key_secret_ref"] = authorized_key_secret_ref

    @builtins.property
    def authorized_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef"]:
        '''The authorized key used for authentication.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxAuth#authorizedKeySecretRef
        '''
        result = self._values.get("authorized_key_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderYandexlockboxAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The authorized key used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderYandexlockboxCaProvider",
    jsii_struct_bases=[],
    name_mapping={"cert_secret_ref": "certSecretRef"},
)
class ClusterSecretStoreSpecProviderYandexlockboxCaProvider:
    def __init__(
        self,
        *,
        cert_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :param cert_secret_ref: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxCaProvider
        '''
        if isinstance(cert_secret_ref, dict):
            cert_secret_ref = ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef(**cert_secret_ref)
        if __debug__:
            def stub(
                *,
                cert_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument cert_secret_ref", value=cert_secret_ref, expected_type=type_hints["cert_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if cert_secret_ref is not None:
            self._values["cert_secret_ref"] = cert_secret_ref

    @builtins.property
    def cert_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxCaProvider#certSecretRef
        '''
        result = self._values.get("cert_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderYandexlockboxCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreSpecRetrySettings",
    jsii_struct_bases=[],
    name_mapping={"max_retries": "maxRetries", "retry_interval": "retryInterval"},
)
class ClusterSecretStoreSpecRetrySettings:
    def __init__(
        self,
        *,
        max_retries: typing.Optional[jsii.Number] = None,
        retry_interval: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Used to configure http retries if failed.

        :param max_retries: 
        :param retry_interval: 

        :schema: ClusterSecretStoreSpecRetrySettings
        '''
        if __debug__:
            def stub(
                *,
                max_retries: typing.Optional[jsii.Number] = None,
                retry_interval: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument max_retries", value=max_retries, expected_type=type_hints["max_retries"])
            check_type(argname="argument retry_interval", value=retry_interval, expected_type=type_hints["retry_interval"])
        self._values: typing.Dict[str, typing.Any] = {}
        if max_retries is not None:
            self._values["max_retries"] = max_retries
        if retry_interval is not None:
            self._values["retry_interval"] = retry_interval

    @builtins.property
    def max_retries(self) -> typing.Optional[jsii.Number]:
        '''
        :schema: ClusterSecretStoreSpecRetrySettings#maxRetries
        '''
        result = self._values.get("max_retries")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def retry_interval(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreSpecRetrySettings#retryInterval
        '''
        result = self._values.get("retry_interval")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreSpecRetrySettings(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ClusterSecretStoreV1Beta1(
    cdk8s.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1",
):
    '''ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of ``storeRef`` fields.

    :schema: ClusterSecretStoreV1Beta1
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1Spec", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Defines a "ClusterSecretStoreV1Beta1" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.
        '''
        if __debug__:
            def stub(
                scope: constructs.Construct,
                id: builtins.str,
                *,
                metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
                spec: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1Spec, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ClusterSecretStoreV1Beta1Props(metadata=metadata, spec=spec)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest")
    @builtins.classmethod
    def manifest(
        cls,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1Spec", typing.Dict[str, typing.Any]]] = None,
    ) -> typing.Any:
        '''Renders a Kubernetes manifest for "ClusterSecretStoreV1Beta1".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.
        '''
        props = ClusterSecretStoreV1Beta1Props(metadata=metadata, spec=spec)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''Renders the object to Kubernetes JSON.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> cdk8s.GroupVersionKind:
        '''Returns the apiVersion and kind for "ClusterSecretStoreV1Beta1".'''
        return typing.cast(cdk8s.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1Props",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class ClusterSecretStoreV1Beta1Props:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1Spec", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of ``storeRef`` fields.

        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.

        :schema: ClusterSecretStoreV1Beta1
        '''
        if isinstance(metadata, dict):
            metadata = cdk8s.ApiObjectMetadata(**metadata)
        if isinstance(spec, dict):
            spec = ClusterSecretStoreV1Beta1Spec(**spec)
        if __debug__:
            def stub(
                *,
                metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
                spec: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1Spec, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(self) -> typing.Optional[cdk8s.ApiObjectMetadata]:
        '''
        :schema: ClusterSecretStoreV1Beta1#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[cdk8s.ApiObjectMetadata], result)

    @builtins.property
    def spec(self) -> typing.Optional["ClusterSecretStoreV1Beta1Spec"]:
        '''SecretStoreSpec defines the desired state of SecretStore.

        :schema: ClusterSecretStoreV1Beta1#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1Spec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1Props(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1Spec",
    jsii_struct_bases=[],
    name_mapping={
        "provider": "provider",
        "conditions": "conditions",
        "controller": "controller",
        "refresh_interval": "refreshInterval",
        "retry_settings": "retrySettings",
    },
)
class ClusterSecretStoreV1Beta1Spec:
    def __init__(
        self,
        *,
        provider: typing.Union["ClusterSecretStoreV1Beta1SpecProvider", typing.Dict[str, typing.Any]],
        conditions: typing.Optional[typing.Sequence[typing.Union["ClusterSecretStoreV1Beta1SpecConditions", typing.Dict[str, typing.Any]]]] = None,
        controller: typing.Optional[builtins.str] = None,
        refresh_interval: typing.Optional[jsii.Number] = None,
        retry_settings: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecRetrySettings", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''SecretStoreSpec defines the desired state of SecretStore.

        :param provider: Used to configure the provider. Only one provider may be set
        :param conditions: Used to constraint a ClusterSecretStore to specific namespaces. Relevant only to ClusterSecretStore
        :param controller: Used to select the correct KES controller (think: ingress.ingressClassName) The KES controller is instantiated with a specific controller name and filters ES based on this property.
        :param refresh_interval: Used to configure store refresh interval in seconds. Empty or 0 will default to the controller config.
        :param retry_settings: Used to configure http retries if failed.

        :schema: ClusterSecretStoreV1Beta1Spec
        '''
        if isinstance(provider, dict):
            provider = ClusterSecretStoreV1Beta1SpecProvider(**provider)
        if isinstance(retry_settings, dict):
            retry_settings = ClusterSecretStoreV1Beta1SpecRetrySettings(**retry_settings)
        if __debug__:
            def stub(
                *,
                provider: typing.Union[ClusterSecretStoreV1Beta1SpecProvider, typing.Dict[str, typing.Any]],
                conditions: typing.Optional[typing.Sequence[typing.Union[ClusterSecretStoreV1Beta1SpecConditions, typing.Dict[str, typing.Any]]]] = None,
                controller: typing.Optional[builtins.str] = None,
                refresh_interval: typing.Optional[jsii.Number] = None,
                retry_settings: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecRetrySettings, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument conditions", value=conditions, expected_type=type_hints["conditions"])
            check_type(argname="argument controller", value=controller, expected_type=type_hints["controller"])
            check_type(argname="argument refresh_interval", value=refresh_interval, expected_type=type_hints["refresh_interval"])
            check_type(argname="argument retry_settings", value=retry_settings, expected_type=type_hints["retry_settings"])
        self._values: typing.Dict[str, typing.Any] = {
            "provider": provider,
        }
        if conditions is not None:
            self._values["conditions"] = conditions
        if controller is not None:
            self._values["controller"] = controller
        if refresh_interval is not None:
            self._values["refresh_interval"] = refresh_interval
        if retry_settings is not None:
            self._values["retry_settings"] = retry_settings

    @builtins.property
    def provider(self) -> "ClusterSecretStoreV1Beta1SpecProvider":
        '''Used to configure the provider.

        Only one provider may be set

        :schema: ClusterSecretStoreV1Beta1Spec#provider
        '''
        result = self._values.get("provider")
        assert result is not None, "Required property 'provider' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProvider", result)

    @builtins.property
    def conditions(
        self,
    ) -> typing.Optional[typing.List["ClusterSecretStoreV1Beta1SpecConditions"]]:
        '''Used to constraint a ClusterSecretStore to specific namespaces.

        Relevant only to ClusterSecretStore

        :schema: ClusterSecretStoreV1Beta1Spec#conditions
        '''
        result = self._values.get("conditions")
        return typing.cast(typing.Optional[typing.List["ClusterSecretStoreV1Beta1SpecConditions"]], result)

    @builtins.property
    def controller(self) -> typing.Optional[builtins.str]:
        '''Used to select the correct KES controller (think: ingress.ingressClassName) The KES controller is instantiated with a specific controller name and filters ES based on this property.

        :schema: ClusterSecretStoreV1Beta1Spec#controller
        '''
        result = self._values.get("controller")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def refresh_interval(self) -> typing.Optional[jsii.Number]:
        '''Used to configure store refresh interval in seconds.

        Empty or 0 will default to the controller config.

        :schema: ClusterSecretStoreV1Beta1Spec#refreshInterval
        '''
        result = self._values.get("refresh_interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def retry_settings(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecRetrySettings"]:
        '''Used to configure http retries if failed.

        :schema: ClusterSecretStoreV1Beta1Spec#retrySettings
        '''
        result = self._values.get("retry_settings")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecRetrySettings"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1Spec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecConditions",
    jsii_struct_bases=[],
    name_mapping={
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
    },
)
class ClusterSecretStoreV1Beta1SpecConditions:
    def __init__(
        self,
        *,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''ClusterSecretStoreCondition describes a condition by which to choose namespaces to process ExternalSecrets in for a ClusterSecretStore instance.

        :param namespaces: Choose namespaces by name.
        :param namespace_selector: Choose namespace using a labelSelector.

        :schema: ClusterSecretStoreV1Beta1SpecConditions
        '''
        if isinstance(namespace_selector, dict):
            namespace_selector = ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector(**namespace_selector)
        if __debug__:
            def stub(
                *,
                namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace_selector: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
        self._values: typing.Dict[str, typing.Any] = {}
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Choose namespaces by name.

        :schema: ClusterSecretStoreV1Beta1SpecConditions#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector"]:
        '''Choose namespace using a labelSelector.

        :schema: ClusterSecretStoreV1Beta1SpecConditions#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecConditions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Choose namespace using a labelSelector.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector
        '''
        if __debug__:
            def stub(
                *,
                match_expressions: typing.Optional[typing.Sequence[typing.Union[ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions, typing.Dict[str, typing.Any]]]] = None,
                match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            def stub(
                *,
                key: builtins.str,
                operator: builtins.str,
                values: typing.Optional[typing.Sequence[builtins.str]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProvider",
    jsii_struct_bases=[],
    name_mapping={
        "akeyless": "akeyless",
        "alibaba": "alibaba",
        "aws": "aws",
        "azurekv": "azurekv",
        "doppler": "doppler",
        "fake": "fake",
        "gcpsm": "gcpsm",
        "gitlab": "gitlab",
        "ibm": "ibm",
        "kubernetes": "kubernetes",
        "onepassword": "onepassword",
        "oracle": "oracle",
        "senhasegura": "senhasegura",
        "vault": "vault",
        "webhook": "webhook",
        "yandexcertificatemanager": "yandexcertificatemanager",
        "yandexlockbox": "yandexlockbox",
    },
)
class ClusterSecretStoreV1Beta1SpecProvider:
    def __init__(
        self,
        *,
        akeyless: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAkeyless", typing.Dict[str, typing.Any]]] = None,
        alibaba: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAlibaba", typing.Dict[str, typing.Any]]] = None,
        aws: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAws", typing.Dict[str, typing.Any]]] = None,
        azurekv: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAzurekv", typing.Dict[str, typing.Any]]] = None,
        doppler: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderDoppler", typing.Dict[str, typing.Any]]] = None,
        fake: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderFake", typing.Dict[str, typing.Any]]] = None,
        gcpsm: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderGcpsm", typing.Dict[str, typing.Any]]] = None,
        gitlab: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderGitlab", typing.Dict[str, typing.Any]]] = None,
        ibm: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderIbm", typing.Dict[str, typing.Any]]] = None,
        kubernetes: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetes", typing.Dict[str, typing.Any]]] = None,
        onepassword: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderOnepassword", typing.Dict[str, typing.Any]]] = None,
        oracle: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderOracle", typing.Dict[str, typing.Any]]] = None,
        senhasegura: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderSenhasegura", typing.Dict[str, typing.Any]]] = None,
        vault: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVault", typing.Dict[str, typing.Any]]] = None,
        webhook: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderWebhook", typing.Dict[str, typing.Any]]] = None,
        yandexcertificatemanager: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager", typing.Dict[str, typing.Any]]] = None,
        yandexlockbox: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderYandexlockbox", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Used to configure the provider.

        Only one provider may be set

        :param akeyless: Akeyless configures this store to sync secrets using Akeyless Vault provider.
        :param alibaba: Alibaba configures this store to sync secrets using Alibaba Cloud provider.
        :param aws: AWS configures this store to sync secrets using AWS Secret Manager provider.
        :param azurekv: AzureKV configures this store to sync secrets using Azure Key Vault provider.
        :param doppler: Doppler configures this store to sync secrets using the Doppler provider.
        :param fake: Fake configures a store with static key/value pairs.
        :param gcpsm: GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.
        :param gitlab: Gitlab configures this store to sync secrets using Gitlab Variables provider.
        :param ibm: IBM configures this store to sync secrets using IBM Cloud provider.
        :param kubernetes: Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.
        :param onepassword: OnePassword configures this store to sync secrets using the 1Password Cloud provider.
        :param oracle: Oracle configures this store to sync secrets using Oracle Vault provider.
        :param senhasegura: Senhasegura configures this store to sync secrets using senhasegura provider.
        :param vault: Vault configures this store to sync secrets using Hashi provider.
        :param webhook: Webhook configures this store to sync secrets using a generic templated webhook.
        :param yandexcertificatemanager: YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider.
        :param yandexlockbox: YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider
        '''
        if isinstance(akeyless, dict):
            akeyless = ClusterSecretStoreV1Beta1SpecProviderAkeyless(**akeyless)
        if isinstance(alibaba, dict):
            alibaba = ClusterSecretStoreV1Beta1SpecProviderAlibaba(**alibaba)
        if isinstance(aws, dict):
            aws = ClusterSecretStoreV1Beta1SpecProviderAws(**aws)
        if isinstance(azurekv, dict):
            azurekv = ClusterSecretStoreV1Beta1SpecProviderAzurekv(**azurekv)
        if isinstance(doppler, dict):
            doppler = ClusterSecretStoreV1Beta1SpecProviderDoppler(**doppler)
        if isinstance(fake, dict):
            fake = ClusterSecretStoreV1Beta1SpecProviderFake(**fake)
        if isinstance(gcpsm, dict):
            gcpsm = ClusterSecretStoreV1Beta1SpecProviderGcpsm(**gcpsm)
        if isinstance(gitlab, dict):
            gitlab = ClusterSecretStoreV1Beta1SpecProviderGitlab(**gitlab)
        if isinstance(ibm, dict):
            ibm = ClusterSecretStoreV1Beta1SpecProviderIbm(**ibm)
        if isinstance(kubernetes, dict):
            kubernetes = ClusterSecretStoreV1Beta1SpecProviderKubernetes(**kubernetes)
        if isinstance(onepassword, dict):
            onepassword = ClusterSecretStoreV1Beta1SpecProviderOnepassword(**onepassword)
        if isinstance(oracle, dict):
            oracle = ClusterSecretStoreV1Beta1SpecProviderOracle(**oracle)
        if isinstance(senhasegura, dict):
            senhasegura = ClusterSecretStoreV1Beta1SpecProviderSenhasegura(**senhasegura)
        if isinstance(vault, dict):
            vault = ClusterSecretStoreV1Beta1SpecProviderVault(**vault)
        if isinstance(webhook, dict):
            webhook = ClusterSecretStoreV1Beta1SpecProviderWebhook(**webhook)
        if isinstance(yandexcertificatemanager, dict):
            yandexcertificatemanager = ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager(**yandexcertificatemanager)
        if isinstance(yandexlockbox, dict):
            yandexlockbox = ClusterSecretStoreV1Beta1SpecProviderYandexlockbox(**yandexlockbox)
        if __debug__:
            def stub(
                *,
                akeyless: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAkeyless, typing.Dict[str, typing.Any]]] = None,
                alibaba: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAlibaba, typing.Dict[str, typing.Any]]] = None,
                aws: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAws, typing.Dict[str, typing.Any]]] = None,
                azurekv: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAzurekv, typing.Dict[str, typing.Any]]] = None,
                doppler: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderDoppler, typing.Dict[str, typing.Any]]] = None,
                fake: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderFake, typing.Dict[str, typing.Any]]] = None,
                gcpsm: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderGcpsm, typing.Dict[str, typing.Any]]] = None,
                gitlab: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderGitlab, typing.Dict[str, typing.Any]]] = None,
                ibm: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderIbm, typing.Dict[str, typing.Any]]] = None,
                kubernetes: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetes, typing.Dict[str, typing.Any]]] = None,
                onepassword: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderOnepassword, typing.Dict[str, typing.Any]]] = None,
                oracle: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderOracle, typing.Dict[str, typing.Any]]] = None,
                senhasegura: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderSenhasegura, typing.Dict[str, typing.Any]]] = None,
                vault: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVault, typing.Dict[str, typing.Any]]] = None,
                webhook: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderWebhook, typing.Dict[str, typing.Any]]] = None,
                yandexcertificatemanager: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager, typing.Dict[str, typing.Any]]] = None,
                yandexlockbox: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderYandexlockbox, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument akeyless", value=akeyless, expected_type=type_hints["akeyless"])
            check_type(argname="argument alibaba", value=alibaba, expected_type=type_hints["alibaba"])
            check_type(argname="argument aws", value=aws, expected_type=type_hints["aws"])
            check_type(argname="argument azurekv", value=azurekv, expected_type=type_hints["azurekv"])
            check_type(argname="argument doppler", value=doppler, expected_type=type_hints["doppler"])
            check_type(argname="argument fake", value=fake, expected_type=type_hints["fake"])
            check_type(argname="argument gcpsm", value=gcpsm, expected_type=type_hints["gcpsm"])
            check_type(argname="argument gitlab", value=gitlab, expected_type=type_hints["gitlab"])
            check_type(argname="argument ibm", value=ibm, expected_type=type_hints["ibm"])
            check_type(argname="argument kubernetes", value=kubernetes, expected_type=type_hints["kubernetes"])
            check_type(argname="argument onepassword", value=onepassword, expected_type=type_hints["onepassword"])
            check_type(argname="argument oracle", value=oracle, expected_type=type_hints["oracle"])
            check_type(argname="argument senhasegura", value=senhasegura, expected_type=type_hints["senhasegura"])
            check_type(argname="argument vault", value=vault, expected_type=type_hints["vault"])
            check_type(argname="argument webhook", value=webhook, expected_type=type_hints["webhook"])
            check_type(argname="argument yandexcertificatemanager", value=yandexcertificatemanager, expected_type=type_hints["yandexcertificatemanager"])
            check_type(argname="argument yandexlockbox", value=yandexlockbox, expected_type=type_hints["yandexlockbox"])
        self._values: typing.Dict[str, typing.Any] = {}
        if akeyless is not None:
            self._values["akeyless"] = akeyless
        if alibaba is not None:
            self._values["alibaba"] = alibaba
        if aws is not None:
            self._values["aws"] = aws
        if azurekv is not None:
            self._values["azurekv"] = azurekv
        if doppler is not None:
            self._values["doppler"] = doppler
        if fake is not None:
            self._values["fake"] = fake
        if gcpsm is not None:
            self._values["gcpsm"] = gcpsm
        if gitlab is not None:
            self._values["gitlab"] = gitlab
        if ibm is not None:
            self._values["ibm"] = ibm
        if kubernetes is not None:
            self._values["kubernetes"] = kubernetes
        if onepassword is not None:
            self._values["onepassword"] = onepassword
        if oracle is not None:
            self._values["oracle"] = oracle
        if senhasegura is not None:
            self._values["senhasegura"] = senhasegura
        if vault is not None:
            self._values["vault"] = vault
        if webhook is not None:
            self._values["webhook"] = webhook
        if yandexcertificatemanager is not None:
            self._values["yandexcertificatemanager"] = yandexcertificatemanager
        if yandexlockbox is not None:
            self._values["yandexlockbox"] = yandexlockbox

    @builtins.property
    def akeyless(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeyless"]:
        '''Akeyless configures this store to sync secrets using Akeyless Vault provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#akeyless
        '''
        result = self._values.get("akeyless")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeyless"], result)

    @builtins.property
    def alibaba(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAlibaba"]:
        '''Alibaba configures this store to sync secrets using Alibaba Cloud provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#alibaba
        '''
        result = self._values.get("alibaba")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAlibaba"], result)

    @builtins.property
    def aws(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAws"]:
        '''AWS configures this store to sync secrets using AWS Secret Manager provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#aws
        '''
        result = self._values.get("aws")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAws"], result)

    @builtins.property
    def azurekv(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekv"]:
        '''AzureKV configures this store to sync secrets using Azure Key Vault provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#azurekv
        '''
        result = self._values.get("azurekv")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekv"], result)

    @builtins.property
    def doppler(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDoppler"]:
        '''Doppler configures this store to sync secrets using the Doppler provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#doppler
        '''
        result = self._values.get("doppler")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDoppler"], result)

    @builtins.property
    def fake(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderFake"]:
        '''Fake configures a store with static key/value pairs.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#fake
        '''
        result = self._values.get("fake")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderFake"], result)

    @builtins.property
    def gcpsm(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGcpsm"]:
        '''GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#gcpsm
        '''
        result = self._values.get("gcpsm")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGcpsm"], result)

    @builtins.property
    def gitlab(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGitlab"]:
        '''Gitlab configures this store to sync secrets using Gitlab Variables provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#gitlab
        '''
        result = self._values.get("gitlab")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGitlab"], result)

    @builtins.property
    def ibm(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderIbm"]:
        '''IBM configures this store to sync secrets using IBM Cloud provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#ibm
        '''
        result = self._values.get("ibm")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderIbm"], result)

    @builtins.property
    def kubernetes(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetes"]:
        '''Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#kubernetes
        '''
        result = self._values.get("kubernetes")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetes"], result)

    @builtins.property
    def onepassword(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderOnepassword"]:
        '''OnePassword configures this store to sync secrets using the 1Password Cloud provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#onepassword
        '''
        result = self._values.get("onepassword")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderOnepassword"], result)

    @builtins.property
    def oracle(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderOracle"]:
        '''Oracle configures this store to sync secrets using Oracle Vault provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#oracle
        '''
        result = self._values.get("oracle")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderOracle"], result)

    @builtins.property
    def senhasegura(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderSenhasegura"]:
        '''Senhasegura configures this store to sync secrets using senhasegura provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#senhasegura
        '''
        result = self._values.get("senhasegura")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderSenhasegura"], result)

    @builtins.property
    def vault(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVault"]:
        '''Vault configures this store to sync secrets using Hashi provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#vault
        '''
        result = self._values.get("vault")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVault"], result)

    @builtins.property
    def webhook(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderWebhook"]:
        '''Webhook configures this store to sync secrets using a generic templated webhook.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#webhook
        '''
        result = self._values.get("webhook")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderWebhook"], result)

    @builtins.property
    def yandexcertificatemanager(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager"]:
        '''YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#yandexcertificatemanager
        '''
        result = self._values.get("yandexcertificatemanager")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager"], result)

    @builtins.property
    def yandexlockbox(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexlockbox"]:
        '''YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :schema: ClusterSecretStoreV1Beta1SpecProvider#yandexlockbox
        '''
        result = self._values.get("yandexlockbox")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexlockbox"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAkeyless",
    jsii_struct_bases=[],
    name_mapping={
        "akeyless_gw_api_url": "akeylessGwApiUrl",
        "auth_secret_ref": "authSecretRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderAkeyless:
    def __init__(
        self,
        *,
        akeyless_gw_api_url: builtins.str,
        auth_secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''Akeyless configures this store to sync secrets using Akeyless Vault provider.

        :param akeyless_gw_api_url: Akeyless GW API Url from which the secrets to be fetched from.
        :param auth_secret_ref: Auth configures how the operator authenticates with Akeyless.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeyless
        '''
        if isinstance(auth_secret_ref, dict):
            auth_secret_ref = ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef(**auth_secret_ref)
        if __debug__:
            def stub(
                *,
                akeyless_gw_api_url: builtins.str,
                auth_secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument akeyless_gw_api_url", value=akeyless_gw_api_url, expected_type=type_hints["akeyless_gw_api_url"])
            check_type(argname="argument auth_secret_ref", value=auth_secret_ref, expected_type=type_hints["auth_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "akeyless_gw_api_url": akeyless_gw_api_url,
            "auth_secret_ref": auth_secret_ref,
        }

    @builtins.property
    def akeyless_gw_api_url(self) -> builtins.str:
        '''Akeyless GW API Url from which the secrets to be fetched from.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeyless#akeylessGWApiURL
        '''
        result = self._values.get("akeyless_gw_api_url")
        assert result is not None, "Required property 'akeyless_gw_api_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth_secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef":
        '''Auth configures how the operator authenticates with Akeyless.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeyless#authSecretRef
        '''
        result = self._values.get("auth_secret_ref")
        assert result is not None, "Required property 'auth_secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAkeyless(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"kubernetes_auth": "kubernetesAuth", "secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef:
    def __init__(
        self,
        *,
        kubernetes_auth: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth", typing.Dict[str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how the operator authenticates with Akeyless.

        :param kubernetes_auth: Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
        :param secret_ref: Reference to a Secret that contains the details to authenticate with Akeyless.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef
        '''
        if isinstance(kubernetes_auth, dict):
            kubernetes_auth = ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth(**kubernetes_auth)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                kubernetes_auth: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth, typing.Dict[str, typing.Any]]] = None,
                secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument kubernetes_auth", value=kubernetes_auth, expected_type=type_hints["kubernetes_auth"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if kubernetes_auth is not None:
            self._values["kubernetes_auth"] = kubernetes_auth
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def kubernetes_auth(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth"]:
        '''Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef#kubernetesAuth
        '''
        result = self._values.get("kubernetes_auth")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef"]:
        '''Reference to a Secret that contains the details to authenticate with Akeyless.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth",
    jsii_struct_bases=[],
    name_mapping={
        "access_id": "accessId",
        "k8_s_conf_name": "k8SConfName",
        "secret_ref": "secretRef",
        "service_account_ref": "serviceAccountRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth:
    def __init__(
        self,
        *,
        access_id: builtins.str,
        k8_s_conf_name: builtins.str,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef", typing.Dict[str, typing.Any]]] = None,
        service_account_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.

        :param access_id: the Akeyless Kubernetes auth-method access-id.
        :param k8_s_conf_name: Kubernetes-auth configuration name in Akeyless-Gateway.
        :param secret_ref: Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.
        :param service_account_ref: Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(**secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                access_id: builtins.str,
                k8_s_conf_name: builtins.str,
                secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef, typing.Dict[str, typing.Any]]] = None,
                service_account_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument access_id", value=access_id, expected_type=type_hints["access_id"])
            check_type(argname="argument k8_s_conf_name", value=k8_s_conf_name, expected_type=type_hints["k8_s_conf_name"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "access_id": access_id,
            "k8_s_conf_name": k8_s_conf_name,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def access_id(self) -> builtins.str:
        '''the Akeyless Kubernetes auth-method access-id.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#accessID
        '''
        result = self._values.get("access_id")
        assert result is not None, "Required property 'access_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def k8_s_conf_name(self) -> builtins.str:
        '''Kubernetes-auth configuration name in Akeyless-Gateway.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#k8sConfName
        '''
        result = self._values.get("k8_s_conf_name")
        assert result is not None, "Required property 'k8_s_conf_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef"]:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless.

        If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef"]:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless.

        If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_id": "accessId",
        "access_type": "accessType",
        "access_type_param": "accessTypeParam",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef:
    def __init__(
        self,
        *,
        access_id: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId", typing.Dict[str, typing.Any]]] = None,
        access_type: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType", typing.Dict[str, typing.Any]]] = None,
        access_type_param: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Reference to a Secret that contains the details to authenticate with Akeyless.

        :param access_id: The SecretAccessID is used for authentication.
        :param access_type: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.
        :param access_type_param: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef
        '''
        if isinstance(access_id, dict):
            access_id = ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId(**access_id)
        if isinstance(access_type, dict):
            access_type = ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType(**access_type)
        if isinstance(access_type_param, dict):
            access_type_param = ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(**access_type_param)
        if __debug__:
            def stub(
                *,
                access_id: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId, typing.Dict[str, typing.Any]]] = None,
                access_type: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType, typing.Dict[str, typing.Any]]] = None,
                access_type_param: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument access_id", value=access_id, expected_type=type_hints["access_id"])
            check_type(argname="argument access_type", value=access_type, expected_type=type_hints["access_type"])
            check_type(argname="argument access_type_param", value=access_type_param, expected_type=type_hints["access_type_param"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_id is not None:
            self._values["access_id"] = access_id
        if access_type is not None:
            self._values["access_type"] = access_type
        if access_type_param is not None:
            self._values["access_type_param"] = access_type_param

    @builtins.property
    def access_id(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId"]:
        '''The SecretAccessID is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessID
        '''
        result = self._values.get("access_id")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId"], result)

    @builtins.property
    def access_type(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessType
        '''
        result = self._values.get("access_type")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType"], result)

    @builtins.property
    def access_type_param(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessTypeParam
        '''
        result = self._values.get("access_type_param")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessID is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAlibaba",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "region_id": "regionId", "endpoint": "endpoint"},
)
class ClusterSecretStoreV1Beta1SpecProviderAlibaba:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth", typing.Dict[str, typing.Any]],
        region_id: builtins.str,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Alibaba configures this store to sync secrets using Alibaba Cloud provider.

        :param auth: AlibabaAuth contains a secretRef for credentials.
        :param region_id: Alibaba Region to be used for the provider.
        :param endpoint: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibaba
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth, typing.Dict[str, typing.Any]],
                region_id: builtins.str,
                endpoint: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument region_id", value=region_id, expected_type=type_hints["region_id"])
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
            "region_id": region_id,
        }
        if endpoint is not None:
            self._values["endpoint"] = endpoint

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth":
        '''AlibabaAuth contains a secretRef for credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibaba#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth", result)

    @builtins.property
    def region_id(self) -> builtins.str:
        '''Alibaba Region to be used for the provider.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibaba#regionID
        '''
        result = self._values.get("region_id")
        assert result is not None, "Required property 'region_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def endpoint(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibaba#endpoint
        '''
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAlibaba(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''AlibabaAuth contains a secretRef for credentials.

        :param secret_ref: AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef":
        '''AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_key_id_secret_ref": "accessKeyIdSecretRef",
        "access_key_secret_secret_ref": "accessKeySecretSecretRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef:
    def __init__(
        self,
        *,
        access_key_id_secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef", typing.Dict[str, typing.Any]],
        access_key_secret_secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :param access_key_id_secret_ref: The AccessKeyID is used for authentication.
        :param access_key_secret_secret_ref: The AccessKeySecret is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef
        '''
        if isinstance(access_key_id_secret_ref, dict):
            access_key_id_secret_ref = ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(**access_key_id_secret_ref)
        if isinstance(access_key_secret_secret_ref, dict):
            access_key_secret_secret_ref = ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(**access_key_secret_secret_ref)
        if __debug__:
            def stub(
                *,
                access_key_id_secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef, typing.Dict[str, typing.Any]],
                access_key_secret_secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument access_key_id_secret_ref", value=access_key_id_secret_ref, expected_type=type_hints["access_key_id_secret_ref"])
            check_type(argname="argument access_key_secret_secret_ref", value=access_key_secret_secret_ref, expected_type=type_hints["access_key_secret_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "access_key_id_secret_ref": access_key_id_secret_ref,
            "access_key_secret_secret_ref": access_key_secret_secret_ref,
        }

    @builtins.property
    def access_key_id_secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef":
        '''The AccessKeyID is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef#accessKeyIDSecretRef
        '''
        result = self._values.get("access_key_id_secret_ref")
        assert result is not None, "Required property 'access_key_id_secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef", result)

    @builtins.property
    def access_key_secret_secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef":
        '''The AccessKeySecret is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef#accessKeySecretSecretRef
        '''
        result = self._values.get("access_key_secret_secret_ref")
        assert result is not None, "Required property 'access_key_secret_secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeyID is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeySecret is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAws",
    jsii_struct_bases=[],
    name_mapping={
        "region": "region",
        "service": "service",
        "auth": "auth",
        "role": "role",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderAws:
    def __init__(
        self,
        *,
        region: builtins.str,
        service: "ClusterSecretStoreV1Beta1SpecProviderAwsService",
        auth: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAwsAuth", typing.Dict[str, typing.Any]]] = None,
        role: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AWS configures this store to sync secrets using AWS Secret Manager provider.

        :param region: AWS Region to be used for the provider.
        :param service: Service defines which service should be used to fetch the secrets.
        :param auth: Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.
        :param role: Role is a Role ARN which the SecretManager provider will assume.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAws
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderAwsAuth(**auth)
        if __debug__:
            def stub(
                *,
                region: builtins.str,
                service: ClusterSecretStoreV1Beta1SpecProviderAwsService,
                auth: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAwsAuth, typing.Dict[str, typing.Any]]] = None,
                role: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
        self._values: typing.Dict[str, typing.Any] = {
            "region": region,
            "service": service,
        }
        if auth is not None:
            self._values["auth"] = auth
        if role is not None:
            self._values["role"] = role

    @builtins.property
    def region(self) -> builtins.str:
        '''AWS Region to be used for the provider.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAws#region
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service(self) -> "ClusterSecretStoreV1Beta1SpecProviderAwsService":
        '''Service defines which service should be used to fetch the secrets.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAws#service
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderAwsService", result)

    @builtins.property
    def auth(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuth"]:
        '''Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAws#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuth"], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a Role ARN which the SecretManager provider will assume.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAws#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAws(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAwsAuth",
    jsii_struct_bases=[],
    name_mapping={"jwt": "jwt", "secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderAwsAuth:
    def __init__(
        self,
        *,
        jwt: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt", typing.Dict[str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.

        :param jwt: Authenticate against AWS using service account tokens.
        :param secret_ref: AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuth
        '''
        if isinstance(jwt, dict):
            jwt = ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt(**jwt)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                jwt: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt, typing.Dict[str, typing.Any]]] = None,
                secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument jwt", value=jwt, expected_type=type_hints["jwt"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if jwt is not None:
            self._values["jwt"] = jwt
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def jwt(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt"]:
        '''Authenticate against AWS using service account tokens.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuth#jwt
        '''
        result = self._values.get("jwt")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef"]:
        '''AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAwsAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt",
    jsii_struct_bases=[],
    name_mapping={"service_account_ref": "serviceAccountRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt:
    def __init__(
        self,
        *,
        service_account_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Authenticate against AWS using service account tokens.

        :param service_account_ref: A reference to a ServiceAccount resource.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                service_account_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef"]:
        '''A reference to a ServiceAccount resource.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_key_id_secret_ref": "accessKeyIdSecretRef",
        "secret_access_key_secret_ref": "secretAccessKeySecretRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef:
    def __init__(
        self,
        *,
        access_key_id_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef", typing.Dict[str, typing.Any]]] = None,
        secret_access_key_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :param access_key_id_secret_ref: The AccessKeyID is used for authentication.
        :param secret_access_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef
        '''
        if isinstance(access_key_id_secret_ref, dict):
            access_key_id_secret_ref = ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(**access_key_id_secret_ref)
        if isinstance(secret_access_key_secret_ref, dict):
            secret_access_key_secret_ref = ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(**secret_access_key_secret_ref)
        if __debug__:
            def stub(
                *,
                access_key_id_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef, typing.Dict[str, typing.Any]]] = None,
                secret_access_key_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument access_key_id_secret_ref", value=access_key_id_secret_ref, expected_type=type_hints["access_key_id_secret_ref"])
            check_type(argname="argument secret_access_key_secret_ref", value=secret_access_key_secret_ref, expected_type=type_hints["secret_access_key_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_key_id_secret_ref is not None:
            self._values["access_key_id_secret_ref"] = access_key_id_secret_ref
        if secret_access_key_secret_ref is not None:
            self._values["secret_access_key_secret_ref"] = secret_access_key_secret_ref

    @builtins.property
    def access_key_id_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef"]:
        '''The AccessKeyID is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef#accessKeyIDSecretRef
        '''
        result = self._values.get("access_key_id_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef"], result)

    @builtins.property
    def secret_access_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef#secretAccessKeySecretRef
        '''
        result = self._values.get("secret_access_key_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeyID is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAwsService"
)
class ClusterSecretStoreV1Beta1SpecProviderAwsService(enum.Enum):
    '''Service defines which service should be used to fetch the secrets.

    :schema: ClusterSecretStoreV1Beta1SpecProviderAwsService
    '''

    SECRETS_MANAGER = "SECRETS_MANAGER"
    '''SecretsManager.'''
    PARAMETER_STORE = "PARAMETER_STORE"
    '''ParameterStore.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAzurekv",
    jsii_struct_bases=[],
    name_mapping={
        "vault_url": "vaultUrl",
        "auth_secret_ref": "authSecretRef",
        "auth_type": "authType",
        "environment_type": "environmentType",
        "identity_id": "identityId",
        "service_account_ref": "serviceAccountRef",
        "tenant_id": "tenantId",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderAzurekv:
    def __init__(
        self,
        *,
        vault_url: builtins.str,
        auth_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef", typing.Dict[str, typing.Any]]] = None,
        auth_type: typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType"] = None,
        environment_type: typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType"] = None,
        identity_id: typing.Optional[builtins.str] = None,
        service_account_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef", typing.Dict[str, typing.Any]]] = None,
        tenant_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AzureKV configures this store to sync secrets using Azure Key Vault provider.

        :param vault_url: Vault Url from which the secrets to be fetched from.
        :param auth_secret_ref: Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type.
        :param auth_type: Auth type defines how to authenticate to the keyvault service. Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
        :param environment_type: EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint. The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152 PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
        :param identity_id: If multiple Managed Identity is assigned to the pod, you can select the one to be used.
        :param service_account_ref: ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
        :param tenant_id: TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekv
        '''
        if isinstance(auth_secret_ref, dict):
            auth_secret_ref = ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef(**auth_secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                vault_url: builtins.str,
                auth_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef, typing.Dict[str, typing.Any]]] = None,
                auth_type: typing.Optional[ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType] = None,
                environment_type: typing.Optional[ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType] = None,
                identity_id: typing.Optional[builtins.str] = None,
                service_account_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef, typing.Dict[str, typing.Any]]] = None,
                tenant_id: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument vault_url", value=vault_url, expected_type=type_hints["vault_url"])
            check_type(argname="argument auth_secret_ref", value=auth_secret_ref, expected_type=type_hints["auth_secret_ref"])
            check_type(argname="argument auth_type", value=auth_type, expected_type=type_hints["auth_type"])
            check_type(argname="argument environment_type", value=environment_type, expected_type=type_hints["environment_type"])
            check_type(argname="argument identity_id", value=identity_id, expected_type=type_hints["identity_id"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument tenant_id", value=tenant_id, expected_type=type_hints["tenant_id"])
        self._values: typing.Dict[str, typing.Any] = {
            "vault_url": vault_url,
        }
        if auth_secret_ref is not None:
            self._values["auth_secret_ref"] = auth_secret_ref
        if auth_type is not None:
            self._values["auth_type"] = auth_type
        if environment_type is not None:
            self._values["environment_type"] = environment_type
        if identity_id is not None:
            self._values["identity_id"] = identity_id
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref
        if tenant_id is not None:
            self._values["tenant_id"] = tenant_id

    @builtins.property
    def vault_url(self) -> builtins.str:
        '''Vault Url from which the secrets to be fetched from.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekv#vaultUrl
        '''
        result = self._values.get("vault_url")
        assert result is not None, "Required property 'vault_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef"]:
        '''Auth configures how the operator authenticates with Azure.

        Required for ServicePrincipal auth type.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekv#authSecretRef
        '''
        result = self._values.get("auth_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef"], result)

    @builtins.property
    def auth_type(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType"]:
        '''Auth type defines how to authenticate to the keyvault service.

        Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekv#authType
        '''
        result = self._values.get("auth_type")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType"], result)

    @builtins.property
    def environment_type(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType"]:
        '''EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure.

        By default it points to the public cloud AAD endpoint. The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152 PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekv#environmentType
        '''
        result = self._values.get("environment_type")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType"], result)

    @builtins.property
    def identity_id(self) -> typing.Optional[builtins.str]:
        '''If multiple Managed Identity is assigned to the pod, you can select the one to be used.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekv#identityId
        '''
        result = self._values.get("identity_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef"]:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekv#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef"], result)

    @builtins.property
    def tenant_id(self) -> typing.Optional[builtins.str]:
        '''TenantID configures the Azure Tenant to send requests to.

        Required for ServicePrincipal auth type.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekv#tenantId
        '''
        result = self._values.get("tenant_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAzurekv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"client_id": "clientId", "client_secret": "clientSecret"},
)
class ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef:
    def __init__(
        self,
        *,
        client_id: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId", typing.Dict[str, typing.Any]]] = None,
        client_secret: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how the operator authenticates with Azure.

        Required for ServicePrincipal auth type.

        :param client_id: The Azure clientId of the service principle used for authentication.
        :param client_secret: The Azure ClientSecret of the service principle used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef
        '''
        if isinstance(client_id, dict):
            client_id = ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId(**client_id)
        if isinstance(client_secret, dict):
            client_secret = ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret(**client_secret)
        if __debug__:
            def stub(
                *,
                client_id: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId, typing.Dict[str, typing.Any]]] = None,
                client_secret: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret", value=client_secret, expected_type=type_hints["client_secret"])
        self._values: typing.Dict[str, typing.Any] = {}
        if client_id is not None:
            self._values["client_id"] = client_id
        if client_secret is not None:
            self._values["client_secret"] = client_secret

    @builtins.property
    def client_id(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId"]:
        '''The Azure clientId of the service principle used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientId
        '''
        result = self._values.get("client_id")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId"], result)

    @builtins.property
    def client_secret(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret"]:
        '''The Azure ClientSecret of the service principle used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientSecret
        '''
        result = self._values.get("client_secret")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Azure clientId of the service principle used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Azure ClientSecret of the service principle used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType"
)
class ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType(enum.Enum):
    '''Auth type defines how to authenticate to the keyvault service.

    Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)

    :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType
    '''

    SERVICE_PRINCIPAL = "SERVICE_PRINCIPAL"
    '''ServicePrincipal.'''
    MANAGED_IDENTITY = "MANAGED_IDENTITY"
    '''ManagedIdentity.'''
    WORKLOAD_IDENTITY = "WORKLOAD_IDENTITY"
    '''WorkloadIdentity.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType"
)
class ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType(enum.Enum):
    '''EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure.

    By default it points to the public cloud AAD endpoint. The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152 PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud

    :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType
    '''

    PUBLIC_CLOUD = "PUBLIC_CLOUD"
    '''PublicCloud.'''
    US_GOVERNMENT_CLOUD = "US_GOVERNMENT_CLOUD"
    '''USGovernmentCloud.'''
    CHINA_CLOUD = "CHINA_CLOUD"
    '''ChinaCloud.'''
    GERMAN_CLOUD = "GERMAN_CLOUD"
    '''GermanCloud.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDoppler",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "config": "config",
        "format": "format",
        "name_transformer": "nameTransformer",
        "project": "project",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderDoppler:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderDopplerAuth", typing.Dict[str, typing.Any]],
        config: typing.Optional[builtins.str] = None,
        format: typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDopplerFormat"] = None,
        name_transformer: typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer"] = None,
        project: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Doppler configures this store to sync secrets using the Doppler provider.

        :param auth: Auth configures how the Operator authenticates with the Doppler API.
        :param config: Doppler config (required if not using a Service Token).
        :param format: Format enables the downloading of secrets as a file (string).
        :param name_transformer: Environment variable compatible name transforms that change secret names to a different format.
        :param project: Doppler project (required if not using a Service Token).

        :schema: ClusterSecretStoreV1Beta1SpecProviderDoppler
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderDopplerAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderDopplerAuth, typing.Dict[str, typing.Any]],
                config: typing.Optional[builtins.str] = None,
                format: typing.Optional[ClusterSecretStoreV1Beta1SpecProviderDopplerFormat] = None,
                name_transformer: typing.Optional[ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer] = None,
                project: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument config", value=config, expected_type=type_hints["config"])
            check_type(argname="argument format", value=format, expected_type=type_hints["format"])
            check_type(argname="argument name_transformer", value=name_transformer, expected_type=type_hints["name_transformer"])
            check_type(argname="argument project", value=project, expected_type=type_hints["project"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
        }
        if config is not None:
            self._values["config"] = config
        if format is not None:
            self._values["format"] = format
        if name_transformer is not None:
            self._values["name_transformer"] = name_transformer
        if project is not None:
            self._values["project"] = project

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderDopplerAuth":
        '''Auth configures how the Operator authenticates with the Doppler API.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDoppler#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderDopplerAuth", result)

    @builtins.property
    def config(self) -> typing.Optional[builtins.str]:
        '''Doppler config (required if not using a Service Token).

        :schema: ClusterSecretStoreV1Beta1SpecProviderDoppler#config
        '''
        result = self._values.get("config")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def format(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDopplerFormat"]:
        '''Format enables the downloading of secrets as a file (string).

        :schema: ClusterSecretStoreV1Beta1SpecProviderDoppler#format
        '''
        result = self._values.get("format")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDopplerFormat"], result)

    @builtins.property
    def name_transformer(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer"]:
        '''Environment variable compatible name transforms that change secret names to a different format.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDoppler#nameTransformer
        '''
        result = self._values.get("name_transformer")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer"], result)

    @builtins.property
    def project(self) -> typing.Optional[builtins.str]:
        '''Doppler project (required if not using a Service Token).

        :schema: ClusterSecretStoreV1Beta1SpecProviderDoppler#project
        '''
        result = self._values.get("project")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderDoppler(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDopplerAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderDopplerAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''Auth configures how the Operator authenticates with the Doppler API.

        :param secret_ref: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderDopplerAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef":
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderDopplerAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderDopplerAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"doppler_token": "dopplerToken"},
)
class ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef:
    def __init__(
        self,
        *,
        doppler_token: typing.Union["ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken", typing.Dict[str, typing.Any]],
    ) -> None:
        '''
        :param doppler_token: The DopplerToken is used for authentication. See https://docs.doppler.com/reference/api#authentication for auth token types. The Key attribute defaults to dopplerToken if not specified.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef
        '''
        if isinstance(doppler_token, dict):
            doppler_token = ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken(**doppler_token)
        if __debug__:
            def stub(
                *,
                doppler_token: typing.Union[ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument doppler_token", value=doppler_token, expected_type=type_hints["doppler_token"])
        self._values: typing.Dict[str, typing.Any] = {
            "doppler_token": doppler_token,
        }

    @builtins.property
    def doppler_token(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken":
        '''The DopplerToken is used for authentication.

        See https://docs.doppler.com/reference/api#authentication for auth token types. The Key attribute defaults to dopplerToken if not specified.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef#dopplerToken
        '''
        result = self._values.get("doppler_token")
        assert result is not None, "Required property 'doppler_token' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The DopplerToken is used for authentication.

        See https://docs.doppler.com/reference/api#authentication for auth token types. The Key attribute defaults to dopplerToken if not specified.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDopplerFormat"
)
class ClusterSecretStoreV1Beta1SpecProviderDopplerFormat(enum.Enum):
    '''Format enables the downloading of secrets as a file (string).

    :schema: ClusterSecretStoreV1Beta1SpecProviderDopplerFormat
    '''

    JSON = "JSON"
    '''json.'''
    DOTNET_JSON = "DOTNET_JSON"
    '''dotnet-json.'''
    ENV = "ENV"
    '''env.'''
    YAML = "YAML"
    '''yaml.'''
    DOCKER = "DOCKER"
    '''docker.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer"
)
class ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer(enum.Enum):
    '''Environment variable compatible name transforms that change secret names to a different format.

    :schema: ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer
    '''

    UPPER_CAMEL = "UPPER_CAMEL"
    '''upper-camel.'''
    CAMEL = "CAMEL"
    '''camel.'''
    LOWER_SNAKE = "LOWER_SNAKE"
    '''lower-snake.'''
    TF_VAR = "TF_VAR"
    '''tf-var.'''
    DOTNET_ENV = "DOTNET_ENV"
    '''dotnet-env.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderFake",
    jsii_struct_bases=[],
    name_mapping={"data": "data"},
)
class ClusterSecretStoreV1Beta1SpecProviderFake:
    def __init__(
        self,
        *,
        data: typing.Sequence[typing.Union["ClusterSecretStoreV1Beta1SpecProviderFakeData", typing.Dict[str, typing.Any]]],
    ) -> None:
        '''Fake configures a store with static key/value pairs.

        :param data: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderFake
        '''
        if __debug__:
            def stub(
                *,
                data: typing.Sequence[typing.Union[ClusterSecretStoreV1Beta1SpecProviderFakeData, typing.Dict[str, typing.Any]]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
        self._values: typing.Dict[str, typing.Any] = {
            "data": data,
        }

    @builtins.property
    def data(self) -> typing.List["ClusterSecretStoreV1Beta1SpecProviderFakeData"]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderFake#data
        '''
        result = self._values.get("data")
        assert result is not None, "Required property 'data' is missing"
        return typing.cast(typing.List["ClusterSecretStoreV1Beta1SpecProviderFakeData"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderFake(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderFakeData",
    jsii_struct_bases=[],
    name_mapping={
        "key": "key",
        "value": "value",
        "value_map": "valueMap",
        "version": "version",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderFakeData:
    def __init__(
        self,
        *,
        key: builtins.str,
        value: typing.Optional[builtins.str] = None,
        value_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param key: 
        :param value: 
        :param value_map: 
        :param version: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderFakeData
        '''
        if __debug__:
            def stub(
                *,
                key: builtins.str,
                value: typing.Optional[builtins.str] = None,
                value_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
                version: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            check_type(argname="argument value_map", value=value_map, expected_type=type_hints["value_map"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }
        if value is not None:
            self._values["value"] = value
        if value_map is not None:
            self._values["value_map"] = value_map
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderFakeData#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderFakeData#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value_map(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderFakeData#valueMap
        '''
        result = self._values.get("value_map")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderFakeData#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderFakeData(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderGcpsm",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "project_id": "projectId"},
)
class ClusterSecretStoreV1Beta1SpecProviderGcpsm:
    def __init__(
        self,
        *,
        auth: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth", typing.Dict[str, typing.Any]]] = None,
        project_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.

        :param auth: Auth defines the information necessary to authenticate against GCP.
        :param project_id: ProjectID project where secret is located.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsm
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth, typing.Dict[str, typing.Any]]] = None,
                project_id: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
        self._values: typing.Dict[str, typing.Any] = {}
        if auth is not None:
            self._values["auth"] = auth
        if project_id is not None:
            self._values["project_id"] = project_id

    @builtins.property
    def auth(self) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth"]:
        '''Auth defines the information necessary to authenticate against GCP.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsm#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth"], result)

    @builtins.property
    def project_id(self) -> typing.Optional[builtins.str]:
        '''ProjectID project where secret is located.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsm#projectID
        '''
        result = self._values.get("project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderGcpsm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "workload_identity": "workloadIdentity"},
)
class ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef", typing.Dict[str, typing.Any]]] = None,
        workload_identity: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against GCP.

        :param secret_ref: 
        :param workload_identity: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef(**secret_ref)
        if isinstance(workload_identity, dict):
            workload_identity = ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity(**workload_identity)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef, typing.Dict[str, typing.Any]]] = None,
                workload_identity: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument workload_identity", value=workload_identity, expected_type=type_hints["workload_identity"])
        self._values: typing.Dict[str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if workload_identity is not None:
            self._values["workload_identity"] = workload_identity

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef"]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef"], result)

    @builtins.property
    def workload_identity(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity"]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth#workloadIdentity
        '''
        result = self._values.get("workload_identity")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"secret_access_key_secret_ref": "secretAccessKeySecretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef:
    def __init__(
        self,
        *,
        secret_access_key_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param secret_access_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef
        '''
        if isinstance(secret_access_key_secret_ref, dict):
            secret_access_key_secret_ref = ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(**secret_access_key_secret_ref)
        if __debug__:
            def stub(
                *,
                secret_access_key_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_access_key_secret_ref", value=secret_access_key_secret_ref, expected_type=type_hints["secret_access_key_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if secret_access_key_secret_ref is not None:
            self._values["secret_access_key_secret_ref"] = secret_access_key_secret_ref

    @builtins.property
    def secret_access_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef#secretAccessKeySecretRef
        '''
        result = self._values.get("secret_access_key_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity",
    jsii_struct_bases=[],
    name_mapping={
        "cluster_location": "clusterLocation",
        "cluster_name": "clusterName",
        "service_account_ref": "serviceAccountRef",
        "cluster_project_id": "clusterProjectId",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity:
    def __init__(
        self,
        *,
        cluster_location: builtins.str,
        cluster_name: builtins.str,
        service_account_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef", typing.Dict[str, typing.Any]],
        cluster_project_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param cluster_location: 
        :param cluster_name: 
        :param service_account_ref: A reference to a ServiceAccount resource.
        :param cluster_project_id: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                cluster_location: builtins.str,
                cluster_name: builtins.str,
                service_account_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef, typing.Dict[str, typing.Any]],
                cluster_project_id: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument cluster_location", value=cluster_location, expected_type=type_hints["cluster_location"])
            check_type(argname="argument cluster_name", value=cluster_name, expected_type=type_hints["cluster_name"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument cluster_project_id", value=cluster_project_id, expected_type=type_hints["cluster_project_id"])
        self._values: typing.Dict[str, typing.Any] = {
            "cluster_location": cluster_location,
            "cluster_name": cluster_name,
            "service_account_ref": service_account_ref,
        }
        if cluster_project_id is not None:
            self._values["cluster_project_id"] = cluster_project_id

    @builtins.property
    def cluster_location(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterLocation
        '''
        result = self._values.get("cluster_location")
        assert result is not None, "Required property 'cluster_location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cluster_name(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterName
        '''
        result = self._values.get("cluster_name")
        assert result is not None, "Required property 'cluster_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef":
        '''A reference to a ServiceAccount resource.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        assert result is not None, "Required property 'service_account_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef", result)

    @builtins.property
    def cluster_project_id(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterProjectID
        '''
        result = self._values.get("cluster_project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderGitlab",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "environment": "environment",
        "project_id": "projectId",
        "url": "url",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderGitlab:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderGitlabAuth", typing.Dict[str, typing.Any]],
        environment: typing.Optional[builtins.str] = None,
        project_id: typing.Optional[builtins.str] = None,
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Gitlab configures this store to sync secrets using Gitlab Variables provider.

        :param auth: Auth configures how secret-manager authenticates with a GitLab instance.
        :param environment: Environment environment_scope of gitlab CI/CD variables (Please see https://docs.gitlab.com/ee/ci/environments/#create-a-static-environment on how to create environments).
        :param project_id: ProjectID specifies a project where secrets are located.
        :param url: URL configures the GitLab instance URL. Defaults to https://gitlab.com/. Default: https://gitlab.com/.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlab
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderGitlabAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderGitlabAuth, typing.Dict[str, typing.Any]],
                environment: typing.Optional[builtins.str] = None,
                project_id: typing.Optional[builtins.str] = None,
                url: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
        }
        if environment is not None:
            self._values["environment"] = environment
        if project_id is not None:
            self._values["project_id"] = project_id
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderGitlabAuth":
        '''Auth configures how secret-manager authenticates with a GitLab instance.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlab#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderGitlabAuth", result)

    @builtins.property
    def environment(self) -> typing.Optional[builtins.str]:
        '''Environment environment_scope of gitlab CI/CD variables (Please see https://docs.gitlab.com/ee/ci/environments/#create-a-static-environment on how to create environments).

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlab#environment
        '''
        result = self._values.get("environment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def project_id(self) -> typing.Optional[builtins.str]:
        '''ProjectID specifies a project where secrets are located.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlab#projectID
        '''
        result = self._values.get("project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''URL configures the GitLab instance URL.

        Defaults to https://gitlab.com/.

        :default: https://gitlab.com/.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlab#url
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderGitlab(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderGitlabAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderGitlabAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''Auth configures how secret-manager authenticates with a GitLab instance.

        :param secret_ref: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlabAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef":
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlabAuth#SecretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderGitlabAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"access_token": "accessToken"},
)
class ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef:
    def __init__(
        self,
        *,
        access_token: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param access_token: AccessToken is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef
        '''
        if isinstance(access_token, dict):
            access_token = ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken(**access_token)
        if __debug__:
            def stub(
                *,
                access_token: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument access_token", value=access_token, expected_type=type_hints["access_token"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_token is not None:
            self._values["access_token"] = access_token

    @builtins.property
    def access_token(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken"]:
        '''AccessToken is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef#accessToken
        '''
        result = self._values.get("access_token")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AccessToken is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderIbm",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "service_url": "serviceUrl"},
)
class ClusterSecretStoreV1Beta1SpecProviderIbm:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderIbmAuth", typing.Dict[str, typing.Any]],
        service_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''IBM configures this store to sync secrets using IBM Cloud provider.

        :param auth: Auth configures how secret-manager authenticates with the IBM secrets manager.
        :param service_url: ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbm
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderIbmAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderIbmAuth, typing.Dict[str, typing.Any]],
                service_url: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument service_url", value=service_url, expected_type=type_hints["service_url"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
        }
        if service_url is not None:
            self._values["service_url"] = service_url

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderIbmAuth":
        '''Auth configures how secret-manager authenticates with the IBM secrets manager.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbm#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderIbmAuth", result)

    @builtins.property
    def service_url(self) -> typing.Optional[builtins.str]:
        '''ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbm#serviceUrl
        '''
        result = self._values.get("service_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderIbm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderIbmAuth",
    jsii_struct_bases=[],
    name_mapping={"container_auth": "containerAuth", "secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderIbmAuth:
    def __init__(
        self,
        *,
        container_auth: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth", typing.Dict[str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how secret-manager authenticates with the IBM secrets manager.

        :param container_auth: IBM Container-based auth with IAM Trusted Profile.
        :param secret_ref: 

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuth
        '''
        if isinstance(container_auth, dict):
            container_auth = ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth(**container_auth)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                container_auth: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth, typing.Dict[str, typing.Any]]] = None,
                secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument container_auth", value=container_auth, expected_type=type_hints["container_auth"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if container_auth is not None:
            self._values["container_auth"] = container_auth
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def container_auth(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth"]:
        '''IBM Container-based auth with IAM Trusted Profile.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuth#containerAuth
        '''
        result = self._values.get("container_auth")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef"]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderIbmAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth",
    jsii_struct_bases=[],
    name_mapping={
        "profile": "profile",
        "iam_endpoint": "iamEndpoint",
        "token_location": "tokenLocation",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth:
    def __init__(
        self,
        *,
        profile: builtins.str,
        iam_endpoint: typing.Optional[builtins.str] = None,
        token_location: typing.Optional[builtins.str] = None,
    ) -> None:
        '''IBM Container-based auth with IAM Trusted Profile.

        :param profile: the IBM Trusted Profile.
        :param iam_endpoint: 
        :param token_location: Location the token is mounted on the pod.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth
        '''
        if __debug__:
            def stub(
                *,
                profile: builtins.str,
                iam_endpoint: typing.Optional[builtins.str] = None,
                token_location: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument profile", value=profile, expected_type=type_hints["profile"])
            check_type(argname="argument iam_endpoint", value=iam_endpoint, expected_type=type_hints["iam_endpoint"])
            check_type(argname="argument token_location", value=token_location, expected_type=type_hints["token_location"])
        self._values: typing.Dict[str, typing.Any] = {
            "profile": profile,
        }
        if iam_endpoint is not None:
            self._values["iam_endpoint"] = iam_endpoint
        if token_location is not None:
            self._values["token_location"] = token_location

    @builtins.property
    def profile(self) -> builtins.str:
        '''the IBM Trusted Profile.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#profile
        '''
        result = self._values.get("profile")
        assert result is not None, "Required property 'profile' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def iam_endpoint(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#iamEndpoint
        '''
        result = self._values.get("iam_endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def token_location(self) -> typing.Optional[builtins.str]:
        '''Location the token is mounted on the pod.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#tokenLocation
        '''
        result = self._values.get("token_location")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"secret_api_key_secret_ref": "secretApiKeySecretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef:
    def __init__(
        self,
        *,
        secret_api_key_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param secret_api_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef
        '''
        if isinstance(secret_api_key_secret_ref, dict):
            secret_api_key_secret_ref = ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef(**secret_api_key_secret_ref)
        if __debug__:
            def stub(
                *,
                secret_api_key_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_api_key_secret_ref", value=secret_api_key_secret_ref, expected_type=type_hints["secret_api_key_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if secret_api_key_secret_ref is not None:
            self._values["secret_api_key_secret_ref"] = secret_api_key_secret_ref

    @builtins.property
    def secret_api_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef#secretApiKeySecretRef
        '''
        result = self._values.get("secret_api_key_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetes",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "remote_namespace": "remoteNamespace",
        "server": "server",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetes:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth", typing.Dict[str, typing.Any]],
        remote_namespace: typing.Optional[builtins.str] = None,
        server: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetesServer", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.

        :param auth: Auth configures how secret-manager authenticates with a Kubernetes instance.
        :param remote_namespace: Remote namespace to fetch the secrets from.
        :param server: configures the Kubernetes server Address.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetes
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth(**auth)
        if isinstance(server, dict):
            server = ClusterSecretStoreV1Beta1SpecProviderKubernetesServer(**server)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth, typing.Dict[str, typing.Any]],
                remote_namespace: typing.Optional[builtins.str] = None,
                server: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetesServer, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument remote_namespace", value=remote_namespace, expected_type=type_hints["remote_namespace"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
        }
        if remote_namespace is not None:
            self._values["remote_namespace"] = remote_namespace
        if server is not None:
            self._values["server"] = server

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth":
        '''Auth configures how secret-manager authenticates with a Kubernetes instance.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetes#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth", result)

    @builtins.property
    def remote_namespace(self) -> typing.Optional[builtins.str]:
        '''Remote namespace to fetch the secrets from.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetes#remoteNamespace
        '''
        result = self._values.get("remote_namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def server(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesServer"]:
        '''configures the Kubernetes server Address.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetes#server
        '''
        result = self._values.get("server")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesServer"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth",
    jsii_struct_bases=[],
    name_mapping={
        "cert": "cert",
        "service_account": "serviceAccount",
        "token": "token",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth:
    def __init__(
        self,
        *,
        cert: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert", typing.Dict[str, typing.Any]]] = None,
        service_account: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount", typing.Dict[str, typing.Any]]] = None,
        token: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how secret-manager authenticates with a Kubernetes instance.

        :param cert: has both clientCert and clientKey as secretKeySelector.
        :param service_account: points to a service account that should be used for authentication.
        :param token: use static token to authenticate with.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth
        '''
        if isinstance(cert, dict):
            cert = ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert(**cert)
        if isinstance(service_account, dict):
            service_account = ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount(**service_account)
        if isinstance(token, dict):
            token = ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken(**token)
        if __debug__:
            def stub(
                *,
                cert: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert, typing.Dict[str, typing.Any]]] = None,
                service_account: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount, typing.Dict[str, typing.Any]]] = None,
                token: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument cert", value=cert, expected_type=type_hints["cert"])
            check_type(argname="argument service_account", value=service_account, expected_type=type_hints["service_account"])
            check_type(argname="argument token", value=token, expected_type=type_hints["token"])
        self._values: typing.Dict[str, typing.Any] = {}
        if cert is not None:
            self._values["cert"] = cert
        if service_account is not None:
            self._values["service_account"] = service_account
        if token is not None:
            self._values["token"] = token

    @builtins.property
    def cert(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert"]:
        '''has both clientCert and clientKey as secretKeySelector.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth#cert
        '''
        result = self._values.get("cert")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert"], result)

    @builtins.property
    def service_account(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount"]:
        '''points to a service account that should be used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth#serviceAccount
        '''
        result = self._values.get("service_account")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount"], result)

    @builtins.property
    def token(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken"]:
        '''use static token to authenticate with.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth#token
        '''
        result = self._values.get("token")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert",
    jsii_struct_bases=[],
    name_mapping={"client_cert": "clientCert", "client_key": "clientKey"},
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert:
    def __init__(
        self,
        *,
        client_cert: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert", typing.Dict[str, typing.Any]]] = None,
        client_key: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''has both clientCert and clientKey as secretKeySelector.

        :param client_cert: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.
        :param client_key: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert
        '''
        if isinstance(client_cert, dict):
            client_cert = ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert(**client_cert)
        if isinstance(client_key, dict):
            client_key = ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey(**client_key)
        if __debug__:
            def stub(
                *,
                client_cert: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert, typing.Dict[str, typing.Any]]] = None,
                client_key: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument client_cert", value=client_cert, expected_type=type_hints["client_cert"])
            check_type(argname="argument client_key", value=client_key, expected_type=type_hints["client_key"])
        self._values: typing.Dict[str, typing.Any] = {}
        if client_cert is not None:
            self._values["client_cert"] = client_cert
        if client_key is not None:
            self._values["client_key"] = client_key

    @builtins.property
    def client_cert(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert#clientCert
        '''
        result = self._values.get("client_cert")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert"], result)

    @builtins.property
    def client_key(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert#clientKey
        '''
        result = self._values.get("client_key")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''points to a service account that should be used for authentication.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken",
    jsii_struct_bases=[],
    name_mapping={"bearer_token": "bearerToken"},
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken:
    def __init__(
        self,
        *,
        bearer_token: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''use static token to authenticate with.

        :param bearer_token: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken
        '''
        if isinstance(bearer_token, dict):
            bearer_token = ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken(**bearer_token)
        if __debug__:
            def stub(
                *,
                bearer_token: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument bearer_token", value=bearer_token, expected_type=type_hints["bearer_token"])
        self._values: typing.Dict[str, typing.Any] = {}
        if bearer_token is not None:
            self._values["bearer_token"] = bearer_token

    @builtins.property
    def bearer_token(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken#bearerToken
        '''
        result = self._values.get("bearer_token")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesServer",
    jsii_struct_bases=[],
    name_mapping={"ca_bundle": "caBundle", "ca_provider": "caProvider", "url": "url"},
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesServer:
    def __init__(
        self,
        *,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider", typing.Dict[str, typing.Any]]] = None,
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''configures the Kubernetes server Address.

        :param ca_bundle: CABundle is a base64-encoded CA certificate.
        :param ca_provider: see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.
        :param url: configures the Kubernetes server Address.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesServer
        '''
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider(**ca_provider)
        if __debug__:
            def stub(
                *,
                ca_bundle: typing.Optional[builtins.str] = None,
                ca_provider: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider, typing.Dict[str, typing.Any]]] = None,
                url: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[str, typing.Any] = {}
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''CABundle is a base64-encoded CA certificate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesServer#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider"]:
        '''see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesServer#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider"], result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''configures the Kubernetes server Address.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesServer#url
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetesServer(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                type: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType,
                key: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        Can only be defined when used in a ClusterSecretStore.

        :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType"
)
class ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOnepassword",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "connect_host": "connectHost", "vaults": "vaults"},
)
class ClusterSecretStoreV1Beta1SpecProviderOnepassword:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth", typing.Dict[str, typing.Any]],
        connect_host: builtins.str,
        vaults: typing.Mapping[builtins.str, jsii.Number],
    ) -> None:
        '''OnePassword configures this store to sync secrets using the 1Password Cloud provider.

        :param auth: Auth defines the information necessary to authenticate against OnePassword Connect Server.
        :param connect_host: ConnectHost defines the OnePassword Connect Server to connect to.
        :param vaults: Vaults defines which OnePassword vaults to search in which order.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepassword
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth, typing.Dict[str, typing.Any]],
                connect_host: builtins.str,
                vaults: typing.Mapping[builtins.str, jsii.Number],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument connect_host", value=connect_host, expected_type=type_hints["connect_host"])
            check_type(argname="argument vaults", value=vaults, expected_type=type_hints["vaults"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
            "connect_host": connect_host,
            "vaults": vaults,
        }

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth":
        '''Auth defines the information necessary to authenticate against OnePassword Connect Server.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepassword#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth", result)

    @builtins.property
    def connect_host(self) -> builtins.str:
        '''ConnectHost defines the OnePassword Connect Server to connect to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepassword#connectHost
        '''
        result = self._values.get("connect_host")
        assert result is not None, "Required property 'connect_host' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vaults(self) -> typing.Mapping[builtins.str, jsii.Number]:
        '''Vaults defines which OnePassword vaults to search in which order.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepassword#vaults
        '''
        result = self._values.get("vaults")
        assert result is not None, "Required property 'vaults' is missing"
        return typing.cast(typing.Mapping[builtins.str, jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOnepassword(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''Auth defines the information necessary to authenticate against OnePassword Connect Server.

        :param secret_ref: OnePasswordAuthSecretRef holds secret references for 1Password credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef":
        '''OnePasswordAuthSecretRef holds secret references for 1Password credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"connect_token_secret_ref": "connectTokenSecretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef:
    def __init__(
        self,
        *,
        connect_token_secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''OnePasswordAuthSecretRef holds secret references for 1Password credentials.

        :param connect_token_secret_ref: The ConnectToken is used for authentication to a 1Password Connect Server.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef
        '''
        if isinstance(connect_token_secret_ref, dict):
            connect_token_secret_ref = ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(**connect_token_secret_ref)
        if __debug__:
            def stub(
                *,
                connect_token_secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument connect_token_secret_ref", value=connect_token_secret_ref, expected_type=type_hints["connect_token_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "connect_token_secret_ref": connect_token_secret_ref,
        }

    @builtins.property
    def connect_token_secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef":
        '''The ConnectToken is used for authentication to a 1Password Connect Server.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef#connectTokenSecretRef
        '''
        result = self._values.get("connect_token_secret_ref")
        assert result is not None, "Required property 'connect_token_secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The ConnectToken is used for authentication to a 1Password Connect Server.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOracle",
    jsii_struct_bases=[],
    name_mapping={"region": "region", "vault": "vault", "auth": "auth"},
)
class ClusterSecretStoreV1Beta1SpecProviderOracle:
    def __init__(
        self,
        *,
        region: builtins.str,
        vault: builtins.str,
        auth: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderOracleAuth", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Oracle configures this store to sync secrets using Oracle Vault provider.

        :param region: Region is the region where vault is located.
        :param vault: Vault is the vault's OCID of the specific vault where secret is located.
        :param auth: Auth configures how secret-manager authenticates with the Oracle Vault. If empty, use the instance principal, otherwise the user credentials specified in Auth.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracle
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderOracleAuth(**auth)
        if __debug__:
            def stub(
                *,
                region: builtins.str,
                vault: builtins.str,
                auth: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderOracleAuth, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument vault", value=vault, expected_type=type_hints["vault"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
        self._values: typing.Dict[str, typing.Any] = {
            "region": region,
            "vault": vault,
        }
        if auth is not None:
            self._values["auth"] = auth

    @builtins.property
    def region(self) -> builtins.str:
        '''Region is the region where vault is located.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracle#region
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vault(self) -> builtins.str:
        '''Vault is the vault's OCID of the specific vault where secret is located.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracle#vault
        '''
        result = self._values.get("vault")
        assert result is not None, "Required property 'vault' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderOracleAuth"]:
        '''Auth configures how secret-manager authenticates with the Oracle Vault.

        If empty, use the instance principal, otherwise the user credentials specified in Auth.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracle#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderOracleAuth"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOracle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOracleAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "tenancy": "tenancy", "user": "user"},
)
class ClusterSecretStoreV1Beta1SpecProviderOracleAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef", typing.Dict[str, typing.Any]],
        tenancy: builtins.str,
        user: builtins.str,
    ) -> None:
        '''Auth configures how secret-manager authenticates with the Oracle Vault.

        If empty, use the instance principal, otherwise the user credentials specified in Auth.

        :param secret_ref: SecretRef to pass through sensitive information.
        :param tenancy: Tenancy is the tenancy OCID where user is located.
        :param user: User is an access OCID specific to the account.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef, typing.Dict[str, typing.Any]],
                tenancy: builtins.str,
                user: builtins.str,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument tenancy", value=tenancy, expected_type=type_hints["tenancy"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_ref": secret_ref,
            "tenancy": tenancy,
            "user": user,
        }

    @builtins.property
    def secret_ref(self) -> "ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef":
        '''SecretRef to pass through sensitive information.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef", result)

    @builtins.property
    def tenancy(self) -> builtins.str:
        '''Tenancy is the tenancy OCID where user is located.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuth#tenancy
        '''
        result = self._values.get("tenancy")
        assert result is not None, "Required property 'tenancy' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def user(self) -> builtins.str:
        '''User is an access OCID specific to the account.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuth#user
        '''
        result = self._values.get("user")
        assert result is not None, "Required property 'user' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOracleAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"fingerprint": "fingerprint", "privatekey": "privatekey"},
)
class ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef:
    def __init__(
        self,
        *,
        fingerprint: typing.Union["ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint", typing.Dict[str, typing.Any]],
        privatekey: typing.Union["ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey", typing.Dict[str, typing.Any]],
    ) -> None:
        '''SecretRef to pass through sensitive information.

        :param fingerprint: Fingerprint is the fingerprint of the API private key.
        :param privatekey: PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef
        '''
        if isinstance(fingerprint, dict):
            fingerprint = ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint(**fingerprint)
        if isinstance(privatekey, dict):
            privatekey = ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey(**privatekey)
        if __debug__:
            def stub(
                *,
                fingerprint: typing.Union[ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint, typing.Dict[str, typing.Any]],
                privatekey: typing.Union[ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument fingerprint", value=fingerprint, expected_type=type_hints["fingerprint"])
            check_type(argname="argument privatekey", value=privatekey, expected_type=type_hints["privatekey"])
        self._values: typing.Dict[str, typing.Any] = {
            "fingerprint": fingerprint,
            "privatekey": privatekey,
        }

    @builtins.property
    def fingerprint(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint":
        '''Fingerprint is the fingerprint of the API private key.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef#fingerprint
        '''
        result = self._values.get("fingerprint")
        assert result is not None, "Required property 'fingerprint' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint", result)

    @builtins.property
    def privatekey(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey":
        '''PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef#privatekey
        '''
        result = self._values.get("privatekey")
        assert result is not None, "Required property 'privatekey' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Fingerprint is the fingerprint of the API private key.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderSenhasegura",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "module": "module",
        "url": "url",
        "ignore_ssl_certificate": "ignoreSslCertificate",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderSenhasegura:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth", typing.Dict[str, typing.Any]],
        module: builtins.str,
        url: builtins.str,
        ignore_ssl_certificate: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Senhasegura configures this store to sync secrets using senhasegura provider.

        :param auth: Auth defines parameters to authenticate in senhasegura.
        :param module: Module defines which senhasegura module should be used to get secrets.
        :param url: URL of senhasegura.
        :param ignore_ssl_certificate: IgnoreSslCertificate defines if SSL certificate must be ignored.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhasegura
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth, typing.Dict[str, typing.Any]],
                module: builtins.str,
                url: builtins.str,
                ignore_ssl_certificate: typing.Optional[builtins.bool] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument module", value=module, expected_type=type_hints["module"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
            check_type(argname="argument ignore_ssl_certificate", value=ignore_ssl_certificate, expected_type=type_hints["ignore_ssl_certificate"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
            "module": module,
            "url": url,
        }
        if ignore_ssl_certificate is not None:
            self._values["ignore_ssl_certificate"] = ignore_ssl_certificate

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth":
        '''Auth defines parameters to authenticate in senhasegura.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhasegura#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth", result)

    @builtins.property
    def module(self) -> builtins.str:
        '''Module defines which senhasegura module should be used to get secrets.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhasegura#module
        '''
        result = self._values.get("module")
        assert result is not None, "Required property 'module' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def url(self) -> builtins.str:
        '''URL of senhasegura.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhasegura#url
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ignore_ssl_certificate(self) -> typing.Optional[builtins.bool]:
        '''IgnoreSslCertificate defines if SSL certificate must be ignored.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhasegura#ignoreSslCertificate
        '''
        result = self._values.get("ignore_ssl_certificate")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderSenhasegura(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth",
    jsii_struct_bases=[],
    name_mapping={
        "client_id": "clientId",
        "client_secret_secret_ref": "clientSecretSecretRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth:
    def __init__(
        self,
        *,
        client_id: builtins.str,
        client_secret_secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''Auth defines parameters to authenticate in senhasegura.

        :param client_id: 
        :param client_secret_secret_ref: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth
        '''
        if isinstance(client_secret_secret_ref, dict):
            client_secret_secret_ref = ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef(**client_secret_secret_ref)
        if __debug__:
            def stub(
                *,
                client_id: builtins.str,
                client_secret_secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret_secret_ref", value=client_secret_secret_ref, expected_type=type_hints["client_secret_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "client_id": client_id,
            "client_secret_secret_ref": client_secret_secret_ref,
        }

    @builtins.property
    def client_id(self) -> builtins.str:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth#clientId
        '''
        result = self._values.get("client_id")
        assert result is not None, "Required property 'client_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def client_secret_secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef":
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth#clientSecretSecretRef
        '''
        result = self._values.get("client_secret_secret_ref")
        assert result is not None, "Required property 'client_secret_secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVault",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "server": "server",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
        "forward_inconsistent": "forwardInconsistent",
        "namespace": "namespace",
        "path": "path",
        "read_your_writes": "readYourWrites",
        "version": "version",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderVault:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuth", typing.Dict[str, typing.Any]],
        server: builtins.str,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider", typing.Dict[str, typing.Any]]] = None,
        forward_inconsistent: typing.Optional[builtins.bool] = None,
        namespace: typing.Optional[builtins.str] = None,
        path: typing.Optional[builtins.str] = None,
        read_your_writes: typing.Optional[builtins.bool] = None,
        version: typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultVersion"] = None,
    ) -> None:
        '''Vault configures this store to sync secrets using Hashi provider.

        :param auth: Auth configures how secret-manager authenticates with the Vault server.
        :param server: Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
        :param ca_bundle: PEM encoded CA bundle used to validate Vault server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
        :param ca_provider: The provider for the CA bundle to use to validate Vault server certificate.
        :param forward_inconsistent: ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop. This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
        :param namespace: Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
        :param path: Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.
        :param read_your_writes: ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request. More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency
        :param version: Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderVaultAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider(**ca_provider)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuth, typing.Dict[str, typing.Any]],
                server: builtins.str,
                ca_bundle: typing.Optional[builtins.str] = None,
                ca_provider: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider, typing.Dict[str, typing.Any]]] = None,
                forward_inconsistent: typing.Optional[builtins.bool] = None,
                namespace: typing.Optional[builtins.str] = None,
                path: typing.Optional[builtins.str] = None,
                read_your_writes: typing.Optional[builtins.bool] = None,
                version: typing.Optional[ClusterSecretStoreV1Beta1SpecProviderVaultVersion] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument forward_inconsistent", value=forward_inconsistent, expected_type=type_hints["forward_inconsistent"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument read_your_writes", value=read_your_writes, expected_type=type_hints["read_your_writes"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
            "server": server,
        }
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if forward_inconsistent is not None:
            self._values["forward_inconsistent"] = forward_inconsistent
        if namespace is not None:
            self._values["namespace"] = namespace
        if path is not None:
            self._values["path"] = path
        if read_your_writes is not None:
            self._values["read_your_writes"] = read_your_writes
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderVaultAuth":
        '''Auth configures how secret-manager authenticates with the Vault server.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderVaultAuth", result)

    @builtins.property
    def server(self) -> builtins.str:
        '''Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault#server
        '''
        result = self._values.get("server")
        assert result is not None, "Required property 'server' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''PEM encoded CA bundle used to validate Vault server certificate.

        Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider"]:
        '''The provider for the CA bundle to use to validate Vault server certificate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider"], result)

    @builtins.property
    def forward_inconsistent(self) -> typing.Optional[builtins.bool]:
        '''ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop.

        This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault#forwardInconsistent
        '''
        result = self._values.get("forward_inconsistent")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Name of the vault namespace.

        Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_your_writes(self) -> typing.Optional[builtins.bool]:
        '''ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request.

        More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault#readYourWrites
        '''
        result = self._values.get("read_your_writes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def version(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultVersion"]:
        '''Version is the Vault KV secret engine version.

        This can be either "v1" or "v2". Version defaults to "v2".

        :schema: ClusterSecretStoreV1Beta1SpecProviderVault#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultVersion"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVault(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuth",
    jsii_struct_bases=[],
    name_mapping={
        "app_role": "appRole",
        "cert": "cert",
        "jwt": "jwt",
        "kubernetes": "kubernetes",
        "ldap": "ldap",
        "token_secret_ref": "tokenSecretRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuth:
    def __init__(
        self,
        *,
        app_role: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole", typing.Dict[str, typing.Any]]] = None,
        cert: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert", typing.Dict[str, typing.Any]]] = None,
        jwt: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt", typing.Dict[str, typing.Any]]] = None,
        kubernetes: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes", typing.Dict[str, typing.Any]]] = None,
        ldap: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap", typing.Dict[str, typing.Any]]] = None,
        token_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how secret-manager authenticates with the Vault server.

        :param app_role: AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
        :param cert: Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.
        :param jwt: Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.
        :param kubernetes: Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
        :param ldap: Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.
        :param token_secret_ref: TokenSecretRef authenticates with Vault by presenting a token.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuth
        '''
        if isinstance(app_role, dict):
            app_role = ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole(**app_role)
        if isinstance(cert, dict):
            cert = ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert(**cert)
        if isinstance(jwt, dict):
            jwt = ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt(**jwt)
        if isinstance(kubernetes, dict):
            kubernetes = ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes(**kubernetes)
        if isinstance(ldap, dict):
            ldap = ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap(**ldap)
        if isinstance(token_secret_ref, dict):
            token_secret_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef(**token_secret_ref)
        if __debug__:
            def stub(
                *,
                app_role: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole, typing.Dict[str, typing.Any]]] = None,
                cert: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert, typing.Dict[str, typing.Any]]] = None,
                jwt: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt, typing.Dict[str, typing.Any]]] = None,
                kubernetes: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes, typing.Dict[str, typing.Any]]] = None,
                ldap: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap, typing.Dict[str, typing.Any]]] = None,
                token_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument app_role", value=app_role, expected_type=type_hints["app_role"])
            check_type(argname="argument cert", value=cert, expected_type=type_hints["cert"])
            check_type(argname="argument jwt", value=jwt, expected_type=type_hints["jwt"])
            check_type(argname="argument kubernetes", value=kubernetes, expected_type=type_hints["kubernetes"])
            check_type(argname="argument ldap", value=ldap, expected_type=type_hints["ldap"])
            check_type(argname="argument token_secret_ref", value=token_secret_ref, expected_type=type_hints["token_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if app_role is not None:
            self._values["app_role"] = app_role
        if cert is not None:
            self._values["cert"] = cert
        if jwt is not None:
            self._values["jwt"] = jwt
        if kubernetes is not None:
            self._values["kubernetes"] = kubernetes
        if ldap is not None:
            self._values["ldap"] = ldap
        if token_secret_ref is not None:
            self._values["token_secret_ref"] = token_secret_ref

    @builtins.property
    def app_role(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole"]:
        '''AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuth#appRole
        '''
        result = self._values.get("app_role")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole"], result)

    @builtins.property
    def cert(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert"]:
        '''Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuth#cert
        '''
        result = self._values.get("cert")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert"], result)

    @builtins.property
    def jwt(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt"]:
        '''Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuth#jwt
        '''
        result = self._values.get("jwt")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt"], result)

    @builtins.property
    def kubernetes(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes"]:
        '''Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuth#kubernetes
        '''
        result = self._values.get("kubernetes")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes"], result)

    @builtins.property
    def ldap(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap"]:
        '''Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuth#ldap
        '''
        result = self._values.get("ldap")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap"], result)

    @builtins.property
    def token_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef"]:
        '''TokenSecretRef authenticates with Vault by presenting a token.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuth#tokenSecretRef
        '''
        result = self._values.get("token_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "role_id": "roleId", "secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole:
    def __init__(
        self,
        *,
        path: builtins.str,
        role_id: builtins.str,
        secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.

        :param path: Path where the App Role authentication backend is mounted in Vault, e.g: "approle".
        :param role_id: RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.
        :param secret_ref: Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The ``key`` field must be specified and denotes which entry within the Secret resource is used as the app role secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                path: builtins.str,
                role_id: builtins.str,
                secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument role_id", value=role_id, expected_type=type_hints["role_id"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
            "role_id": role_id,
            "secret_ref": secret_ref,
        }

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the App Role authentication backend is mounted in Vault, e.g: "approle".

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role_id(self) -> builtins.str:
        '''RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole#roleId
        '''
        result = self._values.get("role_id")
        assert result is not None, "Required property 'role_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef":
        '''Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret resource is used as the app role secret.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret resource is used as the app role secret.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert",
    jsii_struct_bases=[],
    name_mapping={"client_cert": "clientCert", "secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert:
    def __init__(
        self,
        *,
        client_cert: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert", typing.Dict[str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.

        :param client_cert: ClientCert is a certificate to authenticate using the Cert Vault authentication method.
        :param secret_ref: SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert
        '''
        if isinstance(client_cert, dict):
            client_cert = ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert(**client_cert)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                client_cert: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert, typing.Dict[str, typing.Any]]] = None,
                secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument client_cert", value=client_cert, expected_type=type_hints["client_cert"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if client_cert is not None:
            self._values["client_cert"] = client_cert
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def client_cert(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert"]:
        '''ClientCert is a certificate to authenticate using the Cert Vault authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert#clientCert
        '''
        result = self._values.get("client_cert")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef"]:
        '''SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ClientCert is a certificate to authenticate using the Cert Vault authentication method.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt",
    jsii_struct_bases=[],
    name_mapping={
        "path": "path",
        "kubernetes_service_account_token": "kubernetesServiceAccountToken",
        "role": "role",
        "secret_ref": "secretRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt:
    def __init__(
        self,
        *,
        path: builtins.str,
        kubernetes_service_account_token: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken", typing.Dict[str, typing.Any]]] = None,
        role: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.

        :param path: Path where the JWT authentication backend is mounted in Vault, e.g: "jwt".
        :param kubernetes_service_account_token: Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.
        :param role: Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method.
        :param secret_ref: Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt
        '''
        if isinstance(kubernetes_service_account_token, dict):
            kubernetes_service_account_token = ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken(**kubernetes_service_account_token)
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                path: builtins.str,
                kubernetes_service_account_token: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken, typing.Dict[str, typing.Any]]] = None,
                role: typing.Optional[builtins.str] = None,
                secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument kubernetes_service_account_token", value=kubernetes_service_account_token, expected_type=type_hints["kubernetes_service_account_token"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
        }
        if kubernetes_service_account_token is not None:
            self._values["kubernetes_service_account_token"] = kubernetes_service_account_token
        if role is not None:
            self._values["role"] = role
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the JWT authentication backend is mounted in Vault, e.g: "jwt".

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def kubernetes_service_account_token(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken"]:
        '''Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt#kubernetesServiceAccountToken
        '''
        result = self._values.get("kubernetes_service_account_token")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken"], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef"]:
        '''Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken",
    jsii_struct_bases=[],
    name_mapping={
        "service_account_ref": "serviceAccountRef",
        "audiences": "audiences",
        "expiration_seconds": "expirationSeconds",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken:
    def __init__(
        self,
        *,
        service_account_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef", typing.Dict[str, typing.Any]],
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        expiration_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :param service_account_ref: Service account field containing the name of a kubernetes ServiceAccount.
        :param audiences: Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``. Defaults to a single audience ``vault`` it not specified. Deprecated: use serviceAccountRef.Audiences instead Default: a single audience ``vault`` it not specified. Deprecated: use serviceAccountRef.Audiences instead
        :param expiration_seconds: Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``. Deprecated: this will be removed in the future. Defaults to 10 minutes. Default: 10 minutes.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                service_account_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef, typing.Dict[str, typing.Any]],
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                expiration_seconds: typing.Optional[jsii.Number] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument expiration_seconds", value=expiration_seconds, expected_type=type_hints["expiration_seconds"])
        self._values: typing.Dict[str, typing.Any] = {
            "service_account_ref": service_account_ref,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if expiration_seconds is not None:
            self._values["expiration_seconds"] = expiration_seconds

    @builtins.property
    def service_account_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef":
        '''Service account field containing the name of a kubernetes ServiceAccount.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        assert result is not None, "Required property 'service_account_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef", result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``.

        Defaults to a single audience ``vault`` it not specified. Deprecated: use serviceAccountRef.Audiences instead

        :default: a single audience ``vault`` it not specified. Deprecated: use serviceAccountRef.Audiences instead

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def expiration_seconds(self) -> typing.Optional[jsii.Number]:
        '''Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``.

        Deprecated: this will be removed in the future. Defaults to 10 minutes.

        :default: 10 minutes.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#expirationSeconds
        '''
        result = self._values.get("expiration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Service account field containing the name of a kubernetes ServiceAccount.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes",
    jsii_struct_bases=[],
    name_mapping={
        "mount_path": "mountPath",
        "role": "role",
        "secret_ref": "secretRef",
        "service_account_ref": "serviceAccountRef",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes:
    def __init__(
        self,
        *,
        mount_path: builtins.str,
        role: builtins.str,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef", typing.Dict[str, typing.Any]]] = None,
        service_account_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.

        :param mount_path: Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes".
        :param role: A required field containing the Vault Role to assume. A Role binds a Kubernetes ServiceAccount with a set of Vault policies.
        :param secret_ref: Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.
        :param service_account_ref: Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef(**secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                mount_path: builtins.str,
                role: builtins.str,
                secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef, typing.Dict[str, typing.Any]]] = None,
                service_account_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument mount_path", value=mount_path, expected_type=type_hints["mount_path"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "mount_path": mount_path,
            "role": role,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def mount_path(self) -> builtins.str:
        '''Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes".

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes#mountPath
        '''
        result = self._values.get("mount_path")
        assert result is not None, "Required property 'mount_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role(self) -> builtins.str:
        '''A required field containing the Vault Role to assume.

        A Role binds a Kubernetes ServiceAccount with a set of Vault policies.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes#role
        '''
        result = self._values.get("role")
        assert result is not None, "Required property 'role' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef"]:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault.

        If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef"]:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault.

        If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "username": "username", "secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap:
    def __init__(
        self,
        *,
        path: builtins.str,
        username: builtins.str,
        secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.

        :param path: Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap".
        :param username: Username is a LDAP user name used to authenticate using the LDAP Vault authentication method.
        :param secret_ref: SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                path: builtins.str,
                username: builtins.str,
                secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
            "username": username,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap".

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def username(self) -> builtins.str:
        '''Username is a LDAP user name used to authenticate using the LDAP Vault authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap#username
        '''
        result = self._values.get("username")
        assert result is not None, "Required property 'username' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef"]:
        '''SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''TokenSecretRef authenticates with Vault by presenting a token.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Vault server certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                type: ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType,
                key: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        Can only be defined when used in a ClusterSecretStore.

        :schema: ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType"
)
class ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderVaultVersion"
)
class ClusterSecretStoreV1Beta1SpecProviderVaultVersion(enum.Enum):
    '''Version is the Vault KV secret engine version.

    This can be either "v1" or "v2". Version defaults to "v2".

    :schema: ClusterSecretStoreV1Beta1SpecProviderVaultVersion
    '''

    V1 = "V1"
    '''v1.'''
    V2 = "V2"
    '''v2.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderWebhook",
    jsii_struct_bases=[],
    name_mapping={
        "result": "result",
        "url": "url",
        "body": "body",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
        "headers": "headers",
        "method": "method",
        "secrets": "secrets",
        "timeout": "timeout",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderWebhook:
    def __init__(
        self,
        *,
        result: typing.Union["ClusterSecretStoreV1Beta1SpecProviderWebhookResult", typing.Dict[str, typing.Any]],
        url: builtins.str,
        body: typing.Optional[builtins.str] = None,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider", typing.Dict[str, typing.Any]]] = None,
        headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        method: typing.Optional[builtins.str] = None,
        secrets: typing.Optional[typing.Sequence[typing.Union["ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets", typing.Dict[str, typing.Any]]]] = None,
        timeout: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Webhook configures this store to sync secrets using a generic templated webhook.

        :param result: Result formatting.
        :param url: Webhook url to call.
        :param body: Body.
        :param ca_bundle: PEM encoded CA bundle used to validate webhook server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
        :param ca_provider: The provider for the CA bundle to use to validate webhook server certificate.
        :param headers: Headers.
        :param method: Webhook Method.
        :param secrets: Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name.
        :param timeout: Timeout.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhook
        '''
        if isinstance(result, dict):
            result = ClusterSecretStoreV1Beta1SpecProviderWebhookResult(**result)
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider(**ca_provider)
        if __debug__:
            def stub(
                *,
                result: typing.Union[ClusterSecretStoreV1Beta1SpecProviderWebhookResult, typing.Dict[str, typing.Any]],
                url: builtins.str,
                body: typing.Optional[builtins.str] = None,
                ca_bundle: typing.Optional[builtins.str] = None,
                ca_provider: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider, typing.Dict[str, typing.Any]]] = None,
                headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
                method: typing.Optional[builtins.str] = None,
                secrets: typing.Optional[typing.Sequence[typing.Union[ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets, typing.Dict[str, typing.Any]]]] = None,
                timeout: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument result", value=result, expected_type=type_hints["result"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
            check_type(argname="argument body", value=body, expected_type=type_hints["body"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument headers", value=headers, expected_type=type_hints["headers"])
            check_type(argname="argument method", value=method, expected_type=type_hints["method"])
            check_type(argname="argument secrets", value=secrets, expected_type=type_hints["secrets"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
        self._values: typing.Dict[str, typing.Any] = {
            "result": result,
            "url": url,
        }
        if body is not None:
            self._values["body"] = body
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if headers is not None:
            self._values["headers"] = headers
        if method is not None:
            self._values["method"] = method
        if secrets is not None:
            self._values["secrets"] = secrets
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def result(self) -> "ClusterSecretStoreV1Beta1SpecProviderWebhookResult":
        '''Result formatting.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhook#result
        '''
        result = self._values.get("result")
        assert result is not None, "Required property 'result' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderWebhookResult", result)

    @builtins.property
    def url(self) -> builtins.str:
        '''Webhook url to call.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhook#url
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def body(self) -> typing.Optional[builtins.str]:
        '''Body.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhook#body
        '''
        result = self._values.get("body")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''PEM encoded CA bundle used to validate webhook server certificate.

        Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhook#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider"]:
        '''The provider for the CA bundle to use to validate webhook server certificate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhook#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider"], result)

    @builtins.property
    def headers(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Headers.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhook#headers
        '''
        result = self._values.get("headers")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def method(self) -> typing.Optional[builtins.str]:
        '''Webhook Method.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhook#method
        '''
        result = self._values.get("method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secrets(
        self,
    ) -> typing.Optional[typing.List["ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets"]]:
        '''Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhook#secrets
        '''
        result = self._values.get("secrets")
        return typing.cast(typing.Optional[typing.List["ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets"]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[builtins.str]:
        '''Timeout.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhook#timeout
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderWebhook(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate webhook server certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key the value inside of the provider type to use, only used with "Secret" type.
        :param namespace: The namespace the Provider type is in.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                type: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType,
                key: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key the value inside of the provider type to use, only used with "Secret" type.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType"
)
class ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderWebhookResult",
    jsii_struct_bases=[],
    name_mapping={"json_path": "jsonPath"},
)
class ClusterSecretStoreV1Beta1SpecProviderWebhookResult:
    def __init__(self, *, json_path: typing.Optional[builtins.str] = None) -> None:
        '''Result formatting.

        :param json_path: Json path of return value.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookResult
        '''
        if __debug__:
            def stub(*, json_path: typing.Optional[builtins.str] = None) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument json_path", value=json_path, expected_type=type_hints["json_path"])
        self._values: typing.Dict[str, typing.Any] = {}
        if json_path is not None:
            self._values["json_path"] = json_path

    @builtins.property
    def json_path(self) -> typing.Optional[builtins.str]:
        '''Json path of return value.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookResult#jsonPath
        '''
        result = self._values.get("json_path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderWebhookResult(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "secret_ref": "secretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets:
    def __init__(
        self,
        *,
        name: builtins.str,
        secret_ref: typing.Union["ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''
        :param name: Name of this secret in templates.
        :param secret_ref: Secret ref to fill in credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets
        '''
        if isinstance(secret_ref, dict):
            secret_ref = ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                secret_ref: typing.Union[ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "secret_ref": secret_ref,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of this secret in templates.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef":
        '''Secret ref to fill in credentials.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Secret ref to fill in credentials.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "api_endpoint": "apiEndpoint",
        "ca_provider": "caProvider",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth", typing.Dict[str, typing.Any]],
        api_endpoint: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider.

        :param auth: Auth defines the information necessary to authenticate against Yandex Certificate Manager.
        :param api_endpoint: Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').
        :param ca_provider: The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider(**ca_provider)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth, typing.Dict[str, typing.Any]],
                api_endpoint: typing.Optional[builtins.str] = None,
                ca_provider: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument api_endpoint", value=api_endpoint, expected_type=type_hints["api_endpoint"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
        }
        if api_endpoint is not None:
            self._values["api_endpoint"] = api_endpoint
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider

    @builtins.property
    def auth(
        self,
    ) -> "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth":
        '''Auth defines the information necessary to authenticate against Yandex Certificate Manager.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth", result)

    @builtins.property
    def api_endpoint(self) -> typing.Optional[builtins.str]:
        '''Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager#apiEndpoint
        '''
        result = self._values.get("api_endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider"]:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth",
    jsii_struct_bases=[],
    name_mapping={"authorized_key_secret_ref": "authorizedKeySecretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth:
    def __init__(
        self,
        *,
        authorized_key_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against Yandex Certificate Manager.

        :param authorized_key_secret_ref: The authorized key used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth
        '''
        if isinstance(authorized_key_secret_ref, dict):
            authorized_key_secret_ref = ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(**authorized_key_secret_ref)
        if __debug__:
            def stub(
                *,
                authorized_key_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument authorized_key_secret_ref", value=authorized_key_secret_ref, expected_type=type_hints["authorized_key_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if authorized_key_secret_ref is not None:
            self._values["authorized_key_secret_ref"] = authorized_key_secret_ref

    @builtins.property
    def authorized_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef"]:
        '''The authorized key used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth#authorizedKeySecretRef
        '''
        result = self._values.get("authorized_key_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The authorized key used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider",
    jsii_struct_bases=[],
    name_mapping={"cert_secret_ref": "certSecretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider:
    def __init__(
        self,
        *,
        cert_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :param cert_secret_ref: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider
        '''
        if isinstance(cert_secret_ref, dict):
            cert_secret_ref = ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef(**cert_secret_ref)
        if __debug__:
            def stub(
                *,
                cert_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument cert_secret_ref", value=cert_secret_ref, expected_type=type_hints["cert_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if cert_secret_ref is not None:
            self._values["cert_secret_ref"] = cert_secret_ref

    @builtins.property
    def cert_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider#certSecretRef
        '''
        result = self._values.get("cert_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderYandexlockbox",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "api_endpoint": "apiEndpoint",
        "ca_provider": "caProvider",
    },
)
class ClusterSecretStoreV1Beta1SpecProviderYandexlockbox:
    def __init__(
        self,
        *,
        auth: typing.Union["ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth", typing.Dict[str, typing.Any]],
        api_endpoint: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :param auth: Auth defines the information necessary to authenticate against Yandex Lockbox.
        :param api_endpoint: Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').
        :param ca_provider: The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockbox
        '''
        if isinstance(auth, dict):
            auth = ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider(**ca_provider)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth, typing.Dict[str, typing.Any]],
                api_endpoint: typing.Optional[builtins.str] = None,
                ca_provider: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument api_endpoint", value=api_endpoint, expected_type=type_hints["api_endpoint"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
        }
        if api_endpoint is not None:
            self._values["api_endpoint"] = api_endpoint
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider

    @builtins.property
    def auth(self) -> "ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth":
        '''Auth defines the information necessary to authenticate against Yandex Lockbox.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockbox#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth", result)

    @builtins.property
    def api_endpoint(self) -> typing.Optional[builtins.str]:
        '''Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockbox#apiEndpoint
        '''
        result = self._values.get("api_endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider"]:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockbox#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderYandexlockbox(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth",
    jsii_struct_bases=[],
    name_mapping={"authorized_key_secret_ref": "authorizedKeySecretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth:
    def __init__(
        self,
        *,
        authorized_key_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against Yandex Lockbox.

        :param authorized_key_secret_ref: The authorized key used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth
        '''
        if isinstance(authorized_key_secret_ref, dict):
            authorized_key_secret_ref = ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef(**authorized_key_secret_ref)
        if __debug__:
            def stub(
                *,
                authorized_key_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument authorized_key_secret_ref", value=authorized_key_secret_ref, expected_type=type_hints["authorized_key_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if authorized_key_secret_ref is not None:
            self._values["authorized_key_secret_ref"] = authorized_key_secret_ref

    @builtins.property
    def authorized_key_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef"]:
        '''The authorized key used for authentication.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth#authorizedKeySecretRef
        '''
        result = self._values.get("authorized_key_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The authorized key used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider",
    jsii_struct_bases=[],
    name_mapping={"cert_secret_ref": "certSecretRef"},
)
class ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider:
    def __init__(
        self,
        *,
        cert_secret_ref: typing.Optional[typing.Union["ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :param cert_secret_ref: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider
        '''
        if isinstance(cert_secret_ref, dict):
            cert_secret_ref = ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef(**cert_secret_ref)
        if __debug__:
            def stub(
                *,
                cert_secret_ref: typing.Optional[typing.Union[ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument cert_secret_ref", value=cert_secret_ref, expected_type=type_hints["cert_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if cert_secret_ref is not None:
            self._values["cert_secret_ref"] = cert_secret_ref

    @builtins.property
    def cert_secret_ref(
        self,
    ) -> typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider#certSecretRef
        '''
        result = self._values.get("cert_secret_ref")
        return typing.cast(typing.Optional["ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ClusterSecretStoreV1Beta1SpecRetrySettings",
    jsii_struct_bases=[],
    name_mapping={"max_retries": "maxRetries", "retry_interval": "retryInterval"},
)
class ClusterSecretStoreV1Beta1SpecRetrySettings:
    def __init__(
        self,
        *,
        max_retries: typing.Optional[jsii.Number] = None,
        retry_interval: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Used to configure http retries if failed.

        :param max_retries: 
        :param retry_interval: 

        :schema: ClusterSecretStoreV1Beta1SpecRetrySettings
        '''
        if __debug__:
            def stub(
                *,
                max_retries: typing.Optional[jsii.Number] = None,
                retry_interval: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument max_retries", value=max_retries, expected_type=type_hints["max_retries"])
            check_type(argname="argument retry_interval", value=retry_interval, expected_type=type_hints["retry_interval"])
        self._values: typing.Dict[str, typing.Any] = {}
        if max_retries is not None:
            self._values["max_retries"] = max_retries
        if retry_interval is not None:
            self._values["retry_interval"] = retry_interval

    @builtins.property
    def max_retries(self) -> typing.Optional[jsii.Number]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecRetrySettings#maxRetries
        '''
        result = self._values.get("max_retries")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def retry_interval(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ClusterSecretStoreV1Beta1SpecRetrySettings#retryInterval
        '''
        result = self._values.get("retry_interval")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClusterSecretStoreV1Beta1SpecRetrySettings(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ExternalSecret(
    cdk8s.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="ioexternal-secrets.ExternalSecret",
):
    '''ExternalSecret is the Schema for the external-secrets API.

    :schema: ExternalSecret
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ExternalSecretSpec", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Defines a "ExternalSecret" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param metadata: 
        :param spec: ExternalSecretSpec defines the desired state of ExternalSecret.
        '''
        if __debug__:
            def stub(
                scope: constructs.Construct,
                id: builtins.str,
                *,
                metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
                spec: typing.Optional[typing.Union[ExternalSecretSpec, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ExternalSecretProps(metadata=metadata, spec=spec)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest")
    @builtins.classmethod
    def manifest(
        cls,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ExternalSecretSpec", typing.Dict[str, typing.Any]]] = None,
    ) -> typing.Any:
        '''Renders a Kubernetes manifest for "ExternalSecret".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param metadata: 
        :param spec: ExternalSecretSpec defines the desired state of ExternalSecret.
        '''
        props = ExternalSecretProps(metadata=metadata, spec=spec)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''Renders the object to Kubernetes JSON.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> cdk8s.GroupVersionKind:
        '''Returns the apiVersion and kind for "ExternalSecret".'''
        return typing.cast(cdk8s.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretProps",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class ExternalSecretProps:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ExternalSecretSpec", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''ExternalSecret is the Schema for the external-secrets API.

        :param metadata: 
        :param spec: ExternalSecretSpec defines the desired state of ExternalSecret.

        :schema: ExternalSecret
        '''
        if isinstance(metadata, dict):
            metadata = cdk8s.ApiObjectMetadata(**metadata)
        if isinstance(spec, dict):
            spec = ExternalSecretSpec(**spec)
        if __debug__:
            def stub(
                *,
                metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
                spec: typing.Optional[typing.Union[ExternalSecretSpec, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(self) -> typing.Optional[cdk8s.ApiObjectMetadata]:
        '''
        :schema: ExternalSecret#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[cdk8s.ApiObjectMetadata], result)

    @builtins.property
    def spec(self) -> typing.Optional["ExternalSecretSpec"]:
        '''ExternalSecretSpec defines the desired state of ExternalSecret.

        :schema: ExternalSecret#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["ExternalSecretSpec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpec",
    jsii_struct_bases=[],
    name_mapping={
        "secret_store_ref": "secretStoreRef",
        "target": "target",
        "data": "data",
        "data_from": "dataFrom",
        "refresh_interval": "refreshInterval",
    },
)
class ExternalSecretSpec:
    def __init__(
        self,
        *,
        secret_store_ref: typing.Union["ExternalSecretSpecSecretStoreRef", typing.Dict[str, typing.Any]],
        target: typing.Union["ExternalSecretSpecTarget", typing.Dict[str, typing.Any]],
        data: typing.Optional[typing.Sequence[typing.Union["ExternalSecretSpecData", typing.Dict[str, typing.Any]]]] = None,
        data_from: typing.Optional[typing.Sequence[typing.Union["ExternalSecretSpecDataFrom", typing.Dict[str, typing.Any]]]] = None,
        refresh_interval: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ExternalSecretSpec defines the desired state of ExternalSecret.

        :param secret_store_ref: SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
        :param target: ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.
        :param data: Data defines the connection between the Kubernetes Secret keys and the Provider data.
        :param data_from: DataFrom is used to fetch all properties from a specific Provider data If multiple entries are specified, the Secret keys are merged in the specified order.
        :param refresh_interval: RefreshInterval is the amount of time before the values are read again from the SecretStore provider Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h" May be set to zero to fetch and create it once. Defaults to 1h. Default: 1h.

        :schema: ExternalSecretSpec
        '''
        if isinstance(secret_store_ref, dict):
            secret_store_ref = ExternalSecretSpecSecretStoreRef(**secret_store_ref)
        if isinstance(target, dict):
            target = ExternalSecretSpecTarget(**target)
        if __debug__:
            def stub(
                *,
                secret_store_ref: typing.Union[ExternalSecretSpecSecretStoreRef, typing.Dict[str, typing.Any]],
                target: typing.Union[ExternalSecretSpecTarget, typing.Dict[str, typing.Any]],
                data: typing.Optional[typing.Sequence[typing.Union[ExternalSecretSpecData, typing.Dict[str, typing.Any]]]] = None,
                data_from: typing.Optional[typing.Sequence[typing.Union[ExternalSecretSpecDataFrom, typing.Dict[str, typing.Any]]]] = None,
                refresh_interval: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_store_ref", value=secret_store_ref, expected_type=type_hints["secret_store_ref"])
            check_type(argname="argument target", value=target, expected_type=type_hints["target"])
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
            check_type(argname="argument data_from", value=data_from, expected_type=type_hints["data_from"])
            check_type(argname="argument refresh_interval", value=refresh_interval, expected_type=type_hints["refresh_interval"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_store_ref": secret_store_ref,
            "target": target,
        }
        if data is not None:
            self._values["data"] = data
        if data_from is not None:
            self._values["data_from"] = data_from
        if refresh_interval is not None:
            self._values["refresh_interval"] = refresh_interval

    @builtins.property
    def secret_store_ref(self) -> "ExternalSecretSpecSecretStoreRef":
        '''SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :schema: ExternalSecretSpec#secretStoreRef
        '''
        result = self._values.get("secret_store_ref")
        assert result is not None, "Required property 'secret_store_ref' is missing"
        return typing.cast("ExternalSecretSpecSecretStoreRef", result)

    @builtins.property
    def target(self) -> "ExternalSecretSpecTarget":
        '''ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.

        :schema: ExternalSecretSpec#target
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast("ExternalSecretSpecTarget", result)

    @builtins.property
    def data(self) -> typing.Optional[typing.List["ExternalSecretSpecData"]]:
        '''Data defines the connection between the Kubernetes Secret keys and the Provider data.

        :schema: ExternalSecretSpec#data
        '''
        result = self._values.get("data")
        return typing.cast(typing.Optional[typing.List["ExternalSecretSpecData"]], result)

    @builtins.property
    def data_from(self) -> typing.Optional[typing.List["ExternalSecretSpecDataFrom"]]:
        '''DataFrom is used to fetch all properties from a specific Provider data If multiple entries are specified, the Secret keys are merged in the specified order.

        :schema: ExternalSecretSpec#dataFrom
        '''
        result = self._values.get("data_from")
        return typing.cast(typing.Optional[typing.List["ExternalSecretSpecDataFrom"]], result)

    @builtins.property
    def refresh_interval(self) -> typing.Optional[builtins.str]:
        '''RefreshInterval is the amount of time before the values are read again from the SecretStore provider Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h" May be set to zero to fetch and create it once.

        Defaults to 1h.

        :default: 1h.

        :schema: ExternalSecretSpec#refreshInterval
        '''
        result = self._values.get("refresh_interval")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecData",
    jsii_struct_bases=[],
    name_mapping={"remote_ref": "remoteRef", "secret_key": "secretKey"},
)
class ExternalSecretSpecData:
    def __init__(
        self,
        *,
        remote_ref: typing.Union["ExternalSecretSpecDataRemoteRef", typing.Dict[str, typing.Any]],
        secret_key: builtins.str,
    ) -> None:
        '''ExternalSecretData defines the connection between the Kubernetes Secret key (spec.data.) and the Provider data.

        :param remote_ref: ExternalSecretDataRemoteRef defines Provider data location.
        :param secret_key: 

        :schema: ExternalSecretSpecData
        '''
        if isinstance(remote_ref, dict):
            remote_ref = ExternalSecretSpecDataRemoteRef(**remote_ref)
        if __debug__:
            def stub(
                *,
                remote_ref: typing.Union[ExternalSecretSpecDataRemoteRef, typing.Dict[str, typing.Any]],
                secret_key: builtins.str,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument remote_ref", value=remote_ref, expected_type=type_hints["remote_ref"])
            check_type(argname="argument secret_key", value=secret_key, expected_type=type_hints["secret_key"])
        self._values: typing.Dict[str, typing.Any] = {
            "remote_ref": remote_ref,
            "secret_key": secret_key,
        }

    @builtins.property
    def remote_ref(self) -> "ExternalSecretSpecDataRemoteRef":
        '''ExternalSecretDataRemoteRef defines Provider data location.

        :schema: ExternalSecretSpecData#remoteRef
        '''
        result = self._values.get("remote_ref")
        assert result is not None, "Required property 'remote_ref' is missing"
        return typing.cast("ExternalSecretSpecDataRemoteRef", result)

    @builtins.property
    def secret_key(self) -> builtins.str:
        '''
        :schema: ExternalSecretSpecData#secretKey
        '''
        result = self._values.get("secret_key")
        assert result is not None, "Required property 'secret_key' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecData(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecDataFrom",
    jsii_struct_bases=[],
    name_mapping={
        "key": "key",
        "conversion_strategy": "conversionStrategy",
        "property": "property",
        "version": "version",
    },
)
class ExternalSecretSpecDataFrom:
    def __init__(
        self,
        *,
        key: builtins.str,
        conversion_strategy: typing.Optional[builtins.str] = None,
        property: typing.Optional[builtins.str] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ExternalSecretDataRemoteRef defines Provider data location.

        :param key: Key is the key used in the Provider, mandatory.
        :param conversion_strategy: Used to define a conversion Strategy.
        :param property: Used to select a specific property of the Provider value (if a map), if supported.
        :param version: Used to select a specific version of the Provider value, if supported.

        :schema: ExternalSecretSpecDataFrom
        '''
        if __debug__:
            def stub(
                *,
                key: builtins.str,
                conversion_strategy: typing.Optional[builtins.str] = None,
                property: typing.Optional[builtins.str] = None,
                version: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument conversion_strategy", value=conversion_strategy, expected_type=type_hints["conversion_strategy"])
            check_type(argname="argument property", value=property, expected_type=type_hints["property"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }
        if conversion_strategy is not None:
            self._values["conversion_strategy"] = conversion_strategy
        if property is not None:
            self._values["property"] = property
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def key(self) -> builtins.str:
        '''Key is the key used in the Provider, mandatory.

        :schema: ExternalSecretSpecDataFrom#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def conversion_strategy(self) -> typing.Optional[builtins.str]:
        '''Used to define a conversion Strategy.

        :schema: ExternalSecretSpecDataFrom#conversionStrategy
        '''
        result = self._values.get("conversion_strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def property(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific property of the Provider value (if a map), if supported.

        :schema: ExternalSecretSpecDataFrom#property
        '''
        result = self._values.get("property")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific version of the Provider value, if supported.

        :schema: ExternalSecretSpecDataFrom#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecDataFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecDataRemoteRef",
    jsii_struct_bases=[],
    name_mapping={
        "key": "key",
        "conversion_strategy": "conversionStrategy",
        "property": "property",
        "version": "version",
    },
)
class ExternalSecretSpecDataRemoteRef:
    def __init__(
        self,
        *,
        key: builtins.str,
        conversion_strategy: typing.Optional[builtins.str] = None,
        property: typing.Optional[builtins.str] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ExternalSecretDataRemoteRef defines Provider data location.

        :param key: Key is the key used in the Provider, mandatory.
        :param conversion_strategy: Used to define a conversion Strategy.
        :param property: Used to select a specific property of the Provider value (if a map), if supported.
        :param version: Used to select a specific version of the Provider value, if supported.

        :schema: ExternalSecretSpecDataRemoteRef
        '''
        if __debug__:
            def stub(
                *,
                key: builtins.str,
                conversion_strategy: typing.Optional[builtins.str] = None,
                property: typing.Optional[builtins.str] = None,
                version: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument conversion_strategy", value=conversion_strategy, expected_type=type_hints["conversion_strategy"])
            check_type(argname="argument property", value=property, expected_type=type_hints["property"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }
        if conversion_strategy is not None:
            self._values["conversion_strategy"] = conversion_strategy
        if property is not None:
            self._values["property"] = property
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def key(self) -> builtins.str:
        '''Key is the key used in the Provider, mandatory.

        :schema: ExternalSecretSpecDataRemoteRef#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def conversion_strategy(self) -> typing.Optional[builtins.str]:
        '''Used to define a conversion Strategy.

        :schema: ExternalSecretSpecDataRemoteRef#conversionStrategy
        '''
        result = self._values.get("conversion_strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def property(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific property of the Provider value (if a map), if supported.

        :schema: ExternalSecretSpecDataRemoteRef#property
        '''
        result = self._values.get("property")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific version of the Provider value, if supported.

        :schema: ExternalSecretSpecDataRemoteRef#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecDataRemoteRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecSecretStoreRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "kind": "kind"},
)
class ExternalSecretSpecSecretStoreRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        kind: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :param name: Name of the SecretStore resource.
        :param kind: Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``. Default: SecretStore`

        :schema: ExternalSecretSpecSecretStoreRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                kind: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if kind is not None:
            self._values["kind"] = kind

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the SecretStore resource.

        :schema: ExternalSecretSpecSecretStoreRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def kind(self) -> typing.Optional[builtins.str]:
        '''Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``.

        :default: SecretStore`

        :schema: ExternalSecretSpecSecretStoreRef#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecSecretStoreRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecTarget",
    jsii_struct_bases=[],
    name_mapping={
        "creation_policy": "creationPolicy",
        "immutable": "immutable",
        "name": "name",
        "template": "template",
    },
)
class ExternalSecretSpecTarget:
    def __init__(
        self,
        *,
        creation_policy: typing.Optional[builtins.str] = None,
        immutable: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
        template: typing.Optional[typing.Union["ExternalSecretSpecTargetTemplate", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.

        :param creation_policy: CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'. Default: Owner'
        :param immutable: Immutable defines if the final secret will be immutable.
        :param name: Name defines the name of the Secret resource to be managed This field is immutable Defaults to the .metadata.name of the ExternalSecret resource. Default: the .metadata.name of the ExternalSecret resource
        :param template: Template defines a blueprint for the created Secret resource.

        :schema: ExternalSecretSpecTarget
        '''
        if isinstance(template, dict):
            template = ExternalSecretSpecTargetTemplate(**template)
        if __debug__:
            def stub(
                *,
                creation_policy: typing.Optional[builtins.str] = None,
                immutable: typing.Optional[builtins.bool] = None,
                name: typing.Optional[builtins.str] = None,
                template: typing.Optional[typing.Union[ExternalSecretSpecTargetTemplate, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument creation_policy", value=creation_policy, expected_type=type_hints["creation_policy"])
            check_type(argname="argument immutable", value=immutable, expected_type=type_hints["immutable"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument template", value=template, expected_type=type_hints["template"])
        self._values: typing.Dict[str, typing.Any] = {}
        if creation_policy is not None:
            self._values["creation_policy"] = creation_policy
        if immutable is not None:
            self._values["immutable"] = immutable
        if name is not None:
            self._values["name"] = name
        if template is not None:
            self._values["template"] = template

    @builtins.property
    def creation_policy(self) -> typing.Optional[builtins.str]:
        '''CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'.

        :default: Owner'

        :schema: ExternalSecretSpecTarget#creationPolicy
        '''
        result = self._values.get("creation_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def immutable(self) -> typing.Optional[builtins.bool]:
        '''Immutable defines if the final secret will be immutable.

        :schema: ExternalSecretSpecTarget#immutable
        '''
        result = self._values.get("immutable")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name defines the name of the Secret resource to be managed This field is immutable Defaults to the .metadata.name of the ExternalSecret resource.

        :default: the .metadata.name of the ExternalSecret resource

        :schema: ExternalSecretSpecTarget#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def template(self) -> typing.Optional["ExternalSecretSpecTargetTemplate"]:
        '''Template defines a blueprint for the created Secret resource.

        :schema: ExternalSecretSpecTarget#template
        '''
        result = self._values.get("template")
        return typing.cast(typing.Optional["ExternalSecretSpecTargetTemplate"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecTarget(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecTargetTemplate",
    jsii_struct_bases=[],
    name_mapping={
        "data": "data",
        "engine_version": "engineVersion",
        "metadata": "metadata",
        "template_from": "templateFrom",
        "type": "type",
    },
)
class ExternalSecretSpecTargetTemplate:
    def __init__(
        self,
        *,
        data: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        engine_version: typing.Optional[builtins.str] = None,
        metadata: typing.Optional[typing.Union["ExternalSecretSpecTargetTemplateMetadata", typing.Dict[str, typing.Any]]] = None,
        template_from: typing.Optional[typing.Sequence[typing.Union["ExternalSecretSpecTargetTemplateTemplateFrom", typing.Dict[str, typing.Any]]]] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Template defines a blueprint for the created Secret resource.

        :param data: 
        :param engine_version: EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].
        :param metadata: ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
        :param template_from: 
        :param type: 

        :schema: ExternalSecretSpecTargetTemplate
        '''
        if isinstance(metadata, dict):
            metadata = ExternalSecretSpecTargetTemplateMetadata(**metadata)
        if __debug__:
            def stub(
                *,
                data: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
                engine_version: typing.Optional[builtins.str] = None,
                metadata: typing.Optional[typing.Union[ExternalSecretSpecTargetTemplateMetadata, typing.Dict[str, typing.Any]]] = None,
                template_from: typing.Optional[typing.Sequence[typing.Union[ExternalSecretSpecTargetTemplateTemplateFrom, typing.Dict[str, typing.Any]]]] = None,
                type: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
            check_type(argname="argument engine_version", value=engine_version, expected_type=type_hints["engine_version"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument template_from", value=template_from, expected_type=type_hints["template_from"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[str, typing.Any] = {}
        if data is not None:
            self._values["data"] = data
        if engine_version is not None:
            self._values["engine_version"] = engine_version
        if metadata is not None:
            self._values["metadata"] = metadata
        if template_from is not None:
            self._values["template_from"] = template_from
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def data(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ExternalSecretSpecTargetTemplate#data
        '''
        result = self._values.get("data")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def engine_version(self) -> typing.Optional[builtins.str]:
        '''EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].

        :schema: ExternalSecretSpecTargetTemplate#engineVersion
        '''
        result = self._values.get("engine_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metadata(self) -> typing.Optional["ExternalSecretSpecTargetTemplateMetadata"]:
        '''ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.

        :schema: ExternalSecretSpecTargetTemplate#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["ExternalSecretSpecTargetTemplateMetadata"], result)

    @builtins.property
    def template_from(
        self,
    ) -> typing.Optional[typing.List["ExternalSecretSpecTargetTemplateTemplateFrom"]]:
        '''
        :schema: ExternalSecretSpecTargetTemplate#templateFrom
        '''
        result = self._values.get("template_from")
        return typing.cast(typing.Optional[typing.List["ExternalSecretSpecTargetTemplateTemplateFrom"]], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ExternalSecretSpecTargetTemplate#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecTargetTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecTargetTemplateMetadata",
    jsii_struct_bases=[],
    name_mapping={"annotations": "annotations", "labels": "labels"},
)
class ExternalSecretSpecTargetTemplateMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.

        :param annotations: 
        :param labels: 

        :schema: ExternalSecretSpecTargetTemplateMetadata
        '''
        if __debug__:
            def stub(
                *,
                annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
                labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if labels is not None:
            self._values["labels"] = labels

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ExternalSecretSpecTargetTemplateMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ExternalSecretSpecTargetTemplateMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecTargetTemplateMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecTargetTemplateTemplateFrom",
    jsii_struct_bases=[],
    name_mapping={"config_map": "configMap", "secret": "secret"},
)
class ExternalSecretSpecTargetTemplateTemplateFrom:
    def __init__(
        self,
        *,
        config_map: typing.Optional[typing.Union["ExternalSecretSpecTargetTemplateTemplateFromConfigMap", typing.Dict[str, typing.Any]]] = None,
        secret: typing.Optional[typing.Union["ExternalSecretSpecTargetTemplateTemplateFromSecret", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param config_map: 
        :param secret: 

        :schema: ExternalSecretSpecTargetTemplateTemplateFrom
        '''
        if isinstance(config_map, dict):
            config_map = ExternalSecretSpecTargetTemplateTemplateFromConfigMap(**config_map)
        if isinstance(secret, dict):
            secret = ExternalSecretSpecTargetTemplateTemplateFromSecret(**secret)
        if __debug__:
            def stub(
                *,
                config_map: typing.Optional[typing.Union[ExternalSecretSpecTargetTemplateTemplateFromConfigMap, typing.Dict[str, typing.Any]]] = None,
                secret: typing.Optional[typing.Union[ExternalSecretSpecTargetTemplateTemplateFromSecret, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument config_map", value=config_map, expected_type=type_hints["config_map"])
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
        self._values: typing.Dict[str, typing.Any] = {}
        if config_map is not None:
            self._values["config_map"] = config_map
        if secret is not None:
            self._values["secret"] = secret

    @builtins.property
    def config_map(
        self,
    ) -> typing.Optional["ExternalSecretSpecTargetTemplateTemplateFromConfigMap"]:
        '''
        :schema: ExternalSecretSpecTargetTemplateTemplateFrom#configMap
        '''
        result = self._values.get("config_map")
        return typing.cast(typing.Optional["ExternalSecretSpecTargetTemplateTemplateFromConfigMap"], result)

    @builtins.property
    def secret(
        self,
    ) -> typing.Optional["ExternalSecretSpecTargetTemplateTemplateFromSecret"]:
        '''
        :schema: ExternalSecretSpecTargetTemplateTemplateFrom#secret
        '''
        result = self._values.get("secret")
        return typing.cast(typing.Optional["ExternalSecretSpecTargetTemplateTemplateFromSecret"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecTargetTemplateTemplateFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecTargetTemplateTemplateFromConfigMap",
    jsii_struct_bases=[],
    name_mapping={"items": "items", "name": "name"},
)
class ExternalSecretSpecTargetTemplateTemplateFromConfigMap:
    def __init__(
        self,
        *,
        items: typing.Sequence[typing.Union["ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems", typing.Dict[str, typing.Any]]],
        name: builtins.str,
    ) -> None:
        '''
        :param items: 
        :param name: 

        :schema: ExternalSecretSpecTargetTemplateTemplateFromConfigMap
        '''
        if __debug__:
            def stub(
                *,
                items: typing.Sequence[typing.Union[ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems, typing.Dict[str, typing.Any]]],
                name: builtins.str,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {
            "items": items,
            "name": name,
        }

    @builtins.property
    def items(
        self,
    ) -> typing.List["ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems"]:
        '''
        :schema: ExternalSecretSpecTargetTemplateTemplateFromConfigMap#items
        '''
        result = self._values.get("items")
        assert result is not None, "Required property 'items' is missing"
        return typing.cast(typing.List["ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems"], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :schema: ExternalSecretSpecTargetTemplateTemplateFromConfigMap#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecTargetTemplateTemplateFromConfigMap(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key"},
)
class ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems:
    def __init__(self, *, key: builtins.str) -> None:
        '''
        :param key: 

        :schema: ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems
        '''
        if __debug__:
            def stub(*, key: builtins.str) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :schema: ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecTargetTemplateTemplateFromSecret",
    jsii_struct_bases=[],
    name_mapping={"items": "items", "name": "name"},
)
class ExternalSecretSpecTargetTemplateTemplateFromSecret:
    def __init__(
        self,
        *,
        items: typing.Sequence[typing.Union["ExternalSecretSpecTargetTemplateTemplateFromSecretItems", typing.Dict[str, typing.Any]]],
        name: builtins.str,
    ) -> None:
        '''
        :param items: 
        :param name: 

        :schema: ExternalSecretSpecTargetTemplateTemplateFromSecret
        '''
        if __debug__:
            def stub(
                *,
                items: typing.Sequence[typing.Union[ExternalSecretSpecTargetTemplateTemplateFromSecretItems, typing.Dict[str, typing.Any]]],
                name: builtins.str,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {
            "items": items,
            "name": name,
        }

    @builtins.property
    def items(
        self,
    ) -> typing.List["ExternalSecretSpecTargetTemplateTemplateFromSecretItems"]:
        '''
        :schema: ExternalSecretSpecTargetTemplateTemplateFromSecret#items
        '''
        result = self._values.get("items")
        assert result is not None, "Required property 'items' is missing"
        return typing.cast(typing.List["ExternalSecretSpecTargetTemplateTemplateFromSecretItems"], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :schema: ExternalSecretSpecTargetTemplateTemplateFromSecret#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecTargetTemplateTemplateFromSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretSpecTargetTemplateTemplateFromSecretItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key"},
)
class ExternalSecretSpecTargetTemplateTemplateFromSecretItems:
    def __init__(self, *, key: builtins.str) -> None:
        '''
        :param key: 

        :schema: ExternalSecretSpecTargetTemplateTemplateFromSecretItems
        '''
        if __debug__:
            def stub(*, key: builtins.str) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :schema: ExternalSecretSpecTargetTemplateTemplateFromSecretItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretSpecTargetTemplateTemplateFromSecretItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ExternalSecretV1Beta1(
    cdk8s.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1",
):
    '''ExternalSecret is the Schema for the external-secrets API.

    :schema: ExternalSecretV1Beta1
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ExternalSecretV1Beta1Spec", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Defines a "ExternalSecretV1Beta1" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param metadata: 
        :param spec: ExternalSecretSpec defines the desired state of ExternalSecret.
        '''
        if __debug__:
            def stub(
                scope: constructs.Construct,
                id: builtins.str,
                *,
                metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
                spec: typing.Optional[typing.Union[ExternalSecretV1Beta1Spec, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ExternalSecretV1Beta1Props(metadata=metadata, spec=spec)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest")
    @builtins.classmethod
    def manifest(
        cls,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ExternalSecretV1Beta1Spec", typing.Dict[str, typing.Any]]] = None,
    ) -> typing.Any:
        '''Renders a Kubernetes manifest for "ExternalSecretV1Beta1".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param metadata: 
        :param spec: ExternalSecretSpec defines the desired state of ExternalSecret.
        '''
        props = ExternalSecretV1Beta1Props(metadata=metadata, spec=spec)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''Renders the object to Kubernetes JSON.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> cdk8s.GroupVersionKind:
        '''Returns the apiVersion and kind for "ExternalSecretV1Beta1".'''
        return typing.cast(cdk8s.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1Props",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class ExternalSecretV1Beta1Props:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["ExternalSecretV1Beta1Spec", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''ExternalSecret is the Schema for the external-secrets API.

        :param metadata: 
        :param spec: ExternalSecretSpec defines the desired state of ExternalSecret.

        :schema: ExternalSecretV1Beta1
        '''
        if isinstance(metadata, dict):
            metadata = cdk8s.ApiObjectMetadata(**metadata)
        if isinstance(spec, dict):
            spec = ExternalSecretV1Beta1Spec(**spec)
        if __debug__:
            def stub(
                *,
                metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
                spec: typing.Optional[typing.Union[ExternalSecretV1Beta1Spec, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(self) -> typing.Optional[cdk8s.ApiObjectMetadata]:
        '''
        :schema: ExternalSecretV1Beta1#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[cdk8s.ApiObjectMetadata], result)

    @builtins.property
    def spec(self) -> typing.Optional["ExternalSecretV1Beta1Spec"]:
        '''ExternalSecretSpec defines the desired state of ExternalSecret.

        :schema: ExternalSecretV1Beta1#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1Spec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1Props(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1Spec",
    jsii_struct_bases=[],
    name_mapping={
        "secret_store_ref": "secretStoreRef",
        "data": "data",
        "data_from": "dataFrom",
        "refresh_interval": "refreshInterval",
        "target": "target",
    },
)
class ExternalSecretV1Beta1Spec:
    def __init__(
        self,
        *,
        secret_store_ref: typing.Union["ExternalSecretV1Beta1SpecSecretStoreRef", typing.Dict[str, typing.Any]],
        data: typing.Optional[typing.Sequence[typing.Union["ExternalSecretV1Beta1SpecData", typing.Dict[str, typing.Any]]]] = None,
        data_from: typing.Optional[typing.Sequence[typing.Union["ExternalSecretV1Beta1SpecDataFrom", typing.Dict[str, typing.Any]]]] = None,
        refresh_interval: typing.Optional[builtins.str] = None,
        target: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecTarget", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''ExternalSecretSpec defines the desired state of ExternalSecret.

        :param secret_store_ref: SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
        :param data: Data defines the connection between the Kubernetes Secret keys and the Provider data.
        :param data_from: DataFrom is used to fetch all properties from a specific Provider data If multiple entries are specified, the Secret keys are merged in the specified order.
        :param refresh_interval: RefreshInterval is the amount of time before the values are read again from the SecretStore provider Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h" May be set to zero to fetch and create it once. Defaults to 1h. Default: 1h.
        :param target: ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.

        :schema: ExternalSecretV1Beta1Spec
        '''
        if isinstance(secret_store_ref, dict):
            secret_store_ref = ExternalSecretV1Beta1SpecSecretStoreRef(**secret_store_ref)
        if isinstance(target, dict):
            target = ExternalSecretV1Beta1SpecTarget(**target)
        if __debug__:
            def stub(
                *,
                secret_store_ref: typing.Union[ExternalSecretV1Beta1SpecSecretStoreRef, typing.Dict[str, typing.Any]],
                data: typing.Optional[typing.Sequence[typing.Union[ExternalSecretV1Beta1SpecData, typing.Dict[str, typing.Any]]]] = None,
                data_from: typing.Optional[typing.Sequence[typing.Union[ExternalSecretV1Beta1SpecDataFrom, typing.Dict[str, typing.Any]]]] = None,
                refresh_interval: typing.Optional[builtins.str] = None,
                target: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecTarget, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_store_ref", value=secret_store_ref, expected_type=type_hints["secret_store_ref"])
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
            check_type(argname="argument data_from", value=data_from, expected_type=type_hints["data_from"])
            check_type(argname="argument refresh_interval", value=refresh_interval, expected_type=type_hints["refresh_interval"])
            check_type(argname="argument target", value=target, expected_type=type_hints["target"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_store_ref": secret_store_ref,
        }
        if data is not None:
            self._values["data"] = data
        if data_from is not None:
            self._values["data_from"] = data_from
        if refresh_interval is not None:
            self._values["refresh_interval"] = refresh_interval
        if target is not None:
            self._values["target"] = target

    @builtins.property
    def secret_store_ref(self) -> "ExternalSecretV1Beta1SpecSecretStoreRef":
        '''SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :schema: ExternalSecretV1Beta1Spec#secretStoreRef
        '''
        result = self._values.get("secret_store_ref")
        assert result is not None, "Required property 'secret_store_ref' is missing"
        return typing.cast("ExternalSecretV1Beta1SpecSecretStoreRef", result)

    @builtins.property
    def data(self) -> typing.Optional[typing.List["ExternalSecretV1Beta1SpecData"]]:
        '''Data defines the connection between the Kubernetes Secret keys and the Provider data.

        :schema: ExternalSecretV1Beta1Spec#data
        '''
        result = self._values.get("data")
        return typing.cast(typing.Optional[typing.List["ExternalSecretV1Beta1SpecData"]], result)

    @builtins.property
    def data_from(
        self,
    ) -> typing.Optional[typing.List["ExternalSecretV1Beta1SpecDataFrom"]]:
        '''DataFrom is used to fetch all properties from a specific Provider data If multiple entries are specified, the Secret keys are merged in the specified order.

        :schema: ExternalSecretV1Beta1Spec#dataFrom
        '''
        result = self._values.get("data_from")
        return typing.cast(typing.Optional[typing.List["ExternalSecretV1Beta1SpecDataFrom"]], result)

    @builtins.property
    def refresh_interval(self) -> typing.Optional[builtins.str]:
        '''RefreshInterval is the amount of time before the values are read again from the SecretStore provider Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h" May be set to zero to fetch and create it once.

        Defaults to 1h.

        :default: 1h.

        :schema: ExternalSecretV1Beta1Spec#refreshInterval
        '''
        result = self._values.get("refresh_interval")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def target(self) -> typing.Optional["ExternalSecretV1Beta1SpecTarget"]:
        '''ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.

        :schema: ExternalSecretV1Beta1Spec#target
        '''
        result = self._values.get("target")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecTarget"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1Spec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecData",
    jsii_struct_bases=[],
    name_mapping={"remote_ref": "remoteRef", "secret_key": "secretKey"},
)
class ExternalSecretV1Beta1SpecData:
    def __init__(
        self,
        *,
        remote_ref: typing.Union["ExternalSecretV1Beta1SpecDataRemoteRef", typing.Dict[str, typing.Any]],
        secret_key: builtins.str,
    ) -> None:
        '''ExternalSecretData defines the connection between the Kubernetes Secret key (spec.data.) and the Provider data.

        :param remote_ref: ExternalSecretDataRemoteRef defines Provider data location.
        :param secret_key: 

        :schema: ExternalSecretV1Beta1SpecData
        '''
        if isinstance(remote_ref, dict):
            remote_ref = ExternalSecretV1Beta1SpecDataRemoteRef(**remote_ref)
        if __debug__:
            def stub(
                *,
                remote_ref: typing.Union[ExternalSecretV1Beta1SpecDataRemoteRef, typing.Dict[str, typing.Any]],
                secret_key: builtins.str,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument remote_ref", value=remote_ref, expected_type=type_hints["remote_ref"])
            check_type(argname="argument secret_key", value=secret_key, expected_type=type_hints["secret_key"])
        self._values: typing.Dict[str, typing.Any] = {
            "remote_ref": remote_ref,
            "secret_key": secret_key,
        }

    @builtins.property
    def remote_ref(self) -> "ExternalSecretV1Beta1SpecDataRemoteRef":
        '''ExternalSecretDataRemoteRef defines Provider data location.

        :schema: ExternalSecretV1Beta1SpecData#remoteRef
        '''
        result = self._values.get("remote_ref")
        assert result is not None, "Required property 'remote_ref' is missing"
        return typing.cast("ExternalSecretV1Beta1SpecDataRemoteRef", result)

    @builtins.property
    def secret_key(self) -> builtins.str:
        '''
        :schema: ExternalSecretV1Beta1SpecData#secretKey
        '''
        result = self._values.get("secret_key")
        assert result is not None, "Required property 'secret_key' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecData(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFrom",
    jsii_struct_bases=[],
    name_mapping={"extract": "extract", "find": "find", "rewrite": "rewrite"},
)
class ExternalSecretV1Beta1SpecDataFrom:
    def __init__(
        self,
        *,
        extract: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecDataFromExtract", typing.Dict[str, typing.Any]]] = None,
        find: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecDataFromFind", typing.Dict[str, typing.Any]]] = None,
        rewrite: typing.Optional[typing.Sequence[typing.Union["ExternalSecretV1Beta1SpecDataFromRewrite", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param extract: Used to extract multiple key/value pairs from one secret.
        :param find: Used to find secrets based on tags or regular expressions.
        :param rewrite: Used to rewrite secret Keys after getting them from the secret Provider Multiple Rewrite operations can be provided. They are applied in a layered order (first to last)

        :schema: ExternalSecretV1Beta1SpecDataFrom
        '''
        if isinstance(extract, dict):
            extract = ExternalSecretV1Beta1SpecDataFromExtract(**extract)
        if isinstance(find, dict):
            find = ExternalSecretV1Beta1SpecDataFromFind(**find)
        if __debug__:
            def stub(
                *,
                extract: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecDataFromExtract, typing.Dict[str, typing.Any]]] = None,
                find: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecDataFromFind, typing.Dict[str, typing.Any]]] = None,
                rewrite: typing.Optional[typing.Sequence[typing.Union[ExternalSecretV1Beta1SpecDataFromRewrite, typing.Dict[str, typing.Any]]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument extract", value=extract, expected_type=type_hints["extract"])
            check_type(argname="argument find", value=find, expected_type=type_hints["find"])
            check_type(argname="argument rewrite", value=rewrite, expected_type=type_hints["rewrite"])
        self._values: typing.Dict[str, typing.Any] = {}
        if extract is not None:
            self._values["extract"] = extract
        if find is not None:
            self._values["find"] = find
        if rewrite is not None:
            self._values["rewrite"] = rewrite

    @builtins.property
    def extract(self) -> typing.Optional["ExternalSecretV1Beta1SpecDataFromExtract"]:
        '''Used to extract multiple key/value pairs from one secret.

        :schema: ExternalSecretV1Beta1SpecDataFrom#extract
        '''
        result = self._values.get("extract")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataFromExtract"], result)

    @builtins.property
    def find(self) -> typing.Optional["ExternalSecretV1Beta1SpecDataFromFind"]:
        '''Used to find secrets based on tags or regular expressions.

        :schema: ExternalSecretV1Beta1SpecDataFrom#find
        '''
        result = self._values.get("find")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataFromFind"], result)

    @builtins.property
    def rewrite(
        self,
    ) -> typing.Optional[typing.List["ExternalSecretV1Beta1SpecDataFromRewrite"]]:
        '''Used to rewrite secret Keys after getting them from the secret Provider Multiple Rewrite operations can be provided.

        They are applied in a layered order (first to last)

        :schema: ExternalSecretV1Beta1SpecDataFrom#rewrite
        '''
        result = self._values.get("rewrite")
        return typing.cast(typing.Optional[typing.List["ExternalSecretV1Beta1SpecDataFromRewrite"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromExtract",
    jsii_struct_bases=[],
    name_mapping={
        "key": "key",
        "conversion_strategy": "conversionStrategy",
        "decoding_strategy": "decodingStrategy",
        "metadata_policy": "metadataPolicy",
        "property": "property",
        "version": "version",
    },
)
class ExternalSecretV1Beta1SpecDataFromExtract:
    def __init__(
        self,
        *,
        key: builtins.str,
        conversion_strategy: typing.Optional[builtins.str] = None,
        decoding_strategy: typing.Optional[builtins.str] = None,
        metadata_policy: typing.Optional[builtins.str] = None,
        property: typing.Optional[builtins.str] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Used to extract multiple key/value pairs from one secret.

        :param key: Key is the key used in the Provider, mandatory.
        :param conversion_strategy: Used to define a conversion Strategy.
        :param decoding_strategy: Used to define a decoding Strategy.
        :param metadata_policy: Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None Default: None
        :param property: Used to select a specific property of the Provider value (if a map), if supported.
        :param version: Used to select a specific version of the Provider value, if supported.

        :schema: ExternalSecretV1Beta1SpecDataFromExtract
        '''
        if __debug__:
            def stub(
                *,
                key: builtins.str,
                conversion_strategy: typing.Optional[builtins.str] = None,
                decoding_strategy: typing.Optional[builtins.str] = None,
                metadata_policy: typing.Optional[builtins.str] = None,
                property: typing.Optional[builtins.str] = None,
                version: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument conversion_strategy", value=conversion_strategy, expected_type=type_hints["conversion_strategy"])
            check_type(argname="argument decoding_strategy", value=decoding_strategy, expected_type=type_hints["decoding_strategy"])
            check_type(argname="argument metadata_policy", value=metadata_policy, expected_type=type_hints["metadata_policy"])
            check_type(argname="argument property", value=property, expected_type=type_hints["property"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }
        if conversion_strategy is not None:
            self._values["conversion_strategy"] = conversion_strategy
        if decoding_strategy is not None:
            self._values["decoding_strategy"] = decoding_strategy
        if metadata_policy is not None:
            self._values["metadata_policy"] = metadata_policy
        if property is not None:
            self._values["property"] = property
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def key(self) -> builtins.str:
        '''Key is the key used in the Provider, mandatory.

        :schema: ExternalSecretV1Beta1SpecDataFromExtract#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def conversion_strategy(self) -> typing.Optional[builtins.str]:
        '''Used to define a conversion Strategy.

        :schema: ExternalSecretV1Beta1SpecDataFromExtract#conversionStrategy
        '''
        result = self._values.get("conversion_strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def decoding_strategy(self) -> typing.Optional[builtins.str]:
        '''Used to define a decoding Strategy.

        :schema: ExternalSecretV1Beta1SpecDataFromExtract#decodingStrategy
        '''
        result = self._values.get("decoding_strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metadata_policy(self) -> typing.Optional[builtins.str]:
        '''Policy for fetching tags/labels from provider secrets, possible options are Fetch, None.

        Defaults to None

        :default: None

        :schema: ExternalSecretV1Beta1SpecDataFromExtract#metadataPolicy
        '''
        result = self._values.get("metadata_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def property(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific property of the Provider value (if a map), if supported.

        :schema: ExternalSecretV1Beta1SpecDataFromExtract#property
        '''
        result = self._values.get("property")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific version of the Provider value, if supported.

        :schema: ExternalSecretV1Beta1SpecDataFromExtract#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataFromExtract(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromFind",
    jsii_struct_bases=[],
    name_mapping={
        "conversion_strategy": "conversionStrategy",
        "decoding_strategy": "decodingStrategy",
        "name": "name",
        "path": "path",
        "tags": "tags",
    },
)
class ExternalSecretV1Beta1SpecDataFromFind:
    def __init__(
        self,
        *,
        conversion_strategy: typing.Optional[builtins.str] = None,
        decoding_strategy: typing.Optional[builtins.str] = None,
        name: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecDataFromFindName", typing.Dict[str, typing.Any]]] = None,
        path: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Used to find secrets based on tags or regular expressions.

        :param conversion_strategy: Used to define a conversion Strategy.
        :param decoding_strategy: Used to define a decoding Strategy.
        :param name: Finds secrets based on the name.
        :param path: A root path to start the find operations.
        :param tags: Find secrets based on tags.

        :schema: ExternalSecretV1Beta1SpecDataFromFind
        '''
        if isinstance(name, dict):
            name = ExternalSecretV1Beta1SpecDataFromFindName(**name)
        if __debug__:
            def stub(
                *,
                conversion_strategy: typing.Optional[builtins.str] = None,
                decoding_strategy: typing.Optional[builtins.str] = None,
                name: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecDataFromFindName, typing.Dict[str, typing.Any]]] = None,
                path: typing.Optional[builtins.str] = None,
                tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument conversion_strategy", value=conversion_strategy, expected_type=type_hints["conversion_strategy"])
            check_type(argname="argument decoding_strategy", value=decoding_strategy, expected_type=type_hints["decoding_strategy"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
        self._values: typing.Dict[str, typing.Any] = {}
        if conversion_strategy is not None:
            self._values["conversion_strategy"] = conversion_strategy
        if decoding_strategy is not None:
            self._values["decoding_strategy"] = decoding_strategy
        if name is not None:
            self._values["name"] = name
        if path is not None:
            self._values["path"] = path
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def conversion_strategy(self) -> typing.Optional[builtins.str]:
        '''Used to define a conversion Strategy.

        :schema: ExternalSecretV1Beta1SpecDataFromFind#conversionStrategy
        '''
        result = self._values.get("conversion_strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def decoding_strategy(self) -> typing.Optional[builtins.str]:
        '''Used to define a decoding Strategy.

        :schema: ExternalSecretV1Beta1SpecDataFromFind#decodingStrategy
        '''
        result = self._values.get("decoding_strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional["ExternalSecretV1Beta1SpecDataFromFindName"]:
        '''Finds secrets based on the name.

        :schema: ExternalSecretV1Beta1SpecDataFromFind#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataFromFindName"], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''A root path to start the find operations.

        :schema: ExternalSecretV1Beta1SpecDataFromFind#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Find secrets based on tags.

        :schema: ExternalSecretV1Beta1SpecDataFromFind#tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataFromFind(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromFindName",
    jsii_struct_bases=[],
    name_mapping={"regexp": "regexp"},
)
class ExternalSecretV1Beta1SpecDataFromFindName:
    def __init__(self, *, regexp: typing.Optional[builtins.str] = None) -> None:
        '''Finds secrets based on the name.

        :param regexp: Finds secrets base.

        :schema: ExternalSecretV1Beta1SpecDataFromFindName
        '''
        if __debug__:
            def stub(*, regexp: typing.Optional[builtins.str] = None) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument regexp", value=regexp, expected_type=type_hints["regexp"])
        self._values: typing.Dict[str, typing.Any] = {}
        if regexp is not None:
            self._values["regexp"] = regexp

    @builtins.property
    def regexp(self) -> typing.Optional[builtins.str]:
        '''Finds secrets base.

        :schema: ExternalSecretV1Beta1SpecDataFromFindName#regexp
        '''
        result = self._values.get("regexp")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataFromFindName(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromRewrite",
    jsii_struct_bases=[],
    name_mapping={"regexp": "regexp"},
)
class ExternalSecretV1Beta1SpecDataFromRewrite:
    def __init__(
        self,
        *,
        regexp: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecDataFromRewriteRegexp", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param regexp: Used to rewrite with regular expressions. The resulting key will be the output of a regexp.ReplaceAll operation.

        :schema: ExternalSecretV1Beta1SpecDataFromRewrite
        '''
        if isinstance(regexp, dict):
            regexp = ExternalSecretV1Beta1SpecDataFromRewriteRegexp(**regexp)
        if __debug__:
            def stub(
                *,
                regexp: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecDataFromRewriteRegexp, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument regexp", value=regexp, expected_type=type_hints["regexp"])
        self._values: typing.Dict[str, typing.Any] = {}
        if regexp is not None:
            self._values["regexp"] = regexp

    @builtins.property
    def regexp(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecDataFromRewriteRegexp"]:
        '''Used to rewrite with regular expressions.

        The resulting key will be the output of a regexp.ReplaceAll operation.

        :schema: ExternalSecretV1Beta1SpecDataFromRewrite#regexp
        '''
        result = self._values.get("regexp")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecDataFromRewriteRegexp"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataFromRewrite(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataFromRewriteRegexp",
    jsii_struct_bases=[],
    name_mapping={"source": "source", "target": "target"},
)
class ExternalSecretV1Beta1SpecDataFromRewriteRegexp:
    def __init__(self, *, source: builtins.str, target: builtins.str) -> None:
        '''Used to rewrite with regular expressions.

        The resulting key will be the output of a regexp.ReplaceAll operation.

        :param source: Used to define the regular expression of a re.Compiler.
        :param target: Used to define the target pattern of a ReplaceAll operation.

        :schema: ExternalSecretV1Beta1SpecDataFromRewriteRegexp
        '''
        if __debug__:
            def stub(*, source: builtins.str, target: builtins.str) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument source", value=source, expected_type=type_hints["source"])
            check_type(argname="argument target", value=target, expected_type=type_hints["target"])
        self._values: typing.Dict[str, typing.Any] = {
            "source": source,
            "target": target,
        }

    @builtins.property
    def source(self) -> builtins.str:
        '''Used to define the regular expression of a re.Compiler.

        :schema: ExternalSecretV1Beta1SpecDataFromRewriteRegexp#source
        '''
        result = self._values.get("source")
        assert result is not None, "Required property 'source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target(self) -> builtins.str:
        '''Used to define the target pattern of a ReplaceAll operation.

        :schema: ExternalSecretV1Beta1SpecDataFromRewriteRegexp#target
        '''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataFromRewriteRegexp(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecDataRemoteRef",
    jsii_struct_bases=[],
    name_mapping={
        "key": "key",
        "conversion_strategy": "conversionStrategy",
        "decoding_strategy": "decodingStrategy",
        "metadata_policy": "metadataPolicy",
        "property": "property",
        "version": "version",
    },
)
class ExternalSecretV1Beta1SpecDataRemoteRef:
    def __init__(
        self,
        *,
        key: builtins.str,
        conversion_strategy: typing.Optional[builtins.str] = None,
        decoding_strategy: typing.Optional[builtins.str] = None,
        metadata_policy: typing.Optional[builtins.str] = None,
        property: typing.Optional[builtins.str] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ExternalSecretDataRemoteRef defines Provider data location.

        :param key: Key is the key used in the Provider, mandatory.
        :param conversion_strategy: Used to define a conversion Strategy.
        :param decoding_strategy: Used to define a decoding Strategy.
        :param metadata_policy: Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None Default: None
        :param property: Used to select a specific property of the Provider value (if a map), if supported.
        :param version: Used to select a specific version of the Provider value, if supported.

        :schema: ExternalSecretV1Beta1SpecDataRemoteRef
        '''
        if __debug__:
            def stub(
                *,
                key: builtins.str,
                conversion_strategy: typing.Optional[builtins.str] = None,
                decoding_strategy: typing.Optional[builtins.str] = None,
                metadata_policy: typing.Optional[builtins.str] = None,
                property: typing.Optional[builtins.str] = None,
                version: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument conversion_strategy", value=conversion_strategy, expected_type=type_hints["conversion_strategy"])
            check_type(argname="argument decoding_strategy", value=decoding_strategy, expected_type=type_hints["decoding_strategy"])
            check_type(argname="argument metadata_policy", value=metadata_policy, expected_type=type_hints["metadata_policy"])
            check_type(argname="argument property", value=property, expected_type=type_hints["property"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }
        if conversion_strategy is not None:
            self._values["conversion_strategy"] = conversion_strategy
        if decoding_strategy is not None:
            self._values["decoding_strategy"] = decoding_strategy
        if metadata_policy is not None:
            self._values["metadata_policy"] = metadata_policy
        if property is not None:
            self._values["property"] = property
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def key(self) -> builtins.str:
        '''Key is the key used in the Provider, mandatory.

        :schema: ExternalSecretV1Beta1SpecDataRemoteRef#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def conversion_strategy(self) -> typing.Optional[builtins.str]:
        '''Used to define a conversion Strategy.

        :schema: ExternalSecretV1Beta1SpecDataRemoteRef#conversionStrategy
        '''
        result = self._values.get("conversion_strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def decoding_strategy(self) -> typing.Optional[builtins.str]:
        '''Used to define a decoding Strategy.

        :schema: ExternalSecretV1Beta1SpecDataRemoteRef#decodingStrategy
        '''
        result = self._values.get("decoding_strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metadata_policy(self) -> typing.Optional[builtins.str]:
        '''Policy for fetching tags/labels from provider secrets, possible options are Fetch, None.

        Defaults to None

        :default: None

        :schema: ExternalSecretV1Beta1SpecDataRemoteRef#metadataPolicy
        '''
        result = self._values.get("metadata_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def property(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific property of the Provider value (if a map), if supported.

        :schema: ExternalSecretV1Beta1SpecDataRemoteRef#property
        '''
        result = self._values.get("property")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''Used to select a specific version of the Provider value, if supported.

        :schema: ExternalSecretV1Beta1SpecDataRemoteRef#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecDataRemoteRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecSecretStoreRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "kind": "kind"},
)
class ExternalSecretV1Beta1SpecSecretStoreRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        kind: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.

        :param name: Name of the SecretStore resource.
        :param kind: Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``. Default: SecretStore`

        :schema: ExternalSecretV1Beta1SpecSecretStoreRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                kind: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument kind", value=kind, expected_type=type_hints["kind"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if kind is not None:
            self._values["kind"] = kind

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the SecretStore resource.

        :schema: ExternalSecretV1Beta1SpecSecretStoreRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def kind(self) -> typing.Optional[builtins.str]:
        '''Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to ``SecretStore``.

        :default: SecretStore`

        :schema: ExternalSecretV1Beta1SpecSecretStoreRef#kind
        '''
        result = self._values.get("kind")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecSecretStoreRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTarget",
    jsii_struct_bases=[],
    name_mapping={
        "creation_policy": "creationPolicy",
        "deletion_policy": "deletionPolicy",
        "immutable": "immutable",
        "name": "name",
        "template": "template",
    },
)
class ExternalSecretV1Beta1SpecTarget:
    def __init__(
        self,
        *,
        creation_policy: typing.Optional["ExternalSecretV1Beta1SpecTargetCreationPolicy"] = None,
        deletion_policy: typing.Optional["ExternalSecretV1Beta1SpecTargetDeletionPolicy"] = None,
        immutable: typing.Optional[builtins.bool] = None,
        name: typing.Optional[builtins.str] = None,
        template: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecTargetTemplate", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.

        :param creation_policy: CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'. Default: Owner'
        :param deletion_policy: DeletionPolicy defines rules on how to delete the resulting Secret Defaults to 'Retain'. Default: Retain'
        :param immutable: Immutable defines if the final secret will be immutable.
        :param name: Name defines the name of the Secret resource to be managed This field is immutable Defaults to the .metadata.name of the ExternalSecret resource. Default: the .metadata.name of the ExternalSecret resource
        :param template: Template defines a blueprint for the created Secret resource.

        :schema: ExternalSecretV1Beta1SpecTarget
        '''
        if isinstance(template, dict):
            template = ExternalSecretV1Beta1SpecTargetTemplate(**template)
        if __debug__:
            def stub(
                *,
                creation_policy: typing.Optional[ExternalSecretV1Beta1SpecTargetCreationPolicy] = None,
                deletion_policy: typing.Optional[ExternalSecretV1Beta1SpecTargetDeletionPolicy] = None,
                immutable: typing.Optional[builtins.bool] = None,
                name: typing.Optional[builtins.str] = None,
                template: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecTargetTemplate, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument creation_policy", value=creation_policy, expected_type=type_hints["creation_policy"])
            check_type(argname="argument deletion_policy", value=deletion_policy, expected_type=type_hints["deletion_policy"])
            check_type(argname="argument immutable", value=immutable, expected_type=type_hints["immutable"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument template", value=template, expected_type=type_hints["template"])
        self._values: typing.Dict[str, typing.Any] = {}
        if creation_policy is not None:
            self._values["creation_policy"] = creation_policy
        if deletion_policy is not None:
            self._values["deletion_policy"] = deletion_policy
        if immutable is not None:
            self._values["immutable"] = immutable
        if name is not None:
            self._values["name"] = name
        if template is not None:
            self._values["template"] = template

    @builtins.property
    def creation_policy(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecTargetCreationPolicy"]:
        '''CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'.

        :default: Owner'

        :schema: ExternalSecretV1Beta1SpecTarget#creationPolicy
        '''
        result = self._values.get("creation_policy")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecTargetCreationPolicy"], result)

    @builtins.property
    def deletion_policy(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecTargetDeletionPolicy"]:
        '''DeletionPolicy defines rules on how to delete the resulting Secret Defaults to 'Retain'.

        :default: Retain'

        :schema: ExternalSecretV1Beta1SpecTarget#deletionPolicy
        '''
        result = self._values.get("deletion_policy")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecTargetDeletionPolicy"], result)

    @builtins.property
    def immutable(self) -> typing.Optional[builtins.bool]:
        '''Immutable defines if the final secret will be immutable.

        :schema: ExternalSecretV1Beta1SpecTarget#immutable
        '''
        result = self._values.get("immutable")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''Name defines the name of the Secret resource to be managed This field is immutable Defaults to the .metadata.name of the ExternalSecret resource.

        :default: the .metadata.name of the ExternalSecret resource

        :schema: ExternalSecretV1Beta1SpecTarget#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def template(self) -> typing.Optional["ExternalSecretV1Beta1SpecTargetTemplate"]:
        '''Template defines a blueprint for the created Secret resource.

        :schema: ExternalSecretV1Beta1SpecTarget#template
        '''
        result = self._values.get("template")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecTargetTemplate"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecTarget(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetCreationPolicy"
)
class ExternalSecretV1Beta1SpecTargetCreationPolicy(enum.Enum):
    '''CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'.

    :default: Owner'

    :schema: ExternalSecretV1Beta1SpecTargetCreationPolicy
    '''

    OWNER = "OWNER"
    '''Owner.'''
    ORPHAN = "ORPHAN"
    '''Orphan.'''
    MERGE = "MERGE"
    '''Merge.'''
    NONE = "NONE"
    '''None.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetDeletionPolicy"
)
class ExternalSecretV1Beta1SpecTargetDeletionPolicy(enum.Enum):
    '''DeletionPolicy defines rules on how to delete the resulting Secret Defaults to 'Retain'.

    :default: Retain'

    :schema: ExternalSecretV1Beta1SpecTargetDeletionPolicy
    '''

    DELETE = "DELETE"
    '''Delete.'''
    MERGE = "MERGE"
    '''Merge.'''
    RETAIN = "RETAIN"
    '''Retain.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetTemplate",
    jsii_struct_bases=[],
    name_mapping={
        "data": "data",
        "engine_version": "engineVersion",
        "metadata": "metadata",
        "template_from": "templateFrom",
        "type": "type",
    },
)
class ExternalSecretV1Beta1SpecTargetTemplate:
    def __init__(
        self,
        *,
        data: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        engine_version: typing.Optional[builtins.str] = None,
        metadata: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecTargetTemplateMetadata", typing.Dict[str, typing.Any]]] = None,
        template_from: typing.Optional[typing.Sequence[typing.Union["ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom", typing.Dict[str, typing.Any]]]] = None,
        type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Template defines a blueprint for the created Secret resource.

        :param data: 
        :param engine_version: 
        :param metadata: ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
        :param template_from: 
        :param type: 

        :schema: ExternalSecretV1Beta1SpecTargetTemplate
        '''
        if isinstance(metadata, dict):
            metadata = ExternalSecretV1Beta1SpecTargetTemplateMetadata(**metadata)
        if __debug__:
            def stub(
                *,
                data: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
                engine_version: typing.Optional[builtins.str] = None,
                metadata: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecTargetTemplateMetadata, typing.Dict[str, typing.Any]]] = None,
                template_from: typing.Optional[typing.Sequence[typing.Union[ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom, typing.Dict[str, typing.Any]]]] = None,
                type: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
            check_type(argname="argument engine_version", value=engine_version, expected_type=type_hints["engine_version"])
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument template_from", value=template_from, expected_type=type_hints["template_from"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
        self._values: typing.Dict[str, typing.Any] = {}
        if data is not None:
            self._values["data"] = data
        if engine_version is not None:
            self._values["engine_version"] = engine_version
        if metadata is not None:
            self._values["metadata"] = metadata
        if template_from is not None:
            self._values["template_from"] = template_from
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def data(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplate#data
        '''
        result = self._values.get("data")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def engine_version(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplate#engineVersion
        '''
        result = self._values.get("engine_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def metadata(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateMetadata"]:
        '''ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.

        :schema: ExternalSecretV1Beta1SpecTargetTemplate#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateMetadata"], result)

    @builtins.property
    def template_from(
        self,
    ) -> typing.Optional[typing.List["ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom"]]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplate#templateFrom
        '''
        result = self._values.get("template_from")
        return typing.cast(typing.Optional[typing.List["ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom"]], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplate#type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecTargetTemplate(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetTemplateMetadata",
    jsii_struct_bases=[],
    name_mapping={"annotations": "annotations", "labels": "labels"},
)
class ExternalSecretV1Beta1SpecTargetTemplateMetadata:
    def __init__(
        self,
        *,
        annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.

        :param annotations: 
        :param labels: 

        :schema: ExternalSecretV1Beta1SpecTargetTemplateMetadata
        '''
        if __debug__:
            def stub(
                *,
                annotations: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
                labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument labels", value=labels, expected_type=type_hints["labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if annotations is not None:
            self._values["annotations"] = annotations
        if labels is not None:
            self._values["labels"] = labels

    @builtins.property
    def annotations(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplateMetadata#annotations
        '''
        result = self._values.get("annotations")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def labels(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplateMetadata#labels
        '''
        result = self._values.get("labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecTargetTemplateMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom",
    jsii_struct_bases=[],
    name_mapping={"config_map": "configMap", "secret": "secret"},
)
class ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom:
    def __init__(
        self,
        *,
        config_map: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap", typing.Dict[str, typing.Any]]] = None,
        secret: typing.Optional[typing.Union["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param config_map: 
        :param secret: 

        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom
        '''
        if isinstance(config_map, dict):
            config_map = ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap(**config_map)
        if isinstance(secret, dict):
            secret = ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret(**secret)
        if __debug__:
            def stub(
                *,
                config_map: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap, typing.Dict[str, typing.Any]]] = None,
                secret: typing.Optional[typing.Union[ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument config_map", value=config_map, expected_type=type_hints["config_map"])
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
        self._values: typing.Dict[str, typing.Any] = {}
        if config_map is not None:
            self._values["config_map"] = config_map
        if secret is not None:
            self._values["secret"] = secret

    @builtins.property
    def config_map(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap"]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom#configMap
        '''
        result = self._values.get("config_map")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap"], result)

    @builtins.property
    def secret(
        self,
    ) -> typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret"]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom#secret
        '''
        result = self._values.get("secret")
        return typing.cast(typing.Optional["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap",
    jsii_struct_bases=[],
    name_mapping={"items": "items", "name": "name"},
)
class ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap:
    def __init__(
        self,
        *,
        items: typing.Sequence[typing.Union["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems", typing.Dict[str, typing.Any]]],
        name: builtins.str,
    ) -> None:
        '''
        :param items: 
        :param name: 

        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap
        '''
        if __debug__:
            def stub(
                *,
                items: typing.Sequence[typing.Union[ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems, typing.Dict[str, typing.Any]]],
                name: builtins.str,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {
            "items": items,
            "name": name,
        }

    @builtins.property
    def items(
        self,
    ) -> typing.List["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems"]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap#items
        '''
        result = self._values.get("items")
        assert result is not None, "Required property 'items' is missing"
        return typing.cast(typing.List["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems"], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key"},
)
class ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems:
    def __init__(self, *, key: builtins.str) -> None:
        '''
        :param key: 

        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems
        '''
        if __debug__:
            def stub(*, key: builtins.str) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret",
    jsii_struct_bases=[],
    name_mapping={"items": "items", "name": "name"},
)
class ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret:
    def __init__(
        self,
        *,
        items: typing.Sequence[typing.Union["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems", typing.Dict[str, typing.Any]]],
        name: builtins.str,
    ) -> None:
        '''
        :param items: 
        :param name: 

        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret
        '''
        if __debug__:
            def stub(
                *,
                items: typing.Sequence[typing.Union[ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems, typing.Dict[str, typing.Any]]],
                name: builtins.str,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument items", value=items, expected_type=type_hints["items"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
        self._values: typing.Dict[str, typing.Any] = {
            "items": items,
            "name": name,
        }

    @builtins.property
    def items(
        self,
    ) -> typing.List["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems"]:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret#items
        '''
        result = self._values.get("items")
        assert result is not None, "Required property 'items' is missing"
        return typing.cast(typing.List["ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems"], result)

    @builtins.property
    def name(self) -> builtins.str:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems",
    jsii_struct_bases=[],
    name_mapping={"key": "key"},
)
class ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems:
    def __init__(self, *, key: builtins.str) -> None:
        '''
        :param key: 

        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems
        '''
        if __debug__:
            def stub(*, key: builtins.str) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :schema: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SecretStore(
    cdk8s.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="ioexternal-secrets.SecretStore",
):
    '''SecretStore represents a secure external location for storing secrets, which can be referenced as part of ``storeRef`` fields.

    :schema: SecretStore
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["SecretStoreSpec", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Defines a "SecretStore" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.
        '''
        if __debug__:
            def stub(
                scope: constructs.Construct,
                id: builtins.str,
                *,
                metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
                spec: typing.Optional[typing.Union[SecretStoreSpec, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SecretStoreProps(metadata=metadata, spec=spec)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest")
    @builtins.classmethod
    def manifest(
        cls,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["SecretStoreSpec", typing.Dict[str, typing.Any]]] = None,
    ) -> typing.Any:
        '''Renders a Kubernetes manifest for "SecretStore".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.
        '''
        props = SecretStoreProps(metadata=metadata, spec=spec)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''Renders the object to Kubernetes JSON.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> cdk8s.GroupVersionKind:
        '''Returns the apiVersion and kind for "SecretStore".'''
        return typing.cast(cdk8s.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreProps",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class SecretStoreProps:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["SecretStoreSpec", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''SecretStore represents a secure external location for storing secrets, which can be referenced as part of ``storeRef`` fields.

        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.

        :schema: SecretStore
        '''
        if isinstance(metadata, dict):
            metadata = cdk8s.ApiObjectMetadata(**metadata)
        if isinstance(spec, dict):
            spec = SecretStoreSpec(**spec)
        if __debug__:
            def stub(
                *,
                metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
                spec: typing.Optional[typing.Union[SecretStoreSpec, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(self) -> typing.Optional[cdk8s.ApiObjectMetadata]:
        '''
        :schema: SecretStore#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[cdk8s.ApiObjectMetadata], result)

    @builtins.property
    def spec(self) -> typing.Optional["SecretStoreSpec"]:
        '''SecretStoreSpec defines the desired state of SecretStore.

        :schema: SecretStore#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["SecretStoreSpec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpec",
    jsii_struct_bases=[],
    name_mapping={
        "provider": "provider",
        "controller": "controller",
        "retry_settings": "retrySettings",
    },
)
class SecretStoreSpec:
    def __init__(
        self,
        *,
        provider: typing.Union["SecretStoreSpecProvider", typing.Dict[str, typing.Any]],
        controller: typing.Optional[builtins.str] = None,
        retry_settings: typing.Optional[typing.Union["SecretStoreSpecRetrySettings", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''SecretStoreSpec defines the desired state of SecretStore.

        :param provider: Used to configure the provider. Only one provider may be set
        :param controller: Used to select the correct KES controller (think: ingress.ingressClassName) The KES controller is instantiated with a specific controller name and filters ES based on this property.
        :param retry_settings: Used to configure http retries if failed.

        :schema: SecretStoreSpec
        '''
        if isinstance(provider, dict):
            provider = SecretStoreSpecProvider(**provider)
        if isinstance(retry_settings, dict):
            retry_settings = SecretStoreSpecRetrySettings(**retry_settings)
        if __debug__:
            def stub(
                *,
                provider: typing.Union[SecretStoreSpecProvider, typing.Dict[str, typing.Any]],
                controller: typing.Optional[builtins.str] = None,
                retry_settings: typing.Optional[typing.Union[SecretStoreSpecRetrySettings, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument controller", value=controller, expected_type=type_hints["controller"])
            check_type(argname="argument retry_settings", value=retry_settings, expected_type=type_hints["retry_settings"])
        self._values: typing.Dict[str, typing.Any] = {
            "provider": provider,
        }
        if controller is not None:
            self._values["controller"] = controller
        if retry_settings is not None:
            self._values["retry_settings"] = retry_settings

    @builtins.property
    def provider(self) -> "SecretStoreSpecProvider":
        '''Used to configure the provider.

        Only one provider may be set

        :schema: SecretStoreSpec#provider
        '''
        result = self._values.get("provider")
        assert result is not None, "Required property 'provider' is missing"
        return typing.cast("SecretStoreSpecProvider", result)

    @builtins.property
    def controller(self) -> typing.Optional[builtins.str]:
        '''Used to select the correct KES controller (think: ingress.ingressClassName) The KES controller is instantiated with a specific controller name and filters ES based on this property.

        :schema: SecretStoreSpec#controller
        '''
        result = self._values.get("controller")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def retry_settings(self) -> typing.Optional["SecretStoreSpecRetrySettings"]:
        '''Used to configure http retries if failed.

        :schema: SecretStoreSpec#retrySettings
        '''
        result = self._values.get("retry_settings")
        return typing.cast(typing.Optional["SecretStoreSpecRetrySettings"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProvider",
    jsii_struct_bases=[],
    name_mapping={
        "akeyless": "akeyless",
        "alibaba": "alibaba",
        "aws": "aws",
        "azurekv": "azurekv",
        "fake": "fake",
        "gcpsm": "gcpsm",
        "gitlab": "gitlab",
        "ibm": "ibm",
        "kubernetes": "kubernetes",
        "oracle": "oracle",
        "vault": "vault",
        "webhook": "webhook",
        "yandexlockbox": "yandexlockbox",
    },
)
class SecretStoreSpecProvider:
    def __init__(
        self,
        *,
        akeyless: typing.Optional[typing.Union["SecretStoreSpecProviderAkeyless", typing.Dict[str, typing.Any]]] = None,
        alibaba: typing.Optional[typing.Union["SecretStoreSpecProviderAlibaba", typing.Dict[str, typing.Any]]] = None,
        aws: typing.Optional[typing.Union["SecretStoreSpecProviderAws", typing.Dict[str, typing.Any]]] = None,
        azurekv: typing.Optional[typing.Union["SecretStoreSpecProviderAzurekv", typing.Dict[str, typing.Any]]] = None,
        fake: typing.Optional[typing.Union["SecretStoreSpecProviderFake", typing.Dict[str, typing.Any]]] = None,
        gcpsm: typing.Optional[typing.Union["SecretStoreSpecProviderGcpsm", typing.Dict[str, typing.Any]]] = None,
        gitlab: typing.Optional[typing.Union["SecretStoreSpecProviderGitlab", typing.Dict[str, typing.Any]]] = None,
        ibm: typing.Optional[typing.Union["SecretStoreSpecProviderIbm", typing.Dict[str, typing.Any]]] = None,
        kubernetes: typing.Optional[typing.Union["SecretStoreSpecProviderKubernetes", typing.Dict[str, typing.Any]]] = None,
        oracle: typing.Optional[typing.Union["SecretStoreSpecProviderOracle", typing.Dict[str, typing.Any]]] = None,
        vault: typing.Optional[typing.Union["SecretStoreSpecProviderVault", typing.Dict[str, typing.Any]]] = None,
        webhook: typing.Optional[typing.Union["SecretStoreSpecProviderWebhook", typing.Dict[str, typing.Any]]] = None,
        yandexlockbox: typing.Optional[typing.Union["SecretStoreSpecProviderYandexlockbox", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Used to configure the provider.

        Only one provider may be set

        :param akeyless: Akeyless configures this store to sync secrets using Akeyless Vault provider.
        :param alibaba: Alibaba configures this store to sync secrets using Alibaba Cloud provider.
        :param aws: AWS configures this store to sync secrets using AWS Secret Manager provider.
        :param azurekv: AzureKV configures this store to sync secrets using Azure Key Vault provider.
        :param fake: Fake configures a store with static key/value pairs.
        :param gcpsm: GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.
        :param gitlab: Gitlab configures this store to sync secrets using Gitlab Variables provider.
        :param ibm: IBM configures this store to sync secrets using IBM Cloud provider.
        :param kubernetes: Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.
        :param oracle: Oracle configures this store to sync secrets using Oracle Vault provider.
        :param vault: Vault configures this store to sync secrets using Hashi provider.
        :param webhook: Webhook configures this store to sync secrets using a generic templated webhook.
        :param yandexlockbox: YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :schema: SecretStoreSpecProvider
        '''
        if isinstance(akeyless, dict):
            akeyless = SecretStoreSpecProviderAkeyless(**akeyless)
        if isinstance(alibaba, dict):
            alibaba = SecretStoreSpecProviderAlibaba(**alibaba)
        if isinstance(aws, dict):
            aws = SecretStoreSpecProviderAws(**aws)
        if isinstance(azurekv, dict):
            azurekv = SecretStoreSpecProviderAzurekv(**azurekv)
        if isinstance(fake, dict):
            fake = SecretStoreSpecProviderFake(**fake)
        if isinstance(gcpsm, dict):
            gcpsm = SecretStoreSpecProviderGcpsm(**gcpsm)
        if isinstance(gitlab, dict):
            gitlab = SecretStoreSpecProviderGitlab(**gitlab)
        if isinstance(ibm, dict):
            ibm = SecretStoreSpecProviderIbm(**ibm)
        if isinstance(kubernetes, dict):
            kubernetes = SecretStoreSpecProviderKubernetes(**kubernetes)
        if isinstance(oracle, dict):
            oracle = SecretStoreSpecProviderOracle(**oracle)
        if isinstance(vault, dict):
            vault = SecretStoreSpecProviderVault(**vault)
        if isinstance(webhook, dict):
            webhook = SecretStoreSpecProviderWebhook(**webhook)
        if isinstance(yandexlockbox, dict):
            yandexlockbox = SecretStoreSpecProviderYandexlockbox(**yandexlockbox)
        if __debug__:
            def stub(
                *,
                akeyless: typing.Optional[typing.Union[SecretStoreSpecProviderAkeyless, typing.Dict[str, typing.Any]]] = None,
                alibaba: typing.Optional[typing.Union[SecretStoreSpecProviderAlibaba, typing.Dict[str, typing.Any]]] = None,
                aws: typing.Optional[typing.Union[SecretStoreSpecProviderAws, typing.Dict[str, typing.Any]]] = None,
                azurekv: typing.Optional[typing.Union[SecretStoreSpecProviderAzurekv, typing.Dict[str, typing.Any]]] = None,
                fake: typing.Optional[typing.Union[SecretStoreSpecProviderFake, typing.Dict[str, typing.Any]]] = None,
                gcpsm: typing.Optional[typing.Union[SecretStoreSpecProviderGcpsm, typing.Dict[str, typing.Any]]] = None,
                gitlab: typing.Optional[typing.Union[SecretStoreSpecProviderGitlab, typing.Dict[str, typing.Any]]] = None,
                ibm: typing.Optional[typing.Union[SecretStoreSpecProviderIbm, typing.Dict[str, typing.Any]]] = None,
                kubernetes: typing.Optional[typing.Union[SecretStoreSpecProviderKubernetes, typing.Dict[str, typing.Any]]] = None,
                oracle: typing.Optional[typing.Union[SecretStoreSpecProviderOracle, typing.Dict[str, typing.Any]]] = None,
                vault: typing.Optional[typing.Union[SecretStoreSpecProviderVault, typing.Dict[str, typing.Any]]] = None,
                webhook: typing.Optional[typing.Union[SecretStoreSpecProviderWebhook, typing.Dict[str, typing.Any]]] = None,
                yandexlockbox: typing.Optional[typing.Union[SecretStoreSpecProviderYandexlockbox, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument akeyless", value=akeyless, expected_type=type_hints["akeyless"])
            check_type(argname="argument alibaba", value=alibaba, expected_type=type_hints["alibaba"])
            check_type(argname="argument aws", value=aws, expected_type=type_hints["aws"])
            check_type(argname="argument azurekv", value=azurekv, expected_type=type_hints["azurekv"])
            check_type(argname="argument fake", value=fake, expected_type=type_hints["fake"])
            check_type(argname="argument gcpsm", value=gcpsm, expected_type=type_hints["gcpsm"])
            check_type(argname="argument gitlab", value=gitlab, expected_type=type_hints["gitlab"])
            check_type(argname="argument ibm", value=ibm, expected_type=type_hints["ibm"])
            check_type(argname="argument kubernetes", value=kubernetes, expected_type=type_hints["kubernetes"])
            check_type(argname="argument oracle", value=oracle, expected_type=type_hints["oracle"])
            check_type(argname="argument vault", value=vault, expected_type=type_hints["vault"])
            check_type(argname="argument webhook", value=webhook, expected_type=type_hints["webhook"])
            check_type(argname="argument yandexlockbox", value=yandexlockbox, expected_type=type_hints["yandexlockbox"])
        self._values: typing.Dict[str, typing.Any] = {}
        if akeyless is not None:
            self._values["akeyless"] = akeyless
        if alibaba is not None:
            self._values["alibaba"] = alibaba
        if aws is not None:
            self._values["aws"] = aws
        if azurekv is not None:
            self._values["azurekv"] = azurekv
        if fake is not None:
            self._values["fake"] = fake
        if gcpsm is not None:
            self._values["gcpsm"] = gcpsm
        if gitlab is not None:
            self._values["gitlab"] = gitlab
        if ibm is not None:
            self._values["ibm"] = ibm
        if kubernetes is not None:
            self._values["kubernetes"] = kubernetes
        if oracle is not None:
            self._values["oracle"] = oracle
        if vault is not None:
            self._values["vault"] = vault
        if webhook is not None:
            self._values["webhook"] = webhook
        if yandexlockbox is not None:
            self._values["yandexlockbox"] = yandexlockbox

    @builtins.property
    def akeyless(self) -> typing.Optional["SecretStoreSpecProviderAkeyless"]:
        '''Akeyless configures this store to sync secrets using Akeyless Vault provider.

        :schema: SecretStoreSpecProvider#akeyless
        '''
        result = self._values.get("akeyless")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAkeyless"], result)

    @builtins.property
    def alibaba(self) -> typing.Optional["SecretStoreSpecProviderAlibaba"]:
        '''Alibaba configures this store to sync secrets using Alibaba Cloud provider.

        :schema: SecretStoreSpecProvider#alibaba
        '''
        result = self._values.get("alibaba")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAlibaba"], result)

    @builtins.property
    def aws(self) -> typing.Optional["SecretStoreSpecProviderAws"]:
        '''AWS configures this store to sync secrets using AWS Secret Manager provider.

        :schema: SecretStoreSpecProvider#aws
        '''
        result = self._values.get("aws")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAws"], result)

    @builtins.property
    def azurekv(self) -> typing.Optional["SecretStoreSpecProviderAzurekv"]:
        '''AzureKV configures this store to sync secrets using Azure Key Vault provider.

        :schema: SecretStoreSpecProvider#azurekv
        '''
        result = self._values.get("azurekv")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAzurekv"], result)

    @builtins.property
    def fake(self) -> typing.Optional["SecretStoreSpecProviderFake"]:
        '''Fake configures a store with static key/value pairs.

        :schema: SecretStoreSpecProvider#fake
        '''
        result = self._values.get("fake")
        return typing.cast(typing.Optional["SecretStoreSpecProviderFake"], result)

    @builtins.property
    def gcpsm(self) -> typing.Optional["SecretStoreSpecProviderGcpsm"]:
        '''GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.

        :schema: SecretStoreSpecProvider#gcpsm
        '''
        result = self._values.get("gcpsm")
        return typing.cast(typing.Optional["SecretStoreSpecProviderGcpsm"], result)

    @builtins.property
    def gitlab(self) -> typing.Optional["SecretStoreSpecProviderGitlab"]:
        '''Gitlab configures this store to sync secrets using Gitlab Variables provider.

        :schema: SecretStoreSpecProvider#gitlab
        '''
        result = self._values.get("gitlab")
        return typing.cast(typing.Optional["SecretStoreSpecProviderGitlab"], result)

    @builtins.property
    def ibm(self) -> typing.Optional["SecretStoreSpecProviderIbm"]:
        '''IBM configures this store to sync secrets using IBM Cloud provider.

        :schema: SecretStoreSpecProvider#ibm
        '''
        result = self._values.get("ibm")
        return typing.cast(typing.Optional["SecretStoreSpecProviderIbm"], result)

    @builtins.property
    def kubernetes(self) -> typing.Optional["SecretStoreSpecProviderKubernetes"]:
        '''Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.

        :schema: SecretStoreSpecProvider#kubernetes
        '''
        result = self._values.get("kubernetes")
        return typing.cast(typing.Optional["SecretStoreSpecProviderKubernetes"], result)

    @builtins.property
    def oracle(self) -> typing.Optional["SecretStoreSpecProviderOracle"]:
        '''Oracle configures this store to sync secrets using Oracle Vault provider.

        :schema: SecretStoreSpecProvider#oracle
        '''
        result = self._values.get("oracle")
        return typing.cast(typing.Optional["SecretStoreSpecProviderOracle"], result)

    @builtins.property
    def vault(self) -> typing.Optional["SecretStoreSpecProviderVault"]:
        '''Vault configures this store to sync secrets using Hashi provider.

        :schema: SecretStoreSpecProvider#vault
        '''
        result = self._values.get("vault")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVault"], result)

    @builtins.property
    def webhook(self) -> typing.Optional["SecretStoreSpecProviderWebhook"]:
        '''Webhook configures this store to sync secrets using a generic templated webhook.

        :schema: SecretStoreSpecProvider#webhook
        '''
        result = self._values.get("webhook")
        return typing.cast(typing.Optional["SecretStoreSpecProviderWebhook"], result)

    @builtins.property
    def yandexlockbox(self) -> typing.Optional["SecretStoreSpecProviderYandexlockbox"]:
        '''YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :schema: SecretStoreSpecProvider#yandexlockbox
        '''
        result = self._values.get("yandexlockbox")
        return typing.cast(typing.Optional["SecretStoreSpecProviderYandexlockbox"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAkeyless",
    jsii_struct_bases=[],
    name_mapping={
        "akeyless_gw_api_url": "akeylessGwApiUrl",
        "auth_secret_ref": "authSecretRef",
    },
)
class SecretStoreSpecProviderAkeyless:
    def __init__(
        self,
        *,
        akeyless_gw_api_url: builtins.str,
        auth_secret_ref: typing.Union["SecretStoreSpecProviderAkeylessAuthSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''Akeyless configures this store to sync secrets using Akeyless Vault provider.

        :param akeyless_gw_api_url: Akeyless GW API Url from which the secrets to be fetched from.
        :param auth_secret_ref: Auth configures how the operator authenticates with Akeyless.

        :schema: SecretStoreSpecProviderAkeyless
        '''
        if isinstance(auth_secret_ref, dict):
            auth_secret_ref = SecretStoreSpecProviderAkeylessAuthSecretRef(**auth_secret_ref)
        if __debug__:
            def stub(
                *,
                akeyless_gw_api_url: builtins.str,
                auth_secret_ref: typing.Union[SecretStoreSpecProviderAkeylessAuthSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument akeyless_gw_api_url", value=akeyless_gw_api_url, expected_type=type_hints["akeyless_gw_api_url"])
            check_type(argname="argument auth_secret_ref", value=auth_secret_ref, expected_type=type_hints["auth_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "akeyless_gw_api_url": akeyless_gw_api_url,
            "auth_secret_ref": auth_secret_ref,
        }

    @builtins.property
    def akeyless_gw_api_url(self) -> builtins.str:
        '''Akeyless GW API Url from which the secrets to be fetched from.

        :schema: SecretStoreSpecProviderAkeyless#akeylessGWApiURL
        '''
        result = self._values.get("akeyless_gw_api_url")
        assert result is not None, "Required property 'akeyless_gw_api_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth_secret_ref(self) -> "SecretStoreSpecProviderAkeylessAuthSecretRef":
        '''Auth configures how the operator authenticates with Akeyless.

        :schema: SecretStoreSpecProviderAkeyless#authSecretRef
        '''
        result = self._values.get("auth_secret_ref")
        assert result is not None, "Required property 'auth_secret_ref' is missing"
        return typing.cast("SecretStoreSpecProviderAkeylessAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAkeyless(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAkeylessAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"kubernetes_auth": "kubernetesAuth", "secret_ref": "secretRef"},
)
class SecretStoreSpecProviderAkeylessAuthSecretRef:
    def __init__(
        self,
        *,
        kubernetes_auth: typing.Optional[typing.Union["SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth", typing.Dict[str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how the operator authenticates with Akeyless.

        :param kubernetes_auth: Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
        :param secret_ref: Reference to a Secret that contains the details to authenticate with Akeyless.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRef
        '''
        if isinstance(kubernetes_auth, dict):
            kubernetes_auth = SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth(**kubernetes_auth)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                kubernetes_auth: typing.Optional[typing.Union[SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth, typing.Dict[str, typing.Any]]] = None,
                secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument kubernetes_auth", value=kubernetes_auth, expected_type=type_hints["kubernetes_auth"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if kubernetes_auth is not None:
            self._values["kubernetes_auth"] = kubernetes_auth
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def kubernetes_auth(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth"]:
        '''Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRef#kubernetesAuth
        '''
        result = self._values.get("kubernetes_auth")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef"]:
        '''Reference to a Secret that contains the details to authenticate with Akeyless.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRef#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAkeylessAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth",
    jsii_struct_bases=[],
    name_mapping={
        "access_id": "accessId",
        "k8_s_conf_name": "k8SConfName",
        "secret_ref": "secretRef",
        "service_account_ref": "serviceAccountRef",
    },
)
class SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth:
    def __init__(
        self,
        *,
        access_id: builtins.str,
        k8_s_conf_name: builtins.str,
        secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef", typing.Dict[str, typing.Any]]] = None,
        service_account_ref: typing.Optional[typing.Union["SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.

        :param access_id: the Akeyless Kubernetes auth-method access-id.
        :param k8_s_conf_name: Kubernetes-auth configuration name in Akeyless-Gateway.
        :param secret_ref: Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.
        :param service_account_ref: Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(**secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                access_id: builtins.str,
                k8_s_conf_name: builtins.str,
                secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef, typing.Dict[str, typing.Any]]] = None,
                service_account_ref: typing.Optional[typing.Union[SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument access_id", value=access_id, expected_type=type_hints["access_id"])
            check_type(argname="argument k8_s_conf_name", value=k8_s_conf_name, expected_type=type_hints["k8_s_conf_name"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "access_id": access_id,
            "k8_s_conf_name": k8_s_conf_name,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def access_id(self) -> builtins.str:
        '''the Akeyless Kubernetes auth-method access-id.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#accessID
        '''
        result = self._values.get("access_id")
        assert result is not None, "Required property 'access_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def k8_s_conf_name(self) -> builtins.str:
        '''Kubernetes-auth configuration name in Akeyless-Gateway.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#k8sConfName
        '''
        result = self._values.get("k8_s_conf_name")
        assert result is not None, "Required property 'k8_s_conf_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef"]:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless.

        If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef"]:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless.

        If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_id": "accessId",
        "access_type": "accessType",
        "access_type_param": "accessTypeParam",
    },
)
class SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef:
    def __init__(
        self,
        *,
        access_id: typing.Optional[typing.Union["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId", typing.Dict[str, typing.Any]]] = None,
        access_type: typing.Optional[typing.Union["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType", typing.Dict[str, typing.Any]]] = None,
        access_type_param: typing.Optional[typing.Union["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Reference to a Secret that contains the details to authenticate with Akeyless.

        :param access_id: The SecretAccessID is used for authentication.
        :param access_type: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.
        :param access_type_param: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef
        '''
        if isinstance(access_id, dict):
            access_id = SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId(**access_id)
        if isinstance(access_type, dict):
            access_type = SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType(**access_type)
        if isinstance(access_type_param, dict):
            access_type_param = SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(**access_type_param)
        if __debug__:
            def stub(
                *,
                access_id: typing.Optional[typing.Union[SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId, typing.Dict[str, typing.Any]]] = None,
                access_type: typing.Optional[typing.Union[SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType, typing.Dict[str, typing.Any]]] = None,
                access_type_param: typing.Optional[typing.Union[SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument access_id", value=access_id, expected_type=type_hints["access_id"])
            check_type(argname="argument access_type", value=access_type, expected_type=type_hints["access_type"])
            check_type(argname="argument access_type_param", value=access_type_param, expected_type=type_hints["access_type_param"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_id is not None:
            self._values["access_id"] = access_id
        if access_type is not None:
            self._values["access_type"] = access_type
        if access_type_param is not None:
            self._values["access_type_param"] = access_type_param

    @builtins.property
    def access_id(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId"]:
        '''The SecretAccessID is used for authentication.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessID
        '''
        result = self._values.get("access_id")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId"], result)

    @builtins.property
    def access_type(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessType
        '''
        result = self._values.get("access_type")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType"], result)

    @builtins.property
    def access_type_param(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessTypeParam
        '''
        result = self._values.get("access_type_param")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessID is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAlibaba",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "region_id": "regionId", "endpoint": "endpoint"},
)
class SecretStoreSpecProviderAlibaba:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreSpecProviderAlibabaAuth", typing.Dict[str, typing.Any]],
        region_id: builtins.str,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Alibaba configures this store to sync secrets using Alibaba Cloud provider.

        :param auth: AlibabaAuth contains a secretRef for credentials.
        :param region_id: Alibaba Region to be used for the provider.
        :param endpoint: 

        :schema: SecretStoreSpecProviderAlibaba
        '''
        if isinstance(auth, dict):
            auth = SecretStoreSpecProviderAlibabaAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[SecretStoreSpecProviderAlibabaAuth, typing.Dict[str, typing.Any]],
                region_id: builtins.str,
                endpoint: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument region_id", value=region_id, expected_type=type_hints["region_id"])
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
            "region_id": region_id,
        }
        if endpoint is not None:
            self._values["endpoint"] = endpoint

    @builtins.property
    def auth(self) -> "SecretStoreSpecProviderAlibabaAuth":
        '''AlibabaAuth contains a secretRef for credentials.

        :schema: SecretStoreSpecProviderAlibaba#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreSpecProviderAlibabaAuth", result)

    @builtins.property
    def region_id(self) -> builtins.str:
        '''Alibaba Region to be used for the provider.

        :schema: SecretStoreSpecProviderAlibaba#regionID
        '''
        result = self._values.get("region_id")
        assert result is not None, "Required property 'region_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def endpoint(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreSpecProviderAlibaba#endpoint
        '''
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAlibaba(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAlibabaAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class SecretStoreSpecProviderAlibabaAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreSpecProviderAlibabaAuthSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''AlibabaAuth contains a secretRef for credentials.

        :param secret_ref: AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :schema: SecretStoreSpecProviderAlibabaAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderAlibabaAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Union[SecretStoreSpecProviderAlibabaAuthSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "SecretStoreSpecProviderAlibabaAuthSecretRef":
        '''AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :schema: SecretStoreSpecProviderAlibabaAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreSpecProviderAlibabaAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAlibabaAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAlibabaAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_key_id_secret_ref": "accessKeyIdSecretRef",
        "access_key_secret_secret_ref": "accessKeySecretSecretRef",
    },
)
class SecretStoreSpecProviderAlibabaAuthSecretRef:
    def __init__(
        self,
        *,
        access_key_id_secret_ref: typing.Union["SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef", typing.Dict[str, typing.Any]],
        access_key_secret_secret_ref: typing.Union["SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :param access_key_id_secret_ref: The AccessKeyID is used for authentication.
        :param access_key_secret_secret_ref: The AccessKeySecret is used for authentication.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRef
        '''
        if isinstance(access_key_id_secret_ref, dict):
            access_key_id_secret_ref = SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(**access_key_id_secret_ref)
        if isinstance(access_key_secret_secret_ref, dict):
            access_key_secret_secret_ref = SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(**access_key_secret_secret_ref)
        if __debug__:
            def stub(
                *,
                access_key_id_secret_ref: typing.Union[SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef, typing.Dict[str, typing.Any]],
                access_key_secret_secret_ref: typing.Union[SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument access_key_id_secret_ref", value=access_key_id_secret_ref, expected_type=type_hints["access_key_id_secret_ref"])
            check_type(argname="argument access_key_secret_secret_ref", value=access_key_secret_secret_ref, expected_type=type_hints["access_key_secret_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "access_key_id_secret_ref": access_key_id_secret_ref,
            "access_key_secret_secret_ref": access_key_secret_secret_ref,
        }

    @builtins.property
    def access_key_id_secret_ref(
        self,
    ) -> "SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef":
        '''The AccessKeyID is used for authentication.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRef#accessKeyIDSecretRef
        '''
        result = self._values.get("access_key_id_secret_ref")
        assert result is not None, "Required property 'access_key_id_secret_ref' is missing"
        return typing.cast("SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef", result)

    @builtins.property
    def access_key_secret_secret_ref(
        self,
    ) -> "SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef":
        '''The AccessKeySecret is used for authentication.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRef#accessKeySecretSecretRef
        '''
        result = self._values.get("access_key_secret_secret_ref")
        assert result is not None, "Required property 'access_key_secret_secret_ref' is missing"
        return typing.cast("SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAlibabaAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeyID is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeySecret is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAws",
    jsii_struct_bases=[],
    name_mapping={
        "region": "region",
        "service": "service",
        "auth": "auth",
        "role": "role",
    },
)
class SecretStoreSpecProviderAws:
    def __init__(
        self,
        *,
        region: builtins.str,
        service: "SecretStoreSpecProviderAwsService",
        auth: typing.Optional[typing.Union["SecretStoreSpecProviderAwsAuth", typing.Dict[str, typing.Any]]] = None,
        role: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AWS configures this store to sync secrets using AWS Secret Manager provider.

        :param region: AWS Region to be used for the provider.
        :param service: Service defines which service should be used to fetch the secrets.
        :param auth: Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.
        :param role: Role is a Role ARN which the SecretManager provider will assume.

        :schema: SecretStoreSpecProviderAws
        '''
        if isinstance(auth, dict):
            auth = SecretStoreSpecProviderAwsAuth(**auth)
        if __debug__:
            def stub(
                *,
                region: builtins.str,
                service: SecretStoreSpecProviderAwsService,
                auth: typing.Optional[typing.Union[SecretStoreSpecProviderAwsAuth, typing.Dict[str, typing.Any]]] = None,
                role: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
        self._values: typing.Dict[str, typing.Any] = {
            "region": region,
            "service": service,
        }
        if auth is not None:
            self._values["auth"] = auth
        if role is not None:
            self._values["role"] = role

    @builtins.property
    def region(self) -> builtins.str:
        '''AWS Region to be used for the provider.

        :schema: SecretStoreSpecProviderAws#region
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service(self) -> "SecretStoreSpecProviderAwsService":
        '''Service defines which service should be used to fetch the secrets.

        :schema: SecretStoreSpecProviderAws#service
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast("SecretStoreSpecProviderAwsService", result)

    @builtins.property
    def auth(self) -> typing.Optional["SecretStoreSpecProviderAwsAuth"]:
        '''Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.

        :schema: SecretStoreSpecProviderAws#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAwsAuth"], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a Role ARN which the SecretManager provider will assume.

        :schema: SecretStoreSpecProviderAws#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAws(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAwsAuth",
    jsii_struct_bases=[],
    name_mapping={"jwt": "jwt", "secret_ref": "secretRef"},
)
class SecretStoreSpecProviderAwsAuth:
    def __init__(
        self,
        *,
        jwt: typing.Optional[typing.Union["SecretStoreSpecProviderAwsAuthJwt", typing.Dict[str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderAwsAuthSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.

        :param jwt: Authenticate against AWS using service account tokens.
        :param secret_ref: AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :schema: SecretStoreSpecProviderAwsAuth
        '''
        if isinstance(jwt, dict):
            jwt = SecretStoreSpecProviderAwsAuthJwt(**jwt)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderAwsAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                jwt: typing.Optional[typing.Union[SecretStoreSpecProviderAwsAuthJwt, typing.Dict[str, typing.Any]]] = None,
                secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderAwsAuthSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument jwt", value=jwt, expected_type=type_hints["jwt"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if jwt is not None:
            self._values["jwt"] = jwt
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def jwt(self) -> typing.Optional["SecretStoreSpecProviderAwsAuthJwt"]:
        '''Authenticate against AWS using service account tokens.

        :schema: SecretStoreSpecProviderAwsAuth#jwt
        '''
        result = self._values.get("jwt")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAwsAuthJwt"], result)

    @builtins.property
    def secret_ref(self) -> typing.Optional["SecretStoreSpecProviderAwsAuthSecretRef"]:
        '''AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :schema: SecretStoreSpecProviderAwsAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAwsAuthSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAwsAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAwsAuthJwt",
    jsii_struct_bases=[],
    name_mapping={"service_account_ref": "serviceAccountRef"},
)
class SecretStoreSpecProviderAwsAuthJwt:
    def __init__(
        self,
        *,
        service_account_ref: typing.Optional[typing.Union["SecretStoreSpecProviderAwsAuthJwtServiceAccountRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Authenticate against AWS using service account tokens.

        :param service_account_ref: A reference to a ServiceAccount resource.

        :schema: SecretStoreSpecProviderAwsAuthJwt
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreSpecProviderAwsAuthJwtServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                service_account_ref: typing.Optional[typing.Union[SecretStoreSpecProviderAwsAuthJwtServiceAccountRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAwsAuthJwtServiceAccountRef"]:
        '''A reference to a ServiceAccount resource.

        :schema: SecretStoreSpecProviderAwsAuthJwt#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAwsAuthJwtServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAwsAuthJwt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAwsAuthJwtServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreSpecProviderAwsAuthJwtServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAwsAuthJwtServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreSpecProviderAwsAuthJwtServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreSpecProviderAwsAuthJwtServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAwsAuthJwtServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAwsAuthJwtServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAwsAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_key_id_secret_ref": "accessKeyIdSecretRef",
        "secret_access_key_secret_ref": "secretAccessKeySecretRef",
    },
)
class SecretStoreSpecProviderAwsAuthSecretRef:
    def __init__(
        self,
        *,
        access_key_id_secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef", typing.Dict[str, typing.Any]]] = None,
        secret_access_key_secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :param access_key_id_secret_ref: The AccessKeyID is used for authentication.
        :param secret_access_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: SecretStoreSpecProviderAwsAuthSecretRef
        '''
        if isinstance(access_key_id_secret_ref, dict):
            access_key_id_secret_ref = SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(**access_key_id_secret_ref)
        if isinstance(secret_access_key_secret_ref, dict):
            secret_access_key_secret_ref = SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(**secret_access_key_secret_ref)
        if __debug__:
            def stub(
                *,
                access_key_id_secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef, typing.Dict[str, typing.Any]]] = None,
                secret_access_key_secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument access_key_id_secret_ref", value=access_key_id_secret_ref, expected_type=type_hints["access_key_id_secret_ref"])
            check_type(argname="argument secret_access_key_secret_ref", value=secret_access_key_secret_ref, expected_type=type_hints["secret_access_key_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_key_id_secret_ref is not None:
            self._values["access_key_id_secret_ref"] = access_key_id_secret_ref
        if secret_access_key_secret_ref is not None:
            self._values["secret_access_key_secret_ref"] = secret_access_key_secret_ref

    @builtins.property
    def access_key_id_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef"]:
        '''The AccessKeyID is used for authentication.

        :schema: SecretStoreSpecProviderAwsAuthSecretRef#accessKeyIDSecretRef
        '''
        result = self._values.get("access_key_id_secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef"], result)

    @builtins.property
    def secret_access_key_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: SecretStoreSpecProviderAwsAuthSecretRef#secretAccessKeySecretRef
        '''
        result = self._values.get("secret_access_key_secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAwsAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeyID is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.SecretStoreSpecProviderAwsService")
class SecretStoreSpecProviderAwsService(enum.Enum):
    '''Service defines which service should be used to fetch the secrets.

    :schema: SecretStoreSpecProviderAwsService
    '''

    SECRETS_MANAGER = "SECRETS_MANAGER"
    '''SecretsManager.'''
    PARAMETER_STORE = "PARAMETER_STORE"
    '''ParameterStore.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAzurekv",
    jsii_struct_bases=[],
    name_mapping={
        "vault_url": "vaultUrl",
        "auth_secret_ref": "authSecretRef",
        "auth_type": "authType",
        "identity_id": "identityId",
        "service_account_ref": "serviceAccountRef",
        "tenant_id": "tenantId",
    },
)
class SecretStoreSpecProviderAzurekv:
    def __init__(
        self,
        *,
        vault_url: builtins.str,
        auth_secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderAzurekvAuthSecretRef", typing.Dict[str, typing.Any]]] = None,
        auth_type: typing.Optional["SecretStoreSpecProviderAzurekvAuthType"] = None,
        identity_id: typing.Optional[builtins.str] = None,
        service_account_ref: typing.Optional[typing.Union["SecretStoreSpecProviderAzurekvServiceAccountRef", typing.Dict[str, typing.Any]]] = None,
        tenant_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AzureKV configures this store to sync secrets using Azure Key Vault provider.

        :param vault_url: Vault Url from which the secrets to be fetched from.
        :param auth_secret_ref: Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type.
        :param auth_type: Auth type defines how to authenticate to the keyvault service. Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
        :param identity_id: If multiple Managed Identity is assigned to the pod, you can select the one to be used.
        :param service_account_ref: ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
        :param tenant_id: TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type.

        :schema: SecretStoreSpecProviderAzurekv
        '''
        if isinstance(auth_secret_ref, dict):
            auth_secret_ref = SecretStoreSpecProviderAzurekvAuthSecretRef(**auth_secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreSpecProviderAzurekvServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                vault_url: builtins.str,
                auth_secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderAzurekvAuthSecretRef, typing.Dict[str, typing.Any]]] = None,
                auth_type: typing.Optional[SecretStoreSpecProviderAzurekvAuthType] = None,
                identity_id: typing.Optional[builtins.str] = None,
                service_account_ref: typing.Optional[typing.Union[SecretStoreSpecProviderAzurekvServiceAccountRef, typing.Dict[str, typing.Any]]] = None,
                tenant_id: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument vault_url", value=vault_url, expected_type=type_hints["vault_url"])
            check_type(argname="argument auth_secret_ref", value=auth_secret_ref, expected_type=type_hints["auth_secret_ref"])
            check_type(argname="argument auth_type", value=auth_type, expected_type=type_hints["auth_type"])
            check_type(argname="argument identity_id", value=identity_id, expected_type=type_hints["identity_id"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument tenant_id", value=tenant_id, expected_type=type_hints["tenant_id"])
        self._values: typing.Dict[str, typing.Any] = {
            "vault_url": vault_url,
        }
        if auth_secret_ref is not None:
            self._values["auth_secret_ref"] = auth_secret_ref
        if auth_type is not None:
            self._values["auth_type"] = auth_type
        if identity_id is not None:
            self._values["identity_id"] = identity_id
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref
        if tenant_id is not None:
            self._values["tenant_id"] = tenant_id

    @builtins.property
    def vault_url(self) -> builtins.str:
        '''Vault Url from which the secrets to be fetched from.

        :schema: SecretStoreSpecProviderAzurekv#vaultUrl
        '''
        result = self._values.get("vault_url")
        assert result is not None, "Required property 'vault_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAzurekvAuthSecretRef"]:
        '''Auth configures how the operator authenticates with Azure.

        Required for ServicePrincipal auth type.

        :schema: SecretStoreSpecProviderAzurekv#authSecretRef
        '''
        result = self._values.get("auth_secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAzurekvAuthSecretRef"], result)

    @builtins.property
    def auth_type(self) -> typing.Optional["SecretStoreSpecProviderAzurekvAuthType"]:
        '''Auth type defines how to authenticate to the keyvault service.

        Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)

        :schema: SecretStoreSpecProviderAzurekv#authType
        '''
        result = self._values.get("auth_type")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAzurekvAuthType"], result)

    @builtins.property
    def identity_id(self) -> typing.Optional[builtins.str]:
        '''If multiple Managed Identity is assigned to the pod, you can select the one to be used.

        :schema: SecretStoreSpecProviderAzurekv#identityId
        '''
        result = self._values.get("identity_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAzurekvServiceAccountRef"]:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :schema: SecretStoreSpecProviderAzurekv#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAzurekvServiceAccountRef"], result)

    @builtins.property
    def tenant_id(self) -> typing.Optional[builtins.str]:
        '''TenantID configures the Azure Tenant to send requests to.

        Required for ServicePrincipal auth type.

        :schema: SecretStoreSpecProviderAzurekv#tenantId
        '''
        result = self._values.get("tenant_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAzurekv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAzurekvAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"client_id": "clientId", "client_secret": "clientSecret"},
)
class SecretStoreSpecProviderAzurekvAuthSecretRef:
    def __init__(
        self,
        *,
        client_id: typing.Optional[typing.Union["SecretStoreSpecProviderAzurekvAuthSecretRefClientId", typing.Dict[str, typing.Any]]] = None,
        client_secret: typing.Optional[typing.Union["SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how the operator authenticates with Azure.

        Required for ServicePrincipal auth type.

        :param client_id: The Azure clientId of the service principle used for authentication.
        :param client_secret: The Azure ClientSecret of the service principle used for authentication.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRef
        '''
        if isinstance(client_id, dict):
            client_id = SecretStoreSpecProviderAzurekvAuthSecretRefClientId(**client_id)
        if isinstance(client_secret, dict):
            client_secret = SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret(**client_secret)
        if __debug__:
            def stub(
                *,
                client_id: typing.Optional[typing.Union[SecretStoreSpecProviderAzurekvAuthSecretRefClientId, typing.Dict[str, typing.Any]]] = None,
                client_secret: typing.Optional[typing.Union[SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret", value=client_secret, expected_type=type_hints["client_secret"])
        self._values: typing.Dict[str, typing.Any] = {}
        if client_id is not None:
            self._values["client_id"] = client_id
        if client_secret is not None:
            self._values["client_secret"] = client_secret

    @builtins.property
    def client_id(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAzurekvAuthSecretRefClientId"]:
        '''The Azure clientId of the service principle used for authentication.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRef#clientId
        '''
        result = self._values.get("client_id")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAzurekvAuthSecretRefClientId"], result)

    @builtins.property
    def client_secret(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret"]:
        '''The Azure ClientSecret of the service principle used for authentication.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRef#clientSecret
        '''
        result = self._values.get("client_secret")
        return typing.cast(typing.Optional["SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAzurekvAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAzurekvAuthSecretRefClientId",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderAzurekvAuthSecretRefClientId:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Azure clientId of the service principle used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRefClientId
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRefClientId#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRefClientId#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRefClientId#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAzurekvAuthSecretRefClientId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Azure ClientSecret of the service principle used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.SecretStoreSpecProviderAzurekvAuthType")
class SecretStoreSpecProviderAzurekvAuthType(enum.Enum):
    '''Auth type defines how to authenticate to the keyvault service.

    Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)

    :schema: SecretStoreSpecProviderAzurekvAuthType
    '''

    SERVICE_PRINCIPAL = "SERVICE_PRINCIPAL"
    '''ServicePrincipal.'''
    MANAGED_IDENTITY = "MANAGED_IDENTITY"
    '''ManagedIdentity.'''
    WORKLOAD_IDENTITY = "WORKLOAD_IDENTITY"
    '''WorkloadIdentity.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderAzurekvServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreSpecProviderAzurekvServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAzurekvServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreSpecProviderAzurekvServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreSpecProviderAzurekvServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderAzurekvServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderAzurekvServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderFake",
    jsii_struct_bases=[],
    name_mapping={"data": "data"},
)
class SecretStoreSpecProviderFake:
    def __init__(
        self,
        *,
        data: typing.Sequence[typing.Union["SecretStoreSpecProviderFakeData", typing.Dict[str, typing.Any]]],
    ) -> None:
        '''Fake configures a store with static key/value pairs.

        :param data: 

        :schema: SecretStoreSpecProviderFake
        '''
        if __debug__:
            def stub(
                *,
                data: typing.Sequence[typing.Union[SecretStoreSpecProviderFakeData, typing.Dict[str, typing.Any]]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
        self._values: typing.Dict[str, typing.Any] = {
            "data": data,
        }

    @builtins.property
    def data(self) -> typing.List["SecretStoreSpecProviderFakeData"]:
        '''
        :schema: SecretStoreSpecProviderFake#data
        '''
        result = self._values.get("data")
        assert result is not None, "Required property 'data' is missing"
        return typing.cast(typing.List["SecretStoreSpecProviderFakeData"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderFake(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderFakeData",
    jsii_struct_bases=[],
    name_mapping={
        "key": "key",
        "value": "value",
        "value_map": "valueMap",
        "version": "version",
    },
)
class SecretStoreSpecProviderFakeData:
    def __init__(
        self,
        *,
        key: builtins.str,
        value: typing.Optional[builtins.str] = None,
        value_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param key: 
        :param value: 
        :param value_map: 
        :param version: 

        :schema: SecretStoreSpecProviderFakeData
        '''
        if __debug__:
            def stub(
                *,
                key: builtins.str,
                value: typing.Optional[builtins.str] = None,
                value_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
                version: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            check_type(argname="argument value_map", value=value_map, expected_type=type_hints["value_map"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }
        if value is not None:
            self._values["value"] = value
        if value_map is not None:
            self._values["value_map"] = value_map
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :schema: SecretStoreSpecProviderFakeData#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreSpecProviderFakeData#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value_map(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: SecretStoreSpecProviderFakeData#valueMap
        '''
        result = self._values.get("value_map")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreSpecProviderFakeData#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderFakeData(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderGcpsm",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "project_id": "projectId"},
)
class SecretStoreSpecProviderGcpsm:
    def __init__(
        self,
        *,
        auth: typing.Optional[typing.Union["SecretStoreSpecProviderGcpsmAuth", typing.Dict[str, typing.Any]]] = None,
        project_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.

        :param auth: Auth defines the information necessary to authenticate against GCP.
        :param project_id: ProjectID project where secret is located.

        :schema: SecretStoreSpecProviderGcpsm
        '''
        if isinstance(auth, dict):
            auth = SecretStoreSpecProviderGcpsmAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Optional[typing.Union[SecretStoreSpecProviderGcpsmAuth, typing.Dict[str, typing.Any]]] = None,
                project_id: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
        self._values: typing.Dict[str, typing.Any] = {}
        if auth is not None:
            self._values["auth"] = auth
        if project_id is not None:
            self._values["project_id"] = project_id

    @builtins.property
    def auth(self) -> typing.Optional["SecretStoreSpecProviderGcpsmAuth"]:
        '''Auth defines the information necessary to authenticate against GCP.

        :schema: SecretStoreSpecProviderGcpsm#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["SecretStoreSpecProviderGcpsmAuth"], result)

    @builtins.property
    def project_id(self) -> typing.Optional[builtins.str]:
        '''ProjectID project where secret is located.

        :schema: SecretStoreSpecProviderGcpsm#projectID
        '''
        result = self._values.get("project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderGcpsm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderGcpsmAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "workload_identity": "workloadIdentity"},
)
class SecretStoreSpecProviderGcpsmAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderGcpsmAuthSecretRef", typing.Dict[str, typing.Any]]] = None,
        workload_identity: typing.Optional[typing.Union["SecretStoreSpecProviderGcpsmAuthWorkloadIdentity", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against GCP.

        :param secret_ref: 
        :param workload_identity: 

        :schema: SecretStoreSpecProviderGcpsmAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderGcpsmAuthSecretRef(**secret_ref)
        if isinstance(workload_identity, dict):
            workload_identity = SecretStoreSpecProviderGcpsmAuthWorkloadIdentity(**workload_identity)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderGcpsmAuthSecretRef, typing.Dict[str, typing.Any]]] = None,
                workload_identity: typing.Optional[typing.Union[SecretStoreSpecProviderGcpsmAuthWorkloadIdentity, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument workload_identity", value=workload_identity, expected_type=type_hints["workload_identity"])
        self._values: typing.Dict[str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if workload_identity is not None:
            self._values["workload_identity"] = workload_identity

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderGcpsmAuthSecretRef"]:
        '''
        :schema: SecretStoreSpecProviderGcpsmAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderGcpsmAuthSecretRef"], result)

    @builtins.property
    def workload_identity(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderGcpsmAuthWorkloadIdentity"]:
        '''
        :schema: SecretStoreSpecProviderGcpsmAuth#workloadIdentity
        '''
        result = self._values.get("workload_identity")
        return typing.cast(typing.Optional["SecretStoreSpecProviderGcpsmAuthWorkloadIdentity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderGcpsmAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderGcpsmAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"secret_access_key_secret_ref": "secretAccessKeySecretRef"},
)
class SecretStoreSpecProviderGcpsmAuthSecretRef:
    def __init__(
        self,
        *,
        secret_access_key_secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param secret_access_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: SecretStoreSpecProviderGcpsmAuthSecretRef
        '''
        if isinstance(secret_access_key_secret_ref, dict):
            secret_access_key_secret_ref = SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(**secret_access_key_secret_ref)
        if __debug__:
            def stub(
                *,
                secret_access_key_secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_access_key_secret_ref", value=secret_access_key_secret_ref, expected_type=type_hints["secret_access_key_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if secret_access_key_secret_ref is not None:
            self._values["secret_access_key_secret_ref"] = secret_access_key_secret_ref

    @builtins.property
    def secret_access_key_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: SecretStoreSpecProviderGcpsmAuthSecretRef#secretAccessKeySecretRef
        '''
        result = self._values.get("secret_access_key_secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderGcpsmAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderGcpsmAuthWorkloadIdentity",
    jsii_struct_bases=[],
    name_mapping={
        "cluster_location": "clusterLocation",
        "cluster_name": "clusterName",
        "service_account_ref": "serviceAccountRef",
        "cluster_project_id": "clusterProjectId",
    },
)
class SecretStoreSpecProviderGcpsmAuthWorkloadIdentity:
    def __init__(
        self,
        *,
        cluster_location: builtins.str,
        cluster_name: builtins.str,
        service_account_ref: typing.Union["SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef", typing.Dict[str, typing.Any]],
        cluster_project_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param cluster_location: 
        :param cluster_name: 
        :param service_account_ref: A reference to a ServiceAccount resource.
        :param cluster_project_id: 

        :schema: SecretStoreSpecProviderGcpsmAuthWorkloadIdentity
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                cluster_location: builtins.str,
                cluster_name: builtins.str,
                service_account_ref: typing.Union[SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef, typing.Dict[str, typing.Any]],
                cluster_project_id: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument cluster_location", value=cluster_location, expected_type=type_hints["cluster_location"])
            check_type(argname="argument cluster_name", value=cluster_name, expected_type=type_hints["cluster_name"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument cluster_project_id", value=cluster_project_id, expected_type=type_hints["cluster_project_id"])
        self._values: typing.Dict[str, typing.Any] = {
            "cluster_location": cluster_location,
            "cluster_name": cluster_name,
            "service_account_ref": service_account_ref,
        }
        if cluster_project_id is not None:
            self._values["cluster_project_id"] = cluster_project_id

    @builtins.property
    def cluster_location(self) -> builtins.str:
        '''
        :schema: SecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterLocation
        '''
        result = self._values.get("cluster_location")
        assert result is not None, "Required property 'cluster_location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cluster_name(self) -> builtins.str:
        '''
        :schema: SecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterName
        '''
        result = self._values.get("cluster_name")
        assert result is not None, "Required property 'cluster_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> "SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef":
        '''A reference to a ServiceAccount resource.

        :schema: SecretStoreSpecProviderGcpsmAuthWorkloadIdentity#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        assert result is not None, "Required property 'service_account_ref' is missing"
        return typing.cast("SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef", result)

    @builtins.property
    def cluster_project_id(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterProjectID
        '''
        result = self._values.get("cluster_project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderGcpsmAuthWorkloadIdentity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderGitlab",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "project_id": "projectId", "url": "url"},
)
class SecretStoreSpecProviderGitlab:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreSpecProviderGitlabAuth", typing.Dict[str, typing.Any]],
        project_id: typing.Optional[builtins.str] = None,
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Gitlab configures this store to sync secrets using Gitlab Variables provider.

        :param auth: Auth configures how secret-manager authenticates with a GitLab instance.
        :param project_id: ProjectID specifies a project where secrets are located.
        :param url: URL configures the GitLab instance URL. Defaults to https://gitlab.com/. Default: https://gitlab.com/.

        :schema: SecretStoreSpecProviderGitlab
        '''
        if isinstance(auth, dict):
            auth = SecretStoreSpecProviderGitlabAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[SecretStoreSpecProviderGitlabAuth, typing.Dict[str, typing.Any]],
                project_id: typing.Optional[builtins.str] = None,
                url: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
        }
        if project_id is not None:
            self._values["project_id"] = project_id
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def auth(self) -> "SecretStoreSpecProviderGitlabAuth":
        '''Auth configures how secret-manager authenticates with a GitLab instance.

        :schema: SecretStoreSpecProviderGitlab#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreSpecProviderGitlabAuth", result)

    @builtins.property
    def project_id(self) -> typing.Optional[builtins.str]:
        '''ProjectID specifies a project where secrets are located.

        :schema: SecretStoreSpecProviderGitlab#projectID
        '''
        result = self._values.get("project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''URL configures the GitLab instance URL.

        Defaults to https://gitlab.com/.

        :default: https://gitlab.com/.

        :schema: SecretStoreSpecProviderGitlab#url
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderGitlab(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderGitlabAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class SecretStoreSpecProviderGitlabAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreSpecProviderGitlabAuthSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''Auth configures how secret-manager authenticates with a GitLab instance.

        :param secret_ref: 

        :schema: SecretStoreSpecProviderGitlabAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderGitlabAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Union[SecretStoreSpecProviderGitlabAuthSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "SecretStoreSpecProviderGitlabAuthSecretRef":
        '''
        :schema: SecretStoreSpecProviderGitlabAuth#SecretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreSpecProviderGitlabAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderGitlabAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderGitlabAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"access_token": "accessToken"},
)
class SecretStoreSpecProviderGitlabAuthSecretRef:
    def __init__(
        self,
        *,
        access_token: typing.Optional[typing.Union["SecretStoreSpecProviderGitlabAuthSecretRefAccessToken", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param access_token: AccessToken is used for authentication.

        :schema: SecretStoreSpecProviderGitlabAuthSecretRef
        '''
        if isinstance(access_token, dict):
            access_token = SecretStoreSpecProviderGitlabAuthSecretRefAccessToken(**access_token)
        if __debug__:
            def stub(
                *,
                access_token: typing.Optional[typing.Union[SecretStoreSpecProviderGitlabAuthSecretRefAccessToken, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument access_token", value=access_token, expected_type=type_hints["access_token"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_token is not None:
            self._values["access_token"] = access_token

    @builtins.property
    def access_token(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderGitlabAuthSecretRefAccessToken"]:
        '''AccessToken is used for authentication.

        :schema: SecretStoreSpecProviderGitlabAuthSecretRef#accessToken
        '''
        result = self._values.get("access_token")
        return typing.cast(typing.Optional["SecretStoreSpecProviderGitlabAuthSecretRefAccessToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderGitlabAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderGitlabAuthSecretRefAccessToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderGitlabAuthSecretRefAccessToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AccessToken is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderGitlabAuthSecretRefAccessToken
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderGitlabAuthSecretRefAccessToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderGitlabAuthSecretRefAccessToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderGitlabAuthSecretRefAccessToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderGitlabAuthSecretRefAccessToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderIbm",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "service_url": "serviceUrl"},
)
class SecretStoreSpecProviderIbm:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreSpecProviderIbmAuth", typing.Dict[str, typing.Any]],
        service_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''IBM configures this store to sync secrets using IBM Cloud provider.

        :param auth: Auth configures how secret-manager authenticates with the IBM secrets manager.
        :param service_url: ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance.

        :schema: SecretStoreSpecProviderIbm
        '''
        if isinstance(auth, dict):
            auth = SecretStoreSpecProviderIbmAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[SecretStoreSpecProviderIbmAuth, typing.Dict[str, typing.Any]],
                service_url: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument service_url", value=service_url, expected_type=type_hints["service_url"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
        }
        if service_url is not None:
            self._values["service_url"] = service_url

    @builtins.property
    def auth(self) -> "SecretStoreSpecProviderIbmAuth":
        '''Auth configures how secret-manager authenticates with the IBM secrets manager.

        :schema: SecretStoreSpecProviderIbm#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreSpecProviderIbmAuth", result)

    @builtins.property
    def service_url(self) -> typing.Optional[builtins.str]:
        '''ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance.

        :schema: SecretStoreSpecProviderIbm#serviceUrl
        '''
        result = self._values.get("service_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderIbm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderIbmAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class SecretStoreSpecProviderIbmAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreSpecProviderIbmAuthSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''Auth configures how secret-manager authenticates with the IBM secrets manager.

        :param secret_ref: 

        :schema: SecretStoreSpecProviderIbmAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderIbmAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Union[SecretStoreSpecProviderIbmAuthSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "SecretStoreSpecProviderIbmAuthSecretRef":
        '''
        :schema: SecretStoreSpecProviderIbmAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreSpecProviderIbmAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderIbmAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderIbmAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"secret_api_key_secret_ref": "secretApiKeySecretRef"},
)
class SecretStoreSpecProviderIbmAuthSecretRef:
    def __init__(
        self,
        *,
        secret_api_key_secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param secret_api_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: SecretStoreSpecProviderIbmAuthSecretRef
        '''
        if isinstance(secret_api_key_secret_ref, dict):
            secret_api_key_secret_ref = SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef(**secret_api_key_secret_ref)
        if __debug__:
            def stub(
                *,
                secret_api_key_secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_api_key_secret_ref", value=secret_api_key_secret_ref, expected_type=type_hints["secret_api_key_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if secret_api_key_secret_ref is not None:
            self._values["secret_api_key_secret_ref"] = secret_api_key_secret_ref

    @builtins.property
    def secret_api_key_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: SecretStoreSpecProviderIbmAuthSecretRef#secretApiKeySecretRef
        '''
        result = self._values.get("secret_api_key_secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderIbmAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetes",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "remote_namespace": "remoteNamespace",
        "server": "server",
    },
)
class SecretStoreSpecProviderKubernetes:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreSpecProviderKubernetesAuth", typing.Dict[str, typing.Any]],
        remote_namespace: typing.Optional[builtins.str] = None,
        server: typing.Optional[typing.Union["SecretStoreSpecProviderKubernetesServer", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.

        :param auth: Auth configures how secret-manager authenticates with a Kubernetes instance.
        :param remote_namespace: Remote namespace to fetch the secrets from.
        :param server: configures the Kubernetes server Address.

        :schema: SecretStoreSpecProviderKubernetes
        '''
        if isinstance(auth, dict):
            auth = SecretStoreSpecProviderKubernetesAuth(**auth)
        if isinstance(server, dict):
            server = SecretStoreSpecProviderKubernetesServer(**server)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[SecretStoreSpecProviderKubernetesAuth, typing.Dict[str, typing.Any]],
                remote_namespace: typing.Optional[builtins.str] = None,
                server: typing.Optional[typing.Union[SecretStoreSpecProviderKubernetesServer, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument remote_namespace", value=remote_namespace, expected_type=type_hints["remote_namespace"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
        }
        if remote_namespace is not None:
            self._values["remote_namespace"] = remote_namespace
        if server is not None:
            self._values["server"] = server

    @builtins.property
    def auth(self) -> "SecretStoreSpecProviderKubernetesAuth":
        '''Auth configures how secret-manager authenticates with a Kubernetes instance.

        :schema: SecretStoreSpecProviderKubernetes#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreSpecProviderKubernetesAuth", result)

    @builtins.property
    def remote_namespace(self) -> typing.Optional[builtins.str]:
        '''Remote namespace to fetch the secrets from.

        :schema: SecretStoreSpecProviderKubernetes#remoteNamespace
        '''
        result = self._values.get("remote_namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def server(self) -> typing.Optional["SecretStoreSpecProviderKubernetesServer"]:
        '''configures the Kubernetes server Address.

        :schema: SecretStoreSpecProviderKubernetes#server
        '''
        result = self._values.get("server")
        return typing.cast(typing.Optional["SecretStoreSpecProviderKubernetesServer"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesAuth",
    jsii_struct_bases=[],
    name_mapping={
        "cert": "cert",
        "service_account": "serviceAccount",
        "token": "token",
    },
)
class SecretStoreSpecProviderKubernetesAuth:
    def __init__(
        self,
        *,
        cert: typing.Optional[typing.Union["SecretStoreSpecProviderKubernetesAuthCert", typing.Dict[str, typing.Any]]] = None,
        service_account: typing.Optional[typing.Union["SecretStoreSpecProviderKubernetesAuthServiceAccount", typing.Dict[str, typing.Any]]] = None,
        token: typing.Optional[typing.Union["SecretStoreSpecProviderKubernetesAuthToken", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how secret-manager authenticates with a Kubernetes instance.

        :param cert: has both clientCert and clientKey as secretKeySelector.
        :param service_account: points to a service account that should be used for authentication.
        :param token: use static token to authenticate with.

        :schema: SecretStoreSpecProviderKubernetesAuth
        '''
        if isinstance(cert, dict):
            cert = SecretStoreSpecProviderKubernetesAuthCert(**cert)
        if isinstance(service_account, dict):
            service_account = SecretStoreSpecProviderKubernetesAuthServiceAccount(**service_account)
        if isinstance(token, dict):
            token = SecretStoreSpecProviderKubernetesAuthToken(**token)
        if __debug__:
            def stub(
                *,
                cert: typing.Optional[typing.Union[SecretStoreSpecProviderKubernetesAuthCert, typing.Dict[str, typing.Any]]] = None,
                service_account: typing.Optional[typing.Union[SecretStoreSpecProviderKubernetesAuthServiceAccount, typing.Dict[str, typing.Any]]] = None,
                token: typing.Optional[typing.Union[SecretStoreSpecProviderKubernetesAuthToken, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument cert", value=cert, expected_type=type_hints["cert"])
            check_type(argname="argument service_account", value=service_account, expected_type=type_hints["service_account"])
            check_type(argname="argument token", value=token, expected_type=type_hints["token"])
        self._values: typing.Dict[str, typing.Any] = {}
        if cert is not None:
            self._values["cert"] = cert
        if service_account is not None:
            self._values["service_account"] = service_account
        if token is not None:
            self._values["token"] = token

    @builtins.property
    def cert(self) -> typing.Optional["SecretStoreSpecProviderKubernetesAuthCert"]:
        '''has both clientCert and clientKey as secretKeySelector.

        :schema: SecretStoreSpecProviderKubernetesAuth#cert
        '''
        result = self._values.get("cert")
        return typing.cast(typing.Optional["SecretStoreSpecProviderKubernetesAuthCert"], result)

    @builtins.property
    def service_account(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderKubernetesAuthServiceAccount"]:
        '''points to a service account that should be used for authentication.

        :schema: SecretStoreSpecProviderKubernetesAuth#serviceAccount
        '''
        result = self._values.get("service_account")
        return typing.cast(typing.Optional["SecretStoreSpecProviderKubernetesAuthServiceAccount"], result)

    @builtins.property
    def token(self) -> typing.Optional["SecretStoreSpecProviderKubernetesAuthToken"]:
        '''use static token to authenticate with.

        :schema: SecretStoreSpecProviderKubernetesAuth#token
        '''
        result = self._values.get("token")
        return typing.cast(typing.Optional["SecretStoreSpecProviderKubernetesAuthToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetesAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesAuthCert",
    jsii_struct_bases=[],
    name_mapping={"client_cert": "clientCert", "client_key": "clientKey"},
)
class SecretStoreSpecProviderKubernetesAuthCert:
    def __init__(
        self,
        *,
        client_cert: typing.Optional[typing.Union["SecretStoreSpecProviderKubernetesAuthCertClientCert", typing.Dict[str, typing.Any]]] = None,
        client_key: typing.Optional[typing.Union["SecretStoreSpecProviderKubernetesAuthCertClientKey", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''has both clientCert and clientKey as secretKeySelector.

        :param client_cert: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.
        :param client_key: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreSpecProviderKubernetesAuthCert
        '''
        if isinstance(client_cert, dict):
            client_cert = SecretStoreSpecProviderKubernetesAuthCertClientCert(**client_cert)
        if isinstance(client_key, dict):
            client_key = SecretStoreSpecProviderKubernetesAuthCertClientKey(**client_key)
        if __debug__:
            def stub(
                *,
                client_cert: typing.Optional[typing.Union[SecretStoreSpecProviderKubernetesAuthCertClientCert, typing.Dict[str, typing.Any]]] = None,
                client_key: typing.Optional[typing.Union[SecretStoreSpecProviderKubernetesAuthCertClientKey, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument client_cert", value=client_cert, expected_type=type_hints["client_cert"])
            check_type(argname="argument client_key", value=client_key, expected_type=type_hints["client_key"])
        self._values: typing.Dict[str, typing.Any] = {}
        if client_cert is not None:
            self._values["client_cert"] = client_cert
        if client_key is not None:
            self._values["client_key"] = client_key

    @builtins.property
    def client_cert(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderKubernetesAuthCertClientCert"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreSpecProviderKubernetesAuthCert#clientCert
        '''
        result = self._values.get("client_cert")
        return typing.cast(typing.Optional["SecretStoreSpecProviderKubernetesAuthCertClientCert"], result)

    @builtins.property
    def client_key(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderKubernetesAuthCertClientKey"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreSpecProviderKubernetesAuthCert#clientKey
        '''
        result = self._values.get("client_key")
        return typing.cast(typing.Optional["SecretStoreSpecProviderKubernetesAuthCertClientKey"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetesAuthCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesAuthCertClientCert",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderKubernetesAuthCertClientCert:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderKubernetesAuthCertClientCert
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderKubernetesAuthCertClientCert#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderKubernetesAuthCertClientCert#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderKubernetesAuthCertClientCert#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetesAuthCertClientCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesAuthCertClientKey",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderKubernetesAuthCertClientKey:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderKubernetesAuthCertClientKey
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderKubernetesAuthCertClientKey#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderKubernetesAuthCertClientKey#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderKubernetesAuthCertClientKey#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetesAuthCertClientKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesAuthServiceAccount",
    jsii_struct_bases=[],
    name_mapping={"service_account": "serviceAccount"},
)
class SecretStoreSpecProviderKubernetesAuthServiceAccount:
    def __init__(
        self,
        *,
        service_account: typing.Optional[typing.Union["SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''points to a service account that should be used for authentication.

        :param service_account: A reference to a ServiceAccount resource.

        :schema: SecretStoreSpecProviderKubernetesAuthServiceAccount
        '''
        if isinstance(service_account, dict):
            service_account = SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount(**service_account)
        if __debug__:
            def stub(
                *,
                service_account: typing.Optional[typing.Union[SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument service_account", value=service_account, expected_type=type_hints["service_account"])
        self._values: typing.Dict[str, typing.Any] = {}
        if service_account is not None:
            self._values["service_account"] = service_account

    @builtins.property
    def service_account(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount"]:
        '''A reference to a ServiceAccount resource.

        :schema: SecretStoreSpecProviderKubernetesAuthServiceAccount#serviceAccount
        '''
        result = self._values.get("service_account")
        return typing.cast(typing.Optional["SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetesAuthServiceAccount(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesAuthToken",
    jsii_struct_bases=[],
    name_mapping={"bearer_token": "bearerToken"},
)
class SecretStoreSpecProviderKubernetesAuthToken:
    def __init__(
        self,
        *,
        bearer_token: typing.Optional[typing.Union["SecretStoreSpecProviderKubernetesAuthTokenBearerToken", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''use static token to authenticate with.

        :param bearer_token: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreSpecProviderKubernetesAuthToken
        '''
        if isinstance(bearer_token, dict):
            bearer_token = SecretStoreSpecProviderKubernetesAuthTokenBearerToken(**bearer_token)
        if __debug__:
            def stub(
                *,
                bearer_token: typing.Optional[typing.Union[SecretStoreSpecProviderKubernetesAuthTokenBearerToken, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument bearer_token", value=bearer_token, expected_type=type_hints["bearer_token"])
        self._values: typing.Dict[str, typing.Any] = {}
        if bearer_token is not None:
            self._values["bearer_token"] = bearer_token

    @builtins.property
    def bearer_token(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderKubernetesAuthTokenBearerToken"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreSpecProviderKubernetesAuthToken#bearerToken
        '''
        result = self._values.get("bearer_token")
        return typing.cast(typing.Optional["SecretStoreSpecProviderKubernetesAuthTokenBearerToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetesAuthToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesAuthTokenBearerToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderKubernetesAuthTokenBearerToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderKubernetesAuthTokenBearerToken
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderKubernetesAuthTokenBearerToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderKubernetesAuthTokenBearerToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderKubernetesAuthTokenBearerToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetesAuthTokenBearerToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesServer",
    jsii_struct_bases=[],
    name_mapping={"ca_bundle": "caBundle", "ca_provider": "caProvider", "url": "url"},
)
class SecretStoreSpecProviderKubernetesServer:
    def __init__(
        self,
        *,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreSpecProviderKubernetesServerCaProvider", typing.Dict[str, typing.Any]]] = None,
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''configures the Kubernetes server Address.

        :param ca_bundle: CABundle is a base64-encoded CA certificate.
        :param ca_provider: see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.
        :param url: configures the Kubernetes server Address.

        :schema: SecretStoreSpecProviderKubernetesServer
        '''
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreSpecProviderKubernetesServerCaProvider(**ca_provider)
        if __debug__:
            def stub(
                *,
                ca_bundle: typing.Optional[builtins.str] = None,
                ca_provider: typing.Optional[typing.Union[SecretStoreSpecProviderKubernetesServerCaProvider, typing.Dict[str, typing.Any]]] = None,
                url: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[str, typing.Any] = {}
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''CABundle is a base64-encoded CA certificate.

        :schema: SecretStoreSpecProviderKubernetesServer#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderKubernetesServerCaProvider"]:
        '''see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.

        :schema: SecretStoreSpecProviderKubernetesServer#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreSpecProviderKubernetesServerCaProvider"], result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''configures the Kubernetes server Address.

        :schema: SecretStoreSpecProviderKubernetesServer#url
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetesServer(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesServerCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class SecretStoreSpecProviderKubernetesServerCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "SecretStoreSpecProviderKubernetesServerCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key the value inside of the provider type to use, only used with "Secret" type.
        :param namespace: The namespace the Provider type is in.

        :schema: SecretStoreSpecProviderKubernetesServerCaProvider
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                type: SecretStoreSpecProviderKubernetesServerCaProviderType,
                key: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: SecretStoreSpecProviderKubernetesServerCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "SecretStoreSpecProviderKubernetesServerCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: SecretStoreSpecProviderKubernetesServerCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("SecretStoreSpecProviderKubernetesServerCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key the value inside of the provider type to use, only used with "Secret" type.

        :schema: SecretStoreSpecProviderKubernetesServerCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        :schema: SecretStoreSpecProviderKubernetesServerCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderKubernetesServerCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderKubernetesServerCaProviderType"
)
class SecretStoreSpecProviderKubernetesServerCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: SecretStoreSpecProviderKubernetesServerCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderOracle",
    jsii_struct_bases=[],
    name_mapping={"region": "region", "vault": "vault", "auth": "auth"},
)
class SecretStoreSpecProviderOracle:
    def __init__(
        self,
        *,
        region: builtins.str,
        vault: builtins.str,
        auth: typing.Optional[typing.Union["SecretStoreSpecProviderOracleAuth", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Oracle configures this store to sync secrets using Oracle Vault provider.

        :param region: Region is the region where vault is located.
        :param vault: Vault is the vault's OCID of the specific vault where secret is located.
        :param auth: Auth configures how secret-manager authenticates with the Oracle Vault. If empty, use the instance principal, otherwise the user credentials specified in Auth.

        :schema: SecretStoreSpecProviderOracle
        '''
        if isinstance(auth, dict):
            auth = SecretStoreSpecProviderOracleAuth(**auth)
        if __debug__:
            def stub(
                *,
                region: builtins.str,
                vault: builtins.str,
                auth: typing.Optional[typing.Union[SecretStoreSpecProviderOracleAuth, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument vault", value=vault, expected_type=type_hints["vault"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
        self._values: typing.Dict[str, typing.Any] = {
            "region": region,
            "vault": vault,
        }
        if auth is not None:
            self._values["auth"] = auth

    @builtins.property
    def region(self) -> builtins.str:
        '''Region is the region where vault is located.

        :schema: SecretStoreSpecProviderOracle#region
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vault(self) -> builtins.str:
        '''Vault is the vault's OCID of the specific vault where secret is located.

        :schema: SecretStoreSpecProviderOracle#vault
        '''
        result = self._values.get("vault")
        assert result is not None, "Required property 'vault' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth(self) -> typing.Optional["SecretStoreSpecProviderOracleAuth"]:
        '''Auth configures how secret-manager authenticates with the Oracle Vault.

        If empty, use the instance principal, otherwise the user credentials specified in Auth.

        :schema: SecretStoreSpecProviderOracle#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["SecretStoreSpecProviderOracleAuth"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderOracle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderOracleAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "tenancy": "tenancy", "user": "user"},
)
class SecretStoreSpecProviderOracleAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreSpecProviderOracleAuthSecretRef", typing.Dict[str, typing.Any]],
        tenancy: builtins.str,
        user: builtins.str,
    ) -> None:
        '''Auth configures how secret-manager authenticates with the Oracle Vault.

        If empty, use the instance principal, otherwise the user credentials specified in Auth.

        :param secret_ref: SecretRef to pass through sensitive information.
        :param tenancy: Tenancy is the tenancy OCID where user is located.
        :param user: User is an access OCID specific to the account.

        :schema: SecretStoreSpecProviderOracleAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderOracleAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Union[SecretStoreSpecProviderOracleAuthSecretRef, typing.Dict[str, typing.Any]],
                tenancy: builtins.str,
                user: builtins.str,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument tenancy", value=tenancy, expected_type=type_hints["tenancy"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_ref": secret_ref,
            "tenancy": tenancy,
            "user": user,
        }

    @builtins.property
    def secret_ref(self) -> "SecretStoreSpecProviderOracleAuthSecretRef":
        '''SecretRef to pass through sensitive information.

        :schema: SecretStoreSpecProviderOracleAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreSpecProviderOracleAuthSecretRef", result)

    @builtins.property
    def tenancy(self) -> builtins.str:
        '''Tenancy is the tenancy OCID where user is located.

        :schema: SecretStoreSpecProviderOracleAuth#tenancy
        '''
        result = self._values.get("tenancy")
        assert result is not None, "Required property 'tenancy' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def user(self) -> builtins.str:
        '''User is an access OCID specific to the account.

        :schema: SecretStoreSpecProviderOracleAuth#user
        '''
        result = self._values.get("user")
        assert result is not None, "Required property 'user' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderOracleAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderOracleAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"fingerprint": "fingerprint", "privatekey": "privatekey"},
)
class SecretStoreSpecProviderOracleAuthSecretRef:
    def __init__(
        self,
        *,
        fingerprint: typing.Union["SecretStoreSpecProviderOracleAuthSecretRefFingerprint", typing.Dict[str, typing.Any]],
        privatekey: typing.Union["SecretStoreSpecProviderOracleAuthSecretRefPrivatekey", typing.Dict[str, typing.Any]],
    ) -> None:
        '''SecretRef to pass through sensitive information.

        :param fingerprint: Fingerprint is the fingerprint of the API private key.
        :param privatekey: PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :schema: SecretStoreSpecProviderOracleAuthSecretRef
        '''
        if isinstance(fingerprint, dict):
            fingerprint = SecretStoreSpecProviderOracleAuthSecretRefFingerprint(**fingerprint)
        if isinstance(privatekey, dict):
            privatekey = SecretStoreSpecProviderOracleAuthSecretRefPrivatekey(**privatekey)
        if __debug__:
            def stub(
                *,
                fingerprint: typing.Union[SecretStoreSpecProviderOracleAuthSecretRefFingerprint, typing.Dict[str, typing.Any]],
                privatekey: typing.Union[SecretStoreSpecProviderOracleAuthSecretRefPrivatekey, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument fingerprint", value=fingerprint, expected_type=type_hints["fingerprint"])
            check_type(argname="argument privatekey", value=privatekey, expected_type=type_hints["privatekey"])
        self._values: typing.Dict[str, typing.Any] = {
            "fingerprint": fingerprint,
            "privatekey": privatekey,
        }

    @builtins.property
    def fingerprint(self) -> "SecretStoreSpecProviderOracleAuthSecretRefFingerprint":
        '''Fingerprint is the fingerprint of the API private key.

        :schema: SecretStoreSpecProviderOracleAuthSecretRef#fingerprint
        '''
        result = self._values.get("fingerprint")
        assert result is not None, "Required property 'fingerprint' is missing"
        return typing.cast("SecretStoreSpecProviderOracleAuthSecretRefFingerprint", result)

    @builtins.property
    def privatekey(self) -> "SecretStoreSpecProviderOracleAuthSecretRefPrivatekey":
        '''PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :schema: SecretStoreSpecProviderOracleAuthSecretRef#privatekey
        '''
        result = self._values.get("privatekey")
        assert result is not None, "Required property 'privatekey' is missing"
        return typing.cast("SecretStoreSpecProviderOracleAuthSecretRefPrivatekey", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderOracleAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderOracleAuthSecretRefFingerprint",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderOracleAuthSecretRefFingerprint:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Fingerprint is the fingerprint of the API private key.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderOracleAuthSecretRefFingerprint
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderOracleAuthSecretRefFingerprint#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderOracleAuthSecretRefFingerprint#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderOracleAuthSecretRefFingerprint#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderOracleAuthSecretRefFingerprint(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderOracleAuthSecretRefPrivatekey",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderOracleAuthSecretRefPrivatekey:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderOracleAuthSecretRefPrivatekey
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderOracleAuthSecretRefPrivatekey#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderOracleAuthSecretRefPrivatekey#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderOracleAuthSecretRefPrivatekey#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderOracleAuthSecretRefPrivatekey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVault",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "server": "server",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
        "forward_inconsistent": "forwardInconsistent",
        "namespace": "namespace",
        "path": "path",
        "read_your_writes": "readYourWrites",
        "version": "version",
    },
)
class SecretStoreSpecProviderVault:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreSpecProviderVaultAuth", typing.Dict[str, typing.Any]],
        server: builtins.str,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreSpecProviderVaultCaProvider", typing.Dict[str, typing.Any]]] = None,
        forward_inconsistent: typing.Optional[builtins.bool] = None,
        namespace: typing.Optional[builtins.str] = None,
        path: typing.Optional[builtins.str] = None,
        read_your_writes: typing.Optional[builtins.bool] = None,
        version: typing.Optional["SecretStoreSpecProviderVaultVersion"] = None,
    ) -> None:
        '''Vault configures this store to sync secrets using Hashi provider.

        :param auth: Auth configures how secret-manager authenticates with the Vault server.
        :param server: Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
        :param ca_bundle: PEM encoded CA bundle used to validate Vault server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
        :param ca_provider: The provider for the CA bundle to use to validate Vault server certificate.
        :param forward_inconsistent: ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop. This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
        :param namespace: Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
        :param path: Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.
        :param read_your_writes: ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request. More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency
        :param version: Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".

        :schema: SecretStoreSpecProviderVault
        '''
        if isinstance(auth, dict):
            auth = SecretStoreSpecProviderVaultAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreSpecProviderVaultCaProvider(**ca_provider)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[SecretStoreSpecProviderVaultAuth, typing.Dict[str, typing.Any]],
                server: builtins.str,
                ca_bundle: typing.Optional[builtins.str] = None,
                ca_provider: typing.Optional[typing.Union[SecretStoreSpecProviderVaultCaProvider, typing.Dict[str, typing.Any]]] = None,
                forward_inconsistent: typing.Optional[builtins.bool] = None,
                namespace: typing.Optional[builtins.str] = None,
                path: typing.Optional[builtins.str] = None,
                read_your_writes: typing.Optional[builtins.bool] = None,
                version: typing.Optional[SecretStoreSpecProviderVaultVersion] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument forward_inconsistent", value=forward_inconsistent, expected_type=type_hints["forward_inconsistent"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument read_your_writes", value=read_your_writes, expected_type=type_hints["read_your_writes"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
            "server": server,
        }
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if forward_inconsistent is not None:
            self._values["forward_inconsistent"] = forward_inconsistent
        if namespace is not None:
            self._values["namespace"] = namespace
        if path is not None:
            self._values["path"] = path
        if read_your_writes is not None:
            self._values["read_your_writes"] = read_your_writes
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def auth(self) -> "SecretStoreSpecProviderVaultAuth":
        '''Auth configures how secret-manager authenticates with the Vault server.

        :schema: SecretStoreSpecProviderVault#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreSpecProviderVaultAuth", result)

    @builtins.property
    def server(self) -> builtins.str:
        '''Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".

        :schema: SecretStoreSpecProviderVault#server
        '''
        result = self._values.get("server")
        assert result is not None, "Required property 'server' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''PEM encoded CA bundle used to validate Vault server certificate.

        Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.

        :schema: SecretStoreSpecProviderVault#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(self) -> typing.Optional["SecretStoreSpecProviderVaultCaProvider"]:
        '''The provider for the CA bundle to use to validate Vault server certificate.

        :schema: SecretStoreSpecProviderVault#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultCaProvider"], result)

    @builtins.property
    def forward_inconsistent(self) -> typing.Optional[builtins.bool]:
        '''ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop.

        This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header

        :schema: SecretStoreSpecProviderVault#forwardInconsistent
        '''
        result = self._values.get("forward_inconsistent")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Name of the vault namespace.

        Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces

        :schema: SecretStoreSpecProviderVault#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.

        :schema: SecretStoreSpecProviderVault#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_your_writes(self) -> typing.Optional[builtins.bool]:
        '''ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request.

        More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency

        :schema: SecretStoreSpecProviderVault#readYourWrites
        '''
        result = self._values.get("read_your_writes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def version(self) -> typing.Optional["SecretStoreSpecProviderVaultVersion"]:
        '''Version is the Vault KV secret engine version.

        This can be either "v1" or "v2". Version defaults to "v2".

        :schema: SecretStoreSpecProviderVault#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultVersion"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVault(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuth",
    jsii_struct_bases=[],
    name_mapping={
        "app_role": "appRole",
        "cert": "cert",
        "jwt": "jwt",
        "kubernetes": "kubernetes",
        "ldap": "ldap",
        "token_secret_ref": "tokenSecretRef",
    },
)
class SecretStoreSpecProviderVaultAuth:
    def __init__(
        self,
        *,
        app_role: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthAppRole", typing.Dict[str, typing.Any]]] = None,
        cert: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthCert", typing.Dict[str, typing.Any]]] = None,
        jwt: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthJwt", typing.Dict[str, typing.Any]]] = None,
        kubernetes: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthKubernetes", typing.Dict[str, typing.Any]]] = None,
        ldap: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthLdap", typing.Dict[str, typing.Any]]] = None,
        token_secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthTokenSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how secret-manager authenticates with the Vault server.

        :param app_role: AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
        :param cert: Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.
        :param jwt: Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.
        :param kubernetes: Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
        :param ldap: Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.
        :param token_secret_ref: TokenSecretRef authenticates with Vault by presenting a token.

        :schema: SecretStoreSpecProviderVaultAuth
        '''
        if isinstance(app_role, dict):
            app_role = SecretStoreSpecProviderVaultAuthAppRole(**app_role)
        if isinstance(cert, dict):
            cert = SecretStoreSpecProviderVaultAuthCert(**cert)
        if isinstance(jwt, dict):
            jwt = SecretStoreSpecProviderVaultAuthJwt(**jwt)
        if isinstance(kubernetes, dict):
            kubernetes = SecretStoreSpecProviderVaultAuthKubernetes(**kubernetes)
        if isinstance(ldap, dict):
            ldap = SecretStoreSpecProviderVaultAuthLdap(**ldap)
        if isinstance(token_secret_ref, dict):
            token_secret_ref = SecretStoreSpecProviderVaultAuthTokenSecretRef(**token_secret_ref)
        if __debug__:
            def stub(
                *,
                app_role: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthAppRole, typing.Dict[str, typing.Any]]] = None,
                cert: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthCert, typing.Dict[str, typing.Any]]] = None,
                jwt: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthJwt, typing.Dict[str, typing.Any]]] = None,
                kubernetes: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthKubernetes, typing.Dict[str, typing.Any]]] = None,
                ldap: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthLdap, typing.Dict[str, typing.Any]]] = None,
                token_secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthTokenSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument app_role", value=app_role, expected_type=type_hints["app_role"])
            check_type(argname="argument cert", value=cert, expected_type=type_hints["cert"])
            check_type(argname="argument jwt", value=jwt, expected_type=type_hints["jwt"])
            check_type(argname="argument kubernetes", value=kubernetes, expected_type=type_hints["kubernetes"])
            check_type(argname="argument ldap", value=ldap, expected_type=type_hints["ldap"])
            check_type(argname="argument token_secret_ref", value=token_secret_ref, expected_type=type_hints["token_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if app_role is not None:
            self._values["app_role"] = app_role
        if cert is not None:
            self._values["cert"] = cert
        if jwt is not None:
            self._values["jwt"] = jwt
        if kubernetes is not None:
            self._values["kubernetes"] = kubernetes
        if ldap is not None:
            self._values["ldap"] = ldap
        if token_secret_ref is not None:
            self._values["token_secret_ref"] = token_secret_ref

    @builtins.property
    def app_role(self) -> typing.Optional["SecretStoreSpecProviderVaultAuthAppRole"]:
        '''AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.

        :schema: SecretStoreSpecProviderVaultAuth#appRole
        '''
        result = self._values.get("app_role")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthAppRole"], result)

    @builtins.property
    def cert(self) -> typing.Optional["SecretStoreSpecProviderVaultAuthCert"]:
        '''Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.

        :schema: SecretStoreSpecProviderVaultAuth#cert
        '''
        result = self._values.get("cert")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthCert"], result)

    @builtins.property
    def jwt(self) -> typing.Optional["SecretStoreSpecProviderVaultAuthJwt"]:
        '''Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.

        :schema: SecretStoreSpecProviderVaultAuth#jwt
        '''
        result = self._values.get("jwt")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthJwt"], result)

    @builtins.property
    def kubernetes(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderVaultAuthKubernetes"]:
        '''Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.

        :schema: SecretStoreSpecProviderVaultAuth#kubernetes
        '''
        result = self._values.get("kubernetes")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthKubernetes"], result)

    @builtins.property
    def ldap(self) -> typing.Optional["SecretStoreSpecProviderVaultAuthLdap"]:
        '''Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.

        :schema: SecretStoreSpecProviderVaultAuth#ldap
        '''
        result = self._values.get("ldap")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthLdap"], result)

    @builtins.property
    def token_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderVaultAuthTokenSecretRef"]:
        '''TokenSecretRef authenticates with Vault by presenting a token.

        :schema: SecretStoreSpecProviderVaultAuth#tokenSecretRef
        '''
        result = self._values.get("token_secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthTokenSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthAppRole",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "role_id": "roleId", "secret_ref": "secretRef"},
)
class SecretStoreSpecProviderVaultAuthAppRole:
    def __init__(
        self,
        *,
        path: builtins.str,
        role_id: builtins.str,
        secret_ref: typing.Union["SecretStoreSpecProviderVaultAuthAppRoleSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.

        :param path: Path where the App Role authentication backend is mounted in Vault, e.g: "approle".
        :param role_id: RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.
        :param secret_ref: Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The ``key`` field must be specified and denotes which entry within the Secret resource is used as the app role secret.

        :schema: SecretStoreSpecProviderVaultAuthAppRole
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderVaultAuthAppRoleSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                path: builtins.str,
                role_id: builtins.str,
                secret_ref: typing.Union[SecretStoreSpecProviderVaultAuthAppRoleSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument role_id", value=role_id, expected_type=type_hints["role_id"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
            "role_id": role_id,
            "secret_ref": secret_ref,
        }

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the App Role authentication backend is mounted in Vault, e.g: "approle".

        :schema: SecretStoreSpecProviderVaultAuthAppRole#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role_id(self) -> builtins.str:
        '''RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.

        :schema: SecretStoreSpecProviderVaultAuthAppRole#roleId
        '''
        result = self._values.get("role_id")
        assert result is not None, "Required property 'role_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(self) -> "SecretStoreSpecProviderVaultAuthAppRoleSecretRef":
        '''Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret resource is used as the app role secret.

        :schema: SecretStoreSpecProviderVaultAuthAppRole#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreSpecProviderVaultAuthAppRoleSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthAppRole(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthAppRoleSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderVaultAuthAppRoleSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret resource is used as the app role secret.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthAppRoleSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderVaultAuthAppRoleSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderVaultAuthAppRoleSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthAppRoleSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthAppRoleSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthCert",
    jsii_struct_bases=[],
    name_mapping={"client_cert": "clientCert", "secret_ref": "secretRef"},
)
class SecretStoreSpecProviderVaultAuthCert:
    def __init__(
        self,
        *,
        client_cert: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthCertClientCert", typing.Dict[str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthCertSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.

        :param client_cert: ClientCert is a certificate to authenticate using the Cert Vault authentication method.
        :param secret_ref: SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :schema: SecretStoreSpecProviderVaultAuthCert
        '''
        if isinstance(client_cert, dict):
            client_cert = SecretStoreSpecProviderVaultAuthCertClientCert(**client_cert)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderVaultAuthCertSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                client_cert: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthCertClientCert, typing.Dict[str, typing.Any]]] = None,
                secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthCertSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument client_cert", value=client_cert, expected_type=type_hints["client_cert"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if client_cert is not None:
            self._values["client_cert"] = client_cert
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def client_cert(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderVaultAuthCertClientCert"]:
        '''ClientCert is a certificate to authenticate using the Cert Vault authentication method.

        :schema: SecretStoreSpecProviderVaultAuthCert#clientCert
        '''
        result = self._values.get("client_cert")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthCertClientCert"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderVaultAuthCertSecretRef"]:
        '''SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :schema: SecretStoreSpecProviderVaultAuthCert#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthCertSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthCertClientCert",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderVaultAuthCertClientCert:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ClientCert is a certificate to authenticate using the Cert Vault authentication method.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthCertClientCert
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderVaultAuthCertClientCert#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderVaultAuthCertClientCert#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthCertClientCert#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthCertClientCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderVaultAuthCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthCertSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderVaultAuthCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderVaultAuthCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthJwt",
    jsii_struct_bases=[],
    name_mapping={
        "path": "path",
        "kubernetes_service_account_token": "kubernetesServiceAccountToken",
        "role": "role",
        "secret_ref": "secretRef",
    },
)
class SecretStoreSpecProviderVaultAuthJwt:
    def __init__(
        self,
        *,
        path: builtins.str,
        kubernetes_service_account_token: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken", typing.Dict[str, typing.Any]]] = None,
        role: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthJwtSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.

        :param path: Path where the JWT authentication backend is mounted in Vault, e.g: "jwt".
        :param kubernetes_service_account_token: Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.
        :param role: Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method.
        :param secret_ref: Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :schema: SecretStoreSpecProviderVaultAuthJwt
        '''
        if isinstance(kubernetes_service_account_token, dict):
            kubernetes_service_account_token = SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken(**kubernetes_service_account_token)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderVaultAuthJwtSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                path: builtins.str,
                kubernetes_service_account_token: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken, typing.Dict[str, typing.Any]]] = None,
                role: typing.Optional[builtins.str] = None,
                secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthJwtSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument kubernetes_service_account_token", value=kubernetes_service_account_token, expected_type=type_hints["kubernetes_service_account_token"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
        }
        if kubernetes_service_account_token is not None:
            self._values["kubernetes_service_account_token"] = kubernetes_service_account_token
        if role is not None:
            self._values["role"] = role
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the JWT authentication backend is mounted in Vault, e.g: "jwt".

        :schema: SecretStoreSpecProviderVaultAuthJwt#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def kubernetes_service_account_token(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken"]:
        '''Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :schema: SecretStoreSpecProviderVaultAuthJwt#kubernetesServiceAccountToken
        '''
        result = self._values.get("kubernetes_service_account_token")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken"], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method.

        :schema: SecretStoreSpecProviderVaultAuthJwt#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderVaultAuthJwtSecretRef"]:
        '''Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :schema: SecretStoreSpecProviderVaultAuthJwt#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthJwtSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthJwt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken",
    jsii_struct_bases=[],
    name_mapping={
        "service_account_ref": "serviceAccountRef",
        "audiences": "audiences",
        "expiration_seconds": "expirationSeconds",
    },
)
class SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken:
    def __init__(
        self,
        *,
        service_account_ref: typing.Union["SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef", typing.Dict[str, typing.Any]],
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        expiration_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :param service_account_ref: Service account field containing the name of a kubernetes ServiceAccount.
        :param audiences: Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``. Defaults to a single audience ``vault`` it not specified. Default: a single audience ``vault`` it not specified.
        :param expiration_seconds: Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``. Defaults to 10 minutes. Default: 10 minutes.

        :schema: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                service_account_ref: typing.Union[SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef, typing.Dict[str, typing.Any]],
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                expiration_seconds: typing.Optional[jsii.Number] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument expiration_seconds", value=expiration_seconds, expected_type=type_hints["expiration_seconds"])
        self._values: typing.Dict[str, typing.Any] = {
            "service_account_ref": service_account_ref,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if expiration_seconds is not None:
            self._values["expiration_seconds"] = expiration_seconds

    @builtins.property
    def service_account_ref(
        self,
    ) -> "SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef":
        '''Service account field containing the name of a kubernetes ServiceAccount.

        :schema: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        assert result is not None, "Required property 'service_account_ref' is missing"
        return typing.cast("SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef", result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``.

        Defaults to a single audience ``vault`` it not specified.

        :default: a single audience ``vault`` it not specified.

        :schema: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def expiration_seconds(self) -> typing.Optional[jsii.Number]:
        '''Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``.

        Defaults to 10 minutes.

        :default: 10 minutes.

        :schema: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#expirationSeconds
        '''
        result = self._values.get("expiration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Service account field containing the name of a kubernetes ServiceAccount.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthJwtSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderVaultAuthJwtSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthJwtSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderVaultAuthJwtSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderVaultAuthJwtSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthJwtSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthJwtSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthKubernetes",
    jsii_struct_bases=[],
    name_mapping={
        "mount_path": "mountPath",
        "role": "role",
        "secret_ref": "secretRef",
        "service_account_ref": "serviceAccountRef",
    },
)
class SecretStoreSpecProviderVaultAuthKubernetes:
    def __init__(
        self,
        *,
        mount_path: builtins.str,
        role: builtins.str,
        secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthKubernetesSecretRef", typing.Dict[str, typing.Any]]] = None,
        service_account_ref: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.

        :param mount_path: Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes".
        :param role: A required field containing the Vault Role to assume. A Role binds a Kubernetes ServiceAccount with a set of Vault policies.
        :param secret_ref: Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.
        :param service_account_ref: Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: SecretStoreSpecProviderVaultAuthKubernetes
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderVaultAuthKubernetesSecretRef(**secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                mount_path: builtins.str,
                role: builtins.str,
                secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthKubernetesSecretRef, typing.Dict[str, typing.Any]]] = None,
                service_account_ref: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument mount_path", value=mount_path, expected_type=type_hints["mount_path"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "mount_path": mount_path,
            "role": role,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def mount_path(self) -> builtins.str:
        '''Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes".

        :schema: SecretStoreSpecProviderVaultAuthKubernetes#mountPath
        '''
        result = self._values.get("mount_path")
        assert result is not None, "Required property 'mount_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role(self) -> builtins.str:
        '''A required field containing the Vault Role to assume.

        A Role binds a Kubernetes ServiceAccount with a set of Vault policies.

        :schema: SecretStoreSpecProviderVaultAuthKubernetes#role
        '''
        result = self._values.get("role")
        assert result is not None, "Required property 'role' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderVaultAuthKubernetesSecretRef"]:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault.

        If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.

        :schema: SecretStoreSpecProviderVaultAuthKubernetes#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthKubernetesSecretRef"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef"]:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: SecretStoreSpecProviderVaultAuthKubernetes#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthKubernetes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthKubernetesSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderVaultAuthKubernetesSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault.

        If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthKubernetesSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderVaultAuthKubernetesSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderVaultAuthKubernetesSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthKubernetesSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthKubernetesSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthLdap",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "username": "username", "secret_ref": "secretRef"},
)
class SecretStoreSpecProviderVaultAuthLdap:
    def __init__(
        self,
        *,
        path: builtins.str,
        username: builtins.str,
        secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderVaultAuthLdapSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.

        :param path: Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap".
        :param username: Username is a LDAP user name used to authenticate using the LDAP Vault authentication method.
        :param secret_ref: SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :schema: SecretStoreSpecProviderVaultAuthLdap
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderVaultAuthLdapSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                path: builtins.str,
                username: builtins.str,
                secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderVaultAuthLdapSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
            "username": username,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap".

        :schema: SecretStoreSpecProviderVaultAuthLdap#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def username(self) -> builtins.str:
        '''Username is a LDAP user name used to authenticate using the LDAP Vault authentication method.

        :schema: SecretStoreSpecProviderVaultAuthLdap#username
        '''
        result = self._values.get("username")
        assert result is not None, "Required property 'username' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderVaultAuthLdapSecretRef"]:
        '''SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :schema: SecretStoreSpecProviderVaultAuthLdap#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderVaultAuthLdapSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthLdap(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthLdapSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderVaultAuthLdapSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthLdapSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderVaultAuthLdapSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderVaultAuthLdapSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthLdapSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthLdapSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultAuthTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderVaultAuthTokenSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''TokenSecretRef authenticates with Vault by presenting a token.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthTokenSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderVaultAuthTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderVaultAuthTokenSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderVaultAuthTokenSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultAuthTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class SecretStoreSpecProviderVaultCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "SecretStoreSpecProviderVaultCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Vault server certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key the value inside of the provider type to use, only used with "Secret" type.
        :param namespace: The namespace the Provider type is in.

        :schema: SecretStoreSpecProviderVaultCaProvider
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                type: SecretStoreSpecProviderVaultCaProviderType,
                key: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: SecretStoreSpecProviderVaultCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "SecretStoreSpecProviderVaultCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: SecretStoreSpecProviderVaultCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("SecretStoreSpecProviderVaultCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key the value inside of the provider type to use, only used with "Secret" type.

        :schema: SecretStoreSpecProviderVaultCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        :schema: SecretStoreSpecProviderVaultCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderVaultCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultCaProviderType")
class SecretStoreSpecProviderVaultCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: SecretStoreSpecProviderVaultCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.enum(jsii_type="ioexternal-secrets.SecretStoreSpecProviderVaultVersion")
class SecretStoreSpecProviderVaultVersion(enum.Enum):
    '''Version is the Vault KV secret engine version.

    This can be either "v1" or "v2". Version defaults to "v2".

    :schema: SecretStoreSpecProviderVaultVersion
    '''

    V1 = "V1"
    '''v1.'''
    V2 = "V2"
    '''v2.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderWebhook",
    jsii_struct_bases=[],
    name_mapping={
        "result": "result",
        "url": "url",
        "body": "body",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
        "headers": "headers",
        "method": "method",
        "secrets": "secrets",
        "timeout": "timeout",
    },
)
class SecretStoreSpecProviderWebhook:
    def __init__(
        self,
        *,
        result: typing.Union["SecretStoreSpecProviderWebhookResult", typing.Dict[str, typing.Any]],
        url: builtins.str,
        body: typing.Optional[builtins.str] = None,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreSpecProviderWebhookCaProvider", typing.Dict[str, typing.Any]]] = None,
        headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        method: typing.Optional[builtins.str] = None,
        secrets: typing.Optional[typing.Sequence[typing.Union["SecretStoreSpecProviderWebhookSecrets", typing.Dict[str, typing.Any]]]] = None,
        timeout: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Webhook configures this store to sync secrets using a generic templated webhook.

        :param result: Result formatting.
        :param url: Webhook url to call.
        :param body: Body.
        :param ca_bundle: PEM encoded CA bundle used to validate webhook server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
        :param ca_provider: The provider for the CA bundle to use to validate webhook server certificate.
        :param headers: Headers.
        :param method: Webhook Method.
        :param secrets: Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name.
        :param timeout: Timeout.

        :schema: SecretStoreSpecProviderWebhook
        '''
        if isinstance(result, dict):
            result = SecretStoreSpecProviderWebhookResult(**result)
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreSpecProviderWebhookCaProvider(**ca_provider)
        if __debug__:
            def stub(
                *,
                result: typing.Union[SecretStoreSpecProviderWebhookResult, typing.Dict[str, typing.Any]],
                url: builtins.str,
                body: typing.Optional[builtins.str] = None,
                ca_bundle: typing.Optional[builtins.str] = None,
                ca_provider: typing.Optional[typing.Union[SecretStoreSpecProviderWebhookCaProvider, typing.Dict[str, typing.Any]]] = None,
                headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
                method: typing.Optional[builtins.str] = None,
                secrets: typing.Optional[typing.Sequence[typing.Union[SecretStoreSpecProviderWebhookSecrets, typing.Dict[str, typing.Any]]]] = None,
                timeout: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument result", value=result, expected_type=type_hints["result"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
            check_type(argname="argument body", value=body, expected_type=type_hints["body"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument headers", value=headers, expected_type=type_hints["headers"])
            check_type(argname="argument method", value=method, expected_type=type_hints["method"])
            check_type(argname="argument secrets", value=secrets, expected_type=type_hints["secrets"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
        self._values: typing.Dict[str, typing.Any] = {
            "result": result,
            "url": url,
        }
        if body is not None:
            self._values["body"] = body
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if headers is not None:
            self._values["headers"] = headers
        if method is not None:
            self._values["method"] = method
        if secrets is not None:
            self._values["secrets"] = secrets
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def result(self) -> "SecretStoreSpecProviderWebhookResult":
        '''Result formatting.

        :schema: SecretStoreSpecProviderWebhook#result
        '''
        result = self._values.get("result")
        assert result is not None, "Required property 'result' is missing"
        return typing.cast("SecretStoreSpecProviderWebhookResult", result)

    @builtins.property
    def url(self) -> builtins.str:
        '''Webhook url to call.

        :schema: SecretStoreSpecProviderWebhook#url
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def body(self) -> typing.Optional[builtins.str]:
        '''Body.

        :schema: SecretStoreSpecProviderWebhook#body
        '''
        result = self._values.get("body")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''PEM encoded CA bundle used to validate webhook server certificate.

        Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.

        :schema: SecretStoreSpecProviderWebhook#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderWebhookCaProvider"]:
        '''The provider for the CA bundle to use to validate webhook server certificate.

        :schema: SecretStoreSpecProviderWebhook#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreSpecProviderWebhookCaProvider"], result)

    @builtins.property
    def headers(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Headers.

        :schema: SecretStoreSpecProviderWebhook#headers
        '''
        result = self._values.get("headers")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def method(self) -> typing.Optional[builtins.str]:
        '''Webhook Method.

        :schema: SecretStoreSpecProviderWebhook#method
        '''
        result = self._values.get("method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secrets(
        self,
    ) -> typing.Optional[typing.List["SecretStoreSpecProviderWebhookSecrets"]]:
        '''Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name.

        :schema: SecretStoreSpecProviderWebhook#secrets
        '''
        result = self._values.get("secrets")
        return typing.cast(typing.Optional[typing.List["SecretStoreSpecProviderWebhookSecrets"]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[builtins.str]:
        '''Timeout.

        :schema: SecretStoreSpecProviderWebhook#timeout
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderWebhook(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderWebhookCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class SecretStoreSpecProviderWebhookCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "SecretStoreSpecProviderWebhookCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate webhook server certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key the value inside of the provider type to use, only used with "Secret" type.
        :param namespace: The namespace the Provider type is in.

        :schema: SecretStoreSpecProviderWebhookCaProvider
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                type: SecretStoreSpecProviderWebhookCaProviderType,
                key: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: SecretStoreSpecProviderWebhookCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "SecretStoreSpecProviderWebhookCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: SecretStoreSpecProviderWebhookCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("SecretStoreSpecProviderWebhookCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key the value inside of the provider type to use, only used with "Secret" type.

        :schema: SecretStoreSpecProviderWebhookCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        :schema: SecretStoreSpecProviderWebhookCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderWebhookCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.SecretStoreSpecProviderWebhookCaProviderType")
class SecretStoreSpecProviderWebhookCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: SecretStoreSpecProviderWebhookCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderWebhookResult",
    jsii_struct_bases=[],
    name_mapping={"json_path": "jsonPath"},
)
class SecretStoreSpecProviderWebhookResult:
    def __init__(self, *, json_path: typing.Optional[builtins.str] = None) -> None:
        '''Result formatting.

        :param json_path: Json path of return value.

        :schema: SecretStoreSpecProviderWebhookResult
        '''
        if __debug__:
            def stub(*, json_path: typing.Optional[builtins.str] = None) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument json_path", value=json_path, expected_type=type_hints["json_path"])
        self._values: typing.Dict[str, typing.Any] = {}
        if json_path is not None:
            self._values["json_path"] = json_path

    @builtins.property
    def json_path(self) -> typing.Optional[builtins.str]:
        '''Json path of return value.

        :schema: SecretStoreSpecProviderWebhookResult#jsonPath
        '''
        result = self._values.get("json_path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderWebhookResult(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderWebhookSecrets",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "secret_ref": "secretRef"},
)
class SecretStoreSpecProviderWebhookSecrets:
    def __init__(
        self,
        *,
        name: builtins.str,
        secret_ref: typing.Union["SecretStoreSpecProviderWebhookSecretsSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''
        :param name: Name of this secret in templates.
        :param secret_ref: Secret ref to fill in credentials.

        :schema: SecretStoreSpecProviderWebhookSecrets
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreSpecProviderWebhookSecretsSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                secret_ref: typing.Union[SecretStoreSpecProviderWebhookSecretsSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "secret_ref": secret_ref,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of this secret in templates.

        :schema: SecretStoreSpecProviderWebhookSecrets#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(self) -> "SecretStoreSpecProviderWebhookSecretsSecretRef":
        '''Secret ref to fill in credentials.

        :schema: SecretStoreSpecProviderWebhookSecrets#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreSpecProviderWebhookSecretsSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderWebhookSecrets(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderWebhookSecretsSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderWebhookSecretsSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Secret ref to fill in credentials.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderWebhookSecretsSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderWebhookSecretsSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderWebhookSecretsSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderWebhookSecretsSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderWebhookSecretsSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderYandexlockbox",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "api_endpoint": "apiEndpoint",
        "ca_provider": "caProvider",
    },
)
class SecretStoreSpecProviderYandexlockbox:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreSpecProviderYandexlockboxAuth", typing.Dict[str, typing.Any]],
        api_endpoint: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreSpecProviderYandexlockboxCaProvider", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :param auth: Auth defines the information necessary to authenticate against Yandex Lockbox.
        :param api_endpoint: Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').
        :param ca_provider: The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: SecretStoreSpecProviderYandexlockbox
        '''
        if isinstance(auth, dict):
            auth = SecretStoreSpecProviderYandexlockboxAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreSpecProviderYandexlockboxCaProvider(**ca_provider)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[SecretStoreSpecProviderYandexlockboxAuth, typing.Dict[str, typing.Any]],
                api_endpoint: typing.Optional[builtins.str] = None,
                ca_provider: typing.Optional[typing.Union[SecretStoreSpecProviderYandexlockboxCaProvider, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument api_endpoint", value=api_endpoint, expected_type=type_hints["api_endpoint"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
        }
        if api_endpoint is not None:
            self._values["api_endpoint"] = api_endpoint
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider

    @builtins.property
    def auth(self) -> "SecretStoreSpecProviderYandexlockboxAuth":
        '''Auth defines the information necessary to authenticate against Yandex Lockbox.

        :schema: SecretStoreSpecProviderYandexlockbox#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreSpecProviderYandexlockboxAuth", result)

    @builtins.property
    def api_endpoint(self) -> typing.Optional[builtins.str]:
        '''Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').

        :schema: SecretStoreSpecProviderYandexlockbox#apiEndpoint
        '''
        result = self._values.get("api_endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderYandexlockboxCaProvider"]:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: SecretStoreSpecProviderYandexlockbox#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreSpecProviderYandexlockboxCaProvider"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderYandexlockbox(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderYandexlockboxAuth",
    jsii_struct_bases=[],
    name_mapping={"authorized_key_secret_ref": "authorizedKeySecretRef"},
)
class SecretStoreSpecProviderYandexlockboxAuth:
    def __init__(
        self,
        *,
        authorized_key_secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against Yandex Lockbox.

        :param authorized_key_secret_ref: The authorized key used for authentication.

        :schema: SecretStoreSpecProviderYandexlockboxAuth
        '''
        if isinstance(authorized_key_secret_ref, dict):
            authorized_key_secret_ref = SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef(**authorized_key_secret_ref)
        if __debug__:
            def stub(
                *,
                authorized_key_secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument authorized_key_secret_ref", value=authorized_key_secret_ref, expected_type=type_hints["authorized_key_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if authorized_key_secret_ref is not None:
            self._values["authorized_key_secret_ref"] = authorized_key_secret_ref

    @builtins.property
    def authorized_key_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef"]:
        '''The authorized key used for authentication.

        :schema: SecretStoreSpecProviderYandexlockboxAuth#authorizedKeySecretRef
        '''
        result = self._values.get("authorized_key_secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderYandexlockboxAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The authorized key used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderYandexlockboxCaProvider",
    jsii_struct_bases=[],
    name_mapping={"cert_secret_ref": "certSecretRef"},
)
class SecretStoreSpecProviderYandexlockboxCaProvider:
    def __init__(
        self,
        *,
        cert_secret_ref: typing.Optional[typing.Union["SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :param cert_secret_ref: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreSpecProviderYandexlockboxCaProvider
        '''
        if isinstance(cert_secret_ref, dict):
            cert_secret_ref = SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef(**cert_secret_ref)
        if __debug__:
            def stub(
                *,
                cert_secret_ref: typing.Optional[typing.Union[SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument cert_secret_ref", value=cert_secret_ref, expected_type=type_hints["cert_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if cert_secret_ref is not None:
            self._values["cert_secret_ref"] = cert_secret_ref

    @builtins.property
    def cert_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreSpecProviderYandexlockboxCaProvider#certSecretRef
        '''
        result = self._values.get("cert_secret_ref")
        return typing.cast(typing.Optional["SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderYandexlockboxCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreSpecRetrySettings",
    jsii_struct_bases=[],
    name_mapping={"max_retries": "maxRetries", "retry_interval": "retryInterval"},
)
class SecretStoreSpecRetrySettings:
    def __init__(
        self,
        *,
        max_retries: typing.Optional[jsii.Number] = None,
        retry_interval: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Used to configure http retries if failed.

        :param max_retries: 
        :param retry_interval: 

        :schema: SecretStoreSpecRetrySettings
        '''
        if __debug__:
            def stub(
                *,
                max_retries: typing.Optional[jsii.Number] = None,
                retry_interval: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument max_retries", value=max_retries, expected_type=type_hints["max_retries"])
            check_type(argname="argument retry_interval", value=retry_interval, expected_type=type_hints["retry_interval"])
        self._values: typing.Dict[str, typing.Any] = {}
        if max_retries is not None:
            self._values["max_retries"] = max_retries
        if retry_interval is not None:
            self._values["retry_interval"] = retry_interval

    @builtins.property
    def max_retries(self) -> typing.Optional[jsii.Number]:
        '''
        :schema: SecretStoreSpecRetrySettings#maxRetries
        '''
        result = self._values.get("max_retries")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def retry_interval(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreSpecRetrySettings#retryInterval
        '''
        result = self._values.get("retry_interval")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreSpecRetrySettings(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SecretStoreV1Beta1(
    cdk8s.ApiObject,
    metaclass=jsii.JSIIMeta,
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1",
):
    '''SecretStore represents a secure external location for storing secrets, which can be referenced as part of ``storeRef`` fields.

    :schema: SecretStoreV1Beta1
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["SecretStoreV1Beta1Spec", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Defines a "SecretStoreV1Beta1" API object.

        :param scope: the scope in which to define this object.
        :param id: a scope-local name for the object.
        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.
        '''
        if __debug__:
            def stub(
                scope: constructs.Construct,
                id: builtins.str,
                *,
                metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
                spec: typing.Optional[typing.Union[SecretStoreV1Beta1Spec, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SecretStoreV1Beta1Props(metadata=metadata, spec=spec)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="manifest")
    @builtins.classmethod
    def manifest(
        cls,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["SecretStoreV1Beta1Spec", typing.Dict[str, typing.Any]]] = None,
    ) -> typing.Any:
        '''Renders a Kubernetes manifest for "SecretStoreV1Beta1".

        This can be used to inline resource manifests inside other objects (e.g. as templates).

        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.
        '''
        props = SecretStoreV1Beta1Props(metadata=metadata, spec=spec)

        return typing.cast(typing.Any, jsii.sinvoke(cls, "manifest", [props]))

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.Any:
        '''Renders the object to Kubernetes JSON.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toJson", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="GVK")
    def GVK(cls) -> cdk8s.GroupVersionKind:
        '''Returns the apiVersion and kind for "SecretStoreV1Beta1".'''
        return typing.cast(cdk8s.GroupVersionKind, jsii.sget(cls, "GVK"))


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1Props",
    jsii_struct_bases=[],
    name_mapping={"metadata": "metadata", "spec": "spec"},
)
class SecretStoreV1Beta1Props:
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
        spec: typing.Optional[typing.Union["SecretStoreV1Beta1Spec", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''SecretStore represents a secure external location for storing secrets, which can be referenced as part of ``storeRef`` fields.

        :param metadata: 
        :param spec: SecretStoreSpec defines the desired state of SecretStore.

        :schema: SecretStoreV1Beta1
        '''
        if isinstance(metadata, dict):
            metadata = cdk8s.ApiObjectMetadata(**metadata)
        if isinstance(spec, dict):
            spec = SecretStoreV1Beta1Spec(**spec)
        if __debug__:
            def stub(
                *,
                metadata: typing.Optional[typing.Union[cdk8s.ApiObjectMetadata, typing.Dict[str, typing.Any]]] = None,
                spec: typing.Optional[typing.Union[SecretStoreV1Beta1Spec, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument metadata", value=metadata, expected_type=type_hints["metadata"])
            check_type(argname="argument spec", value=spec, expected_type=type_hints["spec"])
        self._values: typing.Dict[str, typing.Any] = {}
        if metadata is not None:
            self._values["metadata"] = metadata
        if spec is not None:
            self._values["spec"] = spec

    @builtins.property
    def metadata(self) -> typing.Optional[cdk8s.ApiObjectMetadata]:
        '''
        :schema: SecretStoreV1Beta1#metadata
        '''
        result = self._values.get("metadata")
        return typing.cast(typing.Optional[cdk8s.ApiObjectMetadata], result)

    @builtins.property
    def spec(self) -> typing.Optional["SecretStoreV1Beta1Spec"]:
        '''SecretStoreSpec defines the desired state of SecretStore.

        :schema: SecretStoreV1Beta1#spec
        '''
        result = self._values.get("spec")
        return typing.cast(typing.Optional["SecretStoreV1Beta1Spec"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1Props(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1Spec",
    jsii_struct_bases=[],
    name_mapping={
        "provider": "provider",
        "conditions": "conditions",
        "controller": "controller",
        "refresh_interval": "refreshInterval",
        "retry_settings": "retrySettings",
    },
)
class SecretStoreV1Beta1Spec:
    def __init__(
        self,
        *,
        provider: typing.Union["SecretStoreV1Beta1SpecProvider", typing.Dict[str, typing.Any]],
        conditions: typing.Optional[typing.Sequence[typing.Union["SecretStoreV1Beta1SpecConditions", typing.Dict[str, typing.Any]]]] = None,
        controller: typing.Optional[builtins.str] = None,
        refresh_interval: typing.Optional[jsii.Number] = None,
        retry_settings: typing.Optional[typing.Union["SecretStoreV1Beta1SpecRetrySettings", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''SecretStoreSpec defines the desired state of SecretStore.

        :param provider: Used to configure the provider. Only one provider may be set
        :param conditions: Used to constraint a ClusterSecretStore to specific namespaces. Relevant only to ClusterSecretStore
        :param controller: Used to select the correct KES controller (think: ingress.ingressClassName) The KES controller is instantiated with a specific controller name and filters ES based on this property.
        :param refresh_interval: Used to configure store refresh interval in seconds. Empty or 0 will default to the controller config.
        :param retry_settings: Used to configure http retries if failed.

        :schema: SecretStoreV1Beta1Spec
        '''
        if isinstance(provider, dict):
            provider = SecretStoreV1Beta1SpecProvider(**provider)
        if isinstance(retry_settings, dict):
            retry_settings = SecretStoreV1Beta1SpecRetrySettings(**retry_settings)
        if __debug__:
            def stub(
                *,
                provider: typing.Union[SecretStoreV1Beta1SpecProvider, typing.Dict[str, typing.Any]],
                conditions: typing.Optional[typing.Sequence[typing.Union[SecretStoreV1Beta1SpecConditions, typing.Dict[str, typing.Any]]]] = None,
                controller: typing.Optional[builtins.str] = None,
                refresh_interval: typing.Optional[jsii.Number] = None,
                retry_settings: typing.Optional[typing.Union[SecretStoreV1Beta1SpecRetrySettings, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument provider", value=provider, expected_type=type_hints["provider"])
            check_type(argname="argument conditions", value=conditions, expected_type=type_hints["conditions"])
            check_type(argname="argument controller", value=controller, expected_type=type_hints["controller"])
            check_type(argname="argument refresh_interval", value=refresh_interval, expected_type=type_hints["refresh_interval"])
            check_type(argname="argument retry_settings", value=retry_settings, expected_type=type_hints["retry_settings"])
        self._values: typing.Dict[str, typing.Any] = {
            "provider": provider,
        }
        if conditions is not None:
            self._values["conditions"] = conditions
        if controller is not None:
            self._values["controller"] = controller
        if refresh_interval is not None:
            self._values["refresh_interval"] = refresh_interval
        if retry_settings is not None:
            self._values["retry_settings"] = retry_settings

    @builtins.property
    def provider(self) -> "SecretStoreV1Beta1SpecProvider":
        '''Used to configure the provider.

        Only one provider may be set

        :schema: SecretStoreV1Beta1Spec#provider
        '''
        result = self._values.get("provider")
        assert result is not None, "Required property 'provider' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProvider", result)

    @builtins.property
    def conditions(
        self,
    ) -> typing.Optional[typing.List["SecretStoreV1Beta1SpecConditions"]]:
        '''Used to constraint a ClusterSecretStore to specific namespaces.

        Relevant only to ClusterSecretStore

        :schema: SecretStoreV1Beta1Spec#conditions
        '''
        result = self._values.get("conditions")
        return typing.cast(typing.Optional[typing.List["SecretStoreV1Beta1SpecConditions"]], result)

    @builtins.property
    def controller(self) -> typing.Optional[builtins.str]:
        '''Used to select the correct KES controller (think: ingress.ingressClassName) The KES controller is instantiated with a specific controller name and filters ES based on this property.

        :schema: SecretStoreV1Beta1Spec#controller
        '''
        result = self._values.get("controller")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def refresh_interval(self) -> typing.Optional[jsii.Number]:
        '''Used to configure store refresh interval in seconds.

        Empty or 0 will default to the controller config.

        :schema: SecretStoreV1Beta1Spec#refreshInterval
        '''
        result = self._values.get("refresh_interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def retry_settings(self) -> typing.Optional["SecretStoreV1Beta1SpecRetrySettings"]:
        '''Used to configure http retries if failed.

        :schema: SecretStoreV1Beta1Spec#retrySettings
        '''
        result = self._values.get("retry_settings")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecRetrySettings"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1Spec(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecConditions",
    jsii_struct_bases=[],
    name_mapping={
        "namespaces": "namespaces",
        "namespace_selector": "namespaceSelector",
    },
)
class SecretStoreV1Beta1SpecConditions:
    def __init__(
        self,
        *,
        namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace_selector: typing.Optional[typing.Union["SecretStoreV1Beta1SpecConditionsNamespaceSelector", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''ClusterSecretStoreCondition describes a condition by which to choose namespaces to process ExternalSecrets in for a ClusterSecretStore instance.

        :param namespaces: Choose namespaces by name.
        :param namespace_selector: Choose namespace using a labelSelector.

        :schema: SecretStoreV1Beta1SpecConditions
        '''
        if isinstance(namespace_selector, dict):
            namespace_selector = SecretStoreV1Beta1SpecConditionsNamespaceSelector(**namespace_selector)
        if __debug__:
            def stub(
                *,
                namespaces: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace_selector: typing.Optional[typing.Union[SecretStoreV1Beta1SpecConditionsNamespaceSelector, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument namespaces", value=namespaces, expected_type=type_hints["namespaces"])
            check_type(argname="argument namespace_selector", value=namespace_selector, expected_type=type_hints["namespace_selector"])
        self._values: typing.Dict[str, typing.Any] = {}
        if namespaces is not None:
            self._values["namespaces"] = namespaces
        if namespace_selector is not None:
            self._values["namespace_selector"] = namespace_selector

    @builtins.property
    def namespaces(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Choose namespaces by name.

        :schema: SecretStoreV1Beta1SpecConditions#namespaces
        '''
        result = self._values.get("namespaces")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace_selector(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecConditionsNamespaceSelector"]:
        '''Choose namespace using a labelSelector.

        :schema: SecretStoreV1Beta1SpecConditions#namespaceSelector
        '''
        result = self._values.get("namespace_selector")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecConditionsNamespaceSelector"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecConditions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecConditionsNamespaceSelector",
    jsii_struct_bases=[],
    name_mapping={
        "match_expressions": "matchExpressions",
        "match_labels": "matchLabels",
    },
)
class SecretStoreV1Beta1SpecConditionsNamespaceSelector:
    def __init__(
        self,
        *,
        match_expressions: typing.Optional[typing.Sequence[typing.Union["SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions", typing.Dict[str, typing.Any]]]] = None,
        match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''Choose namespace using a labelSelector.

        :param match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: SecretStoreV1Beta1SpecConditionsNamespaceSelector
        '''
        if __debug__:
            def stub(
                *,
                match_expressions: typing.Optional[typing.Sequence[typing.Union[SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions, typing.Dict[str, typing.Any]]]] = None,
                match_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument match_expressions", value=match_expressions, expected_type=type_hints["match_expressions"])
            check_type(argname="argument match_labels", value=match_labels, expected_type=type_hints["match_labels"])
        self._values: typing.Dict[str, typing.Any] = {}
        if match_expressions is not None:
            self._values["match_expressions"] = match_expressions
        if match_labels is not None:
            self._values["match_labels"] = match_labels

    @builtins.property
    def match_expressions(
        self,
    ) -> typing.Optional[typing.List["SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions"]]:
        '''matchExpressions is a list of label selector requirements.

        The requirements are ANDed.

        :schema: SecretStoreV1Beta1SpecConditionsNamespaceSelector#matchExpressions
        '''
        result = self._values.get("match_expressions")
        return typing.cast(typing.Optional[typing.List["SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions"]], result)

    @builtins.property
    def match_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''matchLabels is a map of {key,value} pairs.

        A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.

        :schema: SecretStoreV1Beta1SpecConditionsNamespaceSelector#matchLabels
        '''
        result = self._values.get("match_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecConditionsNamespaceSelector(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "operator": "operator", "values": "values"},
)
class SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions:
    def __init__(
        self,
        *,
        key: builtins.str,
        operator: builtins.str,
        values: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.

        :param key: key is the label key that the selector applies to.
        :param operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions
        '''
        if __debug__:
            def stub(
                *,
                key: builtins.str,
                operator: builtins.str,
                values: typing.Optional[typing.Sequence[builtins.str]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument operator", value=operator, expected_type=type_hints["operator"])
            check_type(argname="argument values", value=values, expected_type=type_hints["values"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
            "operator": operator,
        }
        if values is not None:
            self._values["values"] = values

    @builtins.property
    def key(self) -> builtins.str:
        '''key is the label key that the selector applies to.

        :schema: SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def operator(self) -> builtins.str:
        '''operator represents a key's relationship to a set of values.

        Valid operators are In, NotIn, Exists and DoesNotExist.

        :schema: SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#operator
        '''
        result = self._values.get("operator")
        assert result is not None, "Required property 'operator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def values(self) -> typing.Optional[typing.List[builtins.str]]:
        '''values is an array of string values.

        If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.

        :schema: SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#values
        '''
        result = self._values.get("values")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProvider",
    jsii_struct_bases=[],
    name_mapping={
        "akeyless": "akeyless",
        "alibaba": "alibaba",
        "aws": "aws",
        "azurekv": "azurekv",
        "doppler": "doppler",
        "fake": "fake",
        "gcpsm": "gcpsm",
        "gitlab": "gitlab",
        "ibm": "ibm",
        "kubernetes": "kubernetes",
        "onepassword": "onepassword",
        "oracle": "oracle",
        "senhasegura": "senhasegura",
        "vault": "vault",
        "webhook": "webhook",
        "yandexcertificatemanager": "yandexcertificatemanager",
        "yandexlockbox": "yandexlockbox",
    },
)
class SecretStoreV1Beta1SpecProvider:
    def __init__(
        self,
        *,
        akeyless: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAkeyless", typing.Dict[str, typing.Any]]] = None,
        alibaba: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAlibaba", typing.Dict[str, typing.Any]]] = None,
        aws: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAws", typing.Dict[str, typing.Any]]] = None,
        azurekv: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAzurekv", typing.Dict[str, typing.Any]]] = None,
        doppler: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderDoppler", typing.Dict[str, typing.Any]]] = None,
        fake: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderFake", typing.Dict[str, typing.Any]]] = None,
        gcpsm: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderGcpsm", typing.Dict[str, typing.Any]]] = None,
        gitlab: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderGitlab", typing.Dict[str, typing.Any]]] = None,
        ibm: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderIbm", typing.Dict[str, typing.Any]]] = None,
        kubernetes: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKubernetes", typing.Dict[str, typing.Any]]] = None,
        onepassword: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderOnepassword", typing.Dict[str, typing.Any]]] = None,
        oracle: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderOracle", typing.Dict[str, typing.Any]]] = None,
        senhasegura: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderSenhasegura", typing.Dict[str, typing.Any]]] = None,
        vault: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVault", typing.Dict[str, typing.Any]]] = None,
        webhook: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderWebhook", typing.Dict[str, typing.Any]]] = None,
        yandexcertificatemanager: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderYandexcertificatemanager", typing.Dict[str, typing.Any]]] = None,
        yandexlockbox: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderYandexlockbox", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Used to configure the provider.

        Only one provider may be set

        :param akeyless: Akeyless configures this store to sync secrets using Akeyless Vault provider.
        :param alibaba: Alibaba configures this store to sync secrets using Alibaba Cloud provider.
        :param aws: AWS configures this store to sync secrets using AWS Secret Manager provider.
        :param azurekv: AzureKV configures this store to sync secrets using Azure Key Vault provider.
        :param doppler: Doppler configures this store to sync secrets using the Doppler provider.
        :param fake: Fake configures a store with static key/value pairs.
        :param gcpsm: GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.
        :param gitlab: Gitlab configures this store to sync secrets using Gitlab Variables provider.
        :param ibm: IBM configures this store to sync secrets using IBM Cloud provider.
        :param kubernetes: Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.
        :param onepassword: OnePassword configures this store to sync secrets using the 1Password Cloud provider.
        :param oracle: Oracle configures this store to sync secrets using Oracle Vault provider.
        :param senhasegura: Senhasegura configures this store to sync secrets using senhasegura provider.
        :param vault: Vault configures this store to sync secrets using Hashi provider.
        :param webhook: Webhook configures this store to sync secrets using a generic templated webhook.
        :param yandexcertificatemanager: YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider.
        :param yandexlockbox: YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :schema: SecretStoreV1Beta1SpecProvider
        '''
        if isinstance(akeyless, dict):
            akeyless = SecretStoreV1Beta1SpecProviderAkeyless(**akeyless)
        if isinstance(alibaba, dict):
            alibaba = SecretStoreV1Beta1SpecProviderAlibaba(**alibaba)
        if isinstance(aws, dict):
            aws = SecretStoreV1Beta1SpecProviderAws(**aws)
        if isinstance(azurekv, dict):
            azurekv = SecretStoreV1Beta1SpecProviderAzurekv(**azurekv)
        if isinstance(doppler, dict):
            doppler = SecretStoreV1Beta1SpecProviderDoppler(**doppler)
        if isinstance(fake, dict):
            fake = SecretStoreV1Beta1SpecProviderFake(**fake)
        if isinstance(gcpsm, dict):
            gcpsm = SecretStoreV1Beta1SpecProviderGcpsm(**gcpsm)
        if isinstance(gitlab, dict):
            gitlab = SecretStoreV1Beta1SpecProviderGitlab(**gitlab)
        if isinstance(ibm, dict):
            ibm = SecretStoreV1Beta1SpecProviderIbm(**ibm)
        if isinstance(kubernetes, dict):
            kubernetes = SecretStoreV1Beta1SpecProviderKubernetes(**kubernetes)
        if isinstance(onepassword, dict):
            onepassword = SecretStoreV1Beta1SpecProviderOnepassword(**onepassword)
        if isinstance(oracle, dict):
            oracle = SecretStoreV1Beta1SpecProviderOracle(**oracle)
        if isinstance(senhasegura, dict):
            senhasegura = SecretStoreV1Beta1SpecProviderSenhasegura(**senhasegura)
        if isinstance(vault, dict):
            vault = SecretStoreV1Beta1SpecProviderVault(**vault)
        if isinstance(webhook, dict):
            webhook = SecretStoreV1Beta1SpecProviderWebhook(**webhook)
        if isinstance(yandexcertificatemanager, dict):
            yandexcertificatemanager = SecretStoreV1Beta1SpecProviderYandexcertificatemanager(**yandexcertificatemanager)
        if isinstance(yandexlockbox, dict):
            yandexlockbox = SecretStoreV1Beta1SpecProviderYandexlockbox(**yandexlockbox)
        if __debug__:
            def stub(
                *,
                akeyless: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAkeyless, typing.Dict[str, typing.Any]]] = None,
                alibaba: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAlibaba, typing.Dict[str, typing.Any]]] = None,
                aws: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAws, typing.Dict[str, typing.Any]]] = None,
                azurekv: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAzurekv, typing.Dict[str, typing.Any]]] = None,
                doppler: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderDoppler, typing.Dict[str, typing.Any]]] = None,
                fake: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderFake, typing.Dict[str, typing.Any]]] = None,
                gcpsm: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderGcpsm, typing.Dict[str, typing.Any]]] = None,
                gitlab: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderGitlab, typing.Dict[str, typing.Any]]] = None,
                ibm: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderIbm, typing.Dict[str, typing.Any]]] = None,
                kubernetes: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKubernetes, typing.Dict[str, typing.Any]]] = None,
                onepassword: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderOnepassword, typing.Dict[str, typing.Any]]] = None,
                oracle: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderOracle, typing.Dict[str, typing.Any]]] = None,
                senhasegura: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderSenhasegura, typing.Dict[str, typing.Any]]] = None,
                vault: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVault, typing.Dict[str, typing.Any]]] = None,
                webhook: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderWebhook, typing.Dict[str, typing.Any]]] = None,
                yandexcertificatemanager: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderYandexcertificatemanager, typing.Dict[str, typing.Any]]] = None,
                yandexlockbox: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderYandexlockbox, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument akeyless", value=akeyless, expected_type=type_hints["akeyless"])
            check_type(argname="argument alibaba", value=alibaba, expected_type=type_hints["alibaba"])
            check_type(argname="argument aws", value=aws, expected_type=type_hints["aws"])
            check_type(argname="argument azurekv", value=azurekv, expected_type=type_hints["azurekv"])
            check_type(argname="argument doppler", value=doppler, expected_type=type_hints["doppler"])
            check_type(argname="argument fake", value=fake, expected_type=type_hints["fake"])
            check_type(argname="argument gcpsm", value=gcpsm, expected_type=type_hints["gcpsm"])
            check_type(argname="argument gitlab", value=gitlab, expected_type=type_hints["gitlab"])
            check_type(argname="argument ibm", value=ibm, expected_type=type_hints["ibm"])
            check_type(argname="argument kubernetes", value=kubernetes, expected_type=type_hints["kubernetes"])
            check_type(argname="argument onepassword", value=onepassword, expected_type=type_hints["onepassword"])
            check_type(argname="argument oracle", value=oracle, expected_type=type_hints["oracle"])
            check_type(argname="argument senhasegura", value=senhasegura, expected_type=type_hints["senhasegura"])
            check_type(argname="argument vault", value=vault, expected_type=type_hints["vault"])
            check_type(argname="argument webhook", value=webhook, expected_type=type_hints["webhook"])
            check_type(argname="argument yandexcertificatemanager", value=yandexcertificatemanager, expected_type=type_hints["yandexcertificatemanager"])
            check_type(argname="argument yandexlockbox", value=yandexlockbox, expected_type=type_hints["yandexlockbox"])
        self._values: typing.Dict[str, typing.Any] = {}
        if akeyless is not None:
            self._values["akeyless"] = akeyless
        if alibaba is not None:
            self._values["alibaba"] = alibaba
        if aws is not None:
            self._values["aws"] = aws
        if azurekv is not None:
            self._values["azurekv"] = azurekv
        if doppler is not None:
            self._values["doppler"] = doppler
        if fake is not None:
            self._values["fake"] = fake
        if gcpsm is not None:
            self._values["gcpsm"] = gcpsm
        if gitlab is not None:
            self._values["gitlab"] = gitlab
        if ibm is not None:
            self._values["ibm"] = ibm
        if kubernetes is not None:
            self._values["kubernetes"] = kubernetes
        if onepassword is not None:
            self._values["onepassword"] = onepassword
        if oracle is not None:
            self._values["oracle"] = oracle
        if senhasegura is not None:
            self._values["senhasegura"] = senhasegura
        if vault is not None:
            self._values["vault"] = vault
        if webhook is not None:
            self._values["webhook"] = webhook
        if yandexcertificatemanager is not None:
            self._values["yandexcertificatemanager"] = yandexcertificatemanager
        if yandexlockbox is not None:
            self._values["yandexlockbox"] = yandexlockbox

    @builtins.property
    def akeyless(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderAkeyless"]:
        '''Akeyless configures this store to sync secrets using Akeyless Vault provider.

        :schema: SecretStoreV1Beta1SpecProvider#akeyless
        '''
        result = self._values.get("akeyless")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAkeyless"], result)

    @builtins.property
    def alibaba(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderAlibaba"]:
        '''Alibaba configures this store to sync secrets using Alibaba Cloud provider.

        :schema: SecretStoreV1Beta1SpecProvider#alibaba
        '''
        result = self._values.get("alibaba")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAlibaba"], result)

    @builtins.property
    def aws(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderAws"]:
        '''AWS configures this store to sync secrets using AWS Secret Manager provider.

        :schema: SecretStoreV1Beta1SpecProvider#aws
        '''
        result = self._values.get("aws")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAws"], result)

    @builtins.property
    def azurekv(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderAzurekv"]:
        '''AzureKV configures this store to sync secrets using Azure Key Vault provider.

        :schema: SecretStoreV1Beta1SpecProvider#azurekv
        '''
        result = self._values.get("azurekv")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAzurekv"], result)

    @builtins.property
    def doppler(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderDoppler"]:
        '''Doppler configures this store to sync secrets using the Doppler provider.

        :schema: SecretStoreV1Beta1SpecProvider#doppler
        '''
        result = self._values.get("doppler")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderDoppler"], result)

    @builtins.property
    def fake(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderFake"]:
        '''Fake configures a store with static key/value pairs.

        :schema: SecretStoreV1Beta1SpecProvider#fake
        '''
        result = self._values.get("fake")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderFake"], result)

    @builtins.property
    def gcpsm(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderGcpsm"]:
        '''GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.

        :schema: SecretStoreV1Beta1SpecProvider#gcpsm
        '''
        result = self._values.get("gcpsm")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderGcpsm"], result)

    @builtins.property
    def gitlab(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderGitlab"]:
        '''Gitlab configures this store to sync secrets using Gitlab Variables provider.

        :schema: SecretStoreV1Beta1SpecProvider#gitlab
        '''
        result = self._values.get("gitlab")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderGitlab"], result)

    @builtins.property
    def ibm(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderIbm"]:
        '''IBM configures this store to sync secrets using IBM Cloud provider.

        :schema: SecretStoreV1Beta1SpecProvider#ibm
        '''
        result = self._values.get("ibm")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderIbm"], result)

    @builtins.property
    def kubernetes(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderKubernetes"]:
        '''Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.

        :schema: SecretStoreV1Beta1SpecProvider#kubernetes
        '''
        result = self._values.get("kubernetes")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKubernetes"], result)

    @builtins.property
    def onepassword(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderOnepassword"]:
        '''OnePassword configures this store to sync secrets using the 1Password Cloud provider.

        :schema: SecretStoreV1Beta1SpecProvider#onepassword
        '''
        result = self._values.get("onepassword")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderOnepassword"], result)

    @builtins.property
    def oracle(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderOracle"]:
        '''Oracle configures this store to sync secrets using Oracle Vault provider.

        :schema: SecretStoreV1Beta1SpecProvider#oracle
        '''
        result = self._values.get("oracle")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderOracle"], result)

    @builtins.property
    def senhasegura(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderSenhasegura"]:
        '''Senhasegura configures this store to sync secrets using senhasegura provider.

        :schema: SecretStoreV1Beta1SpecProvider#senhasegura
        '''
        result = self._values.get("senhasegura")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderSenhasegura"], result)

    @builtins.property
    def vault(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderVault"]:
        '''Vault configures this store to sync secrets using Hashi provider.

        :schema: SecretStoreV1Beta1SpecProvider#vault
        '''
        result = self._values.get("vault")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVault"], result)

    @builtins.property
    def webhook(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderWebhook"]:
        '''Webhook configures this store to sync secrets using a generic templated webhook.

        :schema: SecretStoreV1Beta1SpecProvider#webhook
        '''
        result = self._values.get("webhook")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderWebhook"], result)

    @builtins.property
    def yandexcertificatemanager(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderYandexcertificatemanager"]:
        '''YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider.

        :schema: SecretStoreV1Beta1SpecProvider#yandexcertificatemanager
        '''
        result = self._values.get("yandexcertificatemanager")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderYandexcertificatemanager"], result)

    @builtins.property
    def yandexlockbox(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderYandexlockbox"]:
        '''YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :schema: SecretStoreV1Beta1SpecProvider#yandexlockbox
        '''
        result = self._values.get("yandexlockbox")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderYandexlockbox"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAkeyless",
    jsii_struct_bases=[],
    name_mapping={
        "akeyless_gw_api_url": "akeylessGwApiUrl",
        "auth_secret_ref": "authSecretRef",
    },
)
class SecretStoreV1Beta1SpecProviderAkeyless:
    def __init__(
        self,
        *,
        akeyless_gw_api_url: builtins.str,
        auth_secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''Akeyless configures this store to sync secrets using Akeyless Vault provider.

        :param akeyless_gw_api_url: Akeyless GW API Url from which the secrets to be fetched from.
        :param auth_secret_ref: Auth configures how the operator authenticates with Akeyless.

        :schema: SecretStoreV1Beta1SpecProviderAkeyless
        '''
        if isinstance(auth_secret_ref, dict):
            auth_secret_ref = SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef(**auth_secret_ref)
        if __debug__:
            def stub(
                *,
                akeyless_gw_api_url: builtins.str,
                auth_secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument akeyless_gw_api_url", value=akeyless_gw_api_url, expected_type=type_hints["akeyless_gw_api_url"])
            check_type(argname="argument auth_secret_ref", value=auth_secret_ref, expected_type=type_hints["auth_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "akeyless_gw_api_url": akeyless_gw_api_url,
            "auth_secret_ref": auth_secret_ref,
        }

    @builtins.property
    def akeyless_gw_api_url(self) -> builtins.str:
        '''Akeyless GW API Url from which the secrets to be fetched from.

        :schema: SecretStoreV1Beta1SpecProviderAkeyless#akeylessGWApiURL
        '''
        result = self._values.get("akeyless_gw_api_url")
        assert result is not None, "Required property 'akeyless_gw_api_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth_secret_ref(self) -> "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef":
        '''Auth configures how the operator authenticates with Akeyless.

        :schema: SecretStoreV1Beta1SpecProviderAkeyless#authSecretRef
        '''
        result = self._values.get("auth_secret_ref")
        assert result is not None, "Required property 'auth_secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAkeyless(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"kubernetes_auth": "kubernetesAuth", "secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef:
    def __init__(
        self,
        *,
        kubernetes_auth: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth", typing.Dict[str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how the operator authenticates with Akeyless.

        :param kubernetes_auth: Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
        :param secret_ref: Reference to a Secret that contains the details to authenticate with Akeyless.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef
        '''
        if isinstance(kubernetes_auth, dict):
            kubernetes_auth = SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth(**kubernetes_auth)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                kubernetes_auth: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth, typing.Dict[str, typing.Any]]] = None,
                secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument kubernetes_auth", value=kubernetes_auth, expected_type=type_hints["kubernetes_auth"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if kubernetes_auth is not None:
            self._values["kubernetes_auth"] = kubernetes_auth
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def kubernetes_auth(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth"]:
        '''Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef#kubernetesAuth
        '''
        result = self._values.get("kubernetes_auth")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef"]:
        '''Reference to a Secret that contains the details to authenticate with Akeyless.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth",
    jsii_struct_bases=[],
    name_mapping={
        "access_id": "accessId",
        "k8_s_conf_name": "k8SConfName",
        "secret_ref": "secretRef",
        "service_account_ref": "serviceAccountRef",
    },
)
class SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth:
    def __init__(
        self,
        *,
        access_id: builtins.str,
        k8_s_conf_name: builtins.str,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef", typing.Dict[str, typing.Any]]] = None,
        service_account_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.

        :param access_id: the Akeyless Kubernetes auth-method access-id.
        :param k8_s_conf_name: Kubernetes-auth configuration name in Akeyless-Gateway.
        :param secret_ref: Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.
        :param service_account_ref: Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(**secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                access_id: builtins.str,
                k8_s_conf_name: builtins.str,
                secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef, typing.Dict[str, typing.Any]]] = None,
                service_account_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument access_id", value=access_id, expected_type=type_hints["access_id"])
            check_type(argname="argument k8_s_conf_name", value=k8_s_conf_name, expected_type=type_hints["k8_s_conf_name"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "access_id": access_id,
            "k8_s_conf_name": k8_s_conf_name,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def access_id(self) -> builtins.str:
        '''the Akeyless Kubernetes auth-method access-id.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#accessID
        '''
        result = self._values.get("access_id")
        assert result is not None, "Required property 'access_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def k8_s_conf_name(self) -> builtins.str:
        '''Kubernetes-auth configuration name in Akeyless-Gateway.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#k8sConfName
        '''
        result = self._values.get("k8_s_conf_name")
        assert result is not None, "Required property 'k8_s_conf_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef"]:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless.

        If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef"]:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless.

        If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_id": "accessId",
        "access_type": "accessType",
        "access_type_param": "accessTypeParam",
    },
)
class SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef:
    def __init__(
        self,
        *,
        access_id: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId", typing.Dict[str, typing.Any]]] = None,
        access_type: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType", typing.Dict[str, typing.Any]]] = None,
        access_type_param: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Reference to a Secret that contains the details to authenticate with Akeyless.

        :param access_id: The SecretAccessID is used for authentication.
        :param access_type: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.
        :param access_type_param: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef
        '''
        if isinstance(access_id, dict):
            access_id = SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId(**access_id)
        if isinstance(access_type, dict):
            access_type = SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType(**access_type)
        if isinstance(access_type_param, dict):
            access_type_param = SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(**access_type_param)
        if __debug__:
            def stub(
                *,
                access_id: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId, typing.Dict[str, typing.Any]]] = None,
                access_type: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType, typing.Dict[str, typing.Any]]] = None,
                access_type_param: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument access_id", value=access_id, expected_type=type_hints["access_id"])
            check_type(argname="argument access_type", value=access_type, expected_type=type_hints["access_type"])
            check_type(argname="argument access_type_param", value=access_type_param, expected_type=type_hints["access_type_param"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_id is not None:
            self._values["access_id"] = access_id
        if access_type is not None:
            self._values["access_type"] = access_type
        if access_type_param is not None:
            self._values["access_type_param"] = access_type_param

    @builtins.property
    def access_id(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId"]:
        '''The SecretAccessID is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessID
        '''
        result = self._values.get("access_id")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId"], result)

    @builtins.property
    def access_type(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessType
        '''
        result = self._values.get("access_type")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType"], result)

    @builtins.property
    def access_type_param(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessTypeParam
        '''
        result = self._values.get("access_type_param")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessID is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAlibaba",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "region_id": "regionId", "endpoint": "endpoint"},
)
class SecretStoreV1Beta1SpecProviderAlibaba:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderAlibabaAuth", typing.Dict[str, typing.Any]],
        region_id: builtins.str,
        endpoint: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Alibaba configures this store to sync secrets using Alibaba Cloud provider.

        :param auth: AlibabaAuth contains a secretRef for credentials.
        :param region_id: Alibaba Region to be used for the provider.
        :param endpoint: 

        :schema: SecretStoreV1Beta1SpecProviderAlibaba
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderAlibabaAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[SecretStoreV1Beta1SpecProviderAlibabaAuth, typing.Dict[str, typing.Any]],
                region_id: builtins.str,
                endpoint: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument region_id", value=region_id, expected_type=type_hints["region_id"])
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
            "region_id": region_id,
        }
        if endpoint is not None:
            self._values["endpoint"] = endpoint

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderAlibabaAuth":
        '''AlibabaAuth contains a secretRef for credentials.

        :schema: SecretStoreV1Beta1SpecProviderAlibaba#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderAlibabaAuth", result)

    @builtins.property
    def region_id(self) -> builtins.str:
        '''Alibaba Region to be used for the provider.

        :schema: SecretStoreV1Beta1SpecProviderAlibaba#regionID
        '''
        result = self._values.get("region_id")
        assert result is not None, "Required property 'region_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def endpoint(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderAlibaba#endpoint
        '''
        result = self._values.get("endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAlibaba(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAlibabaAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderAlibabaAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''AlibabaAuth contains a secretRef for credentials.

        :param secret_ref: AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef":
        '''AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAlibabaAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_key_id_secret_ref": "accessKeyIdSecretRef",
        "access_key_secret_secret_ref": "accessKeySecretSecretRef",
    },
)
class SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef:
    def __init__(
        self,
        *,
        access_key_id_secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef", typing.Dict[str, typing.Any]],
        access_key_secret_secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''AlibabaAuthSecretRef holds secret references for Alibaba credentials.

        :param access_key_id_secret_ref: The AccessKeyID is used for authentication.
        :param access_key_secret_secret_ref: The AccessKeySecret is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef
        '''
        if isinstance(access_key_id_secret_ref, dict):
            access_key_id_secret_ref = SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(**access_key_id_secret_ref)
        if isinstance(access_key_secret_secret_ref, dict):
            access_key_secret_secret_ref = SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(**access_key_secret_secret_ref)
        if __debug__:
            def stub(
                *,
                access_key_id_secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef, typing.Dict[str, typing.Any]],
                access_key_secret_secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument access_key_id_secret_ref", value=access_key_id_secret_ref, expected_type=type_hints["access_key_id_secret_ref"])
            check_type(argname="argument access_key_secret_secret_ref", value=access_key_secret_secret_ref, expected_type=type_hints["access_key_secret_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "access_key_id_secret_ref": access_key_id_secret_ref,
            "access_key_secret_secret_ref": access_key_secret_secret_ref,
        }

    @builtins.property
    def access_key_id_secret_ref(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef":
        '''The AccessKeyID is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef#accessKeyIDSecretRef
        '''
        result = self._values.get("access_key_id_secret_ref")
        assert result is not None, "Required property 'access_key_id_secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef", result)

    @builtins.property
    def access_key_secret_secret_ref(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef":
        '''The AccessKeySecret is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef#accessKeySecretSecretRef
        '''
        result = self._values.get("access_key_secret_secret_ref")
        assert result is not None, "Required property 'access_key_secret_secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeyID is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeySecret is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAws",
    jsii_struct_bases=[],
    name_mapping={
        "region": "region",
        "service": "service",
        "auth": "auth",
        "role": "role",
    },
)
class SecretStoreV1Beta1SpecProviderAws:
    def __init__(
        self,
        *,
        region: builtins.str,
        service: "SecretStoreV1Beta1SpecProviderAwsService",
        auth: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAwsAuth", typing.Dict[str, typing.Any]]] = None,
        role: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AWS configures this store to sync secrets using AWS Secret Manager provider.

        :param region: AWS Region to be used for the provider.
        :param service: Service defines which service should be used to fetch the secrets.
        :param auth: Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.
        :param role: Role is a Role ARN which the SecretManager provider will assume.

        :schema: SecretStoreV1Beta1SpecProviderAws
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderAwsAuth(**auth)
        if __debug__:
            def stub(
                *,
                region: builtins.str,
                service: SecretStoreV1Beta1SpecProviderAwsService,
                auth: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAwsAuth, typing.Dict[str, typing.Any]]] = None,
                role: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
        self._values: typing.Dict[str, typing.Any] = {
            "region": region,
            "service": service,
        }
        if auth is not None:
            self._values["auth"] = auth
        if role is not None:
            self._values["role"] = role

    @builtins.property
    def region(self) -> builtins.str:
        '''AWS Region to be used for the provider.

        :schema: SecretStoreV1Beta1SpecProviderAws#region
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service(self) -> "SecretStoreV1Beta1SpecProviderAwsService":
        '''Service defines which service should be used to fetch the secrets.

        :schema: SecretStoreV1Beta1SpecProviderAws#service
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderAwsService", result)

    @builtins.property
    def auth(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuth"]:
        '''Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.

        :schema: SecretStoreV1Beta1SpecProviderAws#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuth"], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a Role ARN which the SecretManager provider will assume.

        :schema: SecretStoreV1Beta1SpecProviderAws#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAws(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAwsAuth",
    jsii_struct_bases=[],
    name_mapping={"jwt": "jwt", "secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderAwsAuth:
    def __init__(
        self,
        *,
        jwt: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAwsAuthJwt", typing.Dict[str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAwsAuthSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials.

        :param jwt: Authenticate against AWS using service account tokens.
        :param secret_ref: AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuth
        '''
        if isinstance(jwt, dict):
            jwt = SecretStoreV1Beta1SpecProviderAwsAuthJwt(**jwt)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderAwsAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                jwt: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAwsAuthJwt, typing.Dict[str, typing.Any]]] = None,
                secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAwsAuthSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument jwt", value=jwt, expected_type=type_hints["jwt"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if jwt is not None:
            self._values["jwt"] = jwt
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def jwt(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthJwt"]:
        '''Authenticate against AWS using service account tokens.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuth#jwt
        '''
        result = self._values.get("jwt")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthJwt"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthSecretRef"]:
        '''AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAwsAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAwsAuthJwt",
    jsii_struct_bases=[],
    name_mapping={"service_account_ref": "serviceAccountRef"},
)
class SecretStoreV1Beta1SpecProviderAwsAuthJwt:
    def __init__(
        self,
        *,
        service_account_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Authenticate against AWS using service account tokens.

        :param service_account_ref: A reference to a ServiceAccount resource.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthJwt
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                service_account_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef"]:
        '''A reference to a ServiceAccount resource.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthJwt#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAwsAuthJwt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAwsAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={
        "access_key_id_secret_ref": "accessKeyIdSecretRef",
        "secret_access_key_secret_ref": "secretAccessKeySecretRef",
    },
)
class SecretStoreV1Beta1SpecProviderAwsAuthSecretRef:
    def __init__(
        self,
        *,
        access_key_id_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef", typing.Dict[str, typing.Any]]] = None,
        secret_access_key_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.

        :param access_key_id_secret_ref: The AccessKeyID is used for authentication.
        :param secret_access_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRef
        '''
        if isinstance(access_key_id_secret_ref, dict):
            access_key_id_secret_ref = SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(**access_key_id_secret_ref)
        if isinstance(secret_access_key_secret_ref, dict):
            secret_access_key_secret_ref = SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(**secret_access_key_secret_ref)
        if __debug__:
            def stub(
                *,
                access_key_id_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef, typing.Dict[str, typing.Any]]] = None,
                secret_access_key_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument access_key_id_secret_ref", value=access_key_id_secret_ref, expected_type=type_hints["access_key_id_secret_ref"])
            check_type(argname="argument secret_access_key_secret_ref", value=secret_access_key_secret_ref, expected_type=type_hints["secret_access_key_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_key_id_secret_ref is not None:
            self._values["access_key_id_secret_ref"] = access_key_id_secret_ref
        if secret_access_key_secret_ref is not None:
            self._values["secret_access_key_secret_ref"] = secret_access_key_secret_ref

    @builtins.property
    def access_key_id_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef"]:
        '''The AccessKeyID is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRef#accessKeyIDSecretRef
        '''
        result = self._values.get("access_key_id_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef"], result)

    @builtins.property
    def secret_access_key_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRef#secretAccessKeySecretRef
        '''
        result = self._values.get("secret_access_key_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAwsAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The AccessKeyID is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAwsService")
class SecretStoreV1Beta1SpecProviderAwsService(enum.Enum):
    '''Service defines which service should be used to fetch the secrets.

    :schema: SecretStoreV1Beta1SpecProviderAwsService
    '''

    SECRETS_MANAGER = "SECRETS_MANAGER"
    '''SecretsManager.'''
    PARAMETER_STORE = "PARAMETER_STORE"
    '''ParameterStore.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAzurekv",
    jsii_struct_bases=[],
    name_mapping={
        "vault_url": "vaultUrl",
        "auth_secret_ref": "authSecretRef",
        "auth_type": "authType",
        "environment_type": "environmentType",
        "identity_id": "identityId",
        "service_account_ref": "serviceAccountRef",
        "tenant_id": "tenantId",
    },
)
class SecretStoreV1Beta1SpecProviderAzurekv:
    def __init__(
        self,
        *,
        vault_url: builtins.str,
        auth_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef", typing.Dict[str, typing.Any]]] = None,
        auth_type: typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthType"] = None,
        environment_type: typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType"] = None,
        identity_id: typing.Optional[builtins.str] = None,
        service_account_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef", typing.Dict[str, typing.Any]]] = None,
        tenant_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AzureKV configures this store to sync secrets using Azure Key Vault provider.

        :param vault_url: Vault Url from which the secrets to be fetched from.
        :param auth_secret_ref: Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type.
        :param auth_type: Auth type defines how to authenticate to the keyvault service. Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
        :param environment_type: EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint. The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152 PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
        :param identity_id: If multiple Managed Identity is assigned to the pod, you can select the one to be used.
        :param service_account_ref: ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
        :param tenant_id: TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type.

        :schema: SecretStoreV1Beta1SpecProviderAzurekv
        '''
        if isinstance(auth_secret_ref, dict):
            auth_secret_ref = SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef(**auth_secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                vault_url: builtins.str,
                auth_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef, typing.Dict[str, typing.Any]]] = None,
                auth_type: typing.Optional[SecretStoreV1Beta1SpecProviderAzurekvAuthType] = None,
                environment_type: typing.Optional[SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType] = None,
                identity_id: typing.Optional[builtins.str] = None,
                service_account_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef, typing.Dict[str, typing.Any]]] = None,
                tenant_id: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument vault_url", value=vault_url, expected_type=type_hints["vault_url"])
            check_type(argname="argument auth_secret_ref", value=auth_secret_ref, expected_type=type_hints["auth_secret_ref"])
            check_type(argname="argument auth_type", value=auth_type, expected_type=type_hints["auth_type"])
            check_type(argname="argument environment_type", value=environment_type, expected_type=type_hints["environment_type"])
            check_type(argname="argument identity_id", value=identity_id, expected_type=type_hints["identity_id"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument tenant_id", value=tenant_id, expected_type=type_hints["tenant_id"])
        self._values: typing.Dict[str, typing.Any] = {
            "vault_url": vault_url,
        }
        if auth_secret_ref is not None:
            self._values["auth_secret_ref"] = auth_secret_ref
        if auth_type is not None:
            self._values["auth_type"] = auth_type
        if environment_type is not None:
            self._values["environment_type"] = environment_type
        if identity_id is not None:
            self._values["identity_id"] = identity_id
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref
        if tenant_id is not None:
            self._values["tenant_id"] = tenant_id

    @builtins.property
    def vault_url(self) -> builtins.str:
        '''Vault Url from which the secrets to be fetched from.

        :schema: SecretStoreV1Beta1SpecProviderAzurekv#vaultUrl
        '''
        result = self._values.get("vault_url")
        assert result is not None, "Required property 'vault_url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef"]:
        '''Auth configures how the operator authenticates with Azure.

        Required for ServicePrincipal auth type.

        :schema: SecretStoreV1Beta1SpecProviderAzurekv#authSecretRef
        '''
        result = self._values.get("auth_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef"], result)

    @builtins.property
    def auth_type(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthType"]:
        '''Auth type defines how to authenticate to the keyvault service.

        Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)

        :schema: SecretStoreV1Beta1SpecProviderAzurekv#authType
        '''
        result = self._values.get("auth_type")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthType"], result)

    @builtins.property
    def environment_type(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType"]:
        '''EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure.

        By default it points to the public cloud AAD endpoint. The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152 PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud

        :schema: SecretStoreV1Beta1SpecProviderAzurekv#environmentType
        '''
        result = self._values.get("environment_type")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType"], result)

    @builtins.property
    def identity_id(self) -> typing.Optional[builtins.str]:
        '''If multiple Managed Identity is assigned to the pod, you can select the one to be used.

        :schema: SecretStoreV1Beta1SpecProviderAzurekv#identityId
        '''
        result = self._values.get("identity_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef"]:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :schema: SecretStoreV1Beta1SpecProviderAzurekv#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef"], result)

    @builtins.property
    def tenant_id(self) -> typing.Optional[builtins.str]:
        '''TenantID configures the Azure Tenant to send requests to.

        Required for ServicePrincipal auth type.

        :schema: SecretStoreV1Beta1SpecProviderAzurekv#tenantId
        '''
        result = self._values.get("tenant_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAzurekv(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"client_id": "clientId", "client_secret": "clientSecret"},
)
class SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef:
    def __init__(
        self,
        *,
        client_id: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId", typing.Dict[str, typing.Any]]] = None,
        client_secret: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how the operator authenticates with Azure.

        Required for ServicePrincipal auth type.

        :param client_id: The Azure clientId of the service principle used for authentication.
        :param client_secret: The Azure ClientSecret of the service principle used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef
        '''
        if isinstance(client_id, dict):
            client_id = SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId(**client_id)
        if isinstance(client_secret, dict):
            client_secret = SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret(**client_secret)
        if __debug__:
            def stub(
                *,
                client_id: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId, typing.Dict[str, typing.Any]]] = None,
                client_secret: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret", value=client_secret, expected_type=type_hints["client_secret"])
        self._values: typing.Dict[str, typing.Any] = {}
        if client_id is not None:
            self._values["client_id"] = client_id
        if client_secret is not None:
            self._values["client_secret"] = client_secret

    @builtins.property
    def client_id(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId"]:
        '''The Azure clientId of the service principle used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientId
        '''
        result = self._values.get("client_id")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId"], result)

    @builtins.property
    def client_secret(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret"]:
        '''The Azure ClientSecret of the service principle used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientSecret
        '''
        result = self._values.get("client_secret")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Azure clientId of the service principle used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The Azure ClientSecret of the service principle used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAzurekvAuthType"
)
class SecretStoreV1Beta1SpecProviderAzurekvAuthType(enum.Enum):
    '''Auth type defines how to authenticate to the keyvault service.

    Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)

    :schema: SecretStoreV1Beta1SpecProviderAzurekvAuthType
    '''

    SERVICE_PRINCIPAL = "SERVICE_PRINCIPAL"
    '''ServicePrincipal.'''
    MANAGED_IDENTITY = "MANAGED_IDENTITY"
    '''ManagedIdentity.'''
    WORKLOAD_IDENTITY = "WORKLOAD_IDENTITY"
    '''WorkloadIdentity.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType"
)
class SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType(enum.Enum):
    '''EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure.

    By default it points to the public cloud AAD endpoint. The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152 PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud

    :schema: SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType
    '''

    PUBLIC_CLOUD = "PUBLIC_CLOUD"
    '''PublicCloud.'''
    US_GOVERNMENT_CLOUD = "US_GOVERNMENT_CLOUD"
    '''USGovernmentCloud.'''
    CHINA_CLOUD = "CHINA_CLOUD"
    '''ChinaCloud.'''
    GERMAN_CLOUD = "GERMAN_CLOUD"
    '''GermanCloud.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDoppler",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "config": "config",
        "format": "format",
        "name_transformer": "nameTransformer",
        "project": "project",
    },
)
class SecretStoreV1Beta1SpecProviderDoppler:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderDopplerAuth", typing.Dict[str, typing.Any]],
        config: typing.Optional[builtins.str] = None,
        format: typing.Optional["SecretStoreV1Beta1SpecProviderDopplerFormat"] = None,
        name_transformer: typing.Optional["SecretStoreV1Beta1SpecProviderDopplerNameTransformer"] = None,
        project: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Doppler configures this store to sync secrets using the Doppler provider.

        :param auth: Auth configures how the Operator authenticates with the Doppler API.
        :param config: Doppler config (required if not using a Service Token).
        :param format: Format enables the downloading of secrets as a file (string).
        :param name_transformer: Environment variable compatible name transforms that change secret names to a different format.
        :param project: Doppler project (required if not using a Service Token).

        :schema: SecretStoreV1Beta1SpecProviderDoppler
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderDopplerAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[SecretStoreV1Beta1SpecProviderDopplerAuth, typing.Dict[str, typing.Any]],
                config: typing.Optional[builtins.str] = None,
                format: typing.Optional[SecretStoreV1Beta1SpecProviderDopplerFormat] = None,
                name_transformer: typing.Optional[SecretStoreV1Beta1SpecProviderDopplerNameTransformer] = None,
                project: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument config", value=config, expected_type=type_hints["config"])
            check_type(argname="argument format", value=format, expected_type=type_hints["format"])
            check_type(argname="argument name_transformer", value=name_transformer, expected_type=type_hints["name_transformer"])
            check_type(argname="argument project", value=project, expected_type=type_hints["project"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
        }
        if config is not None:
            self._values["config"] = config
        if format is not None:
            self._values["format"] = format
        if name_transformer is not None:
            self._values["name_transformer"] = name_transformer
        if project is not None:
            self._values["project"] = project

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderDopplerAuth":
        '''Auth configures how the Operator authenticates with the Doppler API.

        :schema: SecretStoreV1Beta1SpecProviderDoppler#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderDopplerAuth", result)

    @builtins.property
    def config(self) -> typing.Optional[builtins.str]:
        '''Doppler config (required if not using a Service Token).

        :schema: SecretStoreV1Beta1SpecProviderDoppler#config
        '''
        result = self._values.get("config")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def format(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderDopplerFormat"]:
        '''Format enables the downloading of secrets as a file (string).

        :schema: SecretStoreV1Beta1SpecProviderDoppler#format
        '''
        result = self._values.get("format")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderDopplerFormat"], result)

    @builtins.property
    def name_transformer(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderDopplerNameTransformer"]:
        '''Environment variable compatible name transforms that change secret names to a different format.

        :schema: SecretStoreV1Beta1SpecProviderDoppler#nameTransformer
        '''
        result = self._values.get("name_transformer")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderDopplerNameTransformer"], result)

    @builtins.property
    def project(self) -> typing.Optional[builtins.str]:
        '''Doppler project (required if not using a Service Token).

        :schema: SecretStoreV1Beta1SpecProviderDoppler#project
        '''
        result = self._values.get("project")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderDoppler(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDopplerAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderDopplerAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''Auth configures how the Operator authenticates with the Doppler API.

        :param secret_ref: 

        :schema: SecretStoreV1Beta1SpecProviderDopplerAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef":
        '''
        :schema: SecretStoreV1Beta1SpecProviderDopplerAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderDopplerAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"doppler_token": "dopplerToken"},
)
class SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef:
    def __init__(
        self,
        *,
        doppler_token: typing.Union["SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken", typing.Dict[str, typing.Any]],
    ) -> None:
        '''
        :param doppler_token: The DopplerToken is used for authentication. See https://docs.doppler.com/reference/api#authentication for auth token types. The Key attribute defaults to dopplerToken if not specified.

        :schema: SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef
        '''
        if isinstance(doppler_token, dict):
            doppler_token = SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken(**doppler_token)
        if __debug__:
            def stub(
                *,
                doppler_token: typing.Union[SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument doppler_token", value=doppler_token, expected_type=type_hints["doppler_token"])
        self._values: typing.Dict[str, typing.Any] = {
            "doppler_token": doppler_token,
        }

    @builtins.property
    def doppler_token(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken":
        '''The DopplerToken is used for authentication.

        See https://docs.doppler.com/reference/api#authentication for auth token types. The Key attribute defaults to dopplerToken if not specified.

        :schema: SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef#dopplerToken
        '''
        result = self._values.get("doppler_token")
        assert result is not None, "Required property 'doppler_token' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The DopplerToken is used for authentication.

        See https://docs.doppler.com/reference/api#authentication for auth token types. The Key attribute defaults to dopplerToken if not specified.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDopplerFormat")
class SecretStoreV1Beta1SpecProviderDopplerFormat(enum.Enum):
    '''Format enables the downloading of secrets as a file (string).

    :schema: SecretStoreV1Beta1SpecProviderDopplerFormat
    '''

    JSON = "JSON"
    '''json.'''
    DOTNET_JSON = "DOTNET_JSON"
    '''dotnet-json.'''
    ENV = "ENV"
    '''env.'''
    YAML = "YAML"
    '''yaml.'''
    DOCKER = "DOCKER"
    '''docker.'''


@jsii.enum(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderDopplerNameTransformer"
)
class SecretStoreV1Beta1SpecProviderDopplerNameTransformer(enum.Enum):
    '''Environment variable compatible name transforms that change secret names to a different format.

    :schema: SecretStoreV1Beta1SpecProviderDopplerNameTransformer
    '''

    UPPER_CAMEL = "UPPER_CAMEL"
    '''upper-camel.'''
    CAMEL = "CAMEL"
    '''camel.'''
    LOWER_SNAKE = "LOWER_SNAKE"
    '''lower-snake.'''
    TF_VAR = "TF_VAR"
    '''tf-var.'''
    DOTNET_ENV = "DOTNET_ENV"
    '''dotnet-env.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderFake",
    jsii_struct_bases=[],
    name_mapping={"data": "data"},
)
class SecretStoreV1Beta1SpecProviderFake:
    def __init__(
        self,
        *,
        data: typing.Sequence[typing.Union["SecretStoreV1Beta1SpecProviderFakeData", typing.Dict[str, typing.Any]]],
    ) -> None:
        '''Fake configures a store with static key/value pairs.

        :param data: 

        :schema: SecretStoreV1Beta1SpecProviderFake
        '''
        if __debug__:
            def stub(
                *,
                data: typing.Sequence[typing.Union[SecretStoreV1Beta1SpecProviderFakeData, typing.Dict[str, typing.Any]]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
        self._values: typing.Dict[str, typing.Any] = {
            "data": data,
        }

    @builtins.property
    def data(self) -> typing.List["SecretStoreV1Beta1SpecProviderFakeData"]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderFake#data
        '''
        result = self._values.get("data")
        assert result is not None, "Required property 'data' is missing"
        return typing.cast(typing.List["SecretStoreV1Beta1SpecProviderFakeData"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderFake(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderFakeData",
    jsii_struct_bases=[],
    name_mapping={
        "key": "key",
        "value": "value",
        "value_map": "valueMap",
        "version": "version",
    },
)
class SecretStoreV1Beta1SpecProviderFakeData:
    def __init__(
        self,
        *,
        key: builtins.str,
        value: typing.Optional[builtins.str] = None,
        value_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param key: 
        :param value: 
        :param value_map: 
        :param version: 

        :schema: SecretStoreV1Beta1SpecProviderFakeData
        '''
        if __debug__:
            def stub(
                *,
                key: builtins.str,
                value: typing.Optional[builtins.str] = None,
                value_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
                version: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
            check_type(argname="argument value_map", value=value_map, expected_type=type_hints["value_map"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[str, typing.Any] = {
            "key": key,
        }
        if value is not None:
            self._values["value"] = value
        if value_map is not None:
            self._values["value_map"] = value_map
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def key(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderFakeData#key
        '''
        result = self._values.get("key")
        assert result is not None, "Required property 'key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def value(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderFakeData#value
        '''
        result = self._values.get("value")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def value_map(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderFakeData#valueMap
        '''
        result = self._values.get("value_map")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def version(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderFakeData#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderFakeData(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderGcpsm",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "project_id": "projectId"},
)
class SecretStoreV1Beta1SpecProviderGcpsm:
    def __init__(
        self,
        *,
        auth: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderGcpsmAuth", typing.Dict[str, typing.Any]]] = None,
        project_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider.

        :param auth: Auth defines the information necessary to authenticate against GCP.
        :param project_id: ProjectID project where secret is located.

        :schema: SecretStoreV1Beta1SpecProviderGcpsm
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderGcpsmAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderGcpsmAuth, typing.Dict[str, typing.Any]]] = None,
                project_id: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
        self._values: typing.Dict[str, typing.Any] = {}
        if auth is not None:
            self._values["auth"] = auth
        if project_id is not None:
            self._values["project_id"] = project_id

    @builtins.property
    def auth(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderGcpsmAuth"]:
        '''Auth defines the information necessary to authenticate against GCP.

        :schema: SecretStoreV1Beta1SpecProviderGcpsm#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderGcpsmAuth"], result)

    @builtins.property
    def project_id(self) -> typing.Optional[builtins.str]:
        '''ProjectID project where secret is located.

        :schema: SecretStoreV1Beta1SpecProviderGcpsm#projectID
        '''
        result = self._values.get("project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderGcpsm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderGcpsmAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "workload_identity": "workloadIdentity"},
)
class SecretStoreV1Beta1SpecProviderGcpsmAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef", typing.Dict[str, typing.Any]]] = None,
        workload_identity: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against GCP.

        :param secret_ref: 
        :param workload_identity: 

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef(**secret_ref)
        if isinstance(workload_identity, dict):
            workload_identity = SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity(**workload_identity)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef, typing.Dict[str, typing.Any]]] = None,
                workload_identity: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument workload_identity", value=workload_identity, expected_type=type_hints["workload_identity"])
        self._values: typing.Dict[str, typing.Any] = {}
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if workload_identity is not None:
            self._values["workload_identity"] = workload_identity

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef"]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef"], result)

    @builtins.property
    def workload_identity(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity"]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuth#workloadIdentity
        '''
        result = self._values.get("workload_identity")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderGcpsmAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"secret_access_key_secret_ref": "secretAccessKeySecretRef"},
)
class SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef:
    def __init__(
        self,
        *,
        secret_access_key_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param secret_access_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef
        '''
        if isinstance(secret_access_key_secret_ref, dict):
            secret_access_key_secret_ref = SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(**secret_access_key_secret_ref)
        if __debug__:
            def stub(
                *,
                secret_access_key_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_access_key_secret_ref", value=secret_access_key_secret_ref, expected_type=type_hints["secret_access_key_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if secret_access_key_secret_ref is not None:
            self._values["secret_access_key_secret_ref"] = secret_access_key_secret_ref

    @builtins.property
    def secret_access_key_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef#secretAccessKeySecretRef
        '''
        result = self._values.get("secret_access_key_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity",
    jsii_struct_bases=[],
    name_mapping={
        "cluster_location": "clusterLocation",
        "cluster_name": "clusterName",
        "service_account_ref": "serviceAccountRef",
        "cluster_project_id": "clusterProjectId",
    },
)
class SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity:
    def __init__(
        self,
        *,
        cluster_location: builtins.str,
        cluster_name: builtins.str,
        service_account_ref: typing.Union["SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef", typing.Dict[str, typing.Any]],
        cluster_project_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param cluster_location: 
        :param cluster_name: 
        :param service_account_ref: A reference to a ServiceAccount resource.
        :param cluster_project_id: 

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                cluster_location: builtins.str,
                cluster_name: builtins.str,
                service_account_ref: typing.Union[SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef, typing.Dict[str, typing.Any]],
                cluster_project_id: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument cluster_location", value=cluster_location, expected_type=type_hints["cluster_location"])
            check_type(argname="argument cluster_name", value=cluster_name, expected_type=type_hints["cluster_name"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument cluster_project_id", value=cluster_project_id, expected_type=type_hints["cluster_project_id"])
        self._values: typing.Dict[str, typing.Any] = {
            "cluster_location": cluster_location,
            "cluster_name": cluster_name,
            "service_account_ref": service_account_ref,
        }
        if cluster_project_id is not None:
            self._values["cluster_project_id"] = cluster_project_id

    @builtins.property
    def cluster_location(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterLocation
        '''
        result = self._values.get("cluster_location")
        assert result is not None, "Required property 'cluster_location' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cluster_name(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterName
        '''
        result = self._values.get("cluster_name")
        assert result is not None, "Required property 'cluster_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef":
        '''A reference to a ServiceAccount resource.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        assert result is not None, "Required property 'service_account_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef", result)

    @builtins.property
    def cluster_project_id(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterProjectID
        '''
        result = self._values.get("cluster_project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a ServiceAccount resource.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderGitlab",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "environment": "environment",
        "project_id": "projectId",
        "url": "url",
    },
)
class SecretStoreV1Beta1SpecProviderGitlab:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderGitlabAuth", typing.Dict[str, typing.Any]],
        environment: typing.Optional[builtins.str] = None,
        project_id: typing.Optional[builtins.str] = None,
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Gitlab configures this store to sync secrets using Gitlab Variables provider.

        :param auth: Auth configures how secret-manager authenticates with a GitLab instance.
        :param environment: Environment environment_scope of gitlab CI/CD variables (Please see https://docs.gitlab.com/ee/ci/environments/#create-a-static-environment on how to create environments).
        :param project_id: ProjectID specifies a project where secrets are located.
        :param url: URL configures the GitLab instance URL. Defaults to https://gitlab.com/. Default: https://gitlab.com/.

        :schema: SecretStoreV1Beta1SpecProviderGitlab
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderGitlabAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[SecretStoreV1Beta1SpecProviderGitlabAuth, typing.Dict[str, typing.Any]],
                environment: typing.Optional[builtins.str] = None,
                project_id: typing.Optional[builtins.str] = None,
                url: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
            check_type(argname="argument project_id", value=project_id, expected_type=type_hints["project_id"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
        }
        if environment is not None:
            self._values["environment"] = environment
        if project_id is not None:
            self._values["project_id"] = project_id
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderGitlabAuth":
        '''Auth configures how secret-manager authenticates with a GitLab instance.

        :schema: SecretStoreV1Beta1SpecProviderGitlab#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderGitlabAuth", result)

    @builtins.property
    def environment(self) -> typing.Optional[builtins.str]:
        '''Environment environment_scope of gitlab CI/CD variables (Please see https://docs.gitlab.com/ee/ci/environments/#create-a-static-environment on how to create environments).

        :schema: SecretStoreV1Beta1SpecProviderGitlab#environment
        '''
        result = self._values.get("environment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def project_id(self) -> typing.Optional[builtins.str]:
        '''ProjectID specifies a project where secrets are located.

        :schema: SecretStoreV1Beta1SpecProviderGitlab#projectID
        '''
        result = self._values.get("project_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''URL configures the GitLab instance URL.

        Defaults to https://gitlab.com/.

        :default: https://gitlab.com/.

        :schema: SecretStoreV1Beta1SpecProviderGitlab#url
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderGitlab(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderGitlabAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderGitlabAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''Auth configures how secret-manager authenticates with a GitLab instance.

        :param secret_ref: 

        :schema: SecretStoreV1Beta1SpecProviderGitlabAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef":
        '''
        :schema: SecretStoreV1Beta1SpecProviderGitlabAuth#SecretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderGitlabAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"access_token": "accessToken"},
)
class SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef:
    def __init__(
        self,
        *,
        access_token: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param access_token: AccessToken is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef
        '''
        if isinstance(access_token, dict):
            access_token = SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken(**access_token)
        if __debug__:
            def stub(
                *,
                access_token: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument access_token", value=access_token, expected_type=type_hints["access_token"])
        self._values: typing.Dict[str, typing.Any] = {}
        if access_token is not None:
            self._values["access_token"] = access_token

    @builtins.property
    def access_token(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken"]:
        '''AccessToken is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef#accessToken
        '''
        result = self._values.get("access_token")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''AccessToken is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderIbm",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "service_url": "serviceUrl"},
)
class SecretStoreV1Beta1SpecProviderIbm:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderIbmAuth", typing.Dict[str, typing.Any]],
        service_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''IBM configures this store to sync secrets using IBM Cloud provider.

        :param auth: Auth configures how secret-manager authenticates with the IBM secrets manager.
        :param service_url: ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance.

        :schema: SecretStoreV1Beta1SpecProviderIbm
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderIbmAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[SecretStoreV1Beta1SpecProviderIbmAuth, typing.Dict[str, typing.Any]],
                service_url: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument service_url", value=service_url, expected_type=type_hints["service_url"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
        }
        if service_url is not None:
            self._values["service_url"] = service_url

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderIbmAuth":
        '''Auth configures how secret-manager authenticates with the IBM secrets manager.

        :schema: SecretStoreV1Beta1SpecProviderIbm#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderIbmAuth", result)

    @builtins.property
    def service_url(self) -> typing.Optional[builtins.str]:
        '''ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance.

        :schema: SecretStoreV1Beta1SpecProviderIbm#serviceUrl
        '''
        result = self._values.get("service_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderIbm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderIbmAuth",
    jsii_struct_bases=[],
    name_mapping={"container_auth": "containerAuth", "secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderIbmAuth:
    def __init__(
        self,
        *,
        container_auth: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth", typing.Dict[str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderIbmAuthSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how secret-manager authenticates with the IBM secrets manager.

        :param container_auth: IBM Container-based auth with IAM Trusted Profile.
        :param secret_ref: 

        :schema: SecretStoreV1Beta1SpecProviderIbmAuth
        '''
        if isinstance(container_auth, dict):
            container_auth = SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth(**container_auth)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderIbmAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                container_auth: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth, typing.Dict[str, typing.Any]]] = None,
                secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderIbmAuthSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument container_auth", value=container_auth, expected_type=type_hints["container_auth"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if container_auth is not None:
            self._values["container_auth"] = container_auth
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def container_auth(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth"]:
        '''IBM Container-based auth with IAM Trusted Profile.

        :schema: SecretStoreV1Beta1SpecProviderIbmAuth#containerAuth
        '''
        result = self._values.get("container_auth")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderIbmAuthSecretRef"]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderIbmAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderIbmAuthSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderIbmAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth",
    jsii_struct_bases=[],
    name_mapping={
        "profile": "profile",
        "iam_endpoint": "iamEndpoint",
        "token_location": "tokenLocation",
    },
)
class SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth:
    def __init__(
        self,
        *,
        profile: builtins.str,
        iam_endpoint: typing.Optional[builtins.str] = None,
        token_location: typing.Optional[builtins.str] = None,
    ) -> None:
        '''IBM Container-based auth with IAM Trusted Profile.

        :param profile: the IBM Trusted Profile.
        :param iam_endpoint: 
        :param token_location: Location the token is mounted on the pod.

        :schema: SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth
        '''
        if __debug__:
            def stub(
                *,
                profile: builtins.str,
                iam_endpoint: typing.Optional[builtins.str] = None,
                token_location: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument profile", value=profile, expected_type=type_hints["profile"])
            check_type(argname="argument iam_endpoint", value=iam_endpoint, expected_type=type_hints["iam_endpoint"])
            check_type(argname="argument token_location", value=token_location, expected_type=type_hints["token_location"])
        self._values: typing.Dict[str, typing.Any] = {
            "profile": profile,
        }
        if iam_endpoint is not None:
            self._values["iam_endpoint"] = iam_endpoint
        if token_location is not None:
            self._values["token_location"] = token_location

    @builtins.property
    def profile(self) -> builtins.str:
        '''the IBM Trusted Profile.

        :schema: SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#profile
        '''
        result = self._values.get("profile")
        assert result is not None, "Required property 'profile' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def iam_endpoint(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#iamEndpoint
        '''
        result = self._values.get("iam_endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def token_location(self) -> typing.Optional[builtins.str]:
        '''Location the token is mounted on the pod.

        :schema: SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#tokenLocation
        '''
        result = self._values.get("token_location")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderIbmAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"secret_api_key_secret_ref": "secretApiKeySecretRef"},
)
class SecretStoreV1Beta1SpecProviderIbmAuthSecretRef:
    def __init__(
        self,
        *,
        secret_api_key_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param secret_api_key_secret_ref: The SecretAccessKey is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderIbmAuthSecretRef
        '''
        if isinstance(secret_api_key_secret_ref, dict):
            secret_api_key_secret_ref = SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef(**secret_api_key_secret_ref)
        if __debug__:
            def stub(
                *,
                secret_api_key_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_api_key_secret_ref", value=secret_api_key_secret_ref, expected_type=type_hints["secret_api_key_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if secret_api_key_secret_ref is not None:
            self._values["secret_api_key_secret_ref"] = secret_api_key_secret_ref

    @builtins.property
    def secret_api_key_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef"]:
        '''The SecretAccessKey is used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderIbmAuthSecretRef#secretApiKeySecretRef
        '''
        result = self._values.get("secret_api_key_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderIbmAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The SecretAccessKey is used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetes",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "remote_namespace": "remoteNamespace",
        "server": "server",
    },
)
class SecretStoreV1Beta1SpecProviderKubernetes:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderKubernetesAuth", typing.Dict[str, typing.Any]],
        remote_namespace: typing.Optional[builtins.str] = None,
        server: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKubernetesServer", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes configures this store to sync secrets using a Kubernetes cluster provider.

        :param auth: Auth configures how secret-manager authenticates with a Kubernetes instance.
        :param remote_namespace: Remote namespace to fetch the secrets from.
        :param server: configures the Kubernetes server Address.

        :schema: SecretStoreV1Beta1SpecProviderKubernetes
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderKubernetesAuth(**auth)
        if isinstance(server, dict):
            server = SecretStoreV1Beta1SpecProviderKubernetesServer(**server)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[SecretStoreV1Beta1SpecProviderKubernetesAuth, typing.Dict[str, typing.Any]],
                remote_namespace: typing.Optional[builtins.str] = None,
                server: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKubernetesServer, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument remote_namespace", value=remote_namespace, expected_type=type_hints["remote_namespace"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
        }
        if remote_namespace is not None:
            self._values["remote_namespace"] = remote_namespace
        if server is not None:
            self._values["server"] = server

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderKubernetesAuth":
        '''Auth configures how secret-manager authenticates with a Kubernetes instance.

        :schema: SecretStoreV1Beta1SpecProviderKubernetes#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderKubernetesAuth", result)

    @builtins.property
    def remote_namespace(self) -> typing.Optional[builtins.str]:
        '''Remote namespace to fetch the secrets from.

        :schema: SecretStoreV1Beta1SpecProviderKubernetes#remoteNamespace
        '''
        result = self._values.get("remote_namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def server(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesServer"]:
        '''configures the Kubernetes server Address.

        :schema: SecretStoreV1Beta1SpecProviderKubernetes#server
        '''
        result = self._values.get("server")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesServer"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesAuth",
    jsii_struct_bases=[],
    name_mapping={
        "cert": "cert",
        "service_account": "serviceAccount",
        "token": "token",
    },
)
class SecretStoreV1Beta1SpecProviderKubernetesAuth:
    def __init__(
        self,
        *,
        cert: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKubernetesAuthCert", typing.Dict[str, typing.Any]]] = None,
        service_account: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount", typing.Dict[str, typing.Any]]] = None,
        token: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKubernetesAuthToken", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how secret-manager authenticates with a Kubernetes instance.

        :param cert: has both clientCert and clientKey as secretKeySelector.
        :param service_account: points to a service account that should be used for authentication.
        :param token: use static token to authenticate with.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuth
        '''
        if isinstance(cert, dict):
            cert = SecretStoreV1Beta1SpecProviderKubernetesAuthCert(**cert)
        if isinstance(service_account, dict):
            service_account = SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount(**service_account)
        if isinstance(token, dict):
            token = SecretStoreV1Beta1SpecProviderKubernetesAuthToken(**token)
        if __debug__:
            def stub(
                *,
                cert: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKubernetesAuthCert, typing.Dict[str, typing.Any]]] = None,
                service_account: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount, typing.Dict[str, typing.Any]]] = None,
                token: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKubernetesAuthToken, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument cert", value=cert, expected_type=type_hints["cert"])
            check_type(argname="argument service_account", value=service_account, expected_type=type_hints["service_account"])
            check_type(argname="argument token", value=token, expected_type=type_hints["token"])
        self._values: typing.Dict[str, typing.Any] = {}
        if cert is not None:
            self._values["cert"] = cert
        if service_account is not None:
            self._values["service_account"] = service_account
        if token is not None:
            self._values["token"] = token

    @builtins.property
    def cert(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthCert"]:
        '''has both clientCert and clientKey as secretKeySelector.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuth#cert
        '''
        result = self._values.get("cert")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthCert"], result)

    @builtins.property
    def service_account(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount"]:
        '''points to a service account that should be used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuth#serviceAccount
        '''
        result = self._values.get("service_account")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount"], result)

    @builtins.property
    def token(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthToken"]:
        '''use static token to authenticate with.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuth#token
        '''
        result = self._values.get("token")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetesAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesAuthCert",
    jsii_struct_bases=[],
    name_mapping={"client_cert": "clientCert", "client_key": "clientKey"},
)
class SecretStoreV1Beta1SpecProviderKubernetesAuthCert:
    def __init__(
        self,
        *,
        client_cert: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert", typing.Dict[str, typing.Any]]] = None,
        client_key: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''has both clientCert and clientKey as secretKeySelector.

        :param client_cert: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.
        :param client_key: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCert
        '''
        if isinstance(client_cert, dict):
            client_cert = SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert(**client_cert)
        if isinstance(client_key, dict):
            client_key = SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey(**client_key)
        if __debug__:
            def stub(
                *,
                client_cert: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert, typing.Dict[str, typing.Any]]] = None,
                client_key: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument client_cert", value=client_cert, expected_type=type_hints["client_cert"])
            check_type(argname="argument client_key", value=client_key, expected_type=type_hints["client_key"])
        self._values: typing.Dict[str, typing.Any] = {}
        if client_cert is not None:
            self._values["client_cert"] = client_cert
        if client_key is not None:
            self._values["client_key"] = client_key

    @builtins.property
    def client_cert(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCert#clientCert
        '''
        result = self._values.get("client_cert")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert"], result)

    @builtins.property
    def client_key(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCert#clientKey
        '''
        result = self._values.get("client_key")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetesAuthCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''points to a service account that should be used for authentication.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesAuthToken",
    jsii_struct_bases=[],
    name_mapping={"bearer_token": "bearerToken"},
)
class SecretStoreV1Beta1SpecProviderKubernetesAuthToken:
    def __init__(
        self,
        *,
        bearer_token: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''use static token to authenticate with.

        :param bearer_token: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthToken
        '''
        if isinstance(bearer_token, dict):
            bearer_token = SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken(**bearer_token)
        if __debug__:
            def stub(
                *,
                bearer_token: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument bearer_token", value=bearer_token, expected_type=type_hints["bearer_token"])
        self._values: typing.Dict[str, typing.Any] = {}
        if bearer_token is not None:
            self._values["bearer_token"] = bearer_token

    @builtins.property
    def bearer_token(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthToken#bearerToken
        '''
        result = self._values.get("bearer_token")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetesAuthToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesServer",
    jsii_struct_bases=[],
    name_mapping={"ca_bundle": "caBundle", "ca_provider": "caProvider", "url": "url"},
)
class SecretStoreV1Beta1SpecProviderKubernetesServer:
    def __init__(
        self,
        *,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider", typing.Dict[str, typing.Any]]] = None,
        url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''configures the Kubernetes server Address.

        :param ca_bundle: CABundle is a base64-encoded CA certificate.
        :param ca_provider: see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.
        :param url: configures the Kubernetes server Address.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesServer
        '''
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider(**ca_provider)
        if __debug__:
            def stub(
                *,
                ca_bundle: typing.Optional[builtins.str] = None,
                ca_provider: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider, typing.Dict[str, typing.Any]]] = None,
                url: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
        self._values: typing.Dict[str, typing.Any] = {}
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if url is not None:
            self._values["url"] = url

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''CABundle is a base64-encoded CA certificate.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesServer#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider"]:
        '''see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesServer#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider"], result)

    @builtins.property
    def url(self) -> typing.Optional[builtins.str]:
        '''configures the Kubernetes server Address.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesServer#url
        '''
        result = self._values.get("url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetesServer(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                type: SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType,
                key: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        Can only be defined when used in a ClusterSecretStore.

        :schema: SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType"
)
class SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOnepassword",
    jsii_struct_bases=[],
    name_mapping={"auth": "auth", "connect_host": "connectHost", "vaults": "vaults"},
)
class SecretStoreV1Beta1SpecProviderOnepassword:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderOnepasswordAuth", typing.Dict[str, typing.Any]],
        connect_host: builtins.str,
        vaults: typing.Mapping[builtins.str, jsii.Number],
    ) -> None:
        '''OnePassword configures this store to sync secrets using the 1Password Cloud provider.

        :param auth: Auth defines the information necessary to authenticate against OnePassword Connect Server.
        :param connect_host: ConnectHost defines the OnePassword Connect Server to connect to.
        :param vaults: Vaults defines which OnePassword vaults to search in which order.

        :schema: SecretStoreV1Beta1SpecProviderOnepassword
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderOnepasswordAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[SecretStoreV1Beta1SpecProviderOnepasswordAuth, typing.Dict[str, typing.Any]],
                connect_host: builtins.str,
                vaults: typing.Mapping[builtins.str, jsii.Number],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument connect_host", value=connect_host, expected_type=type_hints["connect_host"])
            check_type(argname="argument vaults", value=vaults, expected_type=type_hints["vaults"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
            "connect_host": connect_host,
            "vaults": vaults,
        }

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderOnepasswordAuth":
        '''Auth defines the information necessary to authenticate against OnePassword Connect Server.

        :schema: SecretStoreV1Beta1SpecProviderOnepassword#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderOnepasswordAuth", result)

    @builtins.property
    def connect_host(self) -> builtins.str:
        '''ConnectHost defines the OnePassword Connect Server to connect to.

        :schema: SecretStoreV1Beta1SpecProviderOnepassword#connectHost
        '''
        result = self._values.get("connect_host")
        assert result is not None, "Required property 'connect_host' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vaults(self) -> typing.Mapping[builtins.str, jsii.Number]:
        '''Vaults defines which OnePassword vaults to search in which order.

        :schema: SecretStoreV1Beta1SpecProviderOnepassword#vaults
        '''
        result = self._values.get("vaults")
        assert result is not None, "Required property 'vaults' is missing"
        return typing.cast(typing.Mapping[builtins.str, jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOnepassword(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOnepasswordAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderOnepasswordAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''Auth defines the information necessary to authenticate against OnePassword Connect Server.

        :param secret_ref: OnePasswordAuthSecretRef holds secret references for 1Password credentials.

        :schema: SecretStoreV1Beta1SpecProviderOnepasswordAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_ref": secret_ref,
        }

    @builtins.property
    def secret_ref(self) -> "SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef":
        '''OnePasswordAuthSecretRef holds secret references for 1Password credentials.

        :schema: SecretStoreV1Beta1SpecProviderOnepasswordAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOnepasswordAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"connect_token_secret_ref": "connectTokenSecretRef"},
)
class SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef:
    def __init__(
        self,
        *,
        connect_token_secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''OnePasswordAuthSecretRef holds secret references for 1Password credentials.

        :param connect_token_secret_ref: The ConnectToken is used for authentication to a 1Password Connect Server.

        :schema: SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef
        '''
        if isinstance(connect_token_secret_ref, dict):
            connect_token_secret_ref = SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(**connect_token_secret_ref)
        if __debug__:
            def stub(
                *,
                connect_token_secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument connect_token_secret_ref", value=connect_token_secret_ref, expected_type=type_hints["connect_token_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "connect_token_secret_ref": connect_token_secret_ref,
        }

    @builtins.property
    def connect_token_secret_ref(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef":
        '''The ConnectToken is used for authentication to a 1Password Connect Server.

        :schema: SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef#connectTokenSecretRef
        '''
        result = self._values.get("connect_token_secret_ref")
        assert result is not None, "Required property 'connect_token_secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The ConnectToken is used for authentication to a 1Password Connect Server.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOracle",
    jsii_struct_bases=[],
    name_mapping={"region": "region", "vault": "vault", "auth": "auth"},
)
class SecretStoreV1Beta1SpecProviderOracle:
    def __init__(
        self,
        *,
        region: builtins.str,
        vault: builtins.str,
        auth: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderOracleAuth", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Oracle configures this store to sync secrets using Oracle Vault provider.

        :param region: Region is the region where vault is located.
        :param vault: Vault is the vault's OCID of the specific vault where secret is located.
        :param auth: Auth configures how secret-manager authenticates with the Oracle Vault. If empty, use the instance principal, otherwise the user credentials specified in Auth.

        :schema: SecretStoreV1Beta1SpecProviderOracle
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderOracleAuth(**auth)
        if __debug__:
            def stub(
                *,
                region: builtins.str,
                vault: builtins.str,
                auth: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderOracleAuth, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument vault", value=vault, expected_type=type_hints["vault"])
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
        self._values: typing.Dict[str, typing.Any] = {
            "region": region,
            "vault": vault,
        }
        if auth is not None:
            self._values["auth"] = auth

    @builtins.property
    def region(self) -> builtins.str:
        '''Region is the region where vault is located.

        :schema: SecretStoreV1Beta1SpecProviderOracle#region
        '''
        result = self._values.get("region")
        assert result is not None, "Required property 'region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vault(self) -> builtins.str:
        '''Vault is the vault's OCID of the specific vault where secret is located.

        :schema: SecretStoreV1Beta1SpecProviderOracle#vault
        '''
        result = self._values.get("vault")
        assert result is not None, "Required property 'vault' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auth(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderOracleAuth"]:
        '''Auth configures how secret-manager authenticates with the Oracle Vault.

        If empty, use the instance principal, otherwise the user credentials specified in Auth.

        :schema: SecretStoreV1Beta1SpecProviderOracle#auth
        '''
        result = self._values.get("auth")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderOracleAuth"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOracle(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOracleAuth",
    jsii_struct_bases=[],
    name_mapping={"secret_ref": "secretRef", "tenancy": "tenancy", "user": "user"},
)
class SecretStoreV1Beta1SpecProviderOracleAuth:
    def __init__(
        self,
        *,
        secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderOracleAuthSecretRef", typing.Dict[str, typing.Any]],
        tenancy: builtins.str,
        user: builtins.str,
    ) -> None:
        '''Auth configures how secret-manager authenticates with the Oracle Vault.

        If empty, use the instance principal, otherwise the user credentials specified in Auth.

        :param secret_ref: SecretRef to pass through sensitive information.
        :param tenancy: Tenancy is the tenancy OCID where user is located.
        :param user: User is an access OCID specific to the account.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuth
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderOracleAuthSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderOracleAuthSecretRef, typing.Dict[str, typing.Any]],
                tenancy: builtins.str,
                user: builtins.str,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument tenancy", value=tenancy, expected_type=type_hints["tenancy"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret_ref": secret_ref,
            "tenancy": tenancy,
            "user": user,
        }

    @builtins.property
    def secret_ref(self) -> "SecretStoreV1Beta1SpecProviderOracleAuthSecretRef":
        '''SecretRef to pass through sensitive information.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuth#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderOracleAuthSecretRef", result)

    @builtins.property
    def tenancy(self) -> builtins.str:
        '''Tenancy is the tenancy OCID where user is located.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuth#tenancy
        '''
        result = self._values.get("tenancy")
        assert result is not None, "Required property 'tenancy' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def user(self) -> builtins.str:
        '''User is an access OCID specific to the account.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuth#user
        '''
        result = self._values.get("user")
        assert result is not None, "Required property 'user' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOracleAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOracleAuthSecretRef",
    jsii_struct_bases=[],
    name_mapping={"fingerprint": "fingerprint", "privatekey": "privatekey"},
)
class SecretStoreV1Beta1SpecProviderOracleAuthSecretRef:
    def __init__(
        self,
        *,
        fingerprint: typing.Union["SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint", typing.Dict[str, typing.Any]],
        privatekey: typing.Union["SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey", typing.Dict[str, typing.Any]],
    ) -> None:
        '''SecretRef to pass through sensitive information.

        :param fingerprint: Fingerprint is the fingerprint of the API private key.
        :param privatekey: PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRef
        '''
        if isinstance(fingerprint, dict):
            fingerprint = SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint(**fingerprint)
        if isinstance(privatekey, dict):
            privatekey = SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey(**privatekey)
        if __debug__:
            def stub(
                *,
                fingerprint: typing.Union[SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint, typing.Dict[str, typing.Any]],
                privatekey: typing.Union[SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument fingerprint", value=fingerprint, expected_type=type_hints["fingerprint"])
            check_type(argname="argument privatekey", value=privatekey, expected_type=type_hints["privatekey"])
        self._values: typing.Dict[str, typing.Any] = {
            "fingerprint": fingerprint,
            "privatekey": privatekey,
        }

    @builtins.property
    def fingerprint(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint":
        '''Fingerprint is the fingerprint of the API private key.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRef#fingerprint
        '''
        result = self._values.get("fingerprint")
        assert result is not None, "Required property 'fingerprint' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint", result)

    @builtins.property
    def privatekey(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey":
        '''PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRef#privatekey
        '''
        result = self._values.get("privatekey")
        assert result is not None, "Required property 'privatekey' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOracleAuthSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Fingerprint is the fingerprint of the API private key.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''PrivateKey is the user's API Signing Key in PEM format, used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderSenhasegura",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "module": "module",
        "url": "url",
        "ignore_ssl_certificate": "ignoreSslCertificate",
    },
)
class SecretStoreV1Beta1SpecProviderSenhasegura:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderSenhaseguraAuth", typing.Dict[str, typing.Any]],
        module: builtins.str,
        url: builtins.str,
        ignore_ssl_certificate: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Senhasegura configures this store to sync secrets using senhasegura provider.

        :param auth: Auth defines parameters to authenticate in senhasegura.
        :param module: Module defines which senhasegura module should be used to get secrets.
        :param url: URL of senhasegura.
        :param ignore_ssl_certificate: IgnoreSslCertificate defines if SSL certificate must be ignored.

        :schema: SecretStoreV1Beta1SpecProviderSenhasegura
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderSenhaseguraAuth(**auth)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[SecretStoreV1Beta1SpecProviderSenhaseguraAuth, typing.Dict[str, typing.Any]],
                module: builtins.str,
                url: builtins.str,
                ignore_ssl_certificate: typing.Optional[builtins.bool] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument module", value=module, expected_type=type_hints["module"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
            check_type(argname="argument ignore_ssl_certificate", value=ignore_ssl_certificate, expected_type=type_hints["ignore_ssl_certificate"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
            "module": module,
            "url": url,
        }
        if ignore_ssl_certificate is not None:
            self._values["ignore_ssl_certificate"] = ignore_ssl_certificate

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderSenhaseguraAuth":
        '''Auth defines parameters to authenticate in senhasegura.

        :schema: SecretStoreV1Beta1SpecProviderSenhasegura#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderSenhaseguraAuth", result)

    @builtins.property
    def module(self) -> builtins.str:
        '''Module defines which senhasegura module should be used to get secrets.

        :schema: SecretStoreV1Beta1SpecProviderSenhasegura#module
        '''
        result = self._values.get("module")
        assert result is not None, "Required property 'module' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def url(self) -> builtins.str:
        '''URL of senhasegura.

        :schema: SecretStoreV1Beta1SpecProviderSenhasegura#url
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ignore_ssl_certificate(self) -> typing.Optional[builtins.bool]:
        '''IgnoreSslCertificate defines if SSL certificate must be ignored.

        :schema: SecretStoreV1Beta1SpecProviderSenhasegura#ignoreSslCertificate
        '''
        result = self._values.get("ignore_ssl_certificate")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderSenhasegura(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderSenhaseguraAuth",
    jsii_struct_bases=[],
    name_mapping={
        "client_id": "clientId",
        "client_secret_secret_ref": "clientSecretSecretRef",
    },
)
class SecretStoreV1Beta1SpecProviderSenhaseguraAuth:
    def __init__(
        self,
        *,
        client_id: builtins.str,
        client_secret_secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''Auth defines parameters to authenticate in senhasegura.

        :param client_id: 
        :param client_secret_secret_ref: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderSenhaseguraAuth
        '''
        if isinstance(client_secret_secret_ref, dict):
            client_secret_secret_ref = SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef(**client_secret_secret_ref)
        if __debug__:
            def stub(
                *,
                client_id: builtins.str,
                client_secret_secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument client_id", value=client_id, expected_type=type_hints["client_id"])
            check_type(argname="argument client_secret_secret_ref", value=client_secret_secret_ref, expected_type=type_hints["client_secret_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "client_id": client_id,
            "client_secret_secret_ref": client_secret_secret_ref,
        }

    @builtins.property
    def client_id(self) -> builtins.str:
        '''
        :schema: SecretStoreV1Beta1SpecProviderSenhaseguraAuth#clientId
        '''
        result = self._values.get("client_id")
        assert result is not None, "Required property 'client_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def client_secret_secret_ref(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef":
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderSenhaseguraAuth#clientSecretSecretRef
        '''
        result = self._values.get("client_secret_secret_ref")
        assert result is not None, "Required property 'client_secret_secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderSenhaseguraAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVault",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "server": "server",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
        "forward_inconsistent": "forwardInconsistent",
        "namespace": "namespace",
        "path": "path",
        "read_your_writes": "readYourWrites",
        "version": "version",
    },
)
class SecretStoreV1Beta1SpecProviderVault:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderVaultAuth", typing.Dict[str, typing.Any]],
        server: builtins.str,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultCaProvider", typing.Dict[str, typing.Any]]] = None,
        forward_inconsistent: typing.Optional[builtins.bool] = None,
        namespace: typing.Optional[builtins.str] = None,
        path: typing.Optional[builtins.str] = None,
        read_your_writes: typing.Optional[builtins.bool] = None,
        version: typing.Optional["SecretStoreV1Beta1SpecProviderVaultVersion"] = None,
    ) -> None:
        '''Vault configures this store to sync secrets using Hashi provider.

        :param auth: Auth configures how secret-manager authenticates with the Vault server.
        :param server: Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
        :param ca_bundle: PEM encoded CA bundle used to validate Vault server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
        :param ca_provider: The provider for the CA bundle to use to validate Vault server certificate.
        :param forward_inconsistent: ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop. This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
        :param namespace: Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
        :param path: Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.
        :param read_your_writes: ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request. More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency
        :param version: Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".

        :schema: SecretStoreV1Beta1SpecProviderVault
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderVaultAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreV1Beta1SpecProviderVaultCaProvider(**ca_provider)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[SecretStoreV1Beta1SpecProviderVaultAuth, typing.Dict[str, typing.Any]],
                server: builtins.str,
                ca_bundle: typing.Optional[builtins.str] = None,
                ca_provider: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultCaProvider, typing.Dict[str, typing.Any]]] = None,
                forward_inconsistent: typing.Optional[builtins.bool] = None,
                namespace: typing.Optional[builtins.str] = None,
                path: typing.Optional[builtins.str] = None,
                read_your_writes: typing.Optional[builtins.bool] = None,
                version: typing.Optional[SecretStoreV1Beta1SpecProviderVaultVersion] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument server", value=server, expected_type=type_hints["server"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument forward_inconsistent", value=forward_inconsistent, expected_type=type_hints["forward_inconsistent"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument read_your_writes", value=read_your_writes, expected_type=type_hints["read_your_writes"])
            check_type(argname="argument version", value=version, expected_type=type_hints["version"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
            "server": server,
        }
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if forward_inconsistent is not None:
            self._values["forward_inconsistent"] = forward_inconsistent
        if namespace is not None:
            self._values["namespace"] = namespace
        if path is not None:
            self._values["path"] = path
        if read_your_writes is not None:
            self._values["read_your_writes"] = read_your_writes
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderVaultAuth":
        '''Auth configures how secret-manager authenticates with the Vault server.

        :schema: SecretStoreV1Beta1SpecProviderVault#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderVaultAuth", result)

    @builtins.property
    def server(self) -> builtins.str:
        '''Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".

        :schema: SecretStoreV1Beta1SpecProviderVault#server
        '''
        result = self._values.get("server")
        assert result is not None, "Required property 'server' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''PEM encoded CA bundle used to validate Vault server certificate.

        Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.

        :schema: SecretStoreV1Beta1SpecProviderVault#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultCaProvider"]:
        '''The provider for the CA bundle to use to validate Vault server certificate.

        :schema: SecretStoreV1Beta1SpecProviderVault#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultCaProvider"], result)

    @builtins.property
    def forward_inconsistent(self) -> typing.Optional[builtins.bool]:
        '''ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop.

        This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header

        :schema: SecretStoreV1Beta1SpecProviderVault#forwardInconsistent
        '''
        result = self._values.get("forward_inconsistent")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Name of the vault namespace.

        Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces

        :schema: SecretStoreV1Beta1SpecProviderVault#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def path(self) -> typing.Optional[builtins.str]:
        '''Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.

        :schema: SecretStoreV1Beta1SpecProviderVault#path
        '''
        result = self._values.get("path")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def read_your_writes(self) -> typing.Optional[builtins.bool]:
        '''ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request.

        More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency

        :schema: SecretStoreV1Beta1SpecProviderVault#readYourWrites
        '''
        result = self._values.get("read_your_writes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def version(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultVersion"]:
        '''Version is the Vault KV secret engine version.

        This can be either "v1" or "v2". Version defaults to "v2".

        :schema: SecretStoreV1Beta1SpecProviderVault#version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultVersion"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVault(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuth",
    jsii_struct_bases=[],
    name_mapping={
        "app_role": "appRole",
        "cert": "cert",
        "jwt": "jwt",
        "kubernetes": "kubernetes",
        "ldap": "ldap",
        "token_secret_ref": "tokenSecretRef",
    },
)
class SecretStoreV1Beta1SpecProviderVaultAuth:
    def __init__(
        self,
        *,
        app_role: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthAppRole", typing.Dict[str, typing.Any]]] = None,
        cert: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthCert", typing.Dict[str, typing.Any]]] = None,
        jwt: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthJwt", typing.Dict[str, typing.Any]]] = None,
        kubernetes: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthKubernetes", typing.Dict[str, typing.Any]]] = None,
        ldap: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthLdap", typing.Dict[str, typing.Any]]] = None,
        token_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth configures how secret-manager authenticates with the Vault server.

        :param app_role: AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
        :param cert: Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.
        :param jwt: Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.
        :param kubernetes: Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
        :param ldap: Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.
        :param token_secret_ref: TokenSecretRef authenticates with Vault by presenting a token.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuth
        '''
        if isinstance(app_role, dict):
            app_role = SecretStoreV1Beta1SpecProviderVaultAuthAppRole(**app_role)
        if isinstance(cert, dict):
            cert = SecretStoreV1Beta1SpecProviderVaultAuthCert(**cert)
        if isinstance(jwt, dict):
            jwt = SecretStoreV1Beta1SpecProviderVaultAuthJwt(**jwt)
        if isinstance(kubernetes, dict):
            kubernetes = SecretStoreV1Beta1SpecProviderVaultAuthKubernetes(**kubernetes)
        if isinstance(ldap, dict):
            ldap = SecretStoreV1Beta1SpecProviderVaultAuthLdap(**ldap)
        if isinstance(token_secret_ref, dict):
            token_secret_ref = SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef(**token_secret_ref)
        if __debug__:
            def stub(
                *,
                app_role: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthAppRole, typing.Dict[str, typing.Any]]] = None,
                cert: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthCert, typing.Dict[str, typing.Any]]] = None,
                jwt: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthJwt, typing.Dict[str, typing.Any]]] = None,
                kubernetes: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthKubernetes, typing.Dict[str, typing.Any]]] = None,
                ldap: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthLdap, typing.Dict[str, typing.Any]]] = None,
                token_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument app_role", value=app_role, expected_type=type_hints["app_role"])
            check_type(argname="argument cert", value=cert, expected_type=type_hints["cert"])
            check_type(argname="argument jwt", value=jwt, expected_type=type_hints["jwt"])
            check_type(argname="argument kubernetes", value=kubernetes, expected_type=type_hints["kubernetes"])
            check_type(argname="argument ldap", value=ldap, expected_type=type_hints["ldap"])
            check_type(argname="argument token_secret_ref", value=token_secret_ref, expected_type=type_hints["token_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if app_role is not None:
            self._values["app_role"] = app_role
        if cert is not None:
            self._values["cert"] = cert
        if jwt is not None:
            self._values["jwt"] = jwt
        if kubernetes is not None:
            self._values["kubernetes"] = kubernetes
        if ldap is not None:
            self._values["ldap"] = ldap
        if token_secret_ref is not None:
            self._values["token_secret_ref"] = token_secret_ref

    @builtins.property
    def app_role(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthAppRole"]:
        '''AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuth#appRole
        '''
        result = self._values.get("app_role")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthAppRole"], result)

    @builtins.property
    def cert(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthCert"]:
        '''Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuth#cert
        '''
        result = self._values.get("cert")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthCert"], result)

    @builtins.property
    def jwt(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthJwt"]:
        '''Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuth#jwt
        '''
        result = self._values.get("jwt")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthJwt"], result)

    @builtins.property
    def kubernetes(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthKubernetes"]:
        '''Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuth#kubernetes
        '''
        result = self._values.get("kubernetes")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthKubernetes"], result)

    @builtins.property
    def ldap(self) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthLdap"]:
        '''Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuth#ldap
        '''
        result = self._values.get("ldap")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthLdap"], result)

    @builtins.property
    def token_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef"]:
        '''TokenSecretRef authenticates with Vault by presenting a token.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuth#tokenSecretRef
        '''
        result = self._values.get("token_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthAppRole",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "role_id": "roleId", "secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthAppRole:
    def __init__(
        self,
        *,
        path: builtins.str,
        role_id: builtins.str,
        secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.

        :param path: Path where the App Role authentication backend is mounted in Vault, e.g: "approle".
        :param role_id: RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.
        :param secret_ref: Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The ``key`` field must be specified and denotes which entry within the Secret resource is used as the app role secret.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRole
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                path: builtins.str,
                role_id: builtins.str,
                secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument role_id", value=role_id, expected_type=type_hints["role_id"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
            "role_id": role_id,
            "secret_ref": secret_ref,
        }

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the App Role authentication backend is mounted in Vault, e.g: "approle".

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRole#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role_id(self) -> builtins.str:
        '''RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRole#roleId
        '''
        result = self._values.get("role_id")
        assert result is not None, "Required property 'role_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(self) -> "SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef":
        '''Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret resource is used as the app role secret.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRole#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthAppRole(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault.

        The ``key`` field must be specified and denotes which entry within the Secret resource is used as the app role secret.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthCert",
    jsii_struct_bases=[],
    name_mapping={"client_cert": "clientCert", "secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthCert:
    def __init__(
        self,
        *,
        client_cert: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert", typing.Dict[str, typing.Any]]] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method.

        :param client_cert: ClientCert is a certificate to authenticate using the Cert Vault authentication method.
        :param secret_ref: SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCert
        '''
        if isinstance(client_cert, dict):
            client_cert = SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert(**client_cert)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                client_cert: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert, typing.Dict[str, typing.Any]]] = None,
                secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument client_cert", value=client_cert, expected_type=type_hints["client_cert"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if client_cert is not None:
            self._values["client_cert"] = client_cert
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def client_cert(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert"]:
        '''ClientCert is a certificate to authenticate using the Cert Vault authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCert#clientCert
        '''
        result = self._values.get("client_cert")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert"], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef"]:
        '''SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCert#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''ClientCert is a certificate to authenticate using the Cert Vault authentication method.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthJwt",
    jsii_struct_bases=[],
    name_mapping={
        "path": "path",
        "kubernetes_service_account_token": "kubernetesServiceAccountToken",
        "role": "role",
        "secret_ref": "secretRef",
    },
)
class SecretStoreV1Beta1SpecProviderVaultAuthJwt:
    def __init__(
        self,
        *,
        path: builtins.str,
        kubernetes_service_account_token: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken", typing.Dict[str, typing.Any]]] = None,
        role: typing.Optional[builtins.str] = None,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method.

        :param path: Path where the JWT authentication backend is mounted in Vault, e.g: "jwt".
        :param kubernetes_service_account_token: Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.
        :param role: Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method.
        :param secret_ref: Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwt
        '''
        if isinstance(kubernetes_service_account_token, dict):
            kubernetes_service_account_token = SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken(**kubernetes_service_account_token)
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                path: builtins.str,
                kubernetes_service_account_token: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken, typing.Dict[str, typing.Any]]] = None,
                role: typing.Optional[builtins.str] = None,
                secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument kubernetes_service_account_token", value=kubernetes_service_account_token, expected_type=type_hints["kubernetes_service_account_token"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
        }
        if kubernetes_service_account_token is not None:
            self._values["kubernetes_service_account_token"] = kubernetes_service_account_token
        if role is not None:
            self._values["role"] = role
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the JWT authentication backend is mounted in Vault, e.g: "jwt".

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwt#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def kubernetes_service_account_token(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken"]:
        '''Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwt#kubernetesServiceAccountToken
        '''
        result = self._values.get("kubernetes_service_account_token")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken"], result)

    @builtins.property
    def role(self) -> typing.Optional[builtins.str]:
        '''Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwt#role
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef"]:
        '''Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwt#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthJwt(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken",
    jsii_struct_bases=[],
    name_mapping={
        "service_account_ref": "serviceAccountRef",
        "audiences": "audiences",
        "expiration_seconds": "expirationSeconds",
    },
)
class SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken:
    def __init__(
        self,
        *,
        service_account_ref: typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef", typing.Dict[str, typing.Any]],
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        expiration_seconds: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the ``TokenRequest`` API.

        :param service_account_ref: Service account field containing the name of a kubernetes ServiceAccount.
        :param audiences: Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``. Defaults to a single audience ``vault`` it not specified. Deprecated: use serviceAccountRef.Audiences instead Default: a single audience ``vault`` it not specified. Deprecated: use serviceAccountRef.Audiences instead
        :param expiration_seconds: Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``. Deprecated: this will be removed in the future. Defaults to 10 minutes. Default: 10 minutes.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken
        '''
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                service_account_ref: typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef, typing.Dict[str, typing.Any]],
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                expiration_seconds: typing.Optional[jsii.Number] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument expiration_seconds", value=expiration_seconds, expected_type=type_hints["expiration_seconds"])
        self._values: typing.Dict[str, typing.Any] = {
            "service_account_ref": service_account_ref,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if expiration_seconds is not None:
            self._values["expiration_seconds"] = expiration_seconds

    @builtins.property
    def service_account_ref(
        self,
    ) -> "SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef":
        '''Service account field containing the name of a kubernetes ServiceAccount.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        assert result is not None, "Required property 'service_account_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef", result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``.

        Defaults to a single audience ``vault`` it not specified. Deprecated: use serviceAccountRef.Audiences instead

        :default: a single audience ``vault`` it not specified. Deprecated: use serviceAccountRef.Audiences instead

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def expiration_seconds(self) -> typing.Optional[jsii.Number]:
        '''Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by ``serviceAccountRef``.

        Deprecated: this will be removed in the future. Defaults to 10 minutes.

        :default: 10 minutes.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#expirationSeconds
        '''
        result = self._values.get("expiration_seconds")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Service account field containing the name of a kubernetes ServiceAccount.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthKubernetes",
    jsii_struct_bases=[],
    name_mapping={
        "mount_path": "mountPath",
        "role": "role",
        "secret_ref": "secretRef",
        "service_account_ref": "serviceAccountRef",
    },
)
class SecretStoreV1Beta1SpecProviderVaultAuthKubernetes:
    def __init__(
        self,
        *,
        mount_path: builtins.str,
        role: builtins.str,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef", typing.Dict[str, typing.Any]]] = None,
        service_account_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.

        :param mount_path: Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes".
        :param role: A required field containing the Vault Role to assume. A Role binds a Kubernetes ServiceAccount with a set of Vault policies.
        :param secret_ref: Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.
        :param service_account_ref: Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetes
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef(**secret_ref)
        if isinstance(service_account_ref, dict):
            service_account_ref = SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef(**service_account_ref)
        if __debug__:
            def stub(
                *,
                mount_path: builtins.str,
                role: builtins.str,
                secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef, typing.Dict[str, typing.Any]]] = None,
                service_account_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument mount_path", value=mount_path, expected_type=type_hints["mount_path"])
            check_type(argname="argument role", value=role, expected_type=type_hints["role"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
            check_type(argname="argument service_account_ref", value=service_account_ref, expected_type=type_hints["service_account_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "mount_path": mount_path,
            "role": role,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref
        if service_account_ref is not None:
            self._values["service_account_ref"] = service_account_ref

    @builtins.property
    def mount_path(self) -> builtins.str:
        '''Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes".

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetes#mountPath
        '''
        result = self._values.get("mount_path")
        assert result is not None, "Required property 'mount_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role(self) -> builtins.str:
        '''A required field containing the Vault Role to assume.

        A Role binds a Kubernetes ServiceAccount with a set of Vault policies.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetes#role
        '''
        result = self._values.get("role")
        assert result is not None, "Required property 'role' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef"]:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault.

        If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetes#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef"], result)

    @builtins.property
    def service_account_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef"]:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetes#serviceAccountRef
        '''
        result = self._values.get("service_account_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthKubernetes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault.

        If a name is specified without a key, ``token`` is the default. If one is not specified, the one bound to the controller will be used.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "audiences": "audiences", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef:
    def __init__(
        self,
        *,
        name: builtins.str,
        audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Optional service account field containing the name of a kubernetes ServiceAccount.

        If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.

        :param name: The name of the ServiceAccount resource being referred to.
        :param audiences: Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                audiences: typing.Optional[typing.Sequence[builtins.str]] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument audiences", value=audiences, expected_type=type_hints["audiences"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if audiences is not None:
            self._values["audiences"] = audiences
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the ServiceAccount resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def audiences(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Audience specifies the ``aud`` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#audiences
        '''
        result = self._values.get("audiences")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthLdap",
    jsii_struct_bases=[],
    name_mapping={"path": "path", "username": "username", "secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthLdap:
    def __init__(
        self,
        *,
        path: builtins.str,
        username: builtins.str,
        secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method.

        :param path: Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap".
        :param username: Username is a LDAP user name used to authenticate using the LDAP Vault authentication method.
        :param secret_ref: SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthLdap
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                path: builtins.str,
                username: builtins.str,
                secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument path", value=path, expected_type=type_hints["path"])
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "path": path,
            "username": username,
        }
        if secret_ref is not None:
            self._values["secret_ref"] = secret_ref

    @builtins.property
    def path(self) -> builtins.str:
        '''Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap".

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthLdap#path
        '''
        result = self._values.get("path")
        assert result is not None, "Required property 'path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def username(self) -> builtins.str:
        '''Username is a LDAP user name used to authenticate using the LDAP Vault authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthLdap#username
        '''
        result = self._values.get("username")
        assert result is not None, "Required property 'username' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef"]:
        '''SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthLdap#secretRef
        '''
        result = self._values.get("secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthLdap(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''TokenSecretRef authenticates with Vault by presenting a token.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class SecretStoreV1Beta1SpecProviderVaultCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "SecretStoreV1Beta1SpecProviderVaultCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Vault server certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key where the CA certificate can be found in the Secret or ConfigMap.
        :param namespace: The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.

        :schema: SecretStoreV1Beta1SpecProviderVaultCaProvider
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                type: SecretStoreV1Beta1SpecProviderVaultCaProviderType,
                key: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: SecretStoreV1Beta1SpecProviderVaultCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "SecretStoreV1Beta1SpecProviderVaultCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: SecretStoreV1Beta1SpecProviderVaultCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderVaultCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key where the CA certificate can be found in the Secret or ConfigMap.

        :schema: SecretStoreV1Beta1SpecProviderVaultCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        Can only be defined when used in a ClusterSecretStore.

        :schema: SecretStoreV1Beta1SpecProviderVaultCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderVaultCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultCaProviderType"
)
class SecretStoreV1Beta1SpecProviderVaultCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: SecretStoreV1Beta1SpecProviderVaultCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.enum(jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderVaultVersion")
class SecretStoreV1Beta1SpecProviderVaultVersion(enum.Enum):
    '''Version is the Vault KV secret engine version.

    This can be either "v1" or "v2". Version defaults to "v2".

    :schema: SecretStoreV1Beta1SpecProviderVaultVersion
    '''

    V1 = "V1"
    '''v1.'''
    V2 = "V2"
    '''v2.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderWebhook",
    jsii_struct_bases=[],
    name_mapping={
        "result": "result",
        "url": "url",
        "body": "body",
        "ca_bundle": "caBundle",
        "ca_provider": "caProvider",
        "headers": "headers",
        "method": "method",
        "secrets": "secrets",
        "timeout": "timeout",
    },
)
class SecretStoreV1Beta1SpecProviderWebhook:
    def __init__(
        self,
        *,
        result: typing.Union["SecretStoreV1Beta1SpecProviderWebhookResult", typing.Dict[str, typing.Any]],
        url: builtins.str,
        body: typing.Optional[builtins.str] = None,
        ca_bundle: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderWebhookCaProvider", typing.Dict[str, typing.Any]]] = None,
        headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        method: typing.Optional[builtins.str] = None,
        secrets: typing.Optional[typing.Sequence[typing.Union["SecretStoreV1Beta1SpecProviderWebhookSecrets", typing.Dict[str, typing.Any]]]] = None,
        timeout: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Webhook configures this store to sync secrets using a generic templated webhook.

        :param result: Result formatting.
        :param url: Webhook url to call.
        :param body: Body.
        :param ca_bundle: PEM encoded CA bundle used to validate webhook server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
        :param ca_provider: The provider for the CA bundle to use to validate webhook server certificate.
        :param headers: Headers.
        :param method: Webhook Method.
        :param secrets: Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name.
        :param timeout: Timeout.

        :schema: SecretStoreV1Beta1SpecProviderWebhook
        '''
        if isinstance(result, dict):
            result = SecretStoreV1Beta1SpecProviderWebhookResult(**result)
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreV1Beta1SpecProviderWebhookCaProvider(**ca_provider)
        if __debug__:
            def stub(
                *,
                result: typing.Union[SecretStoreV1Beta1SpecProviderWebhookResult, typing.Dict[str, typing.Any]],
                url: builtins.str,
                body: typing.Optional[builtins.str] = None,
                ca_bundle: typing.Optional[builtins.str] = None,
                ca_provider: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderWebhookCaProvider, typing.Dict[str, typing.Any]]] = None,
                headers: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
                method: typing.Optional[builtins.str] = None,
                secrets: typing.Optional[typing.Sequence[typing.Union[SecretStoreV1Beta1SpecProviderWebhookSecrets, typing.Dict[str, typing.Any]]]] = None,
                timeout: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument result", value=result, expected_type=type_hints["result"])
            check_type(argname="argument url", value=url, expected_type=type_hints["url"])
            check_type(argname="argument body", value=body, expected_type=type_hints["body"])
            check_type(argname="argument ca_bundle", value=ca_bundle, expected_type=type_hints["ca_bundle"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
            check_type(argname="argument headers", value=headers, expected_type=type_hints["headers"])
            check_type(argname="argument method", value=method, expected_type=type_hints["method"])
            check_type(argname="argument secrets", value=secrets, expected_type=type_hints["secrets"])
            check_type(argname="argument timeout", value=timeout, expected_type=type_hints["timeout"])
        self._values: typing.Dict[str, typing.Any] = {
            "result": result,
            "url": url,
        }
        if body is not None:
            self._values["body"] = body
        if ca_bundle is not None:
            self._values["ca_bundle"] = ca_bundle
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider
        if headers is not None:
            self._values["headers"] = headers
        if method is not None:
            self._values["method"] = method
        if secrets is not None:
            self._values["secrets"] = secrets
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def result(self) -> "SecretStoreV1Beta1SpecProviderWebhookResult":
        '''Result formatting.

        :schema: SecretStoreV1Beta1SpecProviderWebhook#result
        '''
        result = self._values.get("result")
        assert result is not None, "Required property 'result' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderWebhookResult", result)

    @builtins.property
    def url(self) -> builtins.str:
        '''Webhook url to call.

        :schema: SecretStoreV1Beta1SpecProviderWebhook#url
        '''
        result = self._values.get("url")
        assert result is not None, "Required property 'url' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def body(self) -> typing.Optional[builtins.str]:
        '''Body.

        :schema: SecretStoreV1Beta1SpecProviderWebhook#body
        '''
        result = self._values.get("body")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_bundle(self) -> typing.Optional[builtins.str]:
        '''PEM encoded CA bundle used to validate webhook server certificate.

        Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.

        :schema: SecretStoreV1Beta1SpecProviderWebhook#caBundle
        '''
        result = self._values.get("ca_bundle")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderWebhookCaProvider"]:
        '''The provider for the CA bundle to use to validate webhook server certificate.

        :schema: SecretStoreV1Beta1SpecProviderWebhook#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderWebhookCaProvider"], result)

    @builtins.property
    def headers(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Headers.

        :schema: SecretStoreV1Beta1SpecProviderWebhook#headers
        '''
        result = self._values.get("headers")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def method(self) -> typing.Optional[builtins.str]:
        '''Webhook Method.

        :schema: SecretStoreV1Beta1SpecProviderWebhook#method
        '''
        result = self._values.get("method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def secrets(
        self,
    ) -> typing.Optional[typing.List["SecretStoreV1Beta1SpecProviderWebhookSecrets"]]:
        '''Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name.

        :schema: SecretStoreV1Beta1SpecProviderWebhook#secrets
        '''
        result = self._values.get("secrets")
        return typing.cast(typing.Optional[typing.List["SecretStoreV1Beta1SpecProviderWebhookSecrets"]], result)

    @builtins.property
    def timeout(self) -> typing.Optional[builtins.str]:
        '''Timeout.

        :schema: SecretStoreV1Beta1SpecProviderWebhook#timeout
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderWebhook(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderWebhookCaProvider",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "type": "type",
        "key": "key",
        "namespace": "namespace",
    },
)
class SecretStoreV1Beta1SpecProviderWebhookCaProvider:
    def __init__(
        self,
        *,
        name: builtins.str,
        type: "SecretStoreV1Beta1SpecProviderWebhookCaProviderType",
        key: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate webhook server certificate.

        :param name: The name of the object located at the provider type.
        :param type: The type of provider to use such as "Secret", or "ConfigMap".
        :param key: The key the value inside of the provider type to use, only used with "Secret" type.
        :param namespace: The namespace the Provider type is in.

        :schema: SecretStoreV1Beta1SpecProviderWebhookCaProvider
        '''
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                type: SecretStoreV1Beta1SpecProviderWebhookCaProviderType,
                key: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument type", value=type, expected_type=type_hints["type"])
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "type": type,
        }
        if key is not None:
            self._values["key"] = key
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def name(self) -> builtins.str:
        '''The name of the object located at the provider type.

        :schema: SecretStoreV1Beta1SpecProviderWebhookCaProvider#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> "SecretStoreV1Beta1SpecProviderWebhookCaProviderType":
        '''The type of provider to use such as "Secret", or "ConfigMap".

        :schema: SecretStoreV1Beta1SpecProviderWebhookCaProvider#type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderWebhookCaProviderType", result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key the value inside of the provider type to use, only used with "Secret" type.

        :schema: SecretStoreV1Beta1SpecProviderWebhookCaProvider#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''The namespace the Provider type is in.

        :schema: SecretStoreV1Beta1SpecProviderWebhookCaProvider#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderWebhookCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderWebhookCaProviderType"
)
class SecretStoreV1Beta1SpecProviderWebhookCaProviderType(enum.Enum):
    '''The type of provider to use such as "Secret", or "ConfigMap".

    :schema: SecretStoreV1Beta1SpecProviderWebhookCaProviderType
    '''

    SECRET = "SECRET"
    '''Secret.'''
    CONFIG_MAP = "CONFIG_MAP"
    '''ConfigMap.'''


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderWebhookResult",
    jsii_struct_bases=[],
    name_mapping={"json_path": "jsonPath"},
)
class SecretStoreV1Beta1SpecProviderWebhookResult:
    def __init__(self, *, json_path: typing.Optional[builtins.str] = None) -> None:
        '''Result formatting.

        :param json_path: Json path of return value.

        :schema: SecretStoreV1Beta1SpecProviderWebhookResult
        '''
        if __debug__:
            def stub(*, json_path: typing.Optional[builtins.str] = None) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument json_path", value=json_path, expected_type=type_hints["json_path"])
        self._values: typing.Dict[str, typing.Any] = {}
        if json_path is not None:
            self._values["json_path"] = json_path

    @builtins.property
    def json_path(self) -> typing.Optional[builtins.str]:
        '''Json path of return value.

        :schema: SecretStoreV1Beta1SpecProviderWebhookResult#jsonPath
        '''
        result = self._values.get("json_path")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderWebhookResult(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderWebhookSecrets",
    jsii_struct_bases=[],
    name_mapping={"name": "name", "secret_ref": "secretRef"},
)
class SecretStoreV1Beta1SpecProviderWebhookSecrets:
    def __init__(
        self,
        *,
        name: builtins.str,
        secret_ref: typing.Union["SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef", typing.Dict[str, typing.Any]],
    ) -> None:
        '''
        :param name: Name of this secret in templates.
        :param secret_ref: Secret ref to fill in credentials.

        :schema: SecretStoreV1Beta1SpecProviderWebhookSecrets
        '''
        if isinstance(secret_ref, dict):
            secret_ref = SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef(**secret_ref)
        if __debug__:
            def stub(
                *,
                name: builtins.str,
                secret_ref: typing.Union[SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef, typing.Dict[str, typing.Any]],
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument secret_ref", value=secret_ref, expected_type=type_hints["secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "secret_ref": secret_ref,
        }

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of this secret in templates.

        :schema: SecretStoreV1Beta1SpecProviderWebhookSecrets#name
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def secret_ref(self) -> "SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef":
        '''Secret ref to fill in credentials.

        :schema: SecretStoreV1Beta1SpecProviderWebhookSecrets#secretRef
        '''
        result = self._values.get("secret_ref")
        assert result is not None, "Required property 'secret_ref' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderWebhookSecrets(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Secret ref to fill in credentials.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderYandexcertificatemanager",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "api_endpoint": "apiEndpoint",
        "ca_provider": "caProvider",
    },
)
class SecretStoreV1Beta1SpecProviderYandexcertificatemanager:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth", typing.Dict[str, typing.Any]],
        api_endpoint: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider.

        :param auth: Auth defines the information necessary to authenticate against Yandex Certificate Manager.
        :param api_endpoint: Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').
        :param ca_provider: The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanager
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider(**ca_provider)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth, typing.Dict[str, typing.Any]],
                api_endpoint: typing.Optional[builtins.str] = None,
                ca_provider: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument api_endpoint", value=api_endpoint, expected_type=type_hints["api_endpoint"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
        }
        if api_endpoint is not None:
            self._values["api_endpoint"] = api_endpoint
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth":
        '''Auth defines the information necessary to authenticate against Yandex Certificate Manager.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanager#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth", result)

    @builtins.property
    def api_endpoint(self) -> typing.Optional[builtins.str]:
        '''Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanager#apiEndpoint
        '''
        result = self._values.get("api_endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider"]:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanager#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderYandexcertificatemanager(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth",
    jsii_struct_bases=[],
    name_mapping={"authorized_key_secret_ref": "authorizedKeySecretRef"},
)
class SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth:
    def __init__(
        self,
        *,
        authorized_key_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against Yandex Certificate Manager.

        :param authorized_key_secret_ref: The authorized key used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth
        '''
        if isinstance(authorized_key_secret_ref, dict):
            authorized_key_secret_ref = SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(**authorized_key_secret_ref)
        if __debug__:
            def stub(
                *,
                authorized_key_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument authorized_key_secret_ref", value=authorized_key_secret_ref, expected_type=type_hints["authorized_key_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if authorized_key_secret_ref is not None:
            self._values["authorized_key_secret_ref"] = authorized_key_secret_ref

    @builtins.property
    def authorized_key_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef"]:
        '''The authorized key used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth#authorizedKeySecretRef
        '''
        result = self._values.get("authorized_key_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The authorized key used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider",
    jsii_struct_bases=[],
    name_mapping={"cert_secret_ref": "certSecretRef"},
)
class SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider:
    def __init__(
        self,
        *,
        cert_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :param cert_secret_ref: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider
        '''
        if isinstance(cert_secret_ref, dict):
            cert_secret_ref = SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef(**cert_secret_ref)
        if __debug__:
            def stub(
                *,
                cert_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument cert_secret_ref", value=cert_secret_ref, expected_type=type_hints["cert_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if cert_secret_ref is not None:
            self._values["cert_secret_ref"] = cert_secret_ref

    @builtins.property
    def cert_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider#certSecretRef
        '''
        result = self._values.get("cert_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderYandexlockbox",
    jsii_struct_bases=[],
    name_mapping={
        "auth": "auth",
        "api_endpoint": "apiEndpoint",
        "ca_provider": "caProvider",
    },
)
class SecretStoreV1Beta1SpecProviderYandexlockbox:
    def __init__(
        self,
        *,
        auth: typing.Union["SecretStoreV1Beta1SpecProviderYandexlockboxAuth", typing.Dict[str, typing.Any]],
        api_endpoint: typing.Optional[builtins.str] = None,
        ca_provider: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''YandexLockbox configures this store to sync secrets using Yandex Lockbox provider.

        :param auth: Auth defines the information necessary to authenticate against Yandex Lockbox.
        :param api_endpoint: Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').
        :param ca_provider: The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockbox
        '''
        if isinstance(auth, dict):
            auth = SecretStoreV1Beta1SpecProviderYandexlockboxAuth(**auth)
        if isinstance(ca_provider, dict):
            ca_provider = SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider(**ca_provider)
        if __debug__:
            def stub(
                *,
                auth: typing.Union[SecretStoreV1Beta1SpecProviderYandexlockboxAuth, typing.Dict[str, typing.Any]],
                api_endpoint: typing.Optional[builtins.str] = None,
                ca_provider: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument auth", value=auth, expected_type=type_hints["auth"])
            check_type(argname="argument api_endpoint", value=api_endpoint, expected_type=type_hints["api_endpoint"])
            check_type(argname="argument ca_provider", value=ca_provider, expected_type=type_hints["ca_provider"])
        self._values: typing.Dict[str, typing.Any] = {
            "auth": auth,
        }
        if api_endpoint is not None:
            self._values["api_endpoint"] = api_endpoint
        if ca_provider is not None:
            self._values["ca_provider"] = ca_provider

    @builtins.property
    def auth(self) -> "SecretStoreV1Beta1SpecProviderYandexlockboxAuth":
        '''Auth defines the information necessary to authenticate against Yandex Lockbox.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockbox#auth
        '''
        result = self._values.get("auth")
        assert result is not None, "Required property 'auth' is missing"
        return typing.cast("SecretStoreV1Beta1SpecProviderYandexlockboxAuth", result)

    @builtins.property
    def api_endpoint(self) -> typing.Optional[builtins.str]:
        '''Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443').

        :schema: SecretStoreV1Beta1SpecProviderYandexlockbox#apiEndpoint
        '''
        result = self._values.get("api_endpoint")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ca_provider(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider"]:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockbox#caProvider
        '''
        result = self._values.get("ca_provider")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderYandexlockbox(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderYandexlockboxAuth",
    jsii_struct_bases=[],
    name_mapping={"authorized_key_secret_ref": "authorizedKeySecretRef"},
)
class SecretStoreV1Beta1SpecProviderYandexlockboxAuth:
    def __init__(
        self,
        *,
        authorized_key_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''Auth defines the information necessary to authenticate against Yandex Lockbox.

        :param authorized_key_secret_ref: The authorized key used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxAuth
        '''
        if isinstance(authorized_key_secret_ref, dict):
            authorized_key_secret_ref = SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef(**authorized_key_secret_ref)
        if __debug__:
            def stub(
                *,
                authorized_key_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument authorized_key_secret_ref", value=authorized_key_secret_ref, expected_type=type_hints["authorized_key_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if authorized_key_secret_ref is not None:
            self._values["authorized_key_secret_ref"] = authorized_key_secret_ref

    @builtins.property
    def authorized_key_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef"]:
        '''The authorized key used for authentication.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxAuth#authorizedKeySecretRef
        '''
        result = self._values.get("authorized_key_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderYandexlockboxAuth(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The authorized key used for authentication.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider",
    jsii_struct_bases=[],
    name_mapping={"cert_secret_ref": "certSecretRef"},
)
class SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider:
    def __init__(
        self,
        *,
        cert_secret_ref: typing.Optional[typing.Union["SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''The provider for the CA bundle to use to validate Yandex.Cloud server certificate.

        :param cert_secret_ref: A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider
        '''
        if isinstance(cert_secret_ref, dict):
            cert_secret_ref = SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef(**cert_secret_ref)
        if __debug__:
            def stub(
                *,
                cert_secret_ref: typing.Optional[typing.Union[SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef, typing.Dict[str, typing.Any]]] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument cert_secret_ref", value=cert_secret_ref, expected_type=type_hints["cert_secret_ref"])
        self._values: typing.Dict[str, typing.Any] = {}
        if cert_secret_ref is not None:
            self._values["cert_secret_ref"] = cert_secret_ref

    @builtins.property
    def cert_secret_ref(
        self,
    ) -> typing.Optional["SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef"]:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider#certSecretRef
        '''
        result = self._values.get("cert_secret_ref")
        return typing.cast(typing.Optional["SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "name": "name", "namespace": "namespace"},
)
class SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        name: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
    ) -> None:
        '''A reference to a specific 'key' within a Secret resource, In some instances, ``key`` is a required field.

        :param key: The key of the entry in the Secret resource's ``data`` field to be used. Some instances of this field may be defaulted, in others it may be required.
        :param name: The name of the Secret resource being referred to.
        :param namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef
        '''
        if __debug__:
            def stub(
                *,
                key: typing.Optional[builtins.str] = None,
                name: typing.Optional[builtins.str] = None,
                namespace: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument key", value=key, expected_type=type_hints["key"])
            check_type(argname="argument name", value=name, expected_type=type_hints["name"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if name is not None:
            self._values["name"] = name
        if namespace is not None:
            self._values["namespace"] = namespace

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''The key of the entry in the Secret resource's ``data`` field to be used.

        Some instances of this field may be defaulted, in others it may be required.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#key
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def name(self) -> typing.Optional[builtins.str]:
        '''The name of the Secret resource being referred to.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#name
        '''
        result = self._values.get("name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''Namespace of the resource being referred to.

        Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.

        :schema: SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#namespace
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="ioexternal-secrets.SecretStoreV1Beta1SpecRetrySettings",
    jsii_struct_bases=[],
    name_mapping={"max_retries": "maxRetries", "retry_interval": "retryInterval"},
)
class SecretStoreV1Beta1SpecRetrySettings:
    def __init__(
        self,
        *,
        max_retries: typing.Optional[jsii.Number] = None,
        retry_interval: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Used to configure http retries if failed.

        :param max_retries: 
        :param retry_interval: 

        :schema: SecretStoreV1Beta1SpecRetrySettings
        '''
        if __debug__:
            def stub(
                *,
                max_retries: typing.Optional[jsii.Number] = None,
                retry_interval: typing.Optional[builtins.str] = None,
            ) -> None:
                ...
            type_hints = typing.get_type_hints(stub)
            check_type(argname="argument max_retries", value=max_retries, expected_type=type_hints["max_retries"])
            check_type(argname="argument retry_interval", value=retry_interval, expected_type=type_hints["retry_interval"])
        self._values: typing.Dict[str, typing.Any] = {}
        if max_retries is not None:
            self._values["max_retries"] = max_retries
        if retry_interval is not None:
            self._values["retry_interval"] = retry_interval

    @builtins.property
    def max_retries(self) -> typing.Optional[jsii.Number]:
        '''
        :schema: SecretStoreV1Beta1SpecRetrySettings#maxRetries
        '''
        result = self._values.get("max_retries")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def retry_interval(self) -> typing.Optional[builtins.str]:
        '''
        :schema: SecretStoreV1Beta1SpecRetrySettings#retryInterval
        '''
        result = self._values.get("retry_interval")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretStoreV1Beta1SpecRetrySettings(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "ClusterExternalSecret",
    "ClusterExternalSecretProps",
    "ClusterExternalSecretSpec",
    "ClusterExternalSecretSpecExternalSecretSpec",
    "ClusterExternalSecretSpecExternalSecretSpecData",
    "ClusterExternalSecretSpecExternalSecretSpecDataFrom",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromExtract",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromFind",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromFindName",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromRewrite",
    "ClusterExternalSecretSpecExternalSecretSpecDataFromRewriteRegexp",
    "ClusterExternalSecretSpecExternalSecretSpecDataRemoteRef",
    "ClusterExternalSecretSpecExternalSecretSpecSecretStoreRef",
    "ClusterExternalSecretSpecExternalSecretSpecTarget",
    "ClusterExternalSecretSpecExternalSecretSpecTargetCreationPolicy",
    "ClusterExternalSecretSpecExternalSecretSpecTargetDeletionPolicy",
    "ClusterExternalSecretSpecExternalSecretSpecTargetTemplate",
    "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateMetadata",
    "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFrom",
    "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMap",
    "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromConfigMapItems",
    "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecret",
    "ClusterExternalSecretSpecExternalSecretSpecTargetTemplateTemplateFromSecretItems",
    "ClusterExternalSecretSpecNamespaceSelector",
    "ClusterExternalSecretSpecNamespaceSelectorMatchExpressions",
    "ClusterSecretStore",
    "ClusterSecretStoreProps",
    "ClusterSecretStoreSpec",
    "ClusterSecretStoreSpecProvider",
    "ClusterSecretStoreSpecProviderAkeyless",
    "ClusterSecretStoreSpecProviderAkeylessAuthSecretRef",
    "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth",
    "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef",
    "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef",
    "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef",
    "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId",
    "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType",
    "ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam",
    "ClusterSecretStoreSpecProviderAlibaba",
    "ClusterSecretStoreSpecProviderAlibabaAuth",
    "ClusterSecretStoreSpecProviderAlibabaAuthSecretRef",
    "ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef",
    "ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef",
    "ClusterSecretStoreSpecProviderAws",
    "ClusterSecretStoreSpecProviderAwsAuth",
    "ClusterSecretStoreSpecProviderAwsAuthJwt",
    "ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef",
    "ClusterSecretStoreSpecProviderAwsAuthSecretRef",
    "ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef",
    "ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef",
    "ClusterSecretStoreSpecProviderAwsService",
    "ClusterSecretStoreSpecProviderAzurekv",
    "ClusterSecretStoreSpecProviderAzurekvAuthSecretRef",
    "ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId",
    "ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret",
    "ClusterSecretStoreSpecProviderAzurekvAuthType",
    "ClusterSecretStoreSpecProviderAzurekvServiceAccountRef",
    "ClusterSecretStoreSpecProviderFake",
    "ClusterSecretStoreSpecProviderFakeData",
    "ClusterSecretStoreSpecProviderGcpsm",
    "ClusterSecretStoreSpecProviderGcpsmAuth",
    "ClusterSecretStoreSpecProviderGcpsmAuthSecretRef",
    "ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef",
    "ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity",
    "ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef",
    "ClusterSecretStoreSpecProviderGitlab",
    "ClusterSecretStoreSpecProviderGitlabAuth",
    "ClusterSecretStoreSpecProviderGitlabAuthSecretRef",
    "ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken",
    "ClusterSecretStoreSpecProviderIbm",
    "ClusterSecretStoreSpecProviderIbmAuth",
    "ClusterSecretStoreSpecProviderIbmAuthSecretRef",
    "ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef",
    "ClusterSecretStoreSpecProviderKubernetes",
    "ClusterSecretStoreSpecProviderKubernetesAuth",
    "ClusterSecretStoreSpecProviderKubernetesAuthCert",
    "ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert",
    "ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey",
    "ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount",
    "ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount",
    "ClusterSecretStoreSpecProviderKubernetesAuthToken",
    "ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken",
    "ClusterSecretStoreSpecProviderKubernetesServer",
    "ClusterSecretStoreSpecProviderKubernetesServerCaProvider",
    "ClusterSecretStoreSpecProviderKubernetesServerCaProviderType",
    "ClusterSecretStoreSpecProviderOracle",
    "ClusterSecretStoreSpecProviderOracleAuth",
    "ClusterSecretStoreSpecProviderOracleAuthSecretRef",
    "ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint",
    "ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey",
    "ClusterSecretStoreSpecProviderVault",
    "ClusterSecretStoreSpecProviderVaultAuth",
    "ClusterSecretStoreSpecProviderVaultAuthAppRole",
    "ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef",
    "ClusterSecretStoreSpecProviderVaultAuthCert",
    "ClusterSecretStoreSpecProviderVaultAuthCertClientCert",
    "ClusterSecretStoreSpecProviderVaultAuthCertSecretRef",
    "ClusterSecretStoreSpecProviderVaultAuthJwt",
    "ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken",
    "ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef",
    "ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef",
    "ClusterSecretStoreSpecProviderVaultAuthKubernetes",
    "ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef",
    "ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef",
    "ClusterSecretStoreSpecProviderVaultAuthLdap",
    "ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef",
    "ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef",
    "ClusterSecretStoreSpecProviderVaultCaProvider",
    "ClusterSecretStoreSpecProviderVaultCaProviderType",
    "ClusterSecretStoreSpecProviderVaultVersion",
    "ClusterSecretStoreSpecProviderWebhook",
    "ClusterSecretStoreSpecProviderWebhookCaProvider",
    "ClusterSecretStoreSpecProviderWebhookCaProviderType",
    "ClusterSecretStoreSpecProviderWebhookResult",
    "ClusterSecretStoreSpecProviderWebhookSecrets",
    "ClusterSecretStoreSpecProviderWebhookSecretsSecretRef",
    "ClusterSecretStoreSpecProviderYandexlockbox",
    "ClusterSecretStoreSpecProviderYandexlockboxAuth",
    "ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef",
    "ClusterSecretStoreSpecProviderYandexlockboxCaProvider",
    "ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef",
    "ClusterSecretStoreSpecRetrySettings",
    "ClusterSecretStoreV1Beta1",
    "ClusterSecretStoreV1Beta1Props",
    "ClusterSecretStoreV1Beta1Spec",
    "ClusterSecretStoreV1Beta1SpecConditions",
    "ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector",
    "ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions",
    "ClusterSecretStoreV1Beta1SpecProvider",
    "ClusterSecretStoreV1Beta1SpecProviderAkeyless",
    "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth",
    "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef",
    "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId",
    "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType",
    "ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam",
    "ClusterSecretStoreV1Beta1SpecProviderAlibaba",
    "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth",
    "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAws",
    "ClusterSecretStoreV1Beta1SpecProviderAwsAuth",
    "ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt",
    "ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef",
    "ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAwsService",
    "ClusterSecretStoreV1Beta1SpecProviderAzurekv",
    "ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId",
    "ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret",
    "ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType",
    "ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType",
    "ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef",
    "ClusterSecretStoreV1Beta1SpecProviderDoppler",
    "ClusterSecretStoreV1Beta1SpecProviderDopplerAuth",
    "ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken",
    "ClusterSecretStoreV1Beta1SpecProviderDopplerFormat",
    "ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer",
    "ClusterSecretStoreV1Beta1SpecProviderFake",
    "ClusterSecretStoreV1Beta1SpecProviderFakeData",
    "ClusterSecretStoreV1Beta1SpecProviderGcpsm",
    "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth",
    "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity",
    "ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef",
    "ClusterSecretStoreV1Beta1SpecProviderGitlab",
    "ClusterSecretStoreV1Beta1SpecProviderGitlabAuth",
    "ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken",
    "ClusterSecretStoreV1Beta1SpecProviderIbm",
    "ClusterSecretStoreV1Beta1SpecProviderIbmAuth",
    "ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth",
    "ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetes",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesServer",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider",
    "ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType",
    "ClusterSecretStoreV1Beta1SpecProviderOnepassword",
    "ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth",
    "ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderOracle",
    "ClusterSecretStoreV1Beta1SpecProviderOracleAuth",
    "ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint",
    "ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey",
    "ClusterSecretStoreV1Beta1SpecProviderSenhasegura",
    "ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth",
    "ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVault",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuth",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider",
    "ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType",
    "ClusterSecretStoreV1Beta1SpecProviderVaultVersion",
    "ClusterSecretStoreV1Beta1SpecProviderWebhook",
    "ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider",
    "ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType",
    "ClusterSecretStoreV1Beta1SpecProviderWebhookResult",
    "ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets",
    "ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager",
    "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth",
    "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider",
    "ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderYandexlockbox",
    "ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth",
    "ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef",
    "ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider",
    "ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef",
    "ClusterSecretStoreV1Beta1SpecRetrySettings",
    "ExternalSecret",
    "ExternalSecretProps",
    "ExternalSecretSpec",
    "ExternalSecretSpecData",
    "ExternalSecretSpecDataFrom",
    "ExternalSecretSpecDataRemoteRef",
    "ExternalSecretSpecSecretStoreRef",
    "ExternalSecretSpecTarget",
    "ExternalSecretSpecTargetTemplate",
    "ExternalSecretSpecTargetTemplateMetadata",
    "ExternalSecretSpecTargetTemplateTemplateFrom",
    "ExternalSecretSpecTargetTemplateTemplateFromConfigMap",
    "ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems",
    "ExternalSecretSpecTargetTemplateTemplateFromSecret",
    "ExternalSecretSpecTargetTemplateTemplateFromSecretItems",
    "ExternalSecretV1Beta1",
    "ExternalSecretV1Beta1Props",
    "ExternalSecretV1Beta1Spec",
    "ExternalSecretV1Beta1SpecData",
    "ExternalSecretV1Beta1SpecDataFrom",
    "ExternalSecretV1Beta1SpecDataFromExtract",
    "ExternalSecretV1Beta1SpecDataFromFind",
    "ExternalSecretV1Beta1SpecDataFromFindName",
    "ExternalSecretV1Beta1SpecDataFromRewrite",
    "ExternalSecretV1Beta1SpecDataFromRewriteRegexp",
    "ExternalSecretV1Beta1SpecDataRemoteRef",
    "ExternalSecretV1Beta1SpecSecretStoreRef",
    "ExternalSecretV1Beta1SpecTarget",
    "ExternalSecretV1Beta1SpecTargetCreationPolicy",
    "ExternalSecretV1Beta1SpecTargetDeletionPolicy",
    "ExternalSecretV1Beta1SpecTargetTemplate",
    "ExternalSecretV1Beta1SpecTargetTemplateMetadata",
    "ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom",
    "ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap",
    "ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems",
    "ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret",
    "ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems",
    "SecretStore",
    "SecretStoreProps",
    "SecretStoreSpec",
    "SecretStoreSpecProvider",
    "SecretStoreSpecProviderAkeyless",
    "SecretStoreSpecProviderAkeylessAuthSecretRef",
    "SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth",
    "SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef",
    "SecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef",
    "SecretStoreSpecProviderAkeylessAuthSecretRefSecretRef",
    "SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId",
    "SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType",
    "SecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam",
    "SecretStoreSpecProviderAlibaba",
    "SecretStoreSpecProviderAlibabaAuth",
    "SecretStoreSpecProviderAlibabaAuthSecretRef",
    "SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef",
    "SecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef",
    "SecretStoreSpecProviderAws",
    "SecretStoreSpecProviderAwsAuth",
    "SecretStoreSpecProviderAwsAuthJwt",
    "SecretStoreSpecProviderAwsAuthJwtServiceAccountRef",
    "SecretStoreSpecProviderAwsAuthSecretRef",
    "SecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef",
    "SecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef",
    "SecretStoreSpecProviderAwsService",
    "SecretStoreSpecProviderAzurekv",
    "SecretStoreSpecProviderAzurekvAuthSecretRef",
    "SecretStoreSpecProviderAzurekvAuthSecretRefClientId",
    "SecretStoreSpecProviderAzurekvAuthSecretRefClientSecret",
    "SecretStoreSpecProviderAzurekvAuthType",
    "SecretStoreSpecProviderAzurekvServiceAccountRef",
    "SecretStoreSpecProviderFake",
    "SecretStoreSpecProviderFakeData",
    "SecretStoreSpecProviderGcpsm",
    "SecretStoreSpecProviderGcpsmAuth",
    "SecretStoreSpecProviderGcpsmAuthSecretRef",
    "SecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef",
    "SecretStoreSpecProviderGcpsmAuthWorkloadIdentity",
    "SecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef",
    "SecretStoreSpecProviderGitlab",
    "SecretStoreSpecProviderGitlabAuth",
    "SecretStoreSpecProviderGitlabAuthSecretRef",
    "SecretStoreSpecProviderGitlabAuthSecretRefAccessToken",
    "SecretStoreSpecProviderIbm",
    "SecretStoreSpecProviderIbmAuth",
    "SecretStoreSpecProviderIbmAuthSecretRef",
    "SecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef",
    "SecretStoreSpecProviderKubernetes",
    "SecretStoreSpecProviderKubernetesAuth",
    "SecretStoreSpecProviderKubernetesAuthCert",
    "SecretStoreSpecProviderKubernetesAuthCertClientCert",
    "SecretStoreSpecProviderKubernetesAuthCertClientKey",
    "SecretStoreSpecProviderKubernetesAuthServiceAccount",
    "SecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount",
    "SecretStoreSpecProviderKubernetesAuthToken",
    "SecretStoreSpecProviderKubernetesAuthTokenBearerToken",
    "SecretStoreSpecProviderKubernetesServer",
    "SecretStoreSpecProviderKubernetesServerCaProvider",
    "SecretStoreSpecProviderKubernetesServerCaProviderType",
    "SecretStoreSpecProviderOracle",
    "SecretStoreSpecProviderOracleAuth",
    "SecretStoreSpecProviderOracleAuthSecretRef",
    "SecretStoreSpecProviderOracleAuthSecretRefFingerprint",
    "SecretStoreSpecProviderOracleAuthSecretRefPrivatekey",
    "SecretStoreSpecProviderVault",
    "SecretStoreSpecProviderVaultAuth",
    "SecretStoreSpecProviderVaultAuthAppRole",
    "SecretStoreSpecProviderVaultAuthAppRoleSecretRef",
    "SecretStoreSpecProviderVaultAuthCert",
    "SecretStoreSpecProviderVaultAuthCertClientCert",
    "SecretStoreSpecProviderVaultAuthCertSecretRef",
    "SecretStoreSpecProviderVaultAuthJwt",
    "SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken",
    "SecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef",
    "SecretStoreSpecProviderVaultAuthJwtSecretRef",
    "SecretStoreSpecProviderVaultAuthKubernetes",
    "SecretStoreSpecProviderVaultAuthKubernetesSecretRef",
    "SecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef",
    "SecretStoreSpecProviderVaultAuthLdap",
    "SecretStoreSpecProviderVaultAuthLdapSecretRef",
    "SecretStoreSpecProviderVaultAuthTokenSecretRef",
    "SecretStoreSpecProviderVaultCaProvider",
    "SecretStoreSpecProviderVaultCaProviderType",
    "SecretStoreSpecProviderVaultVersion",
    "SecretStoreSpecProviderWebhook",
    "SecretStoreSpecProviderWebhookCaProvider",
    "SecretStoreSpecProviderWebhookCaProviderType",
    "SecretStoreSpecProviderWebhookResult",
    "SecretStoreSpecProviderWebhookSecrets",
    "SecretStoreSpecProviderWebhookSecretsSecretRef",
    "SecretStoreSpecProviderYandexlockbox",
    "SecretStoreSpecProviderYandexlockboxAuth",
    "SecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef",
    "SecretStoreSpecProviderYandexlockboxCaProvider",
    "SecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef",
    "SecretStoreSpecRetrySettings",
    "SecretStoreV1Beta1",
    "SecretStoreV1Beta1Props",
    "SecretStoreV1Beta1Spec",
    "SecretStoreV1Beta1SpecConditions",
    "SecretStoreV1Beta1SpecConditionsNamespaceSelector",
    "SecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions",
    "SecretStoreV1Beta1SpecProvider",
    "SecretStoreV1Beta1SpecProviderAkeyless",
    "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth",
    "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef",
    "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef",
    "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId",
    "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType",
    "SecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam",
    "SecretStoreV1Beta1SpecProviderAlibaba",
    "SecretStoreV1Beta1SpecProviderAlibabaAuth",
    "SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef",
    "SecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef",
    "SecretStoreV1Beta1SpecProviderAws",
    "SecretStoreV1Beta1SpecProviderAwsAuth",
    "SecretStoreV1Beta1SpecProviderAwsAuthJwt",
    "SecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef",
    "SecretStoreV1Beta1SpecProviderAwsAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef",
    "SecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef",
    "SecretStoreV1Beta1SpecProviderAwsService",
    "SecretStoreV1Beta1SpecProviderAzurekv",
    "SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId",
    "SecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret",
    "SecretStoreV1Beta1SpecProviderAzurekvAuthType",
    "SecretStoreV1Beta1SpecProviderAzurekvEnvironmentType",
    "SecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef",
    "SecretStoreV1Beta1SpecProviderDoppler",
    "SecretStoreV1Beta1SpecProviderDopplerAuth",
    "SecretStoreV1Beta1SpecProviderDopplerAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken",
    "SecretStoreV1Beta1SpecProviderDopplerFormat",
    "SecretStoreV1Beta1SpecProviderDopplerNameTransformer",
    "SecretStoreV1Beta1SpecProviderFake",
    "SecretStoreV1Beta1SpecProviderFakeData",
    "SecretStoreV1Beta1SpecProviderGcpsm",
    "SecretStoreV1Beta1SpecProviderGcpsmAuth",
    "SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef",
    "SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity",
    "SecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef",
    "SecretStoreV1Beta1SpecProviderGitlab",
    "SecretStoreV1Beta1SpecProviderGitlabAuth",
    "SecretStoreV1Beta1SpecProviderGitlabAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken",
    "SecretStoreV1Beta1SpecProviderIbm",
    "SecretStoreV1Beta1SpecProviderIbmAuth",
    "SecretStoreV1Beta1SpecProviderIbmAuthContainerAuth",
    "SecretStoreV1Beta1SpecProviderIbmAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef",
    "SecretStoreV1Beta1SpecProviderKubernetes",
    "SecretStoreV1Beta1SpecProviderKubernetesAuth",
    "SecretStoreV1Beta1SpecProviderKubernetesAuthCert",
    "SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert",
    "SecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey",
    "SecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount",
    "SecretStoreV1Beta1SpecProviderKubernetesAuthToken",
    "SecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken",
    "SecretStoreV1Beta1SpecProviderKubernetesServer",
    "SecretStoreV1Beta1SpecProviderKubernetesServerCaProvider",
    "SecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType",
    "SecretStoreV1Beta1SpecProviderOnepassword",
    "SecretStoreV1Beta1SpecProviderOnepasswordAuth",
    "SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef",
    "SecretStoreV1Beta1SpecProviderOracle",
    "SecretStoreV1Beta1SpecProviderOracleAuth",
    "SecretStoreV1Beta1SpecProviderOracleAuthSecretRef",
    "SecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint",
    "SecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey",
    "SecretStoreV1Beta1SpecProviderSenhasegura",
    "SecretStoreV1Beta1SpecProviderSenhaseguraAuth",
    "SecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef",
    "SecretStoreV1Beta1SpecProviderVault",
    "SecretStoreV1Beta1SpecProviderVaultAuth",
    "SecretStoreV1Beta1SpecProviderVaultAuthAppRole",
    "SecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthCert",
    "SecretStoreV1Beta1SpecProviderVaultAuthCertClientCert",
    "SecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthJwt",
    "SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken",
    "SecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthKubernetes",
    "SecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthLdap",
    "SecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef",
    "SecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef",
    "SecretStoreV1Beta1SpecProviderVaultCaProvider",
    "SecretStoreV1Beta1SpecProviderVaultCaProviderType",
    "SecretStoreV1Beta1SpecProviderVaultVersion",
    "SecretStoreV1Beta1SpecProviderWebhook",
    "SecretStoreV1Beta1SpecProviderWebhookCaProvider",
    "SecretStoreV1Beta1SpecProviderWebhookCaProviderType",
    "SecretStoreV1Beta1SpecProviderWebhookResult",
    "SecretStoreV1Beta1SpecProviderWebhookSecrets",
    "SecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef",
    "SecretStoreV1Beta1SpecProviderYandexcertificatemanager",
    "SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth",
    "SecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef",
    "SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider",
    "SecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef",
    "SecretStoreV1Beta1SpecProviderYandexlockbox",
    "SecretStoreV1Beta1SpecProviderYandexlockboxAuth",
    "SecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef",
    "SecretStoreV1Beta1SpecProviderYandexlockboxCaProvider",
    "SecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef",
    "SecretStoreV1Beta1SpecRetrySettings",
]

publication.publish()
